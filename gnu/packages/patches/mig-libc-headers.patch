From cfdeb2f51d4aa8b31e28021cf01234baec975200 Mon Sep 17 00:00:00 2001
From: Manolis Ragkousis <manolis837@gmail.com>
Date: Sat, 13 Aug 2016 10:52:06 +0300
Subject: [PATCH] mig: Add libc headers files.

---
 include/_G_config.h                  |   57 +
 include/a.out.h                      |  339 ++++
 include/aio.h                        |  246 +++
 include/aliases.h                    |   63 +
 include/alloca.h                     |   40 +
 include/ar.h                         |   47 +
 include/argp.h                       |  595 ++++++
 include/argz.h                       |  182 ++
 include/arpa/ftp.h                   |  105 ++
 include/arpa/inet.h                  |  105 ++
 include/arpa/nameser.h               |  535 ++++++
 include/arpa/nameser_compat.h        |  187 ++
 include/arpa/telnet.h                |  316 ++++
 include/arpa/tftp.h                  |   82 +
 include/assert.h                     |  119 ++
 include/bits/barrier-attr.h          |   32 +
 include/bits/barrier.h               |   39 +
 include/bits/byteswap-16.h           |   49 +
 include/bits/byteswap.h              |  155 ++
 include/bits/cancelation.h           |   51 +
 include/bits/cmathcalls.h            |  158 ++
 include/bits/condition-attr.h        |   34 +
 include/bits/condition.h             |   39 +
 include/bits/confname.h              |  675 +++++++
 include/bits/dirent.h                |   59 +
 include/bits/dlfcn.h                 |   64 +
 include/bits/elfclass.h              |   14 +
 include/bits/endian.h                |    7 +
 include/bits/environments.h          |   87 +
 include/bits/errno.h                 |  331 ++++
 include/bits/error.h                 |   73 +
 include/bits/fcntl.h                 |  230 +++
 include/bits/fcntl2.h                |  172 ++
 include/bits/fenv.h                  |  150 ++
 include/bits/fenvinline.h            |    8 +
 include/bits/huge_val.h              |   53 +
 include/bits/huge_valf.h             |   51 +
 include/bits/huge_vall.h             |   41 +
 include/bits/hwcap.h                 |   23 +
 include/bits/in.h                    |   96 +
 include/bits/inf.h                   |   29 +
 include/bits/ioctl-types.h           |  113 ++
 include/bits/ioctls.h                |  432 +++++
 include/bits/ipc.h                   |   51 +
 include/bits/ipctypes.h              |   36 +
 include/bits/libc-lock.h             |  215 +++
 include/bits/libio-ldbl.h            |   24 +
 include/bits/link.h                  |  147 ++
 include/bits/local_lim.h             |   43 +
 include/bits/locale.h                |   40 +
 include/bits/math-finite.h           |  454 +++++
 include/bits/mathcalls.h             |  372 ++++
 include/bits/mathdef.h               |   59 +
 include/bits/mathinline.h            |  973 ++++++++++
 include/bits/mman.h                  |   96 +
 include/bits/monetary-ldbl.h         |   27 +
 include/bits/mqueue.h                |   30 +
 include/bits/mqueue2.h               |   57 +
 include/bits/msq.h                   |   76 +
 include/bits/mutex-attr.h            |   41 +
 include/bits/mutex.h                 |   75 +
 include/bits/nan.h                   |   52 +
 include/bits/netdb.h                 |   32 +
 include/bits/once.h                  |   34 +
 include/bits/param.h                 |   85 +
 include/bits/poll.h                  |   42 +
 include/bits/poll2.h                 |   81 +
 include/bits/posix1_lim.h            |  175 ++
 include/bits/posix2_lim.h            |   90 +
 include/bits/posix_opt.h             |  196 ++
 include/bits/printf-ldbl.h           |   23 +
 include/bits/pthread-np.h            |   38 +
 include/bits/pthread.h               |   38 +
 include/bits/pthreadtypes.h          |   29 +
 include/bits/resource.h              |  192 ++
 include/bits/rwlock-attr.h           |   32 +
 include/bits/rwlock.h                |   46 +
 include/bits/sched.h                 |  151 ++
 include/bits/select.h                |   63 +
 include/bits/select2.h               |   35 +
 include/bits/sem.h                   |   87 +
 include/bits/semaphore.h             |   44 +
 include/bits/setjmp.h                |   40 +
 include/bits/setjmp2.h               |   40 +
 include/bits/shm.h                   |   95 +
 include/bits/sigaction.h             |   81 +
 include/bits/sigcontext.h            |  123 ++
 include/bits/siginfo.h               |  210 +++
 include/bits/signum.h                |   73 +
 include/bits/sigset.h                |   82 +
 include/bits/sigstack.h              |   54 +
 include/bits/sigthread.h             |   34 +
 include/bits/sockaddr.h              |   42 +
 include/bits/socket.h                |  362 ++++
 include/bits/socket2.h               |   77 +
 include/bits/spin-lock-inline.h      |   98 +
 include/bits/spin-lock.h             |   39 +
 include/bits/stab.def                |  233 +++
 include/bits/stat.h                  |  261 +++
 include/bits/statfs.h                |   86 +
 include/bits/statvfs.h               |   95 +
 include/bits/stdio-ldbl.h            |  101 +
 include/bits/stdio-lock.h            |   66 +
 include/bits/stdio.h                 |  190 ++
 include/bits/stdio2.h                |  382 ++++
 include/bits/stdio_lim.h             |   42 +
 include/bits/stdlib-bsearch.h        |   43 +
 include/bits/stdlib-float.h          |   31 +
 include/bits/stdlib-ldbl.h           |   39 +
 include/bits/stdlib.h                |  155 ++
 include/bits/string.h                | 1985 ++++++++++++++++++++
 include/bits/string2.h               | 1329 ++++++++++++++
 include/bits/string3.h               |  151 ++
 include/bits/stropts.h               |  230 +++
 include/bits/sys_errlist.h           |   23 +
 include/bits/syslog-ldbl.h           |   35 +
 include/bits/syslog-path.h           |   28 +
 include/bits/syslog.h                |   49 +
 include/bits/termios.h               |  341 ++++
 include/bits/thread-attr.h           |   47 +
 include/bits/thread-specific.h       |   25 +
 include/bits/time.h                  |   80 +
 include/bits/types.h                 |  194 ++
 include/bits/typesizes.h             |   67 +
 include/bits/uio.h                   |   31 +
 include/bits/unistd.h                |  385 ++++
 include/bits/ustat.h                 |   30 +
 include/bits/utmp.h                  |  123 ++
 include/bits/utmpx.h                 |  102 ++
 include/bits/utsname.h               |   24 +
 include/bits/waitflags.h             |   26 +
 include/bits/waitstatus.h            |  105 ++
 include/bits/wchar-ldbl.h            |   74 +
 include/bits/wchar.h                 |   49 +
 include/bits/wchar2.h                |  593 ++++++
 include/bits/wordsize.h              |   13 +
 include/bits/xopen_lim.h             |  143 ++
 include/bits/xtitypes.h              |   33 +
 include/byteswap.h                   |   39 +
 include/complex.h                    |  112 ++
 include/cpio.h                       |   73 +
 include/crypt.h                      |   75 +
 include/ctype.h                      |  349 ++++
 include/device/device.h              |  325 ++++
 include/device/device_request.h      |  177 ++
 include/dirent.h                     |  403 ++++
 include/dlfcn.h                      |  190 ++
 include/elf.h                        | 3363 ++++++++++++++++++++++++++++++++++
 include/endian.h                     |   96 +
 include/envz.h                       |   73 +
 include/err.h                        |   57 +
 include/errno.h                      |   72 +
 include/error.h                      |   57 +
 include/execinfo.h                   |   43 +
 include/faultexc_server.h            |   43 +
 include/fcntl.h                      |  307 ++++
 include/features.h                   |  405 ++++
 include/fenv.h                       |  135 ++
 include/fmtmsg.h                     |  105 ++
 include/fnmatch.h                    |   62 +
 include/fpu_control.h                |  109 ++
 include/fstab.h                      |   79 +
 include/fts.h                        |  131 ++
 include/ftw.h                        |  177 ++
 include/gconv.h                      |  180 ++
 include/getopt.h                     |  191 ++
 include/glob.h                       |  181 ++
 include/gnu-versions.h               |   52 +
 include/gnu/lib-names.h              |   35 +
 include/gnu/libc-version.h           |   34 +
 include/gnu/stubs.h                  |    0
 include/grp.h                        |  207 +++
 include/gshadow.h                    |  130 ++
 include/hurd.h                       |  350 ++++
 include/hurd/auth.h                  |  197 ++
 include/hurd/auth_reply.h            |  111 ++
 include/hurd/auth_request.h          |  103 ++
 include/hurd/crash.h                 |   81 +
 include/hurd/exec.h                  |  161 ++
 include/hurd/exec_startup.h          |   93 +
 include/hurd/fd.h                    |  295 +++
 include/hurd/fs.h                    |  975 ++++++++++
 include/hurd/fsys.h                  |  337 ++++
 include/hurd/id.h                    |   54 +
 include/hurd/ifsock.h                |   63 +
 include/hurd/interrupt.h             |   63 +
 include/hurd/io.h                    |  849 +++++++++
 include/hurd/io_reply.h              |  913 +++++++++
 include/hurd/io_request.h            |  833 +++++++++
 include/hurd/ioctl.h                 |   76 +
 include/hurd/login.h                 |  165 ++
 include/hurd/lookup.h                |  190 ++
 include/hurd/msg.h                   |  697 +++++++
 include/hurd/msg_reply.h             |   91 +
 include/hurd/msg_request.h           |  103 ++
 include/hurd/msg_server.h            |  369 ++++
 include/hurd/password.h              |   95 +
 include/hurd/pfinet.h                |   67 +
 include/hurd/port.h                  |  189 ++
 include/hurd/process.h               | 1449 +++++++++++++++
 include/hurd/process_request.h       | 1455 +++++++++++++++
 include/hurd/resource.h              |   51 +
 include/hurd/signal.h                |  416 +++++
 include/hurd/sigpreempt.h            |  102 ++
 include/hurd/socket.h                |  489 +++++
 include/hurd/startup.h               |  183 ++
 include/hurd/term.h                  |  309 ++++
 include/hurd/threadvar.h             |   54 +
 include/hurd/tioctl.h                |  831 +++++++++
 include/hurd/userlink.h              |  161 ++
 include/iconv.h                      |   55 +
 include/ieee754.h                    |  198 ++
 include/ifaddrs.h                    |   73 +
 include/inttypes.h                   |  434 +++++
 include/langinfo.h                   |  599 ++++++
 include/lastlog.h                    |    4 +
 include/libgen.h                     |   39 +
 include/libintl.h                    |  123 ++
 include/libio.h                      |  529 ++++++
 include/limits.h                     |  152 ++
 include/link.h                       |  194 ++
 include/locale.h                     |  207 +++
 include/lock-intern.h                |  116 ++
 include/mach-shortcuts.h             |  318 ++++
 include/mach.h                       |  107 ++
 include/mach/default_pager.h         |  185 ++
 include/mach/error.h                 |  137 ++
 include/mach/exc.h                   |   53 +
 include/mach/exc_server.h            |   43 +
 include/mach/gnumach.h               |  221 +++
 include/mach/i386/mach_i386.h        |  189 ++
 include/mach/mach.h                  |    3 +
 include/mach/mach4.h                 |  221 +++
 include/mach/mach_host.h             |  981 ++++++++++
 include/mach/mach_interface.h        | 1275 +++++++++++++
 include/mach/mach_port.h             |  561 ++++++
 include/mach/mach_traps.h            |   78 +
 include/mach/memory_object_default.h |   85 +
 include/mach/memory_object_user.h    |  323 ++++
 include/mach/mig_support.h           |   85 +
 include/mach/task_notify.h           |   49 +
 include/mach_error.h                 |   71 +
 include/mach_init.h                  |   47 +
 include/machine-lock.h               |   79 +
 include/machine-sp.h                 |   30 +
 include/malloc.h                     |  171 ++
 include/math.h                       |  491 +++++
 include/mcheck.h                     |   60 +
 include/memory.h                     |   33 +
 include/mntent.h                     |   97 +
 include/monetary.h                   |   58 +
 include/mqueue.h                     |  100 +
 include/net/ethernet.h               |   75 +
 include/net/if.h                     |  204 +++
 include/net/if_arp.h                 |  144 ++
 include/net/if_ether.h               |   84 +
 include/net/if_ppp.h                 |  169 ++
 include/net/route.h                  |  140 ++
 include/netdb.h                      |  715 ++++++++
 include/netinet/ether.h              |   53 +
 include/netinet/icmp6.h              |  345 ++++
 include/netinet/if_ether.h           |   32 +
 include/netinet/igmp.h               |  125 ++
 include/netinet/in.h                 |  630 +++++++
 include/netinet/in_systm.h           |   40 +
 include/netinet/ip.h                 |  302 +++
 include/netinet/ip6.h                |  188 ++
 include/netinet/ip_icmp.h            |  282 +++
 include/netinet/tcp.h                |  303 +++
 include/netinet/udp.h                |   89 +
 include/nfs/nfs.h                    |   31 +
 include/nl_types.h                   |   54 +
 include/nss.h                        |   63 +
 include/obstack.h                    |  505 +++++
 include/paths.h                      |   75 +
 include/poll.h                       |    1 +
 include/printf.h                     |  188 ++
 include/protocols/routed.h           |  101 +
 include/protocols/rwhod.h            |   67 +
 include/protocols/talkd.h            |  113 ++
 include/protocols/timed.h            |   99 +
 include/pthread.h                    |    7 +
 include/pthread/pthread.h            |  835 +++++++++
 include/pthread/pthreadtypes.h       |  125 ++
 include/pty.h                        |   45 +
 include/pwd.h                        |  185 ++
 include/re_comp.h                    |   25 +
 include/regex.h                      |  581 ++++++
 include/regexp.h                     |  226 +++
 include/resolv.h                     |  389 ++++
 include/rpc/auth.h                   |  210 +++
 include/rpc/auth_des.h               |  111 ++
 include/rpc/auth_unix.h              |   86 +
 include/rpc/clnt.h                   |  418 +++++
 include/rpc/des_crypt.h              |   96 +
 include/rpc/key_prot.h               |  343 ++++
 include/rpc/netdb.h                  |   74 +
 include/rpc/pmap_clnt.h              |   95 +
 include/rpc/pmap_prot.h              |  105 ++
 include/rpc/pmap_rmt.h               |   65 +
 include/rpc/rpc.h                    |   94 +
 include/rpc/rpc_des.h                |   71 +
 include/rpc/rpc_msg.h                |  198 ++
 include/rpc/svc.h                    |  336 ++++
 include/rpc/svc_auth.h               |   50 +
 include/rpc/types.h                  |  105 ++
 include/rpc/xdr.h                    |  377 ++++
 include/rpcsvc/bootparam.h           |   23 +
 include/rpcsvc/bootparam_prot.h      |  124 ++
 include/rpcsvc/bootparam_prot.x      |   97 +
 include/rpcsvc/key_prot.h            |  236 +++
 include/rpcsvc/key_prot.x            |  283 +++
 include/rpcsvc/klm_prot.h            |  136 ++
 include/rpcsvc/klm_prot.x            |  130 ++
 include/rpcsvc/mount.h               |  144 ++
 include/rpcsvc/mount.x               |  161 ++
 include/rpcsvc/nfs_prot.h            |  450 +++++
 include/rpcsvc/nfs_prot.x            |  352 ++++
 include/rpcsvc/nis.h                 |  616 +++++++
 include/rpcsvc/nis.x                 |  474 +++++
 include/rpcsvc/nis_callback.h        |   72 +
 include/rpcsvc/nis_callback.x        |   63 +
 include/rpcsvc/nis_object.x          |  328 ++++
 include/rpcsvc/nis_tags.h            |  129 ++
 include/rpcsvc/nislib.h              |  286 +++
 include/rpcsvc/nlm_prot.h            |  330 ++++
 include/rpcsvc/nlm_prot.x            |  203 ++
 include/rpcsvc/rex.h                 |  227 +++
 include/rpcsvc/rex.x                 |  229 +++
 include/rpcsvc/rquota.h              |   95 +
 include/rpcsvc/rquota.x              |   61 +
 include/rpcsvc/rstat.h               |  162 ++
 include/rpcsvc/rstat.x               |  145 ++
 include/rpcsvc/rusers.h              |  147 ++
 include/rpcsvc/rusers.x              |  240 +++
 include/rpcsvc/sm_inter.h            |  135 ++
 include/rpcsvc/sm_inter.x            |  110 ++
 include/rpcsvc/spray.h               |   81 +
 include/rpcsvc/spray.x               |   84 +
 include/rpcsvc/yp.h                  |  339 ++++
 include/rpcsvc/yp.x                  |  311 ++++
 include/rpcsvc/yp_prot.h             |  366 ++++
 include/rpcsvc/ypclnt.h              |   88 +
 include/rpcsvc/yppasswd.h            |   66 +
 include/rpcsvc/yppasswd.x            |   61 +
 include/rpcsvc/ypupd.h               |   88 +
 include/sched.h                      |  126 ++
 include/search.h                     |  174 ++
 include/semaphore.h                  |   81 +
 include/setjmp.h                     |  114 ++
 include/sgtty.h                      |   40 +
 include/shadow.h                     |  148 ++
 include/signal.h                     |  403 ++++
 include/spawn.h                      |  190 ++
 include/spin-lock.h                  |   33 +
 include/stab.h                       |   17 +
 include/stdc-predef.h                |   59 +
 include/stdint.h                     |  306 ++++
 include/stdio.h                      |  947 ++++++++++
 include/stdio_ext.h                  |   86 +
 include/stdlib.h                     |  970 ++++++++++
 include/string.h                     |  646 +++++++
 include/strings.h                    |  143 ++
 include/stropts.h                    |   92 +
 include/sys/auxv.h                   |   36 +
 include/sys/bitypes.h                |    3 +
 include/sys/cdefs.h                  |  419 +++++
 include/sys/dir.h                    |   27 +
 include/sys/errno.h                  |    1 +
 include/sys/fcntl.h                  |    1 +
 include/sys/file.h                   |   56 +
 include/sys/gmon.h                   |  201 ++
 include/sys/gmon_out.h               |   79 +
 include/sys/io.h                     |  177 ++
 include/sys/ioctl.h                  |   45 +
 include/sys/ipc.h                    |   58 +
 include/sys/mman.h                   |  151 ++
 include/sys/msg.h                    |   83 +
 include/sys/mtio.h                   |  276 +++
 include/sys/param.h                  |  103 ++
 include/sys/poll.h                   |   79 +
 include/sys/profil.h                 |   60 +
 include/sys/ptrace.h                 |  137 ++
 include/sys/queue.h                  |  574 ++++++
 include/sys/reboot.h                 |  171 ++
 include/sys/resource.h               |  102 ++
 include/sys/select.h                 |  133 ++
 include/sys/sem.h                    |   68 +
 include/sys/sendfile.h               |   51 +
 include/sys/shm.h                    |   64 +
 include/sys/signal.h                 |    1 +
 include/sys/socket.h                 |  285 +++
 include/sys/socketvar.h              |    3 +
 include/sys/stat.h                   |  537 ++++++
 include/sys/statfs.h                 |   67 +
 include/sys/statvfs.h                |   90 +
 include/sys/stropts.h                |    1 +
 include/sys/swap.h                   |   32 +
 include/sys/syscall.h                |    1 +
 include/sys/sysinfo.h                |   40 +
 include/sys/syslog.h                 |  215 +++
 include/sys/sysmacros.h              |   30 +
 include/sys/termios.h                |    4 +
 include/sys/time.h                   |  191 ++
 include/sys/timeb.h                  |   45 +
 include/sys/times.h                  |   52 +
 include/sys/ttychars.h               |   61 +
 include/sys/ttydefaults.h            |  100 +
 include/sys/types.h                  |  275 +++
 include/sys/ucontext.h               |  119 ++
 include/sys/uio.h                    |  122 ++
 include/sys/un.h                     |   46 +
 include/sys/unistd.h                 |    1 +
 include/sys/ustat.h                  |   37 +
 include/sys/utsname.h                |   86 +
 include/sys/vfs.h                    |    4 +
 include/sys/vlimit.h                 |   67 +
 include/sys/vtimes.h                 |   68 +
 include/sys/wait.h                   |  186 ++
 include/sys/xattr.h                  |  103 ++
 include/syscall.h                    |    1 +
 include/sysexits.h                   |  114 ++
 include/syslog.h                     |    1 +
 include/tar.h                        |  112 ++
 include/termios.h                    |  109 ++
 include/tgmath.h                     |  454 +++++
 include/time.h                       |  434 +++++
 include/ttyent.h                     |   65 +
 include/uchar.h                      |   83 +
 include/ucontext.h                   |   52 +
 include/ulimit.h                     |   47 +
 include/unistd.h                     | 1153 ++++++++++++
 include/ustat.h                      |    1 +
 include/utime.h                      |   51 +
 include/utmp.h                       |   96 +
 include/utmpx.h                      |  125 ++
 include/values.h                     |   68 +
 include/wait.h                       |    1 +
 include/wchar.h                      |  900 +++++++++
 include/wctype.h                     |  318 ++++
 include/wordexp.h                    |   70 +
 include/xlocale.h                    |   44 +
 442 files changed, 83153 insertions(+)
 create mode 100644 include/_G_config.h
 create mode 100644 include/a.out.h
 create mode 100644 include/aio.h
 create mode 100644 include/aliases.h
 create mode 100644 include/alloca.h
 create mode 100644 include/ar.h
 create mode 100644 include/argp.h
 create mode 100644 include/argz.h
 create mode 100644 include/arpa/ftp.h
 create mode 100644 include/arpa/inet.h
 create mode 100644 include/arpa/nameser.h
 create mode 100644 include/arpa/nameser_compat.h
 create mode 100644 include/arpa/telnet.h
 create mode 100644 include/arpa/tftp.h
 create mode 100644 include/assert.h
 create mode 100644 include/bits/barrier-attr.h
 create mode 100644 include/bits/barrier.h
 create mode 100644 include/bits/byteswap-16.h
 create mode 100644 include/bits/byteswap.h
 create mode 100644 include/bits/cancelation.h
 create mode 100644 include/bits/cmathcalls.h
 create mode 100644 include/bits/condition-attr.h
 create mode 100644 include/bits/condition.h
 create mode 100644 include/bits/confname.h
 create mode 100644 include/bits/dirent.h
 create mode 100644 include/bits/dlfcn.h
 create mode 100644 include/bits/elfclass.h
 create mode 100644 include/bits/endian.h
 create mode 100644 include/bits/environments.h
 create mode 100644 include/bits/errno.h
 create mode 100644 include/bits/error.h
 create mode 100644 include/bits/fcntl.h
 create mode 100644 include/bits/fcntl2.h
 create mode 100644 include/bits/fenv.h
 create mode 100644 include/bits/fenvinline.h
 create mode 100644 include/bits/huge_val.h
 create mode 100644 include/bits/huge_valf.h
 create mode 100644 include/bits/huge_vall.h
 create mode 100644 include/bits/hwcap.h
 create mode 100644 include/bits/in.h
 create mode 100644 include/bits/inf.h
 create mode 100644 include/bits/ioctl-types.h
 create mode 100644 include/bits/ioctls.h
 create mode 100644 include/bits/ipc.h
 create mode 100644 include/bits/ipctypes.h
 create mode 100644 include/bits/libc-lock.h
 create mode 100644 include/bits/libio-ldbl.h
 create mode 100644 include/bits/link.h
 create mode 100644 include/bits/local_lim.h
 create mode 100644 include/bits/locale.h
 create mode 100644 include/bits/math-finite.h
 create mode 100644 include/bits/mathcalls.h
 create mode 100644 include/bits/mathdef.h
 create mode 100644 include/bits/mathinline.h
 create mode 100644 include/bits/mman.h
 create mode 100644 include/bits/monetary-ldbl.h
 create mode 100644 include/bits/mqueue.h
 create mode 100644 include/bits/mqueue2.h
 create mode 100644 include/bits/msq.h
 create mode 100644 include/bits/mutex-attr.h
 create mode 100644 include/bits/mutex.h
 create mode 100644 include/bits/nan.h
 create mode 100644 include/bits/netdb.h
 create mode 100644 include/bits/once.h
 create mode 100644 include/bits/param.h
 create mode 100644 include/bits/poll.h
 create mode 100644 include/bits/poll2.h
 create mode 100644 include/bits/posix1_lim.h
 create mode 100644 include/bits/posix2_lim.h
 create mode 100644 include/bits/posix_opt.h
 create mode 100644 include/bits/printf-ldbl.h
 create mode 100644 include/bits/pthread-np.h
 create mode 100644 include/bits/pthread.h
 create mode 100644 include/bits/pthreadtypes.h
 create mode 100644 include/bits/resource.h
 create mode 100644 include/bits/rwlock-attr.h
 create mode 100644 include/bits/rwlock.h
 create mode 100644 include/bits/sched.h
 create mode 100644 include/bits/select.h
 create mode 100644 include/bits/select2.h
 create mode 100644 include/bits/sem.h
 create mode 100644 include/bits/semaphore.h
 create mode 100644 include/bits/setjmp.h
 create mode 100644 include/bits/setjmp2.h
 create mode 100644 include/bits/shm.h
 create mode 100644 include/bits/sigaction.h
 create mode 100644 include/bits/sigcontext.h
 create mode 100644 include/bits/siginfo.h
 create mode 100644 include/bits/signum.h
 create mode 100644 include/bits/sigset.h
 create mode 100644 include/bits/sigstack.h
 create mode 100644 include/bits/sigthread.h
 create mode 100644 include/bits/sockaddr.h
 create mode 100644 include/bits/socket.h
 create mode 100644 include/bits/socket2.h
 create mode 100644 include/bits/spin-lock-inline.h
 create mode 100644 include/bits/spin-lock.h
 create mode 100644 include/bits/stab.def
 create mode 100644 include/bits/stat.h
 create mode 100644 include/bits/statfs.h
 create mode 100644 include/bits/statvfs.h
 create mode 100644 include/bits/stdio-ldbl.h
 create mode 100644 include/bits/stdio-lock.h
 create mode 100644 include/bits/stdio.h
 create mode 100644 include/bits/stdio2.h
 create mode 100644 include/bits/stdio_lim.h
 create mode 100644 include/bits/stdlib-bsearch.h
 create mode 100644 include/bits/stdlib-float.h
 create mode 100644 include/bits/stdlib-ldbl.h
 create mode 100644 include/bits/stdlib.h
 create mode 100644 include/bits/string.h
 create mode 100644 include/bits/string2.h
 create mode 100644 include/bits/string3.h
 create mode 100644 include/bits/stropts.h
 create mode 100644 include/bits/sys_errlist.h
 create mode 100644 include/bits/syslog-ldbl.h
 create mode 100644 include/bits/syslog-path.h
 create mode 100644 include/bits/syslog.h
 create mode 100644 include/bits/termios.h
 create mode 100644 include/bits/thread-attr.h
 create mode 100644 include/bits/thread-specific.h
 create mode 100644 include/bits/time.h
 create mode 100644 include/bits/types.h
 create mode 100644 include/bits/typesizes.h
 create mode 100644 include/bits/uio.h
 create mode 100644 include/bits/unistd.h
 create mode 100644 include/bits/ustat.h
 create mode 100644 include/bits/utmp.h
 create mode 100644 include/bits/utmpx.h
 create mode 100644 include/bits/utsname.h
 create mode 100644 include/bits/waitflags.h
 create mode 100644 include/bits/waitstatus.h
 create mode 100644 include/bits/wchar-ldbl.h
 create mode 100644 include/bits/wchar.h
 create mode 100644 include/bits/wchar2.h
 create mode 100644 include/bits/wordsize.h
 create mode 100644 include/bits/xopen_lim.h
 create mode 100644 include/bits/xtitypes.h
 create mode 100644 include/byteswap.h
 create mode 100644 include/complex.h
 create mode 100644 include/cpio.h
 create mode 100644 include/crypt.h
 create mode 100644 include/ctype.h
 create mode 100644 include/device/device.h
 create mode 100644 include/device/device_request.h
 create mode 100644 include/dirent.h
 create mode 100644 include/dlfcn.h
 create mode 100644 include/elf.h
 create mode 100644 include/endian.h
 create mode 100644 include/envz.h
 create mode 100644 include/err.h
 create mode 100644 include/errno.h
 create mode 100644 include/error.h
 create mode 100644 include/execinfo.h
 create mode 100644 include/faultexc_server.h
 create mode 100644 include/fcntl.h
 create mode 100644 include/features.h
 create mode 100644 include/fenv.h
 create mode 100644 include/fmtmsg.h
 create mode 100644 include/fnmatch.h
 create mode 100644 include/fpu_control.h
 create mode 100644 include/fstab.h
 create mode 100644 include/fts.h
 create mode 100644 include/ftw.h
 create mode 100644 include/gconv.h
 create mode 100644 include/getopt.h
 create mode 100644 include/glob.h
 create mode 100644 include/gnu-versions.h
 create mode 100644 include/gnu/lib-names.h
 create mode 100644 include/gnu/libc-version.h
 create mode 100644 include/gnu/stubs.h
 create mode 100644 include/grp.h
 create mode 100644 include/gshadow.h
 create mode 100644 include/hurd.h
 create mode 100644 include/hurd/auth.h
 create mode 100644 include/hurd/auth_reply.h
 create mode 100644 include/hurd/auth_request.h
 create mode 100644 include/hurd/crash.h
 create mode 100644 include/hurd/exec.h
 create mode 100644 include/hurd/exec_startup.h
 create mode 100644 include/hurd/fd.h
 create mode 100644 include/hurd/fs.h
 create mode 100644 include/hurd/fsys.h
 create mode 100644 include/hurd/id.h
 create mode 100644 include/hurd/ifsock.h
 create mode 100644 include/hurd/interrupt.h
 create mode 100644 include/hurd/io.h
 create mode 100644 include/hurd/io_reply.h
 create mode 100644 include/hurd/io_request.h
 create mode 100644 include/hurd/ioctl.h
 create mode 100644 include/hurd/login.h
 create mode 100644 include/hurd/lookup.h
 create mode 100644 include/hurd/msg.h
 create mode 100644 include/hurd/msg_reply.h
 create mode 100644 include/hurd/msg_request.h
 create mode 100644 include/hurd/msg_server.h
 create mode 100644 include/hurd/password.h
 create mode 100644 include/hurd/pfinet.h
 create mode 100644 include/hurd/port.h
 create mode 100644 include/hurd/process.h
 create mode 100644 include/hurd/process_request.h
 create mode 100644 include/hurd/resource.h
 create mode 100644 include/hurd/signal.h
 create mode 100644 include/hurd/sigpreempt.h
 create mode 100644 include/hurd/socket.h
 create mode 100644 include/hurd/startup.h
 create mode 100644 include/hurd/term.h
 create mode 100644 include/hurd/threadvar.h
 create mode 100644 include/hurd/tioctl.h
 create mode 100644 include/hurd/userlink.h
 create mode 100644 include/iconv.h
 create mode 100644 include/ieee754.h
 create mode 100644 include/ifaddrs.h
 create mode 100644 include/inttypes.h
 create mode 100644 include/langinfo.h
 create mode 100644 include/lastlog.h
 create mode 100644 include/libgen.h
 create mode 100644 include/libintl.h
 create mode 100644 include/libio.h
 create mode 100644 include/limits.h
 create mode 100644 include/link.h
 create mode 100644 include/locale.h
 create mode 100644 include/lock-intern.h
 create mode 100644 include/mach-shortcuts.h
 create mode 100644 include/mach.h
 create mode 100644 include/mach/default_pager.h
 create mode 100644 include/mach/error.h
 create mode 100644 include/mach/exc.h
 create mode 100644 include/mach/exc_server.h
 create mode 100644 include/mach/gnumach.h
 create mode 100644 include/mach/i386/mach_i386.h
 create mode 100644 include/mach/mach.h
 create mode 100644 include/mach/mach4.h
 create mode 100644 include/mach/mach_host.h
 create mode 100644 include/mach/mach_interface.h
 create mode 100644 include/mach/mach_port.h
 create mode 100644 include/mach/mach_traps.h
 create mode 100644 include/mach/memory_object_default.h
 create mode 100644 include/mach/memory_object_user.h
 create mode 100644 include/mach/mig_support.h
 create mode 100644 include/mach/task_notify.h
 create mode 100644 include/mach_error.h
 create mode 100644 include/mach_init.h
 create mode 100644 include/machine-lock.h
 create mode 100644 include/machine-sp.h
 create mode 100644 include/malloc.h
 create mode 100644 include/math.h
 create mode 100644 include/mcheck.h
 create mode 100644 include/memory.h
 create mode 100644 include/mntent.h
 create mode 100644 include/monetary.h
 create mode 100644 include/mqueue.h
 create mode 100644 include/net/ethernet.h
 create mode 100644 include/net/if.h
 create mode 100644 include/net/if_arp.h
 create mode 100644 include/net/if_ether.h
 create mode 100644 include/net/if_ppp.h
 create mode 100644 include/net/route.h
 create mode 100644 include/netdb.h
 create mode 100644 include/netinet/ether.h
 create mode 100644 include/netinet/icmp6.h
 create mode 100644 include/netinet/if_ether.h
 create mode 100644 include/netinet/igmp.h
 create mode 100644 include/netinet/in.h
 create mode 100644 include/netinet/in_systm.h
 create mode 100644 include/netinet/ip.h
 create mode 100644 include/netinet/ip6.h
 create mode 100644 include/netinet/ip_icmp.h
 create mode 100644 include/netinet/tcp.h
 create mode 100644 include/netinet/udp.h
 create mode 100644 include/nfs/nfs.h
 create mode 100644 include/nl_types.h
 create mode 100644 include/nss.h
 create mode 100644 include/obstack.h
 create mode 100644 include/paths.h
 create mode 100644 include/poll.h
 create mode 100644 include/printf.h
 create mode 100644 include/protocols/routed.h
 create mode 100644 include/protocols/rwhod.h
 create mode 100644 include/protocols/talkd.h
 create mode 100644 include/protocols/timed.h
 create mode 100644 include/pthread.h
 create mode 100644 include/pthread/pthread.h
 create mode 100644 include/pthread/pthreadtypes.h
 create mode 100644 include/pty.h
 create mode 100644 include/pwd.h
 create mode 100644 include/re_comp.h
 create mode 100644 include/regex.h
 create mode 100644 include/regexp.h
 create mode 100644 include/resolv.h
 create mode 100644 include/rpc/auth.h
 create mode 100644 include/rpc/auth_des.h
 create mode 100644 include/rpc/auth_unix.h
 create mode 100644 include/rpc/clnt.h
 create mode 100644 include/rpc/des_crypt.h
 create mode 100644 include/rpc/key_prot.h
 create mode 100644 include/rpc/netdb.h
 create mode 100644 include/rpc/pmap_clnt.h
 create mode 100644 include/rpc/pmap_prot.h
 create mode 100644 include/rpc/pmap_rmt.h
 create mode 100644 include/rpc/rpc.h
 create mode 100644 include/rpc/rpc_des.h
 create mode 100644 include/rpc/rpc_msg.h
 create mode 100644 include/rpc/svc.h
 create mode 100644 include/rpc/svc_auth.h
 create mode 100644 include/rpc/types.h
 create mode 100644 include/rpc/xdr.h
 create mode 100644 include/rpcsvc/bootparam.h
 create mode 100644 include/rpcsvc/bootparam_prot.h
 create mode 100644 include/rpcsvc/bootparam_prot.x
 create mode 100644 include/rpcsvc/key_prot.h
 create mode 100644 include/rpcsvc/key_prot.x
 create mode 100644 include/rpcsvc/klm_prot.h
 create mode 100644 include/rpcsvc/klm_prot.x
 create mode 100644 include/rpcsvc/mount.h
 create mode 100644 include/rpcsvc/mount.x
 create mode 100644 include/rpcsvc/nfs_prot.h
 create mode 100644 include/rpcsvc/nfs_prot.x
 create mode 100644 include/rpcsvc/nis.h
 create mode 100644 include/rpcsvc/nis.x
 create mode 100644 include/rpcsvc/nis_callback.h
 create mode 100644 include/rpcsvc/nis_callback.x
 create mode 100644 include/rpcsvc/nis_object.x
 create mode 100644 include/rpcsvc/nis_tags.h
 create mode 100644 include/rpcsvc/nislib.h
 create mode 100644 include/rpcsvc/nlm_prot.h
 create mode 100644 include/rpcsvc/nlm_prot.x
 create mode 100644 include/rpcsvc/rex.h
 create mode 100644 include/rpcsvc/rex.x
 create mode 100644 include/rpcsvc/rquota.h
 create mode 100644 include/rpcsvc/rquota.x
 create mode 100644 include/rpcsvc/rstat.h
 create mode 100644 include/rpcsvc/rstat.x
 create mode 100644 include/rpcsvc/rusers.h
 create mode 100644 include/rpcsvc/rusers.x
 create mode 100644 include/rpcsvc/sm_inter.h
 create mode 100644 include/rpcsvc/sm_inter.x
 create mode 100644 include/rpcsvc/spray.h
 create mode 100644 include/rpcsvc/spray.x
 create mode 100644 include/rpcsvc/yp.h
 create mode 100644 include/rpcsvc/yp.x
 create mode 100644 include/rpcsvc/yp_prot.h
 create mode 100644 include/rpcsvc/ypclnt.h
 create mode 100644 include/rpcsvc/yppasswd.h
 create mode 100644 include/rpcsvc/yppasswd.x
 create mode 100644 include/rpcsvc/ypupd.h
 create mode 100644 include/sched.h
 create mode 100644 include/search.h
 create mode 100644 include/semaphore.h
 create mode 100644 include/setjmp.h
 create mode 100644 include/sgtty.h
 create mode 100644 include/shadow.h
 create mode 100644 include/signal.h
 create mode 100644 include/spawn.h
 create mode 100644 include/spin-lock.h
 create mode 100644 include/stab.h
 create mode 100644 include/stdc-predef.h
 create mode 100644 include/stdint.h
 create mode 100644 include/stdio.h
 create mode 100644 include/stdio_ext.h
 create mode 100644 include/stdlib.h
 create mode 100644 include/string.h
 create mode 100644 include/strings.h
 create mode 100644 include/stropts.h
 create mode 100644 include/sys/auxv.h
 create mode 100644 include/sys/bitypes.h
 create mode 100644 include/sys/cdefs.h
 create mode 100644 include/sys/dir.h
 create mode 100644 include/sys/errno.h
 create mode 100644 include/sys/fcntl.h
 create mode 100644 include/sys/file.h
 create mode 100644 include/sys/gmon.h
 create mode 100644 include/sys/gmon_out.h
 create mode 100644 include/sys/io.h
 create mode 100644 include/sys/ioctl.h
 create mode 100644 include/sys/ipc.h
 create mode 100644 include/sys/mman.h
 create mode 100644 include/sys/msg.h
 create mode 100644 include/sys/mtio.h
 create mode 100644 include/sys/param.h
 create mode 100644 include/sys/poll.h
 create mode 100644 include/sys/profil.h
 create mode 100644 include/sys/ptrace.h
 create mode 100644 include/sys/queue.h
 create mode 100644 include/sys/reboot.h
 create mode 100644 include/sys/resource.h
 create mode 100644 include/sys/select.h
 create mode 100644 include/sys/sem.h
 create mode 100644 include/sys/sendfile.h
 create mode 100644 include/sys/shm.h
 create mode 100644 include/sys/signal.h
 create mode 100644 include/sys/socket.h
 create mode 100644 include/sys/socketvar.h
 create mode 100644 include/sys/stat.h
 create mode 100644 include/sys/statfs.h
 create mode 100644 include/sys/statvfs.h
 create mode 100644 include/sys/stropts.h
 create mode 100644 include/sys/swap.h
 create mode 100644 include/sys/syscall.h
 create mode 100644 include/sys/sysinfo.h
 create mode 100644 include/sys/syslog.h
 create mode 100644 include/sys/sysmacros.h
 create mode 100644 include/sys/termios.h
 create mode 100644 include/sys/time.h
 create mode 100644 include/sys/timeb.h
 create mode 100644 include/sys/times.h
 create mode 100644 include/sys/ttychars.h
 create mode 100644 include/sys/ttydefaults.h
 create mode 100644 include/sys/types.h
 create mode 100644 include/sys/ucontext.h
 create mode 100644 include/sys/uio.h
 create mode 100644 include/sys/un.h
 create mode 100644 include/sys/unistd.h
 create mode 100644 include/sys/ustat.h
 create mode 100644 include/sys/utsname.h
 create mode 100644 include/sys/vfs.h
 create mode 100644 include/sys/vlimit.h
 create mode 100644 include/sys/vtimes.h
 create mode 100644 include/sys/wait.h
 create mode 100644 include/sys/xattr.h
 create mode 100644 include/syscall.h
 create mode 100644 include/sysexits.h
 create mode 100644 include/syslog.h
 create mode 100644 include/tar.h
 create mode 100644 include/termios.h
 create mode 100644 include/tgmath.h
 create mode 100644 include/time.h
 create mode 100644 include/ttyent.h
 create mode 100644 include/uchar.h
 create mode 100644 include/ucontext.h
 create mode 100644 include/ulimit.h
 create mode 100644 include/unistd.h
 create mode 100644 include/ustat.h
 create mode 100644 include/utime.h
 create mode 100644 include/utmp.h
 create mode 100644 include/utmpx.h
 create mode 100644 include/values.h
 create mode 100644 include/wait.h
 create mode 100644 include/wchar.h
 create mode 100644 include/wctype.h
 create mode 100644 include/wordexp.h
 create mode 100644 include/xlocale.h

diff --git a/include/_G_config.h b/include/_G_config.h
new file mode 100644
index 0000000..f44a3d4
--- /dev/null
+++ b/include/_G_config.h
@@ -0,0 +1,57 @@
+/* This file is needed by libio to define various configuration parameters.
+   These are always the same in the GNU C library.  */
+
+#ifndef _G_config_h
+#define _G_config_h 1
+
+/* Define types for libio in terms of the standard internal type names.  */
+
+#include <bits/types.h>
+#define __need_size_t
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# define __need_wchar_t
+#endif
+#define __need_NULL
+#include <stddef.h>
+#define __need_mbstate_t
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# define __need_wint_t
+#endif
+#include <wchar.h>
+typedef struct
+{
+  __off_t __pos;
+  __mbstate_t __state;
+} _G_fpos_t;
+typedef struct
+{
+  __off64_t __pos;
+  __mbstate_t __state;
+} _G_fpos64_t;
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# include <gconv.h>
+typedef union
+{
+  struct __gconv_info __cd;
+  struct
+  {
+    struct __gconv_info __cd;
+    struct __gconv_step_data __data;
+  } __combined;
+} _G_iconv_t;
+#endif
+
+
+/* These library features are always available in the GNU C library.  */
+#define _G_va_list __gnuc_va_list
+
+#define _G_HAVE_MMAP 1
+
+#define _G_IO_IO_FILE_VERSION 0x20001
+
+/* This is defined by <bits/stat.h> if `st_blksize' exists.  */
+#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)
+
+#define _G_BUFSIZ 8192
+
+#endif	/* _G_config.h */
diff --git a/include/a.out.h b/include/a.out.h
new file mode 100644
index 0000000..2c13762
--- /dev/null
+++ b/include/a.out.h
@@ -0,0 +1,339 @@
+#ifndef __A_OUT_GNU_H__
+#define __A_OUT_GNU_H__
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#define __GNU_EXEC_MACROS__
+
+#ifndef __STRUCT_EXEC_OVERRIDE__
+
+struct exec
+{
+  unsigned long a_info;		/* Use macros N_MAGIC, etc for access */
+  unsigned a_text;		/* size of text, in bytes */
+  unsigned a_data;		/* size of data, in bytes */
+  unsigned a_bss;		/* size of uninitialized data area, in bytes */
+  unsigned a_syms;		/* length of symbol table data, in bytes */
+  unsigned a_entry;		/* start address */
+  unsigned a_trsize;		/* size of reloc info for text, in bytes */
+  unsigned a_drsize;		/* size of reloc info for data, in bytes */
+
+#if defined (sequent) && defined (i386)
+  struct gdtbl
+    {				/* Global Descriptor Table */
+      unsigned g_code[2];
+      unsigned g_data[2];
+      unsigned g_desc[2];
+    } a_gdtbl;
+   unsigned a_shdata;		/* size of initialized shared data */
+   unsigned a_shbss;		/* size of uninitialized shared data */
+   unsigned a_shdrsize;		/* size of shared data relocation */
+   unsigned a_bootstrap[11];	/* bootstrap for standalone */
+   unsigned a_reserved[3];	/* reserved for future use */
+   unsigned a_version;		/* object version */
+#endif /* Sequent Symmetry, Dynix 3.x */
+};
+
+#endif /* __STRUCT_EXEC_OVERRIDE__ */
+
+/* these go in the N_MACHTYPE field */
+enum machine_type {
+#if defined (M_OLDSUN2)
+  M__OLDSUN2 = M_OLDSUN2,
+#else
+  M_OLDSUN2 = 0,
+#endif
+#if defined (M_68010)
+  M__68010 = M_68010,
+#else
+  M_68010 = 1,
+#endif
+#if defined (M_68020)
+  M__68020 = M_68020,
+#else
+  M_68020 = 2,
+#endif
+#if defined (M_SPARC)
+  M__SPARC = M_SPARC,
+#else
+  M_SPARC = 3,
+#endif
+  /* skip a bunch so we don't run into any of sun's numbers */
+  M_386 = 100
+};
+
+#if defined (sequent) && defined (i386)
+
+/* Dynix 3 wants the magic number to be the whole first longword.  */
+
+#define N_MAGIC(exec)		((exec).a_info)
+#define N_MACHTYPE(exec)	0
+#define N_FLAGS(exec)		0
+#define N_SET_INFO(exec, magic, type, flags) N_SET_MAGIC ((exec), (magic))
+#define N_SET_MAGIC(exec, magic)	((exec).a_info = (magic))
+#define N_SET_MACHTYPE(exec, machtype)	((void) 0)
+#define N_SET_FLAGS(exec, flags)	((void) 0)
+#define	OMAGIC		0x12eb	/* impure format - for .o's */
+#define	ZMAGIC		0x22eb	/* demand load format - zero at zero */
+#define NMAGIC		you lose /* syntax error -- no pure format */
+#define N_BADMAG(x)	(N_MAGIC(x) != OMAGIC && N_MAGIC(x) != ZMAGIC)
+#define N_ADDRADJ(x)	(N_MAGIC(x) == ZMAGIC ? SEGMENT_SIZE : 0)
+#define N_DATOFF(x)	(N_TXTOFF(x) + (x).a_text - N_ADDRADJ(x))
+#define N_TRELOFF(x)	(N_DATOFF(x) + (x).a_data + (x).a_shdata)
+#define N_SYMOFF(x)	(N_DRELOFF(x) + (x).a_drsize + (x).a_shdrsize)
+#define N_TXTADDR(x)	SEGMENT_SIZE
+#define N_COMM		0x0a	/** conflicts with N_INDR **/
+#define N_FN		0x0c
+/* Note that the Dynix binutils believe that N_SET[TDB] are
+   N_SH{DATA,BSS,COMM} -- be wary when mixing GNU & Dynix objects.  */
+#define PAGE_SIZE	4096
+#define SEGMENT_SIZE	PAGE_SIZE
+
+#else /* !(sequent && i386) */
+
+#if !defined (N_MAGIC)
+#define N_MAGIC(exec) ((exec).a_info & 0xffff)
+#endif
+#define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info >> 16) & 0xff))
+#define N_FLAGS(exec) (((exec).a_info >> 24) & 0xff)
+#define N_SET_INFO(exec, magic, type, flags) \
+	((exec).a_info = ((magic) & 0xffff) \
+	 | (((int)(type) & 0xff) << 16) \
+	 | (((flags) & 0xff) << 24))
+#define N_SET_MAGIC(exec, magic) \
+	((exec).a_info = (((exec).a_info & 0xffff0000) | ((magic) & 0xffff)))
+
+#define N_SET_MACHTYPE(exec, machtype) \
+	((exec).a_info = \
+	 ((exec).a_info&0xff00ffff) | ((((int)(machtype))&0xff) << 16))
+
+#define N_SET_FLAGS(exec, flags) \
+	((exec).a_info = \
+	 ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))
+
+#endif	/* sequent && i386 */
+
+#ifndef OMAGIC
+/* Code indicating object file or impure executable.  */
+#define OMAGIC 0407
+/* Code indicating pure executable.  */
+#define NMAGIC 0410
+/* Code indicating demand-paged executable.  */
+#define ZMAGIC 0413
+#endif /* not OMAGIC */
+
+#if !defined (N_BADMAG)
+#define N_BADMAG(x)					\
+ (N_MAGIC(x) != OMAGIC && N_MAGIC(x) != NMAGIC		\
+  && N_MAGIC(x) != ZMAGIC)
+#endif
+
+#define _N_BADMAG(x)					\
+ (N_MAGIC(x) != OMAGIC && N_MAGIC(x) != NMAGIC		\
+  && N_MAGIC(x) != ZMAGIC)
+
+#ifndef	sparc
+#define _N_HDROFF(x) (SEGMENT_SIZE - sizeof (struct exec))
+#else
+#define _N_HDROFF(x) (- sizeof (struct exec))
+#endif
+
+#if !defined (N_TXTOFF)
+#define N_TXTOFF(x) \
+ (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) : sizeof (struct exec))
+#endif
+
+#if !defined (N_DATOFF)
+#define N_DATOFF(x) (N_TXTOFF(x) + (x).a_text)
+#endif
+
+#if !defined (N_TRELOFF)
+#define N_TRELOFF(x) (N_DATOFF(x) + (x).a_data)
+#endif
+
+#if !defined (N_DRELOFF)
+#define N_DRELOFF(x) (N_TRELOFF(x) + (x).a_trsize)
+#endif
+
+#if !defined (N_SYMOFF)
+#define N_SYMOFF(x) (N_DRELOFF(x) + (x).a_drsize)
+#endif
+
+#if !defined (N_STROFF)
+#define N_STROFF(x) (N_SYMOFF(x) + (x).a_syms)
+#endif
+
+/* Address of text segment in memory after it is loaded.  */
+#if !defined (N_TXTADDR)
+#define N_TXTADDR(x) 0
+#endif
+
+/* Address of data segment in memory after it is loaded.
+   Note that it is up to you to define SEGMENT_SIZE
+   on machines not listed here.  */
+#if	defined (hp300) || defined (mips)
+#define	PAGE_SIZE	4096
+#endif
+#if	defined (sparc) || defined (NeXT)
+#define	PAGE_SIZE	0x2000
+#endif
+#if	defined (sony) || (defined (sun) && defined (mc68000))
+#define	SEGMENT_SIZE	0x2000
+#endif	/* Sony or 68k Sun.  */
+#ifdef is68k
+#define SEGMENT_SIZE 0x20000
+#endif
+#if defined(m68k) && defined(PORTAR)
+#define PAGE_SIZE 0x400
+#endif
+#if defined(i386) && !defined(sequent)
+/* For COFF encapsulation.  */
+#define SEGMENT_SIZE 0x400000
+#endif
+#ifndef	SEGMENT_SIZE
+/* This used to be first in this paragraph and under:
+   if (defined(vax) || defined(hp300) || defined(pyr) || defined(sparc) \
+     || (defined(m68k) && defined(PORTAR)) \
+     || defined (NeXT) || defined (mips)) */
+#define SEGMENT_SIZE PAGE_SIZE
+#endif
+#ifndef	PAGE_SIZE
+/* This value is for i386-minix, but that has no predefine.
+   Making it default will only cause confusion on machines
+   which have no proper value defined.  */
+#define	PAGE_SIZE 16
+#endif
+
+#define	PAGSIZ	PAGE_SIZE
+#define	SEGSIZ	SEGMENT_SIZE
+
+#define _N_SEGMENT_ROUND(x) (((x) + SEGMENT_SIZE - 1) & ~(SEGMENT_SIZE - 1))
+
+#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)
+
+#ifndef N_DATADDR
+#define N_DATADDR(x) \
+    (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x)) \
+     : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x))))
+#endif
+
+/* Address of bss segment in memory after it is loaded.  */
+#if !defined (N_BSSADDR)
+#define N_BSSADDR(x) (N_DATADDR(x) + (x).a_data)
+#endif
+
+#if !defined (N_NLIST_DECLARED)
+struct nlist {
+  union {
+    char *n_name;
+    struct nlist *n_next;
+    long n_strx;
+  } n_un;
+  unsigned char n_type;
+  char n_other;
+  short n_desc;
+  unsigned long n_value;
+};
+#endif /* no N_NLIST_DECLARED.  */
+
+#if !defined (N_UNDF)
+#define N_UNDF 0
+#endif
+#if !defined (N_ABS)
+#define N_ABS 2
+#endif
+#if !defined (N_TEXT)
+#define N_TEXT 4
+#endif
+#if !defined (N_DATA)
+#define N_DATA 6
+#endif
+#if !defined (N_BSS)
+#define N_BSS 8
+#endif
+#if !defined (N_COMM)
+#define N_COMM 18
+#endif
+#if !defined (N_FN)
+#define N_FN 15
+#endif
+
+#if !defined (N_EXT)
+#define N_EXT 1
+#endif
+#if !defined (N_TYPE)
+#define N_TYPE 036
+#endif
+#if !defined (N_STAB)
+#define N_STAB 0340
+#endif
+
+/* The following type indicates the definition of a symbol as being
+   an indirect reference to another symbol.  The other symbol
+   appears as an undefined reference, immediately following this symbol.
+
+   Indirection is asymmetrical.  The other symbol's value will be used
+   to satisfy requests for the indirect symbol, but not vice versa.
+   If the other symbol does not have a definition, libraries will
+   be searched to find a definition.  */
+#define N_INDR 0xa
+
+/* The following symbols refer to set elements.
+   All the N_SET[ATDB] symbols with the same name form one set.
+   Space is allocated for the set in the text section, and each set
+   element's value is stored into one word of the space.
+   The first word of the space is the length of the set (number of elements).
+
+   The address of the set is made into an N_SETV symbol
+   whose name is the same as the name of the set.
+   This symbol acts like a N_DATA global symbol
+   in that it can satisfy undefined external references.  */
+
+/* These appear as input to LD, in a .o file.  */
+#define	N_SETA	0x14		/* Absolute set element symbol */
+#define	N_SETT	0x16		/* Text set element symbol */
+#define	N_SETD	0x18		/* Data set element symbol */
+#define	N_SETB	0x1A		/* Bss set element symbol */
+
+/* This is output from LD.  */
+#define N_SETV	0x1C		/* Pointer to set vector in data area.  */
+
+#if !defined (N_RELOCATION_INFO_DECLARED)
+/* This structure describes a single relocation to be performed.
+   The text-relocation section of the file is a vector of these structures,
+   all of which apply to the text section.
+   Likewise, the data-relocation section applies to the data section.  */
+
+struct relocation_info
+{
+  /* Address (within segment) to be relocated.  */
+  int r_address;
+  /* The meaning of r_symbolnum depends on r_extern.  */
+  unsigned int r_symbolnum:24;
+  /* Nonzero means value is a pc-relative offset
+     and it should be relocated for changes in its own address
+     as well as for changes in the symbol or section specified.  */
+  unsigned int r_pcrel:1;
+  /* Length (as exponent of 2) of the field to be relocated.
+     Thus, a value of 2 indicates 1<<2 bytes.  */
+  unsigned int r_length:2;
+  /* 1 => relocate with value of symbol.
+          r_symbolnum is the index of the symbol
+	  in file's the symbol table.
+     0 => relocate with the address of a segment.
+          r_symbolnum is N_TEXT, N_DATA, N_BSS or N_ABS
+	  (the N_EXT bit may be set also, but signifies nothing).  */
+  unsigned int r_extern:1;
+  /* Four bits that aren't used, but when writing an object file
+     it is desirable to clear them.  */
+  unsigned int r_pad:4;
+};
+#endif /* no N_RELOCATION_INFO_DECLARED.  */
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* __A_OUT_GNU_H__ */
diff --git a/include/aio.h b/include/aio.h
new file mode 100644
index 0000000..090ff05
--- /dev/null
+++ b/include/aio.h
@@ -0,0 +1,246 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * ISO/IEC 9945-1:1996 6.7: Asynchronous Input and Output
+ */
+
+#ifndef _AIO_H
+#define _AIO_H	1
+
+#include <features.h>
+#include <sys/types.h>
+#define __need_sigevent_t
+#include <bits/siginfo.h>
+#define __need_timespec
+#include <time.h>
+
+__BEGIN_DECLS
+
+/* Asynchronous I/O control block.  */
+struct aiocb
+{
+  int aio_fildes;		/* File desriptor.  */
+  int aio_lio_opcode;		/* Operation to be performed.  */
+  int aio_reqprio;		/* Request priority offset.  */
+  volatile void *aio_buf;	/* Location of buffer.  */
+  size_t aio_nbytes;		/* Length of transfer.  */
+  struct sigevent aio_sigevent;	/* Signal number and value.  */
+
+  /* Internal members.  */
+  struct aiocb *__next_prio;
+  int __abs_prio;
+  int __policy;
+  int __error_code;
+  __ssize_t __return_value;
+
+#ifndef __USE_FILE_OFFSET64
+  __off_t aio_offset;		/* File offset.  */
+  char __pad[sizeof (__off64_t) - sizeof (__off_t)];
+#else
+  __off64_t aio_offset;		/* File offset.  */
+#endif
+  char __glibc_reserved[32];
+};
+
+/* The same for the 64bit offsets.  Please note that the members aio_fildes
+   to __return_value have to be the same in aiocb and aiocb64.  */
+#ifdef __USE_LARGEFILE64
+struct aiocb64
+{
+  int aio_fildes;		/* File desriptor.  */
+  int aio_lio_opcode;		/* Operation to be performed.  */
+  int aio_reqprio;		/* Request priority offset.  */
+  volatile void *aio_buf;	/* Location of buffer.  */
+  size_t aio_nbytes;		/* Length of transfer.  */
+  struct sigevent aio_sigevent;	/* Signal number and value.  */
+
+  /* Internal members.  */
+  struct aiocb *__next_prio;
+  int __abs_prio;
+  int __policy;
+  int __error_code;
+  __ssize_t __return_value;
+
+  __off64_t aio_offset;		/* File offset.  */
+  char __glibc_reserved[32];
+};
+#endif
+
+
+#ifdef __USE_GNU
+/* To customize the implementation one can use the following struct.
+   This implementation follows the one in Irix.  */
+struct aioinit
+  {
+    int aio_threads;		/* Maximal number of threads.  */
+    int aio_num;		/* Number of expected simultanious requests. */
+    int aio_locks;		/* Not used.  */
+    int aio_usedba;		/* Not used.  */
+    int aio_debug;		/* Not used.  */
+    int aio_numusers;		/* Not used.  */
+    int aio_idle_time;		/* Number of seconds before idle thread
+				   terminates.  */
+    int aio_reserved;
+  };
+#endif
+
+
+/* Return values of cancelation function.  */
+enum
+{
+  AIO_CANCELED,
+#define AIO_CANCELED AIO_CANCELED
+  AIO_NOTCANCELED,
+#define AIO_NOTCANCELED AIO_NOTCANCELED
+  AIO_ALLDONE
+#define AIO_ALLDONE AIO_ALLDONE
+};
+
+
+/* Operation codes for `aio_lio_opcode'.  */
+enum
+{
+  LIO_READ,
+#define LIO_READ LIO_READ
+  LIO_WRITE,
+#define LIO_WRITE LIO_WRITE
+  LIO_NOP
+#define LIO_NOP LIO_NOP
+};
+
+
+/* Synchronization options for `lio_listio' function.  */
+enum
+{
+  LIO_WAIT,
+#define LIO_WAIT LIO_WAIT
+  LIO_NOWAIT
+#define LIO_NOWAIT LIO_NOWAIT
+};
+
+
+/* Allow user to specify optimization.  */
+#ifdef __USE_GNU
+extern void aio_init (const struct aioinit *__init) __THROW __nonnull ((1));
+#endif
+
+
+#ifndef __USE_FILE_OFFSET64
+/* Enqueue read request for given number of bytes and the given priority.  */
+extern int aio_read (struct aiocb *__aiocbp) __THROW __nonnull ((1));
+/* Enqueue write request for given number of bytes and the given priority.  */
+extern int aio_write (struct aiocb *__aiocbp) __THROW __nonnull ((1));
+
+/* Initiate list of I/O requests.  */
+extern int lio_listio (int __mode,
+		       struct aiocb *const __list[__restrict_arr],
+		       int __nent, struct sigevent *__restrict __sig)
+  __THROW __nonnull ((2));
+
+/* Retrieve error status associated with AIOCBP.  */
+extern int aio_error (const struct aiocb *__aiocbp) __THROW __nonnull ((1));
+/* Return status associated with AIOCBP.  */
+extern __ssize_t aio_return (struct aiocb *__aiocbp) __THROW __nonnull ((1));
+
+/* Try to cancel asynchronous I/O requests outstanding against file
+   descriptor FILDES.  */
+extern int aio_cancel (int __fildes, struct aiocb *__aiocbp) __THROW;
+
+/* Suspend calling thread until at least one of the asynchronous I/O
+   operations referenced by LIST has completed.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int aio_suspend (const struct aiocb *const __list[], int __nent,
+			const struct timespec *__restrict __timeout)
+  __nonnull ((1));
+
+/* Force all operations associated with file desriptor described by
+   `aio_fildes' member of AIOCBP.  */
+extern int aio_fsync (int __operation, struct aiocb *__aiocbp)
+  __THROW __nonnull ((2));
+#else
+# ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (aio_read, (struct aiocb *__aiocbp), aio_read64)
+  __nonnull ((1));
+extern int __REDIRECT_NTH (aio_write, (struct aiocb *__aiocbp), aio_write64)
+  __nonnull ((1));
+
+extern int __REDIRECT_NTH (lio_listio,
+			   (int __mode,
+			    struct aiocb *const __list[__restrict_arr],
+			    int __nent, struct sigevent *__restrict __sig),
+			   lio_listio64) __nonnull ((2));
+
+extern int __REDIRECT_NTH (aio_error, (const struct aiocb *__aiocbp),
+			   aio_error64) __nonnull ((1));
+extern __ssize_t __REDIRECT_NTH (aio_return, (struct aiocb *__aiocbp),
+				 aio_return64) __nonnull ((1));
+
+extern int __REDIRECT_NTH (aio_cancel,
+			   (int __fildes, struct aiocb *__aiocbp),
+			   aio_cancel64);
+
+extern int __REDIRECT_NTH (aio_suspend,
+			   (const struct aiocb *const __list[], int __nent,
+			    const struct timespec *__restrict __timeout),
+			   aio_suspend64) __nonnull ((1));
+
+extern int __REDIRECT_NTH (aio_fsync,
+			   (int __operation, struct aiocb *__aiocbp),
+			   aio_fsync64) __nonnull ((2));
+
+# else
+#  define aio_read aio_read64
+#  define aio_write aio_write64
+#  define lio_listio lio_listio64
+#  define aio_error aio_error64
+#  define aio_return aio_return64
+#  define aio_cancel aio_cancel64
+#  define aio_suspend aio_suspend64
+#  define aio_fsync aio_fsync64
+# endif
+#endif
+
+#ifdef __USE_LARGEFILE64
+extern int aio_read64 (struct aiocb64 *__aiocbp) __THROW __nonnull ((1));
+extern int aio_write64 (struct aiocb64 *__aiocbp) __THROW __nonnull ((1));
+
+extern int lio_listio64 (int __mode,
+			 struct aiocb64 *const __list[__restrict_arr],
+			 int __nent, struct sigevent *__restrict __sig)
+  __THROW __nonnull ((2));
+
+extern int aio_error64 (const struct aiocb64 *__aiocbp)
+  __THROW __nonnull ((1));
+extern __ssize_t aio_return64 (struct aiocb64 *__aiocbp)
+  __THROW __nonnull ((1));
+
+extern int aio_cancel64 (int __fildes, struct aiocb64 *__aiocbp) __THROW;
+
+extern int aio_suspend64 (const struct aiocb64 *const __list[], int __nent,
+			  const struct timespec *__restrict __timeout)
+  __THROW __nonnull ((1));
+
+extern int aio_fsync64 (int __operation, struct aiocb64 *__aiocbp)
+  __THROW __nonnull ((2));
+#endif
+
+__END_DECLS
+
+#endif /* aio.h */
diff --git a/include/aliases.h b/include/aliases.h
new file mode 100644
index 0000000..895520e
--- /dev/null
+++ b/include/aliases.h
@@ -0,0 +1,63 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ALIASES_H
+#define _ALIASES_H	1
+
+#include <features.h>
+
+#include <sys/types.h>
+
+
+__BEGIN_DECLS
+
+/* Structure to represent one entry of the alias data base.  */
+struct aliasent
+  {
+    char *alias_name;
+    size_t alias_members_len;
+    char **alias_members;
+    int alias_local;
+  };
+
+
+/* Open alias data base files.  */
+extern void setaliasent (void) __THROW;
+
+/* Close alias data base files.  */
+extern void endaliasent (void) __THROW;
+
+/* Get the next entry from the alias data base.  */
+extern struct aliasent *getaliasent (void) __THROW;
+
+/* Get the next entry from the alias data base and put it in RESULT_BUF.  */
+extern int getaliasent_r (struct aliasent *__restrict __result_buf,
+			  char *__restrict __buffer, size_t __buflen,
+			  struct aliasent **__restrict __result) __THROW;
+
+/* Get alias entry corresponding to NAME.  */
+extern struct aliasent *getaliasbyname (const char *__name) __THROW;
+
+/* Get alias entry corresponding to NAME and put it in RESULT_BUF.  */
+extern int getaliasbyname_r (const char *__restrict __name,
+			     struct aliasent *__restrict __result_buf,
+			     char *__restrict __buffer, size_t __buflen,
+			     struct aliasent **__restrict __result) __THROW;
+
+__END_DECLS
+
+#endif /* aliases.h */
diff --git a/include/alloca.h b/include/alloca.h
new file mode 100644
index 0000000..2d592d4
--- /dev/null
+++ b/include/alloca.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_ALLOCA_H
+#define	_ALLOCA_H	1
+
+#include <features.h>
+
+#define	__need_size_t
+#include <stddef.h>
+
+__BEGIN_DECLS
+
+/* Remove any previous definitions.  */
+#undef	alloca
+
+/* Allocate a block that will be freed when the calling function exits.  */
+extern void *alloca (size_t __size) __THROW;
+
+#ifdef	__GNUC__
+# define alloca(size)	__builtin_alloca (size)
+#endif /* GCC.  */
+
+__END_DECLS
+
+#endif /* alloca.h */
diff --git a/include/ar.h b/include/ar.h
new file mode 100644
index 0000000..a226f6d
--- /dev/null
+++ b/include/ar.h
@@ -0,0 +1,47 @@
+/* Header describing `ar' archive file format.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _AR_H
+#define _AR_H 1
+
+#include <sys/cdefs.h>
+
+/* Archive files start with the ARMAG identifying string.  Then follows a
+   `struct ar_hdr', and as many bytes of member file data as its `ar_size'
+   member indicates, for each member file.  */
+
+#define ARMAG	"!<arch>\n"	/* String that begins an archive file.  */
+#define SARMAG	8		/* Size of that string.  */
+
+#define ARFMAG	"`\n"		/* String in ar_fmag at end of each header.  */
+
+__BEGIN_DECLS
+
+struct ar_hdr
+  {
+    char ar_name[16];		/* Member file name, sometimes / terminated. */
+    char ar_date[12];		/* File date, decimal seconds since Epoch.  */
+    char ar_uid[6], ar_gid[6];	/* User and group IDs, in ASCII decimal.  */
+    char ar_mode[8];		/* File mode, in ASCII octal.  */
+    char ar_size[10];		/* File size, in ASCII decimal.  */
+    char ar_fmag[2];		/* Always contains ARFMAG.  */
+  };
+
+__END_DECLS
+
+#endif /* ar.h */
diff --git a/include/argp.h b/include/argp.h
new file mode 100644
index 0000000..3845172
--- /dev/null
+++ b/include/argp.h
@@ -0,0 +1,595 @@
+/* Hierarchial argument parsing, layered over getopt.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Written by Miles Bader <miles@gnu.ai.mit.edu>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ARGP_H
+#define _ARGP_H
+
+#include <stdio.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <limits.h>
+
+#define __need_error_t
+#include <errno.h>
+
+#ifndef __THROW
+# define __THROW
+#endif
+#ifndef __NTH
+# define __NTH(fct) fct __THROW
+#endif
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5) || __STRICT_ANSI__
+#  define __attribute__(Spec) /* empty */
+# endif
+/* The __-protected variants of `format' and `printf' attributes
+   are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7) || __STRICT_ANSI__
+#  define __format__ format
+#  define __printf__ printf
+# endif
+#endif
+
+/* GCC 2.95 and later have "__restrict"; C99 compilers have
+   "restrict", and "configure" may have defined "restrict".  */
+#ifndef __restrict
+# if ! (2 < __GNUC__ || (2 == __GNUC__ && 95 <= __GNUC_MINOR__))
+#  if defined restrict || 199901L <= __STDC_VERSION__
+#   define __restrict restrict
+#  else
+#   define __restrict
+#  endif
+# endif
+#endif
+
+#ifndef __error_t_defined
+typedef int error_t;
+# define __error_t_defined
+#endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* A description of a particular option.  A pointer to an array of
+   these is passed in the OPTIONS field of an argp structure.  Each option
+   entry can correspond to one long option and/or one short option; more
+   names for the same option can be added by following an entry in an option
+   array with options having the OPTION_ALIAS flag set.  */
+struct argp_option
+{
+  /* The long option name.  For more than one name for the same option, you
+     can use following options with the OPTION_ALIAS flag set.  */
+  const char *name;
+
+  /* What key is returned for this option.  If > 0 and printable, then it's
+     also accepted as a short option.  */
+  int key;
+
+  /* If non-NULL, this is the name of the argument associated with this
+     option, which is required unless the OPTION_ARG_OPTIONAL flag is set. */
+  const char *arg;
+
+  /* OPTION_ flags.  */
+  int flags;
+
+  /* The doc string for this option.  If both NAME and KEY are 0, This string
+     will be printed outdented from the normal option column, making it
+     useful as a group header (it will be the first thing printed in its
+     group); in this usage, it's conventional to end the string with a `:'.  */
+  const char *doc;
+
+  /* The group this option is in.  In a long help message, options are sorted
+     alphabetically within each group, and the groups presented in the order
+     0, 1, 2, ..., n, -m, ..., -2, -1.  Every entry in an options array with
+     if this field 0 will inherit the group number of the previous entry, or
+     zero if it's the first one, unless its a group header (NAME and KEY both
+     0), in which case, the previous entry + 1 is the default.  Automagic
+     options such as --help are put into group -1.  */
+  int group;
+};
+
+/* The argument associated with this option is optional.  */
+#define OPTION_ARG_OPTIONAL	0x1
+
+/* This option isn't displayed in any help messages.  */
+#define OPTION_HIDDEN	       	0x2
+
+/* This option is an alias for the closest previous non-alias option.  This
+   means that it will be displayed in the same help entry, and will inherit
+   fields other than NAME and KEY from the aliased option.  */
+#define OPTION_ALIAS		0x4
+
+/* This option isn't actually an option (and so should be ignored by the
+   actual option parser), but rather an arbitrary piece of documentation that
+   should be displayed in much the same manner as the options.  If this flag
+   is set, then the option NAME field is displayed unmodified (e.g., no `--'
+   prefix is added) at the left-margin (where a *short* option would normally
+   be displayed), and the documentation string in the normal place.  For
+   purposes of sorting, any leading whitespace and punctuation is ignored,
+   except that if the first non-whitespace character is not `-', this entry
+   is displayed after all options (and OPTION_DOC entries with a leading `-')
+   in the same group.  */
+#define OPTION_DOC		0x8
+
+/* This option shouldn't be included in `long' usage messages (but is still
+   included in help messages).  This is mainly intended for options that are
+   completely documented in an argp's ARGS_DOC field, in which case including
+   the option in the generic usage list would be redundant.  For instance,
+   if ARGS_DOC is "FOO BAR\n-x BLAH", and the `-x' option's purpose is to
+   distinguish these two cases, -x should probably be marked
+   OPTION_NO_USAGE.  */
+#define OPTION_NO_USAGE		0x10
+
+struct argp;			/* fwd declare this type */
+struct argp_state;		/* " */
+struct argp_child;		/* " */
+
+/* The type of a pointer to an argp parsing function.  */
+typedef error_t (*argp_parser_t) (int __key, char *__arg,
+				  struct argp_state *__state);
+
+/* What to return for unrecognized keys.  For special ARGP_KEY_ keys, such
+   returns will simply be ignored.  For user keys, this error will be turned
+   into EINVAL (if the call to argp_parse is such that errors are propagated
+   back to the user instead of exiting); returning EINVAL itself would result
+   in an immediate stop to parsing in *all* cases.  */
+#define ARGP_ERR_UNKNOWN	E2BIG /* Hurd should never need E2BIG.  XXX */
+
+/* Special values for the KEY argument to an argument parsing function.
+   ARGP_ERR_UNKNOWN should be returned if they aren't understood.
+
+   The sequence of keys to a parsing function is either (where each
+   uppercased word should be prefixed by `ARGP_KEY_' and opt is a user key):
+
+       INIT opt... NO_ARGS END SUCCESS  -- No non-option arguments at all
+   or  INIT (opt | ARG)... END SUCCESS  -- All non-option args parsed
+   or  INIT (opt | ARG)... SUCCESS      -- Some non-option arg unrecognized
+
+   The third case is where every parser returned ARGP_KEY_UNKNOWN for an
+   argument, in which case parsing stops at that argument (returning the
+   unparsed arguments to the caller of argp_parse if requested, or stopping
+   with an error message if not).
+
+   If an error occurs (either detected by argp, or because the parsing
+   function returned an error value), then the parser is called with
+   ARGP_KEY_ERROR, and no further calls are made.  */
+
+/* This is not an option at all, but rather a command line argument.  If a
+   parser receiving this key returns success, the fact is recorded, and the
+   ARGP_KEY_NO_ARGS case won't be used.  HOWEVER, if while processing the
+   argument, a parser function decrements the NEXT field of the state it's
+   passed, the option won't be considered processed; this is to allow you to
+   actually modify the argument (perhaps into an option), and have it
+   processed again.  */
+#define ARGP_KEY_ARG		0
+/* There are remaining arguments not parsed by any parser, which may be found
+   starting at (STATE->argv + STATE->next).  If success is returned, but
+   STATE->next left untouched, it's assumed that all arguments were consume,
+   otherwise, the parser should adjust STATE->next to reflect any arguments
+   consumed.  */
+#define ARGP_KEY_ARGS		0x1000006
+/* There are no more command line arguments at all.  */
+#define ARGP_KEY_END		0x1000001
+/* Because it's common to want to do some special processing if there aren't
+   any non-option args, user parsers are called with this key if they didn't
+   successfully process any non-option arguments.  Called just before
+   ARGP_KEY_END (where more general validity checks on previously parsed
+   arguments can take place).  */
+#define ARGP_KEY_NO_ARGS	0x1000002
+/* Passed in before any parsing is done.  Afterwards, the values of each
+   element of the CHILD_INPUT field, if any, in the state structure is
+   copied to each child's state to be the initial value of the INPUT field.  */
+#define ARGP_KEY_INIT		0x1000003
+/* Use after all other keys, including SUCCESS & END.  */
+#define ARGP_KEY_FINI		0x1000007
+/* Passed in when parsing has successfully been completed (even if there are
+   still arguments remaining).  */
+#define ARGP_KEY_SUCCESS	0x1000004
+/* Passed in if an error occurs.  */
+#define ARGP_KEY_ERROR		0x1000005
+
+/* An argp structure contains a set of options declarations, a function to
+   deal with parsing one, documentation string, a possible vector of child
+   argp's, and perhaps a function to filter help output.  When actually
+   parsing options, getopt is called with the union of all the argp
+   structures chained together through their CHILD pointers, with conflicts
+   being resolved in favor of the first occurrence in the chain.  */
+struct argp
+{
+  /* An array of argp_option structures, terminated by an entry with both
+     NAME and KEY having a value of 0.  */
+  const struct argp_option *options;
+
+  /* What to do with an option from this structure.  KEY is the key
+     associated with the option, and ARG is any associated argument (NULL if
+     none was supplied).  If KEY isn't understood, ARGP_ERR_UNKNOWN should be
+     returned.  If a non-zero, non-ARGP_ERR_UNKNOWN value is returned, then
+     parsing is stopped immediately, and that value is returned from
+     argp_parse().  For special (non-user-supplied) values of KEY, see the
+     ARGP_KEY_ definitions below.  */
+  argp_parser_t parser;
+
+  /* A string describing what other arguments are wanted by this program.  It
+     is only used by argp_usage to print the `Usage:' message.  If it
+     contains newlines, the strings separated by them are considered
+     alternative usage patterns, and printed on separate lines (lines after
+     the first are prefix by `  or: ' instead of `Usage:').  */
+  const char *args_doc;
+
+  /* If non-NULL, a string containing extra text to be printed before and
+     after the options in a long help message (separated by a vertical tab
+     `\v' character).  */
+  const char *doc;
+
+  /* A vector of argp_children structures, terminated by a member with a 0
+     argp field, pointing to child argps should be parsed with this one.  Any
+     conflicts are resolved in favor of this argp, or early argps in the
+     CHILDREN list.  This field is useful if you use libraries that supply
+     their own argp structure, which you want to use in conjunction with your
+     own.  */
+  const struct argp_child *children;
+
+  /* If non-zero, this should be a function to filter the output of help
+     messages.  KEY is either a key from an option, in which case TEXT is
+     that option's help text, or a special key from the ARGP_KEY_HELP_
+     defines, below, describing which other help text TEXT is.  The function
+     should return either TEXT, if it should be used as-is, a replacement
+     string, which should be malloced, and will be freed by argp, or NULL,
+     meaning `print nothing'.  The value for TEXT is *after* any translation
+     has been done, so if any of the replacement text also needs translation,
+     that should be done by the filter function.  INPUT is either the input
+     supplied to argp_parse, or NULL, if argp_help was called directly.  */
+  char *(*help_filter) (int __key, const char *__text, void *__input);
+
+  /* If non-zero the strings used in the argp library are translated using
+     the domain described by this string.  Otherwise the currently installed
+     default domain is used.  */
+  const char *argp_domain;
+};
+
+/* Possible KEY arguments to a help filter function.  */
+#define ARGP_KEY_HELP_PRE_DOC	0x2000001 /* Help text preceeding options. */
+#define ARGP_KEY_HELP_POST_DOC	0x2000002 /* Help text following options. */
+#define ARGP_KEY_HELP_HEADER	0x2000003 /* Option header string. */
+#define ARGP_KEY_HELP_EXTRA	0x2000004 /* After all other documentation;
+					     TEXT is NULL for this key.  */
+/* Explanatory note emitted when duplicate option arguments have been
+   suppressed.  */
+#define ARGP_KEY_HELP_DUP_ARGS_NOTE 0x2000005
+#define ARGP_KEY_HELP_ARGS_DOC	0x2000006 /* Argument doc string.  */
+
+/* When an argp has a non-zero CHILDREN field, it should point to a vector of
+   argp_child structures, each of which describes a subsidiary argp.  */
+struct argp_child
+{
+  /* The child parser.  */
+  const struct argp *argp;
+
+  /* Flags for this child.  */
+  int flags;
+
+  /* If non-zero, an optional header to be printed in help output before the
+     child options.  As a side-effect, a non-zero value forces the child
+     options to be grouped together; to achieve this effect without actually
+     printing a header string, use a value of "".  */
+  const char *header;
+
+  /* Where to group the child options relative to the other (`consolidated')
+     options in the parent argp; the values are the same as the GROUP field
+     in argp_option structs, but all child-groupings follow parent options at
+     a particular group level.  If both this field and HEADER are zero, then
+     they aren't grouped at all, but rather merged with the parent options
+     (merging the child's grouping levels with the parents).  */
+  int group;
+};
+
+/* Parsing state.  This is provided to parsing functions called by argp,
+   which may examine and, as noted, modify fields.  */
+struct argp_state
+{
+  /* The top level ARGP being parsed.  */
+  const struct argp *root_argp;
+
+  /* The argument vector being parsed.  May be modified.  */
+  int argc;
+  char **argv;
+
+  /* The index in ARGV of the next arg that to be parsed.  May be modified. */
+  int next;
+
+  /* The flags supplied to argp_parse.  May be modified.  */
+  unsigned flags;
+
+  /* While calling a parsing function with a key of ARGP_KEY_ARG, this is the
+     number of the current arg, starting at zero, and incremented after each
+     such call returns.  At all other times, this is the number of such
+     arguments that have been processed.  */
+  unsigned arg_num;
+
+  /* If non-zero, the index in ARGV of the first argument following a special
+     `--' argument (which prevents anything following being interpreted as an
+     option).  Only set once argument parsing has proceeded past this point. */
+  int quoted;
+
+  /* An arbitrary pointer passed in from the user.  */
+  void *input;
+  /* Values to pass to child parsers.  This vector will be the same length as
+     the number of children for the current parser.  */
+  void **child_inputs;
+
+  /* For the parser's use.  Initialized to 0.  */
+  void *hook;
+
+  /* The name used when printing messages.  This is initialized to ARGV[0],
+     or PROGRAM_INVOCATION_NAME if that is unavailable.  */
+  char *name;
+
+  /* Streams used when argp prints something.  */
+  FILE *err_stream;		/* For errors; initialized to stderr. */
+  FILE *out_stream;		/* For information; initialized to stdout. */
+
+  void *pstate;			/* Private, for use by argp.  */
+};
+
+/* Flags for argp_parse (note that the defaults are those that are
+   convenient for program command line parsing): */
+
+/* Don't ignore the first element of ARGV.  Normally (and always unless
+   ARGP_NO_ERRS is set) the first element of the argument vector is
+   skipped for option parsing purposes, as it corresponds to the program name
+   in a command line.  */
+#define ARGP_PARSE_ARGV0  0x01
+
+/* Don't print error messages for unknown options to stderr; unless this flag
+   is set, ARGP_PARSE_ARGV0 is ignored, as ARGV[0] is used as the program
+   name in the error messages.  This flag implies ARGP_NO_EXIT (on the
+   assumption that silent exiting upon errors is bad behaviour).  */
+#define ARGP_NO_ERRS	0x02
+
+/* Don't parse any non-option args.  Normally non-option args are parsed by
+   calling the parse functions with a key of ARGP_KEY_ARG, and the actual arg
+   as the value.  Since it's impossible to know which parse function wants to
+   handle it, each one is called in turn, until one returns 0 or an error
+   other than ARGP_ERR_UNKNOWN; if an argument is handled by no one, the
+   argp_parse returns prematurely (but with a return value of 0).  If all
+   args have been parsed without error, all parsing functions are called one
+   last time with a key of ARGP_KEY_END.  This flag needn't normally be set,
+   as the normal behavior is to stop parsing as soon as some argument can't
+   be handled.  */
+#define ARGP_NO_ARGS	0x04
+
+/* Parse options and arguments in the same order they occur on the command
+   line -- normally they're rearranged so that all options come first. */
+#define ARGP_IN_ORDER	0x08
+
+/* Don't provide the standard long option --help, which causes usage and
+      option help information to be output to stdout, and exit (0) called. */
+#define ARGP_NO_HELP	0x10
+
+/* Don't exit on errors (they may still result in error messages).  */
+#define ARGP_NO_EXIT	0x20
+
+/* Use the gnu getopt `long-only' rules for parsing arguments.  */
+#define ARGP_LONG_ONLY	0x40
+
+/* Turns off any message-printing/exiting options.  */
+#define ARGP_SILENT    (ARGP_NO_EXIT | ARGP_NO_ERRS | ARGP_NO_HELP)
+
+/* Parse the options strings in ARGC & ARGV according to the options in ARGP.
+   FLAGS is one of the ARGP_ flags above.  If ARG_INDEX is non-NULL, the
+   index in ARGV of the first unparsed option is returned in it.  If an
+   unknown option is present, ARGP_ERR_UNKNOWN is returned; if some parser
+   routine returned a non-zero value, it is returned; otherwise 0 is
+   returned.  This function may also call exit unless the ARGP_NO_HELP flag
+   is set.  INPUT is a pointer to a value to be passed in to the parser.  */
+extern error_t argp_parse (const struct argp *__restrict __argp,
+			   int __argc, char **__restrict __argv,
+			   unsigned __flags, int *__restrict __arg_index,
+			   void *__restrict __input);
+extern error_t __argp_parse (const struct argp *__restrict __argp,
+			     int __argc, char **__restrict __argv,
+			     unsigned __flags, int *__restrict __arg_index,
+			     void *__restrict __input);
+
+/* Global variables.  */
+
+/* If defined or set by the user program to a non-zero value, then a default
+   option --version is added (unless the ARGP_NO_HELP flag is used), which
+   will print this string followed by a newline and exit (unless the
+   ARGP_NO_EXIT flag is used).  Overridden by ARGP_PROGRAM_VERSION_HOOK.  */
+extern const char *argp_program_version;
+
+/* If defined or set by the user program to a non-zero value, then a default
+   option --version is added (unless the ARGP_NO_HELP flag is used), which
+   calls this function with a stream to print the version to and a pointer to
+   the current parsing state, and then exits (unless the ARGP_NO_EXIT flag is
+   used).  This variable takes precedent over ARGP_PROGRAM_VERSION.  */
+extern void (*argp_program_version_hook) (FILE *__restrict __stream,
+					  struct argp_state *__restrict
+					  __state);
+
+/* If defined or set by the user program, it should point to string that is
+   the bug-reporting address for the program.  It will be printed by
+   argp_help if the ARGP_HELP_BUG_ADDR flag is set (as it is by various
+   standard help messages), embedded in a sentence that says something like
+   `Report bugs to ADDR.'.  */
+extern const char *argp_program_bug_address;
+
+/* The exit status that argp will use when exiting due to a parsing error.
+   If not defined or set by the user program, this defaults to EX_USAGE from
+   <sysexits.h>.  */
+extern error_t argp_err_exit_status;
+
+/* Flags for argp_help.  */
+#define ARGP_HELP_USAGE		0x01 /* a Usage: message. */
+#define ARGP_HELP_SHORT_USAGE	0x02 /*  " but don't actually print options. */
+#define ARGP_HELP_SEE		0x04 /* a `Try ... for more help' message. */
+#define ARGP_HELP_LONG		0x08 /* a long help message. */
+#define ARGP_HELP_PRE_DOC	0x10 /* doc string preceding long help.  */
+#define ARGP_HELP_POST_DOC	0x20 /* doc string following long help.  */
+#define ARGP_HELP_DOC		(ARGP_HELP_PRE_DOC | ARGP_HELP_POST_DOC)
+#define ARGP_HELP_BUG_ADDR	0x40 /* bug report address */
+#define ARGP_HELP_LONG_ONLY	0x80 /* modify output appropriately to
+					reflect ARGP_LONG_ONLY mode.  */
+
+/* These ARGP_HELP flags are only understood by argp_state_help.  */
+#define ARGP_HELP_EXIT_ERR	0x100 /* Call exit(1) instead of returning.  */
+#define ARGP_HELP_EXIT_OK	0x200 /* Call exit(0) instead of returning.  */
+
+/* The standard thing to do after a program command line parsing error, if an
+   error message has already been printed.  */
+#define ARGP_HELP_STD_ERR \
+  (ARGP_HELP_SEE | ARGP_HELP_EXIT_ERR)
+/* The standard thing to do after a program command line parsing error, if no
+   more specific error message has been printed.  */
+#define ARGP_HELP_STD_USAGE \
+  (ARGP_HELP_SHORT_USAGE | ARGP_HELP_SEE | ARGP_HELP_EXIT_ERR)
+/* The standard thing to do in response to a --help option.  */
+#define ARGP_HELP_STD_HELP \
+  (ARGP_HELP_SHORT_USAGE | ARGP_HELP_LONG | ARGP_HELP_EXIT_OK \
+   | ARGP_HELP_DOC | ARGP_HELP_BUG_ADDR)
+
+/* Output a usage message for ARGP to STREAM.  FLAGS are from the set
+   ARGP_HELP_*.  */
+extern void argp_help (const struct argp *__restrict __argp,
+		       FILE *__restrict __stream,
+		       unsigned __flags, char *__restrict __name);
+extern void __argp_help (const struct argp *__restrict __argp,
+			 FILE *__restrict __stream, unsigned __flags,
+			 char *__name);
+
+/* The following routines are intended to be called from within an argp
+   parsing routine (thus taking an argp_state structure as the first
+   argument).  They may or may not print an error message and exit, depending
+   on the flags in STATE -- in any case, the caller should be prepared for
+   them *not* to exit, and should return an appropiate error after calling
+   them.  [argp_usage & argp_error should probably be called argp_state_...,
+   but they're used often enough that they should be short]  */
+
+/* Output, if appropriate, a usage message for STATE to STREAM.  FLAGS are
+   from the set ARGP_HELP_*.  */
+extern void argp_state_help (const struct argp_state *__restrict __state,
+			     FILE *__restrict __stream,
+			     unsigned int __flags);
+extern void __argp_state_help (const struct argp_state *__restrict __state,
+			       FILE *__restrict __stream,
+			       unsigned int __flags);
+
+/* Possibly output the standard usage message for ARGP to stderr and exit.  */
+extern void argp_usage (const struct argp_state *__state);
+extern void __argp_usage (const struct argp_state *__state);
+
+/* If appropriate, print the printf string FMT and following args, preceded
+   by the program name and `:', to stderr, and followed by a `Try ... --help'
+   message, then exit (1).  */
+extern void argp_error (const struct argp_state *__restrict __state,
+			const char *__restrict __fmt, ...)
+     __attribute__ ((__format__ (__printf__, 2, 3)));
+extern void __argp_error (const struct argp_state *__restrict __state,
+			  const char *__restrict __fmt, ...)
+     __attribute__ ((__format__ (__printf__, 2, 3)));
+
+/* Similar to the standard gnu error-reporting function error(), but will
+   respect the ARGP_NO_EXIT and ARGP_NO_ERRS flags in STATE, and will print
+   to STATE->err_stream.  This is useful for argument parsing code that is
+   shared between program startup (when exiting is desired) and runtime
+   option parsing (when typically an error code is returned instead).  The
+   difference between this function and argp_error is that the latter is for
+   *parsing errors*, and the former is for other problems that occur during
+   parsing but don't reflect a (syntactic) problem with the input.  */
+extern void argp_failure (const struct argp_state *__restrict __state,
+			  int __status, int __errnum,
+			  const char *__restrict __fmt, ...)
+     __attribute__ ((__format__ (__printf__, 4, 5)));
+extern void __argp_failure (const struct argp_state *__restrict __state,
+			    int __status, int __errnum,
+			    const char *__restrict __fmt, ...)
+     __attribute__ ((__format__ (__printf__, 4, 5)));
+
+/* Returns true if the option OPT is a valid short option.  */
+extern int _option_is_short (const struct argp_option *__opt) __THROW;
+extern int __option_is_short (const struct argp_option *__opt) __THROW;
+
+/* Returns true if the option OPT is in fact the last (unused) entry in an
+   options array.  */
+extern int _option_is_end (const struct argp_option *__opt) __THROW;
+extern int __option_is_end (const struct argp_option *__opt) __THROW;
+
+/* Return the input field for ARGP in the parser corresponding to STATE; used
+   by the help routines.  */
+extern void *_argp_input (const struct argp *__restrict __argp,
+			  const struct argp_state *__restrict __state)
+     __THROW;
+extern void *__argp_input (const struct argp *__restrict __argp,
+			   const struct argp_state *__restrict __state)
+     __THROW;
+
+#ifdef __USE_EXTERN_INLINES
+
+# if !_LIBC
+#  define __argp_usage argp_usage
+#  define __argp_state_help argp_state_help
+#  define __option_is_short _option_is_short
+#  define __option_is_end _option_is_end
+# endif
+
+# ifndef ARGP_EI
+#  define ARGP_EI __extern_inline
+# endif
+
+ARGP_EI void
+__argp_usage (const struct argp_state *__state)
+{
+  __argp_state_help (__state, stderr, ARGP_HELP_STD_USAGE);
+}
+
+ARGP_EI int
+__NTH (__option_is_short (const struct argp_option *__opt))
+{
+  if (__opt->flags & OPTION_DOC)
+    return 0;
+  else
+    {
+      int __key = __opt->key;
+      return __key > 0 && __key <= UCHAR_MAX && isprint (__key);
+    }
+}
+
+ARGP_EI int
+__NTH (__option_is_end (const struct argp_option *__opt))
+{
+  return !__opt->key && !__opt->name && !__opt->doc && !__opt->group;
+}
+
+# if !_LIBC
+#  undef __argp_usage
+#  undef __argp_state_help
+#  undef __option_is_short
+#  undef __option_is_end
+# endif
+#endif /* Use extern inlines.  */
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /* argp.h */
diff --git a/include/argz.h b/include/argz.h
new file mode 100644
index 0000000..f43271f
--- /dev/null
+++ b/include/argz.h
@@ -0,0 +1,182 @@
+/* Routines for dealing with '\0' separated arg vectors.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ARGZ_H
+#define _ARGZ_H	1
+
+#include <features.h>
+
+#define __need_error_t
+#include <errno.h>
+#include <string.h>		/* Need size_t, and strchr is called below.  */
+
+#ifndef __error_t_defined
+typedef int error_t;
+#endif
+
+
+__BEGIN_DECLS
+
+/* Make a '\0' separated arg vector from a unix argv vector, returning it in
+   ARGZ, and the total length in LEN.  If a memory allocation error occurs,
+   ENOMEM is returned, otherwise 0.  The result can be destroyed using free. */
+extern error_t __argz_create (char *const __argv[], char **__restrict __argz,
+			      size_t *__restrict __len) __THROW;
+extern error_t argz_create (char *const __argv[], char **__restrict __argz,
+			    size_t *__restrict __len) __THROW;
+
+/* Make a '\0' separated arg vector from a SEP separated list in
+   STRING, returning it in ARGZ, and the total length in LEN.  If a
+   memory allocation error occurs, ENOMEM is returned, otherwise 0.
+   The result can be destroyed using free.  */
+extern error_t __argz_create_sep (const char *__restrict __string,
+				  int __sep, char **__restrict __argz,
+				  size_t *__restrict __len) __THROW;
+extern error_t argz_create_sep (const char *__restrict __string,
+				int __sep, char **__restrict __argz,
+				size_t *__restrict __len) __THROW;
+
+/* Returns the number of strings in ARGZ.  */
+extern size_t __argz_count (const char *__argz, size_t __len)
+     __THROW __attribute_pure__;
+extern size_t argz_count (const char *__argz, size_t __len)
+     __THROW __attribute_pure__;
+
+/* Puts pointers to each string in ARGZ into ARGV, which must be large enough
+   to hold them all.  */
+extern void __argz_extract (const char *__restrict __argz, size_t __len,
+			    char **__restrict __argv) __THROW;
+extern void argz_extract (const char *__restrict __argz, size_t __len,
+			  char **__restrict __argv) __THROW;
+
+/* Make '\0' separated arg vector ARGZ printable by converting all the '\0's
+   except the last into the character SEP.  */
+extern void __argz_stringify (char *__argz, size_t __len, int __sep) __THROW;
+extern void argz_stringify (char *__argz, size_t __len, int __sep) __THROW;
+
+/* Append BUF, of length BUF_LEN to the argz vector in ARGZ & ARGZ_LEN.  */
+extern error_t __argz_append (char **__restrict __argz,
+			      size_t *__restrict __argz_len,
+			      const char *__restrict __buf, size_t __buf_len)
+     __THROW;
+extern error_t argz_append (char **__restrict __argz,
+			    size_t *__restrict __argz_len,
+			    const char *__restrict __buf, size_t __buf_len)
+     __THROW;
+
+/* Append STR to the argz vector in ARGZ & ARGZ_LEN.  */
+extern error_t __argz_add (char **__restrict __argz,
+			   size_t *__restrict __argz_len,
+			   const char *__restrict __str) __THROW;
+extern error_t argz_add (char **__restrict __argz,
+			 size_t *__restrict __argz_len,
+			 const char *__restrict __str) __THROW;
+
+/* Append SEP separated list in STRING to the argz vector in ARGZ &
+   ARGZ_LEN.  */
+extern error_t __argz_add_sep (char **__restrict __argz,
+			       size_t *__restrict __argz_len,
+			       const char *__restrict __string, int __delim)
+     __THROW;
+extern error_t argz_add_sep (char **__restrict __argz,
+			     size_t *__restrict __argz_len,
+			     const char *__restrict __string, int __delim)
+     __THROW;
+
+/* Delete ENTRY from ARGZ & ARGZ_LEN, if it appears there.  */
+extern void __argz_delete (char **__restrict __argz,
+			   size_t *__restrict __argz_len,
+			   char *__restrict __entry) __THROW;
+extern void argz_delete (char **__restrict __argz,
+			 size_t *__restrict __argz_len,
+			 char *__restrict __entry) __THROW;
+
+/* Insert ENTRY into ARGZ & ARGZ_LEN before BEFORE, which should be an
+   existing entry in ARGZ; if BEFORE is NULL, ENTRY is appended to the end.
+   Since ARGZ's first entry is the same as ARGZ, argz_insert (ARGZ, ARGZ_LEN,
+   ARGZ, ENTRY) will insert ENTRY at the beginning of ARGZ.  If BEFORE is not
+   in ARGZ, EINVAL is returned, else if memory can't be allocated for the new
+   ARGZ, ENOMEM is returned, else 0.  */
+extern error_t __argz_insert (char **__restrict __argz,
+			      size_t *__restrict __argz_len,
+			      char *__restrict __before,
+			      const char *__restrict __entry) __THROW;
+extern error_t argz_insert (char **__restrict __argz,
+			    size_t *__restrict __argz_len,
+			    char *__restrict __before,
+			    const char *__restrict __entry) __THROW;
+
+/* Replace any occurrences of the string STR in ARGZ with WITH, reallocating
+   ARGZ as necessary.  If REPLACE_COUNT is non-zero, *REPLACE_COUNT will be
+   incremented by number of replacements performed.  */
+extern error_t __argz_replace (char **__restrict __argz,
+			       size_t *__restrict __argz_len,
+			       const char *__restrict __str,
+			       const char *__restrict __with,
+			       unsigned int *__restrict __replace_count);
+extern error_t argz_replace (char **__restrict __argz,
+			     size_t *__restrict __argz_len,
+			     const char *__restrict __str,
+			     const char *__restrict __with,
+			     unsigned int *__restrict __replace_count);
+
+/* Returns the next entry in ARGZ & ARGZ_LEN after ENTRY, or NULL if there
+   are no more.  If entry is NULL, then the first entry is returned.  This
+   behavior allows two convenient iteration styles:
+
+    char *entry = 0;
+    while ((entry = argz_next (argz, argz_len, entry)))
+      ...;
+
+   or
+
+    char *entry;
+    for (entry = argz; entry; entry = argz_next (argz, argz_len, entry))
+      ...;
+*/
+extern char *__argz_next (const char *__restrict __argz, size_t __argz_len,
+			  const char *__restrict __entry) __THROW;
+extern char *argz_next (const char *__restrict __argz, size_t __argz_len,
+			const char *__restrict __entry) __THROW;
+
+#ifdef __USE_EXTERN_INLINES
+__extern_inline char *
+__NTH (__argz_next (const char *__argz, size_t __argz_len,
+		    const char *__entry))
+{
+  if (__entry)
+    {
+      if (__entry < __argz + __argz_len)
+	__entry = strchr (__entry, '\0') + 1;
+
+      return __entry >= __argz + __argz_len ? (char *) NULL : (char *) __entry;
+    }
+  else
+    return __argz_len > 0 ? (char *) __argz : 0;
+}
+__extern_inline char *
+__NTH (argz_next (const char *__argz, size_t __argz_len,
+		  const char *__entry))
+{
+  return __argz_next (__argz, __argz_len, __entry);
+}
+#endif /* Use extern inlines.  */
+
+__END_DECLS
+
+#endif /* argz.h */
diff --git a/include/arpa/ftp.h b/include/arpa/ftp.h
new file mode 100644
index 0000000..e5b340d
--- /dev/null
+++ b/include/arpa/ftp.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 1983, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ftp.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _ARPA_FTP_H
+#define	_ARPA_FTP_H 1
+
+/* Definitions for FTP; see RFC-765. */
+
+/*
+ * Reply codes.
+ */
+#define PRELIM		1	/* positive preliminary */
+#define COMPLETE	2	/* positive completion */
+#define CONTINUE	3	/* positive intermediate */
+#define TRANSIENT	4	/* transient negative completion */
+#define ERROR		5	/* permanent negative completion */
+
+/*
+ * Type codes
+ */
+#define	TYPE_A		1	/* ASCII */
+#define	TYPE_E		2	/* EBCDIC */
+#define	TYPE_I		3	/* image */
+#define	TYPE_L		4	/* local byte size */
+
+#ifdef FTP_NAMES
+char *typenames[] =  {"0", "ASCII", "EBCDIC", "Image", "Local" };
+#endif
+
+/*
+ * Form codes
+ */
+#define	FORM_N		1	/* non-print */
+#define	FORM_T		2	/* telnet format effectors */
+#define	FORM_C		3	/* carriage control (ASA) */
+#ifdef FTP_NAMES
+char *formnames[] =  {"0", "Nonprint", "Telnet", "Carriage-control" };
+#endif
+
+/*
+ * Structure codes
+ */
+#define	STRU_F		1	/* file (no record structure) */
+#define	STRU_R		2	/* record structure */
+#define	STRU_P		3	/* page structure */
+#ifdef FTP_NAMES
+char *strunames[] =  {"0", "File", "Record", "Page" };
+#endif
+
+/*
+ * Mode types
+ */
+#define	MODE_S		1	/* stream */
+#define	MODE_B		2	/* block */
+#define	MODE_C		3	/* compressed */
+#ifdef FTP_NAMES
+char *modenames[] =  {"0", "Stream", "Block", "Compressed" };
+#endif
+
+/*
+ * Record Tokens
+ */
+#define	REC_ESC		'\377'	/* Record-mode Escape */
+#define	REC_EOR		'\001'	/* Record-mode End-of-Record */
+#define REC_EOF		'\002'	/* Record-mode End-of-File */
+
+/*
+ * Block Header
+ */
+#define	BLK_EOR		0x80	/* Block is End-of-Record */
+#define	BLK_EOF		0x40	/* Block is End-of-File */
+#define BLK_ERRORS	0x20	/* Block is suspected of containing errors */
+#define	BLK_RESTART	0x10	/* Block is Restart Marker */
+
+#define	BLK_BYTECOUNT	2	/* Bytes in this block */
+
+#endif /* arpa/ftp.h */
diff --git a/include/arpa/inet.h b/include/arpa/inet.h
new file mode 100644
index 0000000..22b5542
--- /dev/null
+++ b/include/arpa/inet.h
@@ -0,0 +1,105 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ARPA_INET_H
+#define	_ARPA_INET_H	1
+
+#include <features.h>
+#include <netinet/in.h>		/* To define `struct in_addr'.  */
+
+/* Type for length arguments in socket calls.  */
+#ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+# define __socklen_t_defined
+#endif
+
+__BEGIN_DECLS
+
+/* Convert Internet host address from numbers-and-dots notation in CP
+   into binary data in network byte order.  */
+extern in_addr_t inet_addr (const char *__cp) __THROW;
+
+/* Return the local host address part of the Internet address in IN.  */
+extern in_addr_t inet_lnaof (struct in_addr __in) __THROW;
+
+/* Make Internet host address in network byte order by combining the
+   network number NET with the local address HOST.  */
+extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
+     __THROW;
+
+/* Return network number part of the Internet address IN.  */
+extern in_addr_t inet_netof (struct in_addr __in) __THROW;
+
+/* Extract the network number in network byte order from the address
+   in numbers-and-dots natation starting at CP.  */
+extern in_addr_t inet_network (const char *__cp) __THROW;
+
+/* Convert Internet number in IN to ASCII representation.  The return value
+   is a pointer to an internal array containing the string.  */
+extern char *inet_ntoa (struct in_addr __in) __THROW;
+
+/* Convert from presentation format of an Internet number in buffer
+   starting at CP to the binary network format and store result for
+   interface type AF in buffer starting at BUF.  */
+extern int inet_pton (int __af, const char *__restrict __cp,
+		      void *__restrict __buf) __THROW;
+
+/* Convert a Internet address in binary network format for interface
+   type AF in buffer starting at CP to presentation form and place
+   result in buffer of length LEN astarting at BUF.  */
+extern const char *inet_ntop (int __af, const void *__restrict __cp,
+			      char *__restrict __buf, socklen_t __len)
+     __THROW;
+
+
+/* The following functions are not part of XNS 5.2.  */
+#ifdef __USE_MISC
+/* Convert Internet host address from numbers-and-dots notation in CP
+   into binary data and store the result in the structure INP.  */
+extern int inet_aton (const char *__cp, struct in_addr *__inp) __THROW;
+
+/* Format a network number NET into presentation format and place result
+   in buffer starting at BUF with length of LEN bytes.  */
+extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __THROW;
+
+/* Convert network number for interface type AF in buffer starting at
+   CP to presentation format.  The result will specifiy BITS bits of
+   the number.  */
+extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
+			    char *__buf, size_t __len) __THROW;
+
+/* Convert network number for interface type AF from presentation in
+   buffer starting at CP to network format and store result int
+   buffer starting at BUF of size LEN.  */
+extern int inet_net_pton (int __af, const char *__cp,
+			  void *__buf, size_t __len) __THROW;
+
+/* Convert ASCII representation in hexadecimal form of the Internet
+   address to binary form and place result in buffer of length LEN
+   starting at BUF.  */
+extern unsigned int inet_nsap_addr (const char *__cp,
+				    unsigned char *__buf, int __len) __THROW;
+
+/* Convert internet address in binary form in LEN bytes starting at CP
+   a presentation form and place result in BUF.  */
+extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
+			     char *__buf) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* arpa/inet.h */
diff --git a/include/arpa/nameser.h b/include/arpa/nameser.h
new file mode 100644
index 0000000..fb8513b
--- /dev/null
+++ b/include/arpa/nameser.h
@@ -0,0 +1,535 @@
+/*
+ * Copyright (c) 1983, 1989, 1993
+ *    The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (c) 1996-1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+ * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+ * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+/*
+ *	$BINDId: nameser.h,v 8.37 2000/03/30 21:16:49 vixie Exp $
+ */
+
+#ifndef _ARPA_NAMESER_H_
+#define _ARPA_NAMESER_H_
+
+/*! \file */
+
+#define BIND_4_COMPAT
+
+#include <sys/param.h>
+#if (!defined(BSD)) || (BSD < 199306)
+# include <sys/bitypes.h>
+#else
+# include <sys/types.h>
+#endif
+#include <sys/cdefs.h>
+
+/*%
+ * Revision information.  This is the release date in YYYYMMDD format.
+ * It can change every day so the right thing to do with it is use it
+ * in preprocessor commands such as "#if (__NAMESER > 19931104)".  Do not
+ * compare for equality; rather, use it to determine whether your libbind.a
+ * contains a new enough lib/nameser/ to support the feature you need.
+ */
+
+#define __NAMESER	19991006	/*%< New interface version stamp. */
+/*
+ * Define constants based on RFC 883, RFC 1034, RFC 1035
+ */
+#define NS_PACKETSZ	512	/*%< default UDP packet size */
+#define NS_MAXDNAME	1025	/*%< maximum domain name */
+#define NS_MAXMSG	65535	/*%< maximum message size */
+#define NS_MAXCDNAME	255	/*%< maximum compressed domain name */
+#define NS_MAXLABEL	63	/*%< maximum length of domain label */
+#define NS_HFIXEDSZ	12	/*%< #/bytes of fixed data in header */
+#define NS_QFIXEDSZ	4	/*%< #/bytes of fixed data in query */
+#define NS_RRFIXEDSZ	10	/*%< #/bytes of fixed data in r record */
+#define NS_INT32SZ	4	/*%< #/bytes of data in a u_int32_t */
+#define NS_INT16SZ	2	/*%< #/bytes of data in a u_int16_t */
+#define NS_INT8SZ	1	/*%< #/bytes of data in a u_int8_t */
+#define NS_INADDRSZ	4	/*%< IPv4 T_A */
+#define NS_IN6ADDRSZ	16	/*%< IPv6 T_AAAA */
+#define NS_CMPRSFLGS	0xc0	/*%< Flag bits indicating name compression. */
+#define NS_DEFAULTPORT	53	/*%< For both TCP and UDP. */
+/*
+ * These can be expanded with synonyms, just keep ns_parse.c:ns_parserecord()
+ * in synch with it.
+ */
+typedef enum __ns_sect {
+	ns_s_qd = 0,		/*%< Query: Question. */
+	ns_s_zn = 0,		/*%< Update: Zone. */
+	ns_s_an = 1,		/*%< Query: Answer. */
+	ns_s_pr = 1,		/*%< Update: Prerequisites. */
+	ns_s_ns = 2,		/*%< Query: Name servers. */
+	ns_s_ud = 2,		/*%< Update: Update. */
+	ns_s_ar = 3,		/*%< Query|Update: Additional records. */
+	ns_s_max = 4
+} ns_sect;
+
+/*%
+ * This is a message handle.  It is caller allocated and has no dynamic data.
+ * This structure is intended to be opaque to all but ns_parse.c, thus the
+ * leading _'s on the member names.  Use the accessor functions, not the _'s.
+ */
+typedef struct __ns_msg {
+	const u_char	*_msg, *_eom;
+	u_int16_t	_id, _flags, _counts[ns_s_max];
+	const u_char	*_sections[ns_s_max];
+	ns_sect		_sect;
+	int		_rrnum;
+	const u_char	*_msg_ptr;
+} ns_msg;
+
+/* Private data structure - do not use from outside library. */
+struct _ns_flagdata {  int mask, shift;  };
+extern const struct _ns_flagdata _ns_flagdata[];
+
+/* Accessor macros - this is part of the public interface. */
+
+#define ns_msg_id(handle) ((handle)._id + 0)
+#define ns_msg_base(handle) ((handle)._msg + 0)
+#define ns_msg_end(handle) ((handle)._eom + 0)
+#define ns_msg_size(handle) ((handle)._eom - (handle)._msg)
+#define ns_msg_count(handle, section) ((handle)._counts[section] + 0)
+
+/*%
+ * This is a parsed record.  It is caller allocated and has no dynamic data.
+ */
+typedef	struct __ns_rr {
+	char		name[NS_MAXDNAME];
+	u_int16_t	type;
+	u_int16_t	rr_class;
+	u_int32_t	ttl;
+	u_int16_t	rdlength;
+	const u_char *	rdata;
+} ns_rr;
+
+/* Accessor macros - this is part of the public interface. */
+#define ns_rr_name(rr)	(((rr).name[0] != '\0') ? (rr).name : ".")
+#define ns_rr_type(rr)	((ns_type)((rr).type + 0))
+#define ns_rr_class(rr)	((ns_class)((rr).rr_class + 0))
+#define ns_rr_ttl(rr)	((rr).ttl + 0)
+#define ns_rr_rdlen(rr)	((rr).rdlength + 0)
+#define ns_rr_rdata(rr)	((rr).rdata + 0)
+
+/*%
+ * These don't have to be in the same order as in the packet flags word,
+ * and they can even overlap in some cases, but they will need to be kept
+ * in synch with ns_parse.c:ns_flagdata[].
+ */
+typedef enum __ns_flag {
+	ns_f_qr,		/*%< Question/Response. */
+	ns_f_opcode,		/*%< Operation code. */
+	ns_f_aa,		/*%< Authoritative Answer. */
+	ns_f_tc,		/*%< Truncation occurred. */
+	ns_f_rd,		/*%< Recursion Desired. */
+	ns_f_ra,		/*%< Recursion Available. */
+	ns_f_z,			/*%< MBZ. */
+	ns_f_ad,		/*%< Authentic Data (DNSSEC). */
+	ns_f_cd,		/*%< Checking Disabled (DNSSEC). */
+	ns_f_rcode,		/*%< Response code. */
+	ns_f_max
+} ns_flag;
+
+/*%
+ * Currently defined opcodes.
+ */
+typedef enum __ns_opcode {
+	ns_o_query = 0,		/*%< Standard query. */
+	ns_o_iquery = 1,	/*%< Inverse query (deprecated/unsupported). */
+	ns_o_status = 2,	/*%< Name server status query (unsupported). */
+				/* Opcode 3 is undefined/reserved. */
+	ns_o_notify = 4,	/*%< Zone change notification. */
+	ns_o_update = 5,	/*%< Zone update message. */
+	ns_o_max = 6
+} ns_opcode;
+
+/*%
+ * Currently defined response codes.
+ */
+typedef	enum __ns_rcode {
+	ns_r_noerror = 0,	/*%< No error occurred. */
+	ns_r_formerr = 1,	/*%< Format error. */
+	ns_r_servfail = 2,	/*%< Server failure. */
+	ns_r_nxdomain = 3,	/*%< Name error. */
+	ns_r_notimpl = 4,	/*%< Unimplemented. */
+	ns_r_refused = 5,	/*%< Operation refused. */
+	/* these are for BIND_UPDATE */
+	ns_r_yxdomain = 6,	/*%< Name exists */
+	ns_r_yxrrset = 7,	/*%< RRset exists */
+	ns_r_nxrrset = 8,	/*%< RRset does not exist */
+	ns_r_notauth = 9,	/*%< Not authoritative for zone */
+	ns_r_notzone = 10,	/*%< Zone of record different from zone section */
+	ns_r_max = 11,
+	/* The following are EDNS extended rcodes */
+	ns_r_badvers = 16,
+	/* The following are TSIG errors */
+	ns_r_badsig = 16,
+	ns_r_badkey = 17,
+	ns_r_badtime = 18
+} ns_rcode;
+
+/* BIND_UPDATE */
+typedef enum __ns_update_operation {
+	ns_uop_delete = 0,
+	ns_uop_add = 1,
+	ns_uop_max = 2
+} ns_update_operation;
+
+/*%
+ * This structure is used for TSIG authenticated messages
+ */
+struct ns_tsig_key {
+        char name[NS_MAXDNAME], alg[NS_MAXDNAME];
+        unsigned char *data;
+        int len;
+};
+typedef struct ns_tsig_key ns_tsig_key;
+
+/*%
+ * This structure is used for TSIG authenticated TCP messages
+ */
+struct ns_tcp_tsig_state {
+	int counter;
+	struct dst_key *key;
+	void *ctx;
+	unsigned char sig[NS_PACKETSZ];
+	int siglen;
+};
+typedef struct ns_tcp_tsig_state ns_tcp_tsig_state;
+
+#define NS_TSIG_FUDGE 300
+#define NS_TSIG_TCP_COUNT 100
+#define NS_TSIG_ALG_HMAC_MD5 "HMAC-MD5.SIG-ALG.REG.INT"
+
+#define NS_TSIG_ERROR_NO_TSIG -10
+#define NS_TSIG_ERROR_NO_SPACE -11
+#define NS_TSIG_ERROR_FORMERR -12
+
+/*%
+ * Currently defined type values for resources and queries.
+ */
+typedef enum __ns_type {
+	ns_t_invalid = 0,	/*%< Cookie. */
+	ns_t_a = 1,		/*%< Host address. */
+	ns_t_ns = 2,		/*%< Authoritative server. */
+	ns_t_md = 3,		/*%< Mail destination. */
+	ns_t_mf = 4,		/*%< Mail forwarder. */
+	ns_t_cname = 5,		/*%< Canonical name. */
+	ns_t_soa = 6,		/*%< Start of authority zone. */
+	ns_t_mb = 7,		/*%< Mailbox domain name. */
+	ns_t_mg = 8,		/*%< Mail group member. */
+	ns_t_mr = 9,		/*%< Mail rename name. */
+	ns_t_null = 10,		/*%< Null resource record. */
+	ns_t_wks = 11,		/*%< Well known service. */
+	ns_t_ptr = 12,		/*%< Domain name pointer. */
+	ns_t_hinfo = 13,	/*%< Host information. */
+	ns_t_minfo = 14,	/*%< Mailbox information. */
+	ns_t_mx = 15,		/*%< Mail routing information. */
+	ns_t_txt = 16,		/*%< Text strings. */
+	ns_t_rp = 17,		/*%< Responsible person. */
+	ns_t_afsdb = 18,	/*%< AFS cell database. */
+	ns_t_x25 = 19,		/*%< X_25 calling address. */
+	ns_t_isdn = 20,		/*%< ISDN calling address. */
+	ns_t_rt = 21,		/*%< Router. */
+	ns_t_nsap = 22,		/*%< NSAP address. */
+	ns_t_nsap_ptr = 23,	/*%< Reverse NSAP lookup (deprecated). */
+	ns_t_sig = 24,		/*%< Security signature. */
+	ns_t_key = 25,		/*%< Security key. */
+	ns_t_px = 26,		/*%< X.400 mail mapping. */
+	ns_t_gpos = 27,		/*%< Geographical position (withdrawn). */
+	ns_t_aaaa = 28,		/*%< Ip6 Address. */
+	ns_t_loc = 29,		/*%< Location Information. */
+	ns_t_nxt = 30,		/*%< Next domain (security). */
+	ns_t_eid = 31,		/*%< Endpoint identifier. */
+	ns_t_nimloc = 32,	/*%< Nimrod Locator. */
+	ns_t_srv = 33,		/*%< Server Selection. */
+	ns_t_atma = 34,		/*%< ATM Address */
+	ns_t_naptr = 35,	/*%< Naming Authority PoinTeR */
+	ns_t_kx = 36,		/*%< Key Exchange */
+	ns_t_cert = 37,		/*%< Certification record */
+	ns_t_a6 = 38,		/*%< IPv6 address (deprecated, use ns_t_aaaa) */
+	ns_t_dname = 39,	/*%< Non-terminal DNAME (for IPv6) */
+	ns_t_sink = 40,		/*%< Kitchen sink (experimentatl) */
+	ns_t_opt = 41,		/*%< EDNS0 option (meta-RR) */
+	ns_t_apl = 42,		/*%< Address prefix list (RFC3123) */
+	ns_t_tkey = 249,	/*%< Transaction key */
+	ns_t_tsig = 250,	/*%< Transaction signature. */
+	ns_t_ixfr = 251,	/*%< Incremental zone transfer. */
+	ns_t_axfr = 252,	/*%< Transfer zone of authority. */
+	ns_t_mailb = 253,	/*%< Transfer mailbox records. */
+	ns_t_maila = 254,	/*%< Transfer mail agent records. */
+	ns_t_any = 255,		/*%< Wildcard match. */
+	ns_t_zxfr = 256,	/*%< BIND-specific, nonstandard. */
+	ns_t_max = 65536
+} ns_type;
+
+/* Exclusively a QTYPE? (not also an RTYPE) */
+#define	ns_t_qt_p(t) (ns_t_xfr_p(t) || (t) == ns_t_any || \
+		      (t) == ns_t_mailb || (t) == ns_t_maila)
+/* Some kind of meta-RR? (not a QTYPE, but also not an RTYPE) */
+#define	ns_t_mrr_p(t) ((t) == ns_t_tsig || (t) == ns_t_opt)
+/* Exclusively an RTYPE? (not also a QTYPE or a meta-RR) */
+#define ns_t_rr_p(t) (!ns_t_qt_p(t) && !ns_t_mrr_p(t))
+#define ns_t_udp_p(t) ((t) != ns_t_axfr && (t) != ns_t_zxfr)
+#define ns_t_xfr_p(t) ((t) == ns_t_axfr || (t) == ns_t_ixfr || \
+		       (t) == ns_t_zxfr)
+
+/*%
+ * Values for class field
+ */
+typedef enum __ns_class {
+	ns_c_invalid = 0,	/*%< Cookie. */
+	ns_c_in = 1,		/*%< Internet. */
+	ns_c_2 = 2,		/*%< unallocated/unsupported. */
+	ns_c_chaos = 3,		/*%< MIT Chaos-net. */
+	ns_c_hs = 4,		/*%< MIT Hesiod. */
+	/* Query class values which do not appear in resource records */
+	ns_c_none = 254,	/*%< for prereq. sections in update requests */
+	ns_c_any = 255,		/*%< Wildcard match. */
+	ns_c_max = 65536
+} ns_class;
+
+/* DNSSEC constants. */
+
+typedef enum __ns_key_types {
+	ns_kt_rsa = 1,		/*%< key type RSA/MD5 */
+	ns_kt_dh  = 2,		/*%< Diffie Hellman */
+	ns_kt_dsa = 3,		/*%< Digital Signature Standard (MANDATORY) */
+	ns_kt_private = 254	/*%< Private key type starts with OID */
+} ns_key_types;
+
+typedef enum __ns_cert_types {
+	cert_t_pkix = 1,	/*%< PKIX (X.509v3) */
+	cert_t_spki = 2,	/*%< SPKI */
+	cert_t_pgp  = 3,	/*%< PGP */
+	cert_t_url  = 253,	/*%< URL private type */
+	cert_t_oid  = 254	/*%< OID private type */
+} ns_cert_types;
+
+/* Flags field of the KEY RR rdata. */
+#define	NS_KEY_TYPEMASK		0xC000	/*%< Mask for "type" bits */
+#define	NS_KEY_TYPE_AUTH_CONF	0x0000	/*%< Key usable for both */
+#define	NS_KEY_TYPE_CONF_ONLY	0x8000	/*%< Key usable for confidentiality */
+#define	NS_KEY_TYPE_AUTH_ONLY	0x4000	/*%< Key usable for authentication */
+#define	NS_KEY_TYPE_NO_KEY	0xC000	/*%< No key usable for either; no key */
+/* The type bits can also be interpreted independently, as single bits: */
+#define	NS_KEY_NO_AUTH		0x8000	/*%< Key unusable for authentication */
+#define	NS_KEY_NO_CONF		0x4000	/*%< Key unusable for confidentiality */
+#define	NS_KEY_RESERVED2	0x2000	/* Security is *mandatory* if bit=0 */
+#define	NS_KEY_EXTENDED_FLAGS	0x1000	/*%< reserved - must be zero */
+#define	NS_KEY_RESERVED4	0x0800  /*%< reserved - must be zero */
+#define	NS_KEY_RESERVED5	0x0400  /*%< reserved - must be zero */
+#define	NS_KEY_NAME_TYPE	0x0300	/*%< these bits determine the type */
+#define	NS_KEY_NAME_USER	0x0000	/*%< key is assoc. with user */
+#define	NS_KEY_NAME_ENTITY	0x0200	/*%< key is assoc. with entity eg host */
+#define	NS_KEY_NAME_ZONE	0x0100	/*%< key is zone key */
+#define	NS_KEY_NAME_RESERVED	0x0300	/*%< reserved meaning */
+#define	NS_KEY_RESERVED8	0x0080  /*%< reserved - must be zero */
+#define	NS_KEY_RESERVED9	0x0040  /*%< reserved - must be zero */
+#define	NS_KEY_RESERVED10	0x0020  /*%< reserved - must be zero */
+#define	NS_KEY_RESERVED11	0x0010  /*%< reserved - must be zero */
+#define	NS_KEY_SIGNATORYMASK	0x000F	/*%< key can sign RR's of same name */
+#define	NS_KEY_RESERVED_BITMASK ( NS_KEY_RESERVED2 | \
+				  NS_KEY_RESERVED4 | \
+				  NS_KEY_RESERVED5 | \
+				  NS_KEY_RESERVED8 | \
+				  NS_KEY_RESERVED9 | \
+				  NS_KEY_RESERVED10 | \
+				  NS_KEY_RESERVED11 )
+#define NS_KEY_RESERVED_BITMASK2 0xFFFF /*%< no bits defined here */
+/* The Algorithm field of the KEY and SIG RR's is an integer, {1..254} */
+#define	NS_ALG_MD5RSA		1	/*%< MD5 with RSA */
+#define	NS_ALG_DH               2	/*%< Diffie Hellman KEY */
+#define	NS_ALG_DSA              3	/*%< DSA KEY */
+#define	NS_ALG_DSS              NS_ALG_DSA
+#define	NS_ALG_EXPIRE_ONLY	253	/*%< No alg, no security */
+#define	NS_ALG_PRIVATE_OID	254	/*%< Key begins with OID giving alg */
+/* Protocol values  */
+/* value 0 is reserved */
+#define NS_KEY_PROT_TLS         1
+#define NS_KEY_PROT_EMAIL       2
+#define NS_KEY_PROT_DNSSEC      3
+#define NS_KEY_PROT_IPSEC       4
+#define NS_KEY_PROT_ANY		255
+
+/* Signatures */
+#define	NS_MD5RSA_MIN_BITS	 512	/*%< Size of a mod or exp in bits */
+#define	NS_MD5RSA_MAX_BITS	4096
+	/* Total of binary mod and exp */
+#define	NS_MD5RSA_MAX_BYTES	((NS_MD5RSA_MAX_BITS+7/8)*2+3)
+	/* Max length of text sig block */
+#define	NS_MD5RSA_MAX_BASE64	(((NS_MD5RSA_MAX_BYTES+2)/3)*4)
+#define NS_MD5RSA_MIN_SIZE	((NS_MD5RSA_MIN_BITS+7)/8)
+#define NS_MD5RSA_MAX_SIZE	((NS_MD5RSA_MAX_BITS+7)/8)
+
+#define NS_DSA_SIG_SIZE         41
+#define NS_DSA_MIN_SIZE         213
+#define NS_DSA_MAX_BYTES        405
+
+/* Offsets into SIG record rdata to find various values */
+#define	NS_SIG_TYPE	0	/*%< Type flags */
+#define	NS_SIG_ALG	2	/*%< Algorithm */
+#define	NS_SIG_LABELS	3	/*%< How many labels in name */
+#define	NS_SIG_OTTL	4	/*%< Original TTL */
+#define	NS_SIG_EXPIR	8	/*%< Expiration time */
+#define	NS_SIG_SIGNED	12	/*%< Signature time */
+#define	NS_SIG_FOOT	16	/*%< Key footprint */
+#define	NS_SIG_SIGNER	18	/*%< Domain name of who signed it */
+/* How RR types are represented as bit-flags in NXT records */
+#define	NS_NXT_BITS 8
+#define	NS_NXT_BIT_SET(  n,p) (p[(n)/NS_NXT_BITS] |=  (0x80>>((n)%NS_NXT_BITS)))
+#define	NS_NXT_BIT_CLEAR(n,p) (p[(n)/NS_NXT_BITS] &= ~(0x80>>((n)%NS_NXT_BITS)))
+#define	NS_NXT_BIT_ISSET(n,p) (p[(n)/NS_NXT_BITS] &   (0x80>>((n)%NS_NXT_BITS)))
+#define NS_NXT_MAX 127
+
+/*%
+ * EDNS0 extended flags and option codes, host order.
+ */
+#define NS_OPT_DNSSEC_OK        0x8000U
+#define NS_OPT_NSID		3
+
+/*%
+ * Inline versions of get/put short/long.  Pointer is advanced.
+ */
+#define NS_GET16(s, cp) do { \
+	const u_char *t_cp = (const u_char *)(cp); \
+	(s) = ((u_int16_t)t_cp[0] << 8) \
+	    | ((u_int16_t)t_cp[1]) \
+	    ; \
+	(cp) += NS_INT16SZ; \
+} while (0)
+
+#define NS_GET32(l, cp) do { \
+	const u_char *t_cp = (const u_char *)(cp); \
+	(l) = ((u_int32_t)t_cp[0] << 24) \
+	    | ((u_int32_t)t_cp[1] << 16) \
+	    | ((u_int32_t)t_cp[2] << 8) \
+	    | ((u_int32_t)t_cp[3]) \
+	    ; \
+	(cp) += NS_INT32SZ; \
+} while (0)
+
+#define NS_PUT16(s, cp) do { \
+	u_int16_t t_s = (u_int16_t)(s); \
+	u_char *t_cp = (u_char *)(cp); \
+	*t_cp++ = t_s >> 8; \
+	*t_cp   = t_s; \
+	(cp) += NS_INT16SZ; \
+} while (0)
+
+#define NS_PUT32(l, cp) do { \
+	u_int32_t t_l = (u_int32_t)(l); \
+	u_char *t_cp = (u_char *)(cp); \
+	*t_cp++ = t_l >> 24; \
+	*t_cp++ = t_l >> 16; \
+	*t_cp++ = t_l >> 8; \
+	*t_cp   = t_l; \
+	(cp) += NS_INT32SZ; \
+} while (0)
+
+__BEGIN_DECLS
+int		ns_msg_getflag (ns_msg, int) __THROW;
+u_int		ns_get16 (const u_char *) __THROW;
+u_long		ns_get32 (const u_char *) __THROW;
+void		ns_put16 (u_int, u_char *) __THROW;
+void		ns_put32 (u_long, u_char *) __THROW;
+int		ns_initparse (const u_char *, int, ns_msg *) __THROW;
+int		ns_skiprr (const u_char *, const u_char *, ns_sect, int)
+     __THROW;
+int		ns_parserr (ns_msg *, ns_sect, int, ns_rr *) __THROW;
+int		ns_sprintrr (const ns_msg *, const ns_rr *,
+			     const char *, const char *, char *, size_t)
+     __THROW;
+int		ns_sprintrrf (const u_char *, size_t, const char *,
+			      ns_class, ns_type, u_long, const u_char *,
+			      size_t, const char *, const char *,
+			      char *, size_t) __THROW;
+int		ns_format_ttl (u_long, char *, size_t) __THROW;
+int		ns_parse_ttl (const char *, u_long *) __THROW;
+u_int32_t	ns_datetosecs (const char *, int *) __THROW;
+int		ns_name_ntol (const u_char *, u_char *, size_t) __THROW;
+int		ns_name_ntop (const u_char *, char *, size_t) __THROW;
+int		ns_name_pton (const char *, u_char *, size_t) __THROW;
+int		ns_name_unpack (const u_char *, const u_char *,
+				const u_char *, u_char *, size_t) __THROW;
+int		ns_name_pack (const u_char *, u_char *, int,
+			      const u_char **, const u_char **) __THROW;
+int		ns_name_uncompress (const u_char *, const u_char *,
+				    const u_char *, char *, size_t) __THROW;
+int		ns_name_compress (const char *, u_char *, size_t,
+				  const u_char **, const u_char **) __THROW;
+int		ns_name_skip (const u_char **, const u_char *) __THROW;
+void		ns_name_rollback (const u_char *, const u_char **,
+				  const u_char **) __THROW;
+int		ns_sign (u_char *, int *, int, int, void *,
+			 const u_char *, int, u_char *, int *, time_t) __THROW;
+int		ns_sign2 (u_char *, int *, int, int, void *,
+			  const u_char *, int, u_char *, int *, time_t,
+			  u_char **, u_char **) __THROW;
+int		ns_sign_tcp (u_char *, int *, int, int,
+			     ns_tcp_tsig_state *, int) __THROW;
+int		ns_sign_tcp2 (u_char *, int *, int, int,
+			      ns_tcp_tsig_state *, int,
+			      u_char **, u_char **) __THROW;
+int		ns_sign_tcp_init (void *, const u_char *, int,
+				  ns_tcp_tsig_state *) __THROW;
+u_char		*ns_find_tsig (u_char *, u_char *) __THROW;
+int		ns_verify (u_char *, int *, void *, const u_char *, int,
+			   u_char *, int *, time_t *, int) __THROW;
+int		ns_verify_tcp (u_char *, int *, ns_tcp_tsig_state *, int)
+     __THROW;
+int		ns_verify_tcp_init (void *, const u_char *, int,
+				    ns_tcp_tsig_state *) __THROW;
+int		ns_samedomain (const char *, const char *) __THROW;
+int		ns_subdomain (const char *, const char *) __THROW;
+int		ns_makecanon (const char *, char *, size_t) __THROW;
+int		ns_samename (const char *, const char *) __THROW;
+__END_DECLS
+
+#ifdef BIND_4_COMPAT
+#include <arpa/nameser_compat.h>
+#endif
+
+#endif /* !_ARPA_NAMESER_H_ */
+/*! \file */
diff --git a/include/arpa/nameser_compat.h b/include/arpa/nameser_compat.h
new file mode 100644
index 0000000..d59c9e4
--- /dev/null
+++ b/include/arpa/nameser_compat.h
@@ -0,0 +1,187 @@
+/* Copyright (c) 1983, 1989
+ *    The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*%
+ *      from nameser.h	8.1 (Berkeley) 6/2/93
+ *	$BINDId: nameser_compat.h,v 8.11 1999/01/02 08:00:58 vixie Exp $
+ */
+
+#ifndef _ARPA_NAMESER_COMPAT_
+#define	_ARPA_NAMESER_COMPAT_
+
+#define	__BIND		19950621	/*%< (DEAD) interface version stamp. */
+
+#include <endian.h>
+
+/*%
+ * Structure for query header.  The order of the fields is machine- and
+ * compiler-dependent, depending on the byte/bit order and the layout
+ * of bit fields.  We use bit fields only in int variables, as this
+ * is all ANSI requires.  This requires a somewhat confusing rearrangement.
+ */
+
+typedef struct {
+	unsigned	id :16;		/*%< query identification number */
+#if BYTE_ORDER == BIG_ENDIAN
+			/* fields in third byte */
+	unsigned	qr: 1;		/*%< response flag */
+	unsigned	opcode: 4;	/*%< purpose of message */
+	unsigned	aa: 1;		/*%< authoritive answer */
+	unsigned	tc: 1;		/*%< truncated message */
+	unsigned	rd: 1;		/*%< recursion desired */
+			/* fields in fourth byte */
+	unsigned	ra: 1;		/*%< recursion available */
+	unsigned	unused :1;	/*%< unused bits (MBZ as of 4.9.3a3) */
+	unsigned	ad: 1;		/*%< authentic data from named */
+	unsigned	cd: 1;		/*%< checking disabled by resolver */
+	unsigned	rcode :4;	/*%< response code */
+#endif
+#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
+			/* fields in third byte */
+	unsigned	rd :1;		/*%< recursion desired */
+	unsigned	tc :1;		/*%< truncated message */
+	unsigned	aa :1;		/*%< authoritive answer */
+	unsigned	opcode :4;	/*%< purpose of message */
+	unsigned	qr :1;		/*%< response flag */
+			/* fields in fourth byte */
+	unsigned	rcode :4;	/*%< response code */
+	unsigned	cd: 1;		/*%< checking disabled by resolver */
+	unsigned	ad: 1;		/*%< authentic data from named */
+	unsigned	unused :1;	/*%< unused bits (MBZ as of 4.9.3a3) */
+	unsigned	ra :1;		/*%< recursion available */
+#endif
+			/* remaining bytes */
+	unsigned	qdcount :16;	/*%< number of question entries */
+	unsigned	ancount :16;	/*%< number of answer entries */
+	unsigned	nscount :16;	/*%< number of authority entries */
+	unsigned	arcount :16;	/*%< number of resource entries */
+} HEADER;
+
+#define PACKETSZ	NS_PACKETSZ
+#define MAXDNAME	NS_MAXDNAME
+#define MAXCDNAME	NS_MAXCDNAME
+#define MAXLABEL	NS_MAXLABEL
+#define	HFIXEDSZ	NS_HFIXEDSZ
+#define QFIXEDSZ	NS_QFIXEDSZ
+#define RRFIXEDSZ	NS_RRFIXEDSZ
+#define	INT32SZ		NS_INT32SZ
+#define	INT16SZ		NS_INT16SZ
+#define INT8SZ		NS_INT8SZ
+#define	INADDRSZ	NS_INADDRSZ
+#define	IN6ADDRSZ	NS_IN6ADDRSZ
+#define	INDIR_MASK	NS_CMPRSFLGS
+#define NAMESERVER_PORT	NS_DEFAULTPORT
+
+#define S_ZONE		ns_s_zn
+#define S_PREREQ	ns_s_pr
+#define S_UPDATE	ns_s_ud
+#define S_ADDT		ns_s_ar
+
+#define QUERY		ns_o_query
+#define IQUERY		ns_o_iquery
+#define STATUS		ns_o_status
+#define	NS_NOTIFY_OP	ns_o_notify
+#define	NS_UPDATE_OP	ns_o_update
+
+#define NOERROR		ns_r_noerror
+#define FORMERR		ns_r_formerr
+#define SERVFAIL	ns_r_servfail
+#define NXDOMAIN	ns_r_nxdomain
+#define NOTIMP		ns_r_notimpl
+#define REFUSED		ns_r_refused
+#define YXDOMAIN	ns_r_yxdomain
+#define YXRRSET		ns_r_yxrrset
+#define NXRRSET		ns_r_nxrrset
+#define NOTAUTH		ns_r_notauth
+#define NOTZONE		ns_r_notzone
+/*#define BADSIG		ns_r_badsig*/
+/*#define BADKEY		ns_r_badkey*/
+/*#define BADTIME		ns_r_badtime*/
+
+
+#define DELETE		ns_uop_delete
+#define ADD		ns_uop_add
+
+#define T_A		ns_t_a
+#define T_NS		ns_t_ns
+#define T_MD		ns_t_md
+#define T_MF		ns_t_mf
+#define T_CNAME		ns_t_cname
+#define T_SOA		ns_t_soa
+#define T_MB		ns_t_mb
+#define T_MG		ns_t_mg
+#define T_MR		ns_t_mr
+#define T_NULL		ns_t_null
+#define T_WKS		ns_t_wks
+#define T_PTR		ns_t_ptr
+#define T_HINFO		ns_t_hinfo
+#define T_MINFO		ns_t_minfo
+#define T_MX		ns_t_mx
+#define T_TXT		ns_t_txt
+#define	T_RP		ns_t_rp
+#define T_AFSDB		ns_t_afsdb
+#define T_X25		ns_t_x25
+#define T_ISDN		ns_t_isdn
+#define T_RT		ns_t_rt
+#define T_NSAP		ns_t_nsap
+#define T_NSAP_PTR	ns_t_nsap_ptr
+#define	T_SIG		ns_t_sig
+#define	T_KEY		ns_t_key
+#define	T_PX		ns_t_px
+#define	T_GPOS		ns_t_gpos
+#define	T_AAAA		ns_t_aaaa
+#define	T_LOC		ns_t_loc
+#define	T_NXT		ns_t_nxt
+#define	T_EID		ns_t_eid
+#define	T_NIMLOC	ns_t_nimloc
+#define	T_SRV		ns_t_srv
+#define T_ATMA		ns_t_atma
+#define T_NAPTR		ns_t_naptr
+#define T_A6		ns_t_a6
+#define T_DNAME		ns_t_dname
+#define	T_TSIG		ns_t_tsig
+#define	T_IXFR		ns_t_ixfr
+#define T_AXFR		ns_t_axfr
+#define T_MAILB		ns_t_mailb
+#define T_MAILA		ns_t_maila
+#define T_ANY		ns_t_any
+
+#define C_IN		ns_c_in
+#define C_CHAOS		ns_c_chaos
+#define C_HS		ns_c_hs
+/* BIND_UPDATE */
+#define C_NONE		ns_c_none
+#define C_ANY		ns_c_any
+
+#define	GETSHORT		NS_GET16
+#define	GETLONG			NS_GET32
+#define	PUTSHORT		NS_PUT16
+#define	PUTLONG			NS_PUT32
+
+#endif /* _ARPA_NAMESER_COMPAT_ */
+/*! \file */
diff --git a/include/arpa/telnet.h b/include/arpa/telnet.h
new file mode 100644
index 0000000..3774c89
--- /dev/null
+++ b/include/arpa/telnet.h
@@ -0,0 +1,316 @@
+/*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)telnet.h	8.2 (Berkeley) 12/15/93
+ */
+
+#ifndef _ARPA_TELNET_H
+#define	_ARPA_TELNET_H 1
+
+/*
+ * Definitions for the TELNET protocol.
+ */
+#define	IAC	255		/* interpret as command: */
+#define	DONT	254		/* you are not to use option */
+#define	DO	253		/* please, you use option */
+#define	WONT	252		/* I won't use option */
+#define	WILL	251		/* I will use option */
+#define	SB	250		/* interpret as subnegotiation */
+#define	GA	249		/* you may reverse the line */
+#define	EL	248		/* erase the current line */
+#define	EC	247		/* erase the current character */
+#define	AYT	246		/* are you there */
+#define	AO	245		/* abort output--but let prog finish */
+#define	IP	244		/* interrupt process--permanently */
+#define	BREAK	243		/* break */
+#define	DM	242		/* data mark--for connect. cleaning */
+#define	NOP	241		/* nop */
+#define	SE	240		/* end sub negotiation */
+#define EOR     239             /* end of record (transparent mode) */
+#define	ABORT	238		/* Abort process */
+#define	SUSP	237		/* Suspend process */
+#define	xEOF	236		/* End of file: EOF is already used... */
+
+#define SYNCH	242		/* for telfunc calls */
+
+#ifdef TELCMDS
+char *telcmds[] = {
+	"EOF", "SUSP", "ABORT", "EOR",
+	"SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC",
+	"EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC", 0,
+};
+#else
+extern char *telcmds[];
+#endif
+
+#define	TELCMD_FIRST	xEOF
+#define	TELCMD_LAST	IAC
+#define	TELCMD_OK(x)	((unsigned int)(x) <= TELCMD_LAST && \
+			 (unsigned int)(x) >= TELCMD_FIRST)
+#define	TELCMD(x)	telcmds[(x)-TELCMD_FIRST]
+
+/* telnet options */
+#define TELOPT_BINARY	0	/* 8-bit data path */
+#define TELOPT_ECHO	1	/* echo */
+#define	TELOPT_RCP	2	/* prepare to reconnect */
+#define	TELOPT_SGA	3	/* suppress go ahead */
+#define	TELOPT_NAMS	4	/* approximate message size */
+#define	TELOPT_STATUS	5	/* give status */
+#define	TELOPT_TM	6	/* timing mark */
+#define	TELOPT_RCTE	7	/* remote controlled transmission and echo */
+#define TELOPT_NAOL 	8	/* negotiate about output line width */
+#define TELOPT_NAOP 	9	/* negotiate about output page size */
+#define TELOPT_NAOCRD	10	/* negotiate about CR disposition */
+#define TELOPT_NAOHTS	11	/* negotiate about horizontal tabstops */
+#define TELOPT_NAOHTD	12	/* negotiate about horizontal tab disposition */
+#define TELOPT_NAOFFD	13	/* negotiate about formfeed disposition */
+#define TELOPT_NAOVTS	14	/* negotiate about vertical tab stops */
+#define TELOPT_NAOVTD	15	/* negotiate about vertical tab disposition */
+#define TELOPT_NAOLFD	16	/* negotiate about output LF disposition */
+#define TELOPT_XASCII	17	/* extended ascii character set */
+#define	TELOPT_LOGOUT	18	/* force logout */
+#define	TELOPT_BM	19	/* byte macro */
+#define	TELOPT_DET	20	/* data entry terminal */
+#define	TELOPT_SUPDUP	21	/* supdup protocol */
+#define	TELOPT_SUPDUPOUTPUT 22	/* supdup output */
+#define	TELOPT_SNDLOC	23	/* send location */
+#define	TELOPT_TTYPE	24	/* terminal type */
+#define	TELOPT_EOR	25	/* end or record */
+#define	TELOPT_TUID	26	/* TACACS user identification */
+#define	TELOPT_OUTMRK	27	/* output marking */
+#define	TELOPT_TTYLOC	28	/* terminal location number */
+#define	TELOPT_3270REGIME 29	/* 3270 regime */
+#define	TELOPT_X3PAD	30	/* X.3 PAD */
+#define	TELOPT_NAWS	31	/* window size */
+#define	TELOPT_TSPEED	32	/* terminal speed */
+#define	TELOPT_LFLOW	33	/* remote flow control */
+#define TELOPT_LINEMODE	34	/* Linemode option */
+#define TELOPT_XDISPLOC	35	/* X Display Location */
+#define TELOPT_OLD_ENVIRON 36	/* Old - Environment variables */
+#define	TELOPT_AUTHENTICATION 37/* Authenticate */
+#define	TELOPT_ENCRYPT	38	/* Encryption option */
+#define TELOPT_NEW_ENVIRON 39	/* New - Environment variables */
+#define	TELOPT_EXOPL	255	/* extended-options-list */
+
+
+#define	NTELOPTS	(1+TELOPT_NEW_ENVIRON)
+#ifdef TELOPTS
+char *telopts[NTELOPTS+1] = {
+	"BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD", "NAME",
+	"STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
+	"NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
+	"NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
+	"DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT",
+	"SEND LOCATION", "TERMINAL TYPE", "END OF RECORD",
+	"TACACS UID", "OUTPUT MARKING", "TTYLOC",
+	"3270 REGIME", "X.3 PAD", "NAWS", "TSPEED", "LFLOW",
+	"LINEMODE", "XDISPLOC", "OLD-ENVIRON", "AUTHENTICATION",
+	"ENCRYPT", "NEW-ENVIRON",
+	0,
+};
+#define	TELOPT_FIRST	TELOPT_BINARY
+#define	TELOPT_LAST	TELOPT_NEW_ENVIRON
+#define	TELOPT_OK(x)	((unsigned int)(x) <= TELOPT_LAST)
+#define	TELOPT(x)	telopts[(x)-TELOPT_FIRST]
+#endif
+
+/* sub-option qualifiers */
+#define	TELQUAL_IS	0	/* option is... */
+#define	TELQUAL_SEND	1	/* send option */
+#define	TELQUAL_INFO	2	/* ENVIRON: informational version of IS */
+#define	TELQUAL_REPLY	2	/* AUTHENTICATION: client version of IS */
+#define	TELQUAL_NAME	3	/* AUTHENTICATION: client version of IS */
+
+#define	LFLOW_OFF		0	/* Disable remote flow control */
+#define	LFLOW_ON		1	/* Enable remote flow control */
+#define	LFLOW_RESTART_ANY	2	/* Restart output on any char */
+#define	LFLOW_RESTART_XON	3	/* Restart output only on XON */
+
+/*
+ * LINEMODE suboptions
+ */
+
+#define	LM_MODE		1
+#define	LM_FORWARDMASK	2
+#define	LM_SLC		3
+
+#define	MODE_EDIT	0x01
+#define	MODE_TRAPSIG	0x02
+#define	MODE_ACK	0x04
+#define MODE_SOFT_TAB	0x08
+#define MODE_LIT_ECHO	0x10
+
+#define	MODE_MASK	0x1f
+
+/* Not part of protocol, but needed to simplify things... */
+#define MODE_FLOW		0x0100
+#define MODE_ECHO		0x0200
+#define MODE_INBIN		0x0400
+#define MODE_OUTBIN		0x0800
+#define MODE_FORCE		0x1000
+
+#define	SLC_SYNCH	1
+#define	SLC_BRK		2
+#define	SLC_IP		3
+#define	SLC_AO		4
+#define	SLC_AYT		5
+#define	SLC_EOR		6
+#define	SLC_ABORT	7
+#define	SLC_EOF		8
+#define	SLC_SUSP	9
+#define	SLC_EC		10
+#define	SLC_EL		11
+#define	SLC_EW		12
+#define	SLC_RP		13
+#define	SLC_LNEXT	14
+#define	SLC_XON		15
+#define	SLC_XOFF	16
+#define	SLC_FORW1	17
+#define	SLC_FORW2	18
+
+#define	NSLC		18
+
+/*
+ * For backwards compatibility, we define SLC_NAMES to be the
+ * list of names if SLC_NAMES is not defined.
+ */
+#define	SLC_NAMELIST	"0", "SYNCH", "BRK", "IP", "AO", "AYT", "EOR", \
+			"ABORT", "EOF", "SUSP", "EC", "EL", "EW", "RP", \
+			"LNEXT", "XON", "XOFF", "FORW1", "FORW2", 0,
+#ifdef	SLC_NAMES
+char *slc_names[] = {
+	SLC_NAMELIST
+};
+#else
+extern char *slc_names[];
+#define	SLC_NAMES SLC_NAMELIST
+#endif
+
+#define	SLC_NAME_OK(x)	((unsigned int)(x) <= NSLC)
+#define SLC_NAME(x)	slc_names[x]
+
+#define	SLC_NOSUPPORT	0
+#define	SLC_CANTCHANGE	1
+#define	SLC_VARIABLE	2
+#define	SLC_DEFAULT	3
+#define	SLC_LEVELBITS	0x03
+
+#define	SLC_FUNC	0
+#define	SLC_FLAGS	1
+#define	SLC_VALUE	2
+
+#define	SLC_ACK		0x80
+#define	SLC_FLUSHIN	0x40
+#define	SLC_FLUSHOUT	0x20
+
+#define	OLD_ENV_VAR	1
+#define	OLD_ENV_VALUE	0
+#define	NEW_ENV_VAR	0
+#define	NEW_ENV_VALUE	1
+#define	ENV_ESC		2
+#define ENV_USERVAR	3
+
+/*
+ * AUTHENTICATION suboptions
+ */
+
+/*
+ * Who is authenticating who ...
+ */
+#define	AUTH_WHO_CLIENT		0	/* Client authenticating server */
+#define	AUTH_WHO_SERVER		1	/* Server authenticating client */
+#define	AUTH_WHO_MASK		1
+
+/*
+ * amount of authentication done
+ */
+#define	AUTH_HOW_ONE_WAY	0
+#define	AUTH_HOW_MUTUAL		2
+#define	AUTH_HOW_MASK		2
+
+#define	AUTHTYPE_NULL		0
+#define	AUTHTYPE_KERBEROS_V4	1
+#define	AUTHTYPE_KERBEROS_V5	2
+#define	AUTHTYPE_SPX		3
+#define	AUTHTYPE_MINK		4
+#define	AUTHTYPE_CNT		5
+
+#define	AUTHTYPE_TEST		99
+
+#ifdef	AUTH_NAMES
+char *authtype_names[] = {
+	"NULL", "KERBEROS_V4", "KERBEROS_V5", "SPX", "MINK", 0,
+};
+#else
+extern char *authtype_names[];
+#endif
+
+#define	AUTHTYPE_NAME_OK(x)	((unsigned int)(x) < AUTHTYPE_CNT)
+#define	AUTHTYPE_NAME(x)	authtype_names[x]
+
+/*
+ * ENCRYPTion suboptions
+ */
+#define	ENCRYPT_IS		0	/* I pick encryption type ... */
+#define	ENCRYPT_SUPPORT		1	/* I support encryption types ... */
+#define	ENCRYPT_REPLY		2	/* Initial setup response */
+#define	ENCRYPT_START		3	/* Am starting to send encrypted */
+#define	ENCRYPT_END		4	/* Am ending encrypted */
+#define	ENCRYPT_REQSTART	5	/* Request you start encrypting */
+#define	ENCRYPT_REQEND		6	/* Request you send encrypting */
+#define	ENCRYPT_ENC_KEYID	7
+#define	ENCRYPT_DEC_KEYID	8
+#define	ENCRYPT_CNT		9
+
+#define	ENCTYPE_ANY		0
+#define	ENCTYPE_DES_CFB64	1
+#define	ENCTYPE_DES_OFB64	2
+#define	ENCTYPE_CNT		3
+
+#ifdef	ENCRYPT_NAMES
+char *encrypt_names[] = {
+	"IS", "SUPPORT", "REPLY", "START", "END",
+	"REQUEST-START", "REQUEST-END", "ENC-KEYID", "DEC-KEYID",
+	0,
+};
+char *enctype_names[] = {
+	"ANY", "DES_CFB64",  "DES_OFB64",  0,
+};
+#else
+extern char *encrypt_names[];
+extern char *enctype_names[];
+#endif
+
+
+#define	ENCRYPT_NAME_OK(x)	((unsigned int)(x) < ENCRYPT_CNT)
+#define	ENCRYPT_NAME(x)		encrypt_names[x]
+
+#define	ENCTYPE_NAME_OK(x)	((unsigned int)(x) < ENCTYPE_CNT)
+#define	ENCTYPE_NAME(x)		enctype_names[x]
+
+#endif /* arpa/telnet.h */
diff --git a/include/arpa/tftp.h b/include/arpa/tftp.h
new file mode 100644
index 0000000..86e0b6e
--- /dev/null
+++ b/include/arpa/tftp.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)tftp.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _ARPA_TFTP_H
+#define	_ARPA_TFTP_H 1
+
+/*
+ * Trivial File Transfer Protocol (IEN-133)
+ */
+#define	SEGSIZE		512		/* data segment size */
+
+/*
+ * Packet types.
+ */
+#define	RRQ	01				/* read request */
+#define	WRQ	02				/* write request */
+#define	DATA	03				/* data packet */
+#define	ACK	04				/* acknowledgement */
+#define	ERROR	05				/* error code */
+
+struct	tftphdr {
+	short	th_opcode;			/* packet type */
+	union {
+		char	tu_padding[3];		/* sizeof() compat */
+		struct {
+			union {
+				unsigned short	tu_block;	/* block # */
+				short	tu_code;		/* error code */
+			} __attribute__ ((__packed__)) th_u3;
+			char tu_data[0];	/* data or error string */
+		} __attribute__ ((__packed__)) th_u2;
+		char	tu_stuff[0];		/* request packet stuff */
+	} __attribute__ ((__packed__)) th_u1;
+} __attribute__ ((__packed__));
+
+#define	th_block	th_u1.th_u2.th_u3.tu_block
+#define	th_code		th_u1.th_u2.th_u3.tu_code
+#define	th_stuff	th_u1.tu_stuff
+#define	th_data		th_u1.th_u2.tu_data
+#define	th_msg		th_u1.th_u2.tu_data
+
+/*
+ * Error codes.
+ */
+#define	EUNDEF		0		/* not defined */
+#define	ENOTFOUND	1		/* file not found */
+#define	EACCESS		2		/* access violation */
+#define	ENOSPACE	3		/* disk full or allocation exceeded */
+#define	EBADOP		4		/* illegal TFTP operation */
+#define	EBADID		5		/* unknown transfer ID */
+#define	EEXISTS		6		/* file already exists */
+#define	ENOUSER		7		/* no such user */
+
+#endif /* arpa/tftp.h */
diff --git a/include/assert.h b/include/assert.h
new file mode 100644
index 0000000..2661391
--- /dev/null
+++ b/include/assert.h
@@ -0,0 +1,119 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
+ */
+
+#ifdef	_ASSERT_H
+
+# undef	_ASSERT_H
+# undef	assert
+# undef __ASSERT_VOID_CAST
+
+# ifdef	__USE_GNU
+#  undef assert_perror
+# endif
+
+#endif /* assert.h	*/
+
+#define	_ASSERT_H	1
+#include <features.h>
+
+#if defined __cplusplus && __GNUC_PREREQ (2,95)
+# define __ASSERT_VOID_CAST static_cast<void>
+#else
+# define __ASSERT_VOID_CAST (void)
+#endif
+
+/* void assert (int expression);
+
+   If NDEBUG is defined, do nothing.
+   If not, and EXPRESSION is zero, print an error message and abort.  */
+
+#ifdef	NDEBUG
+
+# define assert(expr)		(__ASSERT_VOID_CAST (0))
+
+/* void assert_perror (int errnum);
+
+   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
+   error message with the error text for ERRNUM and abort.
+   (This is a GNU extension.) */
+
+# ifdef	__USE_GNU
+#  define assert_perror(errnum)	(__ASSERT_VOID_CAST (0))
+# endif
+
+#else /* Not NDEBUG.  */
+
+__BEGIN_DECLS
+
+/* This prints an "Assertion failed" message and aborts.  */
+extern void __assert_fail (const char *__assertion, const char *__file,
+			   unsigned int __line, const char *__function)
+     __THROW __attribute__ ((__noreturn__));
+
+/* Likewise, but prints the error text for ERRNUM.  */
+extern void __assert_perror_fail (int __errnum, const char *__file,
+				  unsigned int __line, const char *__function)
+     __THROW __attribute__ ((__noreturn__));
+
+
+/* The following is not at all used here but needed for standard
+   compliance.  */
+extern void __assert (const char *__assertion, const char *__file, int __line)
+     __THROW __attribute__ ((__noreturn__));
+
+
+__END_DECLS
+
+# define assert(expr)							\
+  ((expr)								\
+   ? __ASSERT_VOID_CAST (0)						\
+   : __assert_fail (__STRING(expr), __FILE__, __LINE__, __ASSERT_FUNCTION))
+
+# ifdef	__USE_GNU
+#  define assert_perror(errnum)						\
+  (!(errnum)								\
+   ? __ASSERT_VOID_CAST (0)						\
+   : __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))
+# endif
+
+/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
+   which contains the name of the function currently being defined.
+   This is broken in G++ before version 2.6.
+   C9x has a similar variable called __func__, but prefer the GCC one since
+   it demangles C++ function names.  */
+# if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)
+#   define __ASSERT_FUNCTION	__PRETTY_FUNCTION__
+# else
+#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#   define __ASSERT_FUNCTION	__func__
+#  else
+#   define __ASSERT_FUNCTION	((const char *) 0)
+#  endif
+# endif
+
+#endif /* NDEBUG.  */
+
+
+#if defined __USE_ISOC11 && !defined __cplusplus
+/* Static assertion.  Requires support in the compiler.  */
+# undef static_assert
+# define static_assert _Static_assert
+#endif
diff --git a/include/bits/barrier-attr.h b/include/bits/barrier-attr.h
new file mode 100644
index 0000000..7734069
--- /dev/null
+++ b/include/bits/barrier-attr.h
@@ -0,0 +1,32 @@
+/* Thread barrier attribute type.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_BARRIER_ATTR_H
+#define _BITS_BARRIER_ATTR_H	1
+
+enum __pthread_process_shared;
+
+/* This structure describes the attributes of a POSIX thread barrier.
+   Note that not all of them are supported on all systems.  */
+struct __pthread_barrierattr
+{
+  enum __pthread_process_shared __pshared;
+};
+
+#endif /* bits/barrier-attr.h */
diff --git a/include/bits/barrier.h b/include/bits/barrier.h
new file mode 100644
index 0000000..dabe86f
--- /dev/null
+++ b/include/bits/barrier.h
@@ -0,0 +1,39 @@
+/* Thread barrier attribute type.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_BARRIER_H
+#define _BITS_BARRIER_H	1
+
+#include <bits/spin-lock.h>
+
+/* This structure describes the attributes of a POSIX barrier.  */
+struct __pthread_barrier
+{
+  __pthread_spinlock_t __lock;
+  struct __pthread *__queue; /* List of waiters.  */
+  unsigned __pending;	/* Number of that still need to wait on
+			   barrier.  */
+  unsigned __count;	/* Number of threads that must wait before
+			   barrier is passed.  */
+  struct __pthread_barrierattr *__attr;
+  void *__data;
+};
+
+
+#endif /* bits/barrier.h */
diff --git a/include/bits/byteswap-16.h b/include/bits/byteswap-16.h
new file mode 100644
index 0000000..f3a9c6b
--- /dev/null
+++ b/include/bits/byteswap-16.h
@@ -0,0 +1,49 @@
+/* Macros to swap the order of bytes in 16-bit integer values.
+   Copyright (C) 2012-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_BYTESWAP_H
+# error "Never use <bits/byteswap-16.h> directly; include <byteswap.h> instead."
+#endif
+
+#ifdef __GNUC__
+# if __GNUC__ >= 2
+#  define __bswap_16(x) \
+     (__extension__							      \
+      ({ unsigned short int __v, __x = (unsigned short int) (x);	      \
+	 if (__builtin_constant_p (__x))				      \
+	   __v = __bswap_constant_16 (__x);				      \
+	 else								      \
+	   __asm__ ("rorw $8, %w0"					      \
+		    : "=r" (__v)					      \
+		    : "0" (__x)						      \
+		    : "cc");						      \
+	 __v; }))
+# else
+/* This is better than nothing.  */
+#  define __bswap_16(x) \
+     (__extension__							      \
+      ({ unsigned short int __x = (unsigned short int) (x);		      \
+	 __bswap_constant_16 (__x); }))
+# endif
+#else
+static __inline unsigned short int
+__bswap_16 (unsigned short int __bsx)
+{
+  return __bswap_constant_16 (__bsx);
+}
+#endif
diff --git a/include/bits/byteswap.h b/include/bits/byteswap.h
new file mode 100644
index 0000000..933fe4b
--- /dev/null
+++ b/include/bits/byteswap.h
@@ -0,0 +1,155 @@
+/* Macros to swap the order of bytes in integer values.
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _BYTESWAP_H && !defined _NETINET_IN_H && !defined _ENDIAN_H
+# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
+#endif
+
+#ifndef _BITS_BYTESWAP_H
+#define _BITS_BYTESWAP_H 1
+
+#include <features.h>
+#include <bits/types.h>
+#include <bits/wordsize.h>
+
+/* Swap bytes in 16 bit value.  */
+#define __bswap_constant_16(x) \
+     ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
+
+/* Get __bswap_16.  */
+#include <bits/byteswap-16.h>
+
+/* Swap bytes in 32 bit value.  */
+#define __bswap_constant_32(x) \
+     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
+      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
+
+#ifdef __GNUC__
+# if __GNUC_PREREQ (4, 3)
+static __inline unsigned int
+__bswap_32 (unsigned int __bsx)
+{
+  return __builtin_bswap32 (__bsx);
+}
+# elif __GNUC__ >= 2
+#  if __WORDSIZE == 64 || (defined __i486__ || defined __pentium__	      \
+			   || defined __pentiumpro__ || defined __pentium4__  \
+			   || defined __k8__ || defined __athlon__	      \
+			   || defined __k6__ || defined __nocona__	      \
+			   || defined __core2__ || defined __geode__	      \
+			   || defined __amdfam10__)
+/* To swap the bytes in a word the i486 processors and up provide the
+   `bswap' opcode.  On i386 we have to use three instructions.  */
+#   define __bswap_32(x) \
+      (__extension__							      \
+       ({ unsigned int __v, __x = (x);					      \
+	  if (__builtin_constant_p (__x))				      \
+	    __v = __bswap_constant_32 (__x);				      \
+	  else								      \
+	    __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
+	  __v; }))
+#  else
+#   define __bswap_32(x)						      \
+      (__extension__							      \
+       ({ unsigned int __v, __x = (x);					      \
+	  if (__builtin_constant_p (__x))				      \
+	    __v = __bswap_constant_32 (__x);				      \
+	  else								      \
+	    __asm__ ("rorw $8, %w0;"					      \
+		     "rorl $16, %0;"					      \
+		     "rorw $8, %w0"					      \
+		     : "=r" (__v)					      \
+		     : "0" (__x)					      \
+		     : "cc");						      \
+	  __v; }))
+#  endif
+# else
+#  define __bswap_32(x) \
+     (__extension__							      \
+      ({ unsigned int __x = (x); __bswap_constant_32 (__x); }))
+# endif
+#else
+static __inline unsigned int
+__bswap_32 (unsigned int __bsx)
+{
+  return __bswap_constant_32 (__bsx);
+}
+#endif
+
+
+#if __GNUC_PREREQ (2, 0)
+/* Swap bytes in 64 bit value.  */
+# define __bswap_constant_64(x) \
+     (__extension__ ((((x) & 0xff00000000000000ull) >> 56)		      \
+		     | (((x) & 0x00ff000000000000ull) >> 40)		      \
+		     | (((x) & 0x0000ff0000000000ull) >> 24)		      \
+		     | (((x) & 0x000000ff00000000ull) >> 8)		      \
+		     | (((x) & 0x00000000ff000000ull) << 8)		      \
+		     | (((x) & 0x0000000000ff0000ull) << 24)		      \
+		     | (((x) & 0x000000000000ff00ull) << 40)		      \
+		     | (((x) & 0x00000000000000ffull) << 56)))
+
+# if __GNUC_PREREQ (4, 3)
+static __inline __uint64_t
+__bswap_64 (__uint64_t __bsx)
+{
+  return __builtin_bswap64 (__bsx);
+}
+# elif __WORDSIZE == 64
+#  define __bswap_64(x) \
+     (__extension__							      \
+      ({ __uint64_t __v, __x = (x);					      \
+	 if (__builtin_constant_p (__x))				      \
+	   __v = __bswap_constant_64 (__x);				      \
+	 else								      \
+	   __asm__ ("bswap %q0" : "=r" (__v) : "0" (__x));		      \
+	 __v; }))
+# else
+#  define __bswap_64(x) \
+     (__extension__                                                           \
+      ({ union { __extension__ __uint64_t __ll;		                      \
+		 unsigned int __l[2]; } __w, __r;                             \
+	 if (__builtin_constant_p (x))                                        \
+	   __r.__ll = __bswap_constant_64 (x);                                \
+	 else                                                                 \
+	   {                                                                  \
+	     __w.__ll = (x);                                                  \
+	     __r.__l[0] = __bswap_32 (__w.__l[1]);                            \
+	     __r.__l[1] = __bswap_32 (__w.__l[0]);                            \
+	   }                                                                  \
+	 __r.__ll; }))
+# endif
+#else
+# define __bswap_constant_64(x) \
+     ((((x) & 0xff00000000000000ull) >> 56)				      \
+      | (((x) & 0x00ff000000000000ull) >> 40)				      \
+      | (((x) & 0x0000ff0000000000ull) >> 24)				      \
+      | (((x) & 0x000000ff00000000ull) >> 8)				      \
+      | (((x) & 0x00000000ff000000ull) << 8)				      \
+      | (((x) & 0x0000000000ff0000ull) << 24)				      \
+      | (((x) & 0x000000000000ff00ull) << 40)				      \
+      | (((x) & 0x00000000000000ffull) << 56))
+
+static __inline __uint64_t
+__bswap_64 (__uint64_t __bsx)
+{
+  return __bswap_constant_64 (__bsx);
+}
+#endif
+
+#endif /* _BITS_BYTESWAP_H */
diff --git a/include/bits/cancelation.h b/include/bits/cancelation.h
new file mode 100644
index 0000000..1ed16c6
--- /dev/null
+++ b/include/bits/cancelation.h
@@ -0,0 +1,51 @@
+/* Cancelation.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_CANCELATION_H
+#define _BITS_CANCELATION_H	1
+
+struct __pthread_cancelation_handler
+{
+  void (*__handler)(void *);
+  void *__arg;
+  struct __pthread_cancelation_handler *__next;
+};
+
+/* Returns the thread local location of the cleanup handler stack.  */
+struct __pthread_cancelation_handler **__pthread_get_cleanup_stack (void);
+
+#define __pthread_cleanup_push(rt, rtarg) \
+	{ \
+	  struct __pthread_cancelation_handler **__handlers \
+	    = __pthread_get_cleanup_stack (); \
+	  struct __pthread_cancelation_handler __handler = \
+	    { \
+	      (rt), \
+	      (rtarg), \
+	      *__handlers \
+	    }; \
+	  *__handlers = &__handler;
+	  
+#define __pthread_cleanup_pop(execute) \
+	  if (execute) \
+	    __handler.__handler (__handler.__arg); \
+	  *__handlers = __handler.__next; \
+	}
+
+#endif /* _BITS_CANCELATION_H */
diff --git a/include/bits/cmathcalls.h b/include/bits/cmathcalls.h
new file mode 100644
index 0000000..25351b3
--- /dev/null
+++ b/include/bits/cmathcalls.h
@@ -0,0 +1,158 @@
+/* Prototype declarations for complex math functions;
+   helper file for <complex.h>.
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* NOTE: Because of the special way this file is used by <complex.h>, this
+   file must NOT be protected from multiple inclusion as header files
+   usually are.
+
+   This file provides prototype declarations for the math functions.
+   Most functions are declared using the macro:
+
+   __MATHCALL (NAME, (ARGS...));
+
+   This means there is a function `NAME' returning `double' and a function
+   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
+   prototype, that is actually `double' in the prototype for `NAME' and
+   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
+   called `NAME_r' and `NAMEf_r'.
+
+   Functions returning other types like `int' are declared using the macro:
+
+   __MATHDECL (TYPE, NAME, (ARGS...));
+
+   This is just like __MATHCALL but for a function returning `TYPE'
+   instead of `_Mdouble_'.  In all of these cases, there is still
+   both a `NAME' and a `NAMEf' that takes `float' arguments.  */
+
+#ifndef _COMPLEX_H
+#error "Never use <bits/cmathcalls.h> directly; include <complex.h> instead."
+#endif
+
+#define _Mdouble_complex_ _Mdouble_ _Complex
+
+
+/* Trigonometric functions.  */
+
+/* Arc cosine of Z.  */
+__MATHCALL (cacos, (_Mdouble_complex_ __z));
+/* Arc sine of Z.  */
+__MATHCALL (casin, (_Mdouble_complex_ __z));
+/* Arc tangent of Z.  */
+__MATHCALL (catan, (_Mdouble_complex_ __z));
+
+/* Cosine of Z.  */
+__MATHCALL (ccos, (_Mdouble_complex_ __z));
+/* Sine of Z.  */
+__MATHCALL (csin, (_Mdouble_complex_ __z));
+/* Tangent of Z.  */
+__MATHCALL (ctan, (_Mdouble_complex_ __z));
+
+
+/* Hyperbolic functions.  */
+
+/* Hyperbolic arc cosine of Z.  */
+__MATHCALL (cacosh, (_Mdouble_complex_ __z));
+/* Hyperbolic arc sine of Z.  */
+__MATHCALL (casinh, (_Mdouble_complex_ __z));
+/* Hyperbolic arc tangent of Z.  */
+__MATHCALL (catanh, (_Mdouble_complex_ __z));
+
+/* Hyperbolic cosine of Z.  */
+__MATHCALL (ccosh, (_Mdouble_complex_ __z));
+/* Hyperbolic sine of Z.  */
+__MATHCALL (csinh, (_Mdouble_complex_ __z));
+/* Hyperbolic tangent of Z.  */
+__MATHCALL (ctanh, (_Mdouble_complex_ __z));
+
+
+/* Exponential and logarithmic functions.  */
+
+/* Exponential function of Z.  */
+__MATHCALL (cexp, (_Mdouble_complex_ __z));
+
+/* Natural logarithm of Z.  */
+__MATHCALL (clog, (_Mdouble_complex_ __z));
+
+#ifdef __USE_GNU
+/* The base 10 logarithm is not defined by the standard but to implement
+   the standard C++ library it is handy.  */
+__MATHCALL (clog10, (_Mdouble_complex_ __z));
+#endif
+
+/* Power functions.  */
+
+/* Return X to the Y power.  */
+__MATHCALL (cpow, (_Mdouble_complex_ __x, _Mdouble_complex_ __y));
+
+/* Return the square root of Z.  */
+__MATHCALL (csqrt, (_Mdouble_complex_ __z));
+
+
+/* Absolute value, conjugates, and projection.  */
+
+/* Absolute value of Z.  */
+__MATHDECL (_Mdouble_,cabs, (_Mdouble_complex_ __z));
+
+/* Argument value of Z.  */
+__MATHDECL (_Mdouble_,carg, (_Mdouble_complex_ __z));
+
+/* Complex conjugate of Z.  */
+__MATHCALL (conj, (_Mdouble_complex_ __z));
+
+/* Projection of Z onto the Riemann sphere.  */
+__MATHCALL (cproj, (_Mdouble_complex_ __z));
+
+
+/* Decomposing complex values.  */
+
+/* Imaginary part of Z.  */
+__MATHDECL (_Mdouble_,cimag, (_Mdouble_complex_ __z));
+
+/* Real part of Z.  */
+__MATHDECL (_Mdouble_,creal, (_Mdouble_complex_ __z));
+
+
+/* Now some optimized versions.  GCC has handy notations for these
+   functions.  Recent GCC handles these as builtin functions so does
+   not need inlines.  */
+#if defined __GNUC__ && !__GNUC_PREREQ (2, 97) && defined __OPTIMIZE__ \
+    && defined __extern_inline
+
+/* Imaginary part of Z.  */
+__extern_inline _Mdouble_
+__MATH_PRECNAME(cimag) (_Mdouble_complex_ __z) __THROW
+{
+  return __imag__ __z;
+}
+
+/* Real part of Z.  */
+__extern_inline _Mdouble_
+__MATH_PRECNAME(creal) (_Mdouble_complex_ __z) __THROW
+{
+  return __real__ __z;
+}
+
+/* Complex conjugate of Z.  */
+__extern_inline _Mdouble_complex_
+__MATH_PRECNAME(conj) (_Mdouble_complex_ __z) __THROW
+{
+  return __extension__ ~__z;
+}
+
+#endif
diff --git a/include/bits/condition-attr.h b/include/bits/condition-attr.h
new file mode 100644
index 0000000..19c92bb
--- /dev/null
+++ b/include/bits/condition-attr.h
@@ -0,0 +1,34 @@
+/* Condition attribute type.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_CONDITION_ATTR_H
+#define _BITS_CONDITION_ATTR_H	1
+
+#include <bits/types.h>
+
+enum __pthread_process_shared;
+
+/* User visible part of a condition attribute variable.  */
+struct __pthread_condattr
+  {
+    enum __pthread_process_shared __pshared;
+    __clockid_t __clock;
+  };
+
+#endif /* bits/condition.h */
diff --git a/include/bits/condition.h b/include/bits/condition.h
new file mode 100644
index 0000000..bf13ada
--- /dev/null
+++ b/include/bits/condition.h
@@ -0,0 +1,39 @@
+/* Condition type.  Generic version.
+   Copyright (C) 2000, 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_CONDITION_H
+#define _BITS_CONDITION_H	1
+
+#include <bits/spin-lock.h>
+
+/* User visible part of a condition variable.  */
+struct __pthread_cond
+  {
+    __pthread_spinlock_t __lock;
+    struct __pthread *__queue;
+    struct __pthread_condattr *__attr;
+    struct __pthread_condimpl *__impl;
+    void *__data;
+  };
+
+/* Initializer for a condition variable.  */
+#define __PTHREAD_COND_INITIALIZER \
+  { __PTHREAD_SPIN_LOCK_INITIALIZER, NULL, NULL, NULL, NULL }
+
+#endif /* bits/condition.h */
diff --git a/include/bits/confname.h b/include/bits/confname.h
new file mode 100644
index 0000000..bf2fcc5
--- /dev/null
+++ b/include/bits/confname.h
@@ -0,0 +1,675 @@
+/* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _UNISTD_H
+# error "Never use <bits/confname.h> directly; include <unistd.h> instead."
+#endif
+
+/* Values for the NAME argument to `pathconf' and `fpathconf'.  */
+enum
+  {
+    _PC_LINK_MAX,
+#define	_PC_LINK_MAX			_PC_LINK_MAX
+    _PC_MAX_CANON,
+#define	_PC_MAX_CANON			_PC_MAX_CANON
+    _PC_MAX_INPUT,
+#define	_PC_MAX_INPUT			_PC_MAX_INPUT
+    _PC_NAME_MAX,
+#define	_PC_NAME_MAX			_PC_NAME_MAX
+    _PC_PATH_MAX,
+#define	_PC_PATH_MAX			_PC_PATH_MAX
+    _PC_PIPE_BUF,
+#define	_PC_PIPE_BUF			_PC_PIPE_BUF
+    _PC_CHOWN_RESTRICTED,
+#define	_PC_CHOWN_RESTRICTED		_PC_CHOWN_RESTRICTED
+    _PC_NO_TRUNC,
+#define	_PC_NO_TRUNC			_PC_NO_TRUNC
+    _PC_VDISABLE,
+#define _PC_VDISABLE			_PC_VDISABLE
+    _PC_SYNC_IO,
+#define	_PC_SYNC_IO			_PC_SYNC_IO
+    _PC_ASYNC_IO,
+#define	_PC_ASYNC_IO			_PC_ASYNC_IO
+    _PC_PRIO_IO,
+#define	_PC_PRIO_IO			_PC_PRIO_IO
+    _PC_SOCK_MAXBUF,
+#define	_PC_SOCK_MAXBUF			_PC_SOCK_MAXBUF
+    _PC_FILESIZEBITS,
+#define _PC_FILESIZEBITS		_PC_FILESIZEBITS
+    _PC_REC_INCR_XFER_SIZE,
+#define _PC_REC_INCR_XFER_SIZE		_PC_REC_INCR_XFER_SIZE
+    _PC_REC_MAX_XFER_SIZE,
+#define _PC_REC_MAX_XFER_SIZE		_PC_REC_MAX_XFER_SIZE
+    _PC_REC_MIN_XFER_SIZE,
+#define _PC_REC_MIN_XFER_SIZE		_PC_REC_MIN_XFER_SIZE
+    _PC_REC_XFER_ALIGN,
+#define _PC_REC_XFER_ALIGN		_PC_REC_XFER_ALIGN
+    _PC_ALLOC_SIZE_MIN,
+#define _PC_ALLOC_SIZE_MIN		_PC_ALLOC_SIZE_MIN
+    _PC_SYMLINK_MAX,
+#define _PC_SYMLINK_MAX			_PC_SYMLINK_MAX
+    _PC_2_SYMLINKS
+#define _PC_2_SYMLINKS			_PC_2_SYMLINKS
+  };
+
+/* Values for the argument to `sysconf'.  */
+enum
+  {
+    _SC_ARG_MAX,
+#define	_SC_ARG_MAX			_SC_ARG_MAX
+    _SC_CHILD_MAX,
+#define	_SC_CHILD_MAX			_SC_CHILD_MAX
+    _SC_CLK_TCK,
+#define	_SC_CLK_TCK			_SC_CLK_TCK
+    _SC_NGROUPS_MAX,
+#define	_SC_NGROUPS_MAX			_SC_NGROUPS_MAX
+    _SC_OPEN_MAX,
+#define	_SC_OPEN_MAX			_SC_OPEN_MAX
+    _SC_STREAM_MAX,
+#define	_SC_STREAM_MAX			_SC_STREAM_MAX
+    _SC_TZNAME_MAX,
+#define	_SC_TZNAME_MAX			_SC_TZNAME_MAX
+    _SC_JOB_CONTROL,
+#define	_SC_JOB_CONTROL			_SC_JOB_CONTROL
+    _SC_SAVED_IDS,
+#define	_SC_SAVED_IDS			_SC_SAVED_IDS
+    _SC_REALTIME_SIGNALS,
+#define	_SC_REALTIME_SIGNALS		_SC_REALTIME_SIGNALS
+    _SC_PRIORITY_SCHEDULING,
+#define	_SC_PRIORITY_SCHEDULING		_SC_PRIORITY_SCHEDULING
+    _SC_TIMERS,
+#define	_SC_TIMERS			_SC_TIMERS
+    _SC_ASYNCHRONOUS_IO,
+#define	_SC_ASYNCHRONOUS_IO		_SC_ASYNCHRONOUS_IO
+    _SC_PRIORITIZED_IO,
+#define	_SC_PRIORITIZED_IO		_SC_PRIORITIZED_IO
+    _SC_SYNCHRONIZED_IO,
+#define	_SC_SYNCHRONIZED_IO		_SC_SYNCHRONIZED_IO
+    _SC_FSYNC,
+#define	_SC_FSYNC			_SC_FSYNC
+    _SC_MAPPED_FILES,
+#define	_SC_MAPPED_FILES		_SC_MAPPED_FILES
+    _SC_MEMLOCK,
+#define	_SC_MEMLOCK			_SC_MEMLOCK
+    _SC_MEMLOCK_RANGE,
+#define	_SC_MEMLOCK_RANGE		_SC_MEMLOCK_RANGE
+    _SC_MEMORY_PROTECTION,
+#define	_SC_MEMORY_PROTECTION		_SC_MEMORY_PROTECTION
+    _SC_MESSAGE_PASSING,
+#define	_SC_MESSAGE_PASSING		_SC_MESSAGE_PASSING
+    _SC_SEMAPHORES,
+#define	_SC_SEMAPHORES			_SC_SEMAPHORES
+    _SC_SHARED_MEMORY_OBJECTS,
+#define	_SC_SHARED_MEMORY_OBJECTS	_SC_SHARED_MEMORY_OBJECTS
+    _SC_AIO_LISTIO_MAX,
+#define	_SC_AIO_LISTIO_MAX		_SC_AIO_LISTIO_MAX
+    _SC_AIO_MAX,
+#define	_SC_AIO_MAX			_SC_AIO_MAX
+    _SC_AIO_PRIO_DELTA_MAX,
+#define	_SC_AIO_PRIO_DELTA_MAX		_SC_AIO_PRIO_DELTA_MAX
+    _SC_DELAYTIMER_MAX,
+#define	_SC_DELAYTIMER_MAX		_SC_DELAYTIMER_MAX
+    _SC_MQ_OPEN_MAX,
+#define	_SC_MQ_OPEN_MAX			_SC_MQ_OPEN_MAX
+    _SC_MQ_PRIO_MAX,
+#define	_SC_MQ_PRIO_MAX			_SC_MQ_PRIO_MAX
+    _SC_VERSION,
+#define	_SC_VERSION			_SC_VERSION
+    _SC_PAGESIZE,
+#define	_SC_PAGESIZE			_SC_PAGESIZE
+#define	_SC_PAGE_SIZE			_SC_PAGESIZE
+    _SC_RTSIG_MAX,
+#define	_SC_RTSIG_MAX			_SC_RTSIG_MAX
+    _SC_SEM_NSEMS_MAX,
+#define	_SC_SEM_NSEMS_MAX		_SC_SEM_NSEMS_MAX
+    _SC_SEM_VALUE_MAX,
+#define	_SC_SEM_VALUE_MAX		_SC_SEM_VALUE_MAX
+    _SC_SIGQUEUE_MAX,
+#define	_SC_SIGQUEUE_MAX		_SC_SIGQUEUE_MAX
+    _SC_TIMER_MAX,
+#define	_SC_TIMER_MAX			_SC_TIMER_MAX
+
+    /* Values for the argument to `sysconf'
+       corresponding to _POSIX2_* symbols.  */
+    _SC_BC_BASE_MAX,
+#define	_SC_BC_BASE_MAX			_SC_BC_BASE_MAX
+    _SC_BC_DIM_MAX,
+#define	_SC_BC_DIM_MAX			_SC_BC_DIM_MAX
+    _SC_BC_SCALE_MAX,
+#define	_SC_BC_SCALE_MAX		_SC_BC_SCALE_MAX
+    _SC_BC_STRING_MAX,
+#define	_SC_BC_STRING_MAX		_SC_BC_STRING_MAX
+    _SC_COLL_WEIGHTS_MAX,
+#define	_SC_COLL_WEIGHTS_MAX		_SC_COLL_WEIGHTS_MAX
+    _SC_EQUIV_CLASS_MAX,
+#define	_SC_EQUIV_CLASS_MAX		_SC_EQUIV_CLASS_MAX
+    _SC_EXPR_NEST_MAX,
+#define	_SC_EXPR_NEST_MAX		_SC_EXPR_NEST_MAX
+    _SC_LINE_MAX,
+#define	_SC_LINE_MAX			_SC_LINE_MAX
+    _SC_RE_DUP_MAX,
+#define	_SC_RE_DUP_MAX			_SC_RE_DUP_MAX
+    _SC_CHARCLASS_NAME_MAX,
+#define	_SC_CHARCLASS_NAME_MAX		_SC_CHARCLASS_NAME_MAX
+
+    _SC_2_VERSION,
+#define	_SC_2_VERSION			_SC_2_VERSION
+    _SC_2_C_BIND,
+#define	_SC_2_C_BIND			_SC_2_C_BIND
+    _SC_2_C_DEV,
+#define	_SC_2_C_DEV			_SC_2_C_DEV
+    _SC_2_FORT_DEV,
+#define	_SC_2_FORT_DEV			_SC_2_FORT_DEV
+    _SC_2_FORT_RUN,
+#define	_SC_2_FORT_RUN			_SC_2_FORT_RUN
+    _SC_2_SW_DEV,
+#define	_SC_2_SW_DEV			_SC_2_SW_DEV
+    _SC_2_LOCALEDEF,
+#define	_SC_2_LOCALEDEF			_SC_2_LOCALEDEF
+
+    _SC_PII,
+#define	_SC_PII				_SC_PII
+    _SC_PII_XTI,
+#define	_SC_PII_XTI			_SC_PII_XTI
+    _SC_PII_SOCKET,
+#define	_SC_PII_SOCKET			_SC_PII_SOCKET
+    _SC_PII_INTERNET,
+#define	_SC_PII_INTERNET		_SC_PII_INTERNET
+    _SC_PII_OSI,
+#define	_SC_PII_OSI			_SC_PII_OSI
+    _SC_POLL,
+#define	_SC_POLL			_SC_POLL
+    _SC_SELECT,
+#define	_SC_SELECT			_SC_SELECT
+    _SC_UIO_MAXIOV,
+#define	_SC_UIO_MAXIOV			_SC_UIO_MAXIOV
+    _SC_IOV_MAX = _SC_UIO_MAXIOV,
+#define _SC_IOV_MAX			_SC_IOV_MAX
+    _SC_PII_INTERNET_STREAM,
+#define	_SC_PII_INTERNET_STREAM		_SC_PII_INTERNET_STREAM
+    _SC_PII_INTERNET_DGRAM,
+#define	_SC_PII_INTERNET_DGRAM		_SC_PII_INTERNET_DGRAM
+    _SC_PII_OSI_COTS,
+#define	_SC_PII_OSI_COTS		_SC_PII_OSI_COTS
+    _SC_PII_OSI_CLTS,
+#define	_SC_PII_OSI_CLTS		_SC_PII_OSI_CLTS
+    _SC_PII_OSI_M,
+#define	_SC_PII_OSI_M			_SC_PII_OSI_M
+    _SC_T_IOV_MAX,
+#define	_SC_T_IOV_MAX			_SC_T_IOV_MAX
+
+    /* Values according to POSIX 1003.1c (POSIX threads).  */
+    _SC_THREADS,
+#define	_SC_THREADS			_SC_THREADS
+    _SC_THREAD_SAFE_FUNCTIONS,
+#define _SC_THREAD_SAFE_FUNCTIONS	_SC_THREAD_SAFE_FUNCTIONS
+    _SC_GETGR_R_SIZE_MAX,
+#define	_SC_GETGR_R_SIZE_MAX		_SC_GETGR_R_SIZE_MAX
+    _SC_GETPW_R_SIZE_MAX,
+#define	_SC_GETPW_R_SIZE_MAX		_SC_GETPW_R_SIZE_MAX
+    _SC_LOGIN_NAME_MAX,
+#define	_SC_LOGIN_NAME_MAX		_SC_LOGIN_NAME_MAX
+    _SC_TTY_NAME_MAX,
+#define	_SC_TTY_NAME_MAX		_SC_TTY_NAME_MAX
+    _SC_THREAD_DESTRUCTOR_ITERATIONS,
+#define	_SC_THREAD_DESTRUCTOR_ITERATIONS _SC_THREAD_DESTRUCTOR_ITERATIONS
+    _SC_THREAD_KEYS_MAX,
+#define	_SC_THREAD_KEYS_MAX		_SC_THREAD_KEYS_MAX
+    _SC_THREAD_STACK_MIN,
+#define	_SC_THREAD_STACK_MIN		_SC_THREAD_STACK_MIN
+    _SC_THREAD_THREADS_MAX,
+#define	_SC_THREAD_THREADS_MAX		_SC_THREAD_THREADS_MAX
+    _SC_THREAD_ATTR_STACKADDR,
+#define	_SC_THREAD_ATTR_STACKADDR	_SC_THREAD_ATTR_STACKADDR
+    _SC_THREAD_ATTR_STACKSIZE,
+#define	_SC_THREAD_ATTR_STACKSIZE	_SC_THREAD_ATTR_STACKSIZE
+    _SC_THREAD_PRIORITY_SCHEDULING,
+#define	_SC_THREAD_PRIORITY_SCHEDULING	_SC_THREAD_PRIORITY_SCHEDULING
+    _SC_THREAD_PRIO_INHERIT,
+#define	_SC_THREAD_PRIO_INHERIT		_SC_THREAD_PRIO_INHERIT
+    _SC_THREAD_PRIO_PROTECT,
+#define	_SC_THREAD_PRIO_PROTECT		_SC_THREAD_PRIO_PROTECT
+    _SC_THREAD_PROCESS_SHARED,
+#define	_SC_THREAD_PROCESS_SHARED	_SC_THREAD_PROCESS_SHARED
+
+    _SC_NPROCESSORS_CONF,
+#define _SC_NPROCESSORS_CONF		_SC_NPROCESSORS_CONF
+    _SC_NPROCESSORS_ONLN,
+#define _SC_NPROCESSORS_ONLN		_SC_NPROCESSORS_ONLN
+    _SC_PHYS_PAGES,
+#define _SC_PHYS_PAGES			_SC_PHYS_PAGES
+    _SC_AVPHYS_PAGES,
+#define _SC_AVPHYS_PAGES		_SC_AVPHYS_PAGES
+    _SC_ATEXIT_MAX,
+#define _SC_ATEXIT_MAX			_SC_ATEXIT_MAX
+    _SC_PASS_MAX,
+#define _SC_PASS_MAX			_SC_PASS_MAX
+
+    _SC_XOPEN_VERSION,
+#define _SC_XOPEN_VERSION		_SC_XOPEN_VERSION
+    _SC_XOPEN_XCU_VERSION,
+#define _SC_XOPEN_XCU_VERSION		_SC_XOPEN_XCU_VERSION
+    _SC_XOPEN_UNIX,
+#define _SC_XOPEN_UNIX			_SC_XOPEN_UNIX
+    _SC_XOPEN_CRYPT,
+#define _SC_XOPEN_CRYPT			_SC_XOPEN_CRYPT
+    _SC_XOPEN_ENH_I18N,
+#define _SC_XOPEN_ENH_I18N		_SC_XOPEN_ENH_I18N
+    _SC_XOPEN_SHM,
+#define _SC_XOPEN_SHM			_SC_XOPEN_SHM
+
+    _SC_2_CHAR_TERM,
+#define _SC_2_CHAR_TERM			_SC_2_CHAR_TERM
+    _SC_2_C_VERSION,
+#define _SC_2_C_VERSION			_SC_2_C_VERSION
+    _SC_2_UPE,
+#define _SC_2_UPE			_SC_2_UPE
+
+    _SC_XOPEN_XPG2,
+#define _SC_XOPEN_XPG2			_SC_XOPEN_XPG2
+    _SC_XOPEN_XPG3,
+#define _SC_XOPEN_XPG3			_SC_XOPEN_XPG3
+    _SC_XOPEN_XPG4,
+#define _SC_XOPEN_XPG4			_SC_XOPEN_XPG4
+
+    _SC_CHAR_BIT,
+#define	_SC_CHAR_BIT			_SC_CHAR_BIT
+    _SC_CHAR_MAX,
+#define	_SC_CHAR_MAX			_SC_CHAR_MAX
+    _SC_CHAR_MIN,
+#define	_SC_CHAR_MIN			_SC_CHAR_MIN
+    _SC_INT_MAX,
+#define	_SC_INT_MAX			_SC_INT_MAX
+    _SC_INT_MIN,
+#define	_SC_INT_MIN			_SC_INT_MIN
+    _SC_LONG_BIT,
+#define	_SC_LONG_BIT			_SC_LONG_BIT
+    _SC_WORD_BIT,
+#define	_SC_WORD_BIT			_SC_WORD_BIT
+    _SC_MB_LEN_MAX,
+#define	_SC_MB_LEN_MAX			_SC_MB_LEN_MAX
+    _SC_NZERO,
+#define	_SC_NZERO			_SC_NZERO
+    _SC_SSIZE_MAX,
+#define	_SC_SSIZE_MAX			_SC_SSIZE_MAX
+    _SC_SCHAR_MAX,
+#define	_SC_SCHAR_MAX			_SC_SCHAR_MAX
+    _SC_SCHAR_MIN,
+#define	_SC_SCHAR_MIN			_SC_SCHAR_MIN
+    _SC_SHRT_MAX,
+#define	_SC_SHRT_MAX			_SC_SHRT_MAX
+    _SC_SHRT_MIN,
+#define	_SC_SHRT_MIN			_SC_SHRT_MIN
+    _SC_UCHAR_MAX,
+#define	_SC_UCHAR_MAX			_SC_UCHAR_MAX
+    _SC_UINT_MAX,
+#define	_SC_UINT_MAX			_SC_UINT_MAX
+    _SC_ULONG_MAX,
+#define	_SC_ULONG_MAX			_SC_ULONG_MAX
+    _SC_USHRT_MAX,
+#define	_SC_USHRT_MAX			_SC_USHRT_MAX
+
+    _SC_NL_ARGMAX,
+#define	_SC_NL_ARGMAX			_SC_NL_ARGMAX
+    _SC_NL_LANGMAX,
+#define	_SC_NL_LANGMAX			_SC_NL_LANGMAX
+    _SC_NL_MSGMAX,
+#define	_SC_NL_MSGMAX			_SC_NL_MSGMAX
+    _SC_NL_NMAX,
+#define	_SC_NL_NMAX			_SC_NL_NMAX
+    _SC_NL_SETMAX,
+#define	_SC_NL_SETMAX			_SC_NL_SETMAX
+    _SC_NL_TEXTMAX,
+#define	_SC_NL_TEXTMAX			_SC_NL_TEXTMAX
+
+    _SC_XBS5_ILP32_OFF32,
+#define _SC_XBS5_ILP32_OFF32		_SC_XBS5_ILP32_OFF32
+    _SC_XBS5_ILP32_OFFBIG,
+#define _SC_XBS5_ILP32_OFFBIG		_SC_XBS5_ILP32_OFFBIG
+    _SC_XBS5_LP64_OFF64,
+#define _SC_XBS5_LP64_OFF64		_SC_XBS5_LP64_OFF64
+    _SC_XBS5_LPBIG_OFFBIG,
+#define _SC_XBS5_LPBIG_OFFBIG		_SC_XBS5_LPBIG_OFFBIG
+
+    _SC_XOPEN_LEGACY,
+#define _SC_XOPEN_LEGACY		_SC_XOPEN_LEGACY
+    _SC_XOPEN_REALTIME,
+#define _SC_XOPEN_REALTIME		_SC_XOPEN_REALTIME
+    _SC_XOPEN_REALTIME_THREADS,
+#define _SC_XOPEN_REALTIME_THREADS	_SC_XOPEN_REALTIME_THREADS
+
+    _SC_ADVISORY_INFO,
+#define _SC_ADVISORY_INFO		_SC_ADVISORY_INFO
+    _SC_BARRIERS,
+#define _SC_BARRIERS			_SC_BARRIERS
+    _SC_BASE,
+#define _SC_BASE			_SC_BASE
+    _SC_C_LANG_SUPPORT,
+#define _SC_C_LANG_SUPPORT		_SC_C_LANG_SUPPORT
+    _SC_C_LANG_SUPPORT_R,
+#define _SC_C_LANG_SUPPORT_R		_SC_C_LANG_SUPPORT_R
+    _SC_CLOCK_SELECTION,
+#define _SC_CLOCK_SELECTION		_SC_CLOCK_SELECTION
+    _SC_CPUTIME,
+#define _SC_CPUTIME			_SC_CPUTIME
+    _SC_THREAD_CPUTIME,
+#define _SC_THREAD_CPUTIME		_SC_THREAD_CPUTIME
+    _SC_DEVICE_IO,
+#define _SC_DEVICE_IO			_SC_DEVICE_IO
+    _SC_DEVICE_SPECIFIC,
+#define _SC_DEVICE_SPECIFIC		_SC_DEVICE_SPECIFIC
+    _SC_DEVICE_SPECIFIC_R,
+#define _SC_DEVICE_SPECIFIC_R		_SC_DEVICE_SPECIFIC_R
+    _SC_FD_MGMT,
+#define _SC_FD_MGMT			_SC_FD_MGMT
+    _SC_FIFO,
+#define _SC_FIFO			_SC_FIFO
+    _SC_PIPE,
+#define _SC_PIPE			_SC_PIPE
+    _SC_FILE_ATTRIBUTES,
+#define _SC_FILE_ATTRIBUTES		_SC_FILE_ATTRIBUTES
+    _SC_FILE_LOCKING,
+#define _SC_FILE_LOCKING		_SC_FILE_LOCKING
+    _SC_FILE_SYSTEM,
+#define _SC_FILE_SYSTEM			_SC_FILE_SYSTEM
+    _SC_MONOTONIC_CLOCK,
+#define _SC_MONOTONIC_CLOCK		_SC_MONOTONIC_CLOCK
+    _SC_MULTI_PROCESS,
+#define _SC_MULTI_PROCESS		_SC_MULTI_PROCESS
+    _SC_SINGLE_PROCESS,
+#define _SC_SINGLE_PROCESS		_SC_SINGLE_PROCESS
+    _SC_NETWORKING,
+#define _SC_NETWORKING			_SC_NETWORKING
+    _SC_READER_WRITER_LOCKS,
+#define _SC_READER_WRITER_LOCKS		_SC_READER_WRITER_LOCKS
+    _SC_SPIN_LOCKS,
+#define _SC_SPIN_LOCKS			_SC_SPIN_LOCKS
+    _SC_REGEXP,
+#define _SC_REGEXP			_SC_REGEXP
+    _SC_REGEX_VERSION,
+#define _SC_REGEX_VERSION		_SC_REGEX_VERSION
+    _SC_SHELL,
+#define _SC_SHELL			_SC_SHELL
+    _SC_SIGNALS,
+#define _SC_SIGNALS			_SC_SIGNALS
+    _SC_SPAWN,
+#define _SC_SPAWN			_SC_SPAWN
+    _SC_SPORADIC_SERVER,
+#define _SC_SPORADIC_SERVER		_SC_SPORADIC_SERVER
+    _SC_THREAD_SPORADIC_SERVER,
+#define _SC_THREAD_SPORADIC_SERVER	_SC_THREAD_SPORADIC_SERVER
+    _SC_SYSTEM_DATABASE,
+#define _SC_SYSTEM_DATABASE		_SC_SYSTEM_DATABASE
+    _SC_SYSTEM_DATABASE_R,
+#define _SC_SYSTEM_DATABASE_R		_SC_SYSTEM_DATABASE_R
+    _SC_TIMEOUTS,
+#define _SC_TIMEOUTS			_SC_TIMEOUTS
+    _SC_TYPED_MEMORY_OBJECTS,
+#define _SC_TYPED_MEMORY_OBJECTS	_SC_TYPED_MEMORY_OBJECTS
+    _SC_USER_GROUPS,
+#define _SC_USER_GROUPS			_SC_USER_GROUPS
+    _SC_USER_GROUPS_R,
+#define _SC_USER_GROUPS_R		_SC_USER_GROUPS_R
+    _SC_2_PBS,
+#define _SC_2_PBS			_SC_2_PBS
+    _SC_2_PBS_ACCOUNTING,
+#define _SC_2_PBS_ACCOUNTING		_SC_2_PBS_ACCOUNTING
+    _SC_2_PBS_LOCATE,
+#define _SC_2_PBS_LOCATE		_SC_2_PBS_LOCATE
+    _SC_2_PBS_MESSAGE,
+#define _SC_2_PBS_MESSAGE		_SC_2_PBS_MESSAGE
+    _SC_2_PBS_TRACK,
+#define _SC_2_PBS_TRACK			_SC_2_PBS_TRACK
+    _SC_SYMLOOP_MAX,
+#define _SC_SYMLOOP_MAX			_SC_SYMLOOP_MAX
+    _SC_STREAMS,
+#define _SC_STREAMS			_SC_STREAMS
+    _SC_2_PBS_CHECKPOINT,
+#define _SC_2_PBS_CHECKPOINT		_SC_2_PBS_CHECKPOINT
+
+    _SC_V6_ILP32_OFF32,
+#define _SC_V6_ILP32_OFF32		_SC_V6_ILP32_OFF32
+    _SC_V6_ILP32_OFFBIG,
+#define _SC_V6_ILP32_OFFBIG		_SC_V6_ILP32_OFFBIG
+    _SC_V6_LP64_OFF64,
+#define _SC_V6_LP64_OFF64		_SC_V6_LP64_OFF64
+    _SC_V6_LPBIG_OFFBIG,
+#define _SC_V6_LPBIG_OFFBIG		_SC_V6_LPBIG_OFFBIG
+
+    _SC_HOST_NAME_MAX,
+#define _SC_HOST_NAME_MAX		_SC_HOST_NAME_MAX
+    _SC_TRACE,
+#define _SC_TRACE			_SC_TRACE
+    _SC_TRACE_EVENT_FILTER,
+#define _SC_TRACE_EVENT_FILTER		_SC_TRACE_EVENT_FILTER
+    _SC_TRACE_INHERIT,
+#define _SC_TRACE_INHERIT		_SC_TRACE_INHERIT
+    _SC_TRACE_LOG,
+#define _SC_TRACE_LOG			_SC_TRACE_LOG
+
+    _SC_LEVEL1_ICACHE_SIZE,
+#define _SC_LEVEL1_ICACHE_SIZE		_SC_LEVEL1_ICACHE_SIZE
+    _SC_LEVEL1_ICACHE_ASSOC,
+#define _SC_LEVEL1_ICACHE_ASSOC		_SC_LEVEL1_ICACHE_ASSOC
+    _SC_LEVEL1_ICACHE_LINESIZE,
+#define _SC_LEVEL1_ICACHE_LINESIZE	_SC_LEVEL1_ICACHE_LINESIZE
+    _SC_LEVEL1_DCACHE_SIZE,
+#define _SC_LEVEL1_DCACHE_SIZE		_SC_LEVEL1_DCACHE_SIZE
+    _SC_LEVEL1_DCACHE_ASSOC,
+#define _SC_LEVEL1_DCACHE_ASSOC		_SC_LEVEL1_DCACHE_ASSOC
+    _SC_LEVEL1_DCACHE_LINESIZE,
+#define _SC_LEVEL1_DCACHE_LINESIZE	_SC_LEVEL1_DCACHE_LINESIZE
+    _SC_LEVEL2_CACHE_SIZE,
+#define _SC_LEVEL2_CACHE_SIZE		_SC_LEVEL2_CACHE_SIZE
+    _SC_LEVEL2_CACHE_ASSOC,
+#define _SC_LEVEL2_CACHE_ASSOC		_SC_LEVEL2_CACHE_ASSOC
+    _SC_LEVEL2_CACHE_LINESIZE,
+#define _SC_LEVEL2_CACHE_LINESIZE	_SC_LEVEL2_CACHE_LINESIZE
+    _SC_LEVEL3_CACHE_SIZE,
+#define _SC_LEVEL3_CACHE_SIZE		_SC_LEVEL3_CACHE_SIZE
+    _SC_LEVEL3_CACHE_ASSOC,
+#define _SC_LEVEL3_CACHE_ASSOC		_SC_LEVEL3_CACHE_ASSOC
+    _SC_LEVEL3_CACHE_LINESIZE,
+#define _SC_LEVEL3_CACHE_LINESIZE	_SC_LEVEL3_CACHE_LINESIZE
+    _SC_LEVEL4_CACHE_SIZE,
+#define _SC_LEVEL4_CACHE_SIZE		_SC_LEVEL4_CACHE_SIZE
+    _SC_LEVEL4_CACHE_ASSOC,
+#define _SC_LEVEL4_CACHE_ASSOC		_SC_LEVEL4_CACHE_ASSOC
+    _SC_LEVEL4_CACHE_LINESIZE,
+#define _SC_LEVEL4_CACHE_LINESIZE	_SC_LEVEL4_CACHE_LINESIZE
+    /* Leave room here, maybe we need a few more cache levels some day.  */
+
+    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
+#define _SC_IPV6			_SC_IPV6
+    _SC_RAW_SOCKETS,
+#define _SC_RAW_SOCKETS			_SC_RAW_SOCKETS
+
+    _SC_V7_ILP32_OFF32,
+#define _SC_V7_ILP32_OFF32		_SC_V7_ILP32_OFF32
+    _SC_V7_ILP32_OFFBIG,
+#define _SC_V7_ILP32_OFFBIG		_SC_V7_ILP32_OFFBIG
+    _SC_V7_LP64_OFF64,
+#define _SC_V7_LP64_OFF64		_SC_V7_LP64_OFF64
+    _SC_V7_LPBIG_OFFBIG,
+#define _SC_V7_LPBIG_OFFBIG		_SC_V7_LPBIG_OFFBIG
+
+    _SC_SS_REPL_MAX,
+#define _SC_SS_REPL_MAX			_SC_SS_REPL_MAX
+
+    _SC_TRACE_EVENT_NAME_MAX,
+#define _SC_TRACE_EVENT_NAME_MAX	_SC_TRACE_EVENT_NAME_MAX
+    _SC_TRACE_NAME_MAX,
+#define _SC_TRACE_NAME_MAX		_SC_TRACE_NAME_MAX
+    _SC_TRACE_SYS_MAX,
+#define _SC_TRACE_SYS_MAX		_SC_TRACE_SYS_MAX
+    _SC_TRACE_USER_EVENT_MAX,
+#define _SC_TRACE_USER_EVENT_MAX	_SC_TRACE_USER_EVENT_MAX
+
+    _SC_XOPEN_STREAMS,
+#define _SC_XOPEN_STREAMS		_SC_XOPEN_STREAMS
+
+    _SC_THREAD_ROBUST_PRIO_INHERIT,
+#define _SC_THREAD_ROBUST_PRIO_INHERIT	_SC_THREAD_ROBUST_PRIO_INHERIT
+    _SC_THREAD_ROBUST_PRIO_PROTECT
+#define _SC_THREAD_ROBUST_PRIO_PROTECT	_SC_THREAD_ROBUST_PRIO_PROTECT
+  };
+
+/* Values for the NAME argument to `confstr'.  */
+enum
+  {
+    _CS_PATH,			/* The default search path.  */
+#define _CS_PATH		_CS_PATH
+
+    _CS_V6_WIDTH_RESTRICTED_ENVS,
+#define _CS_V6_WIDTH_RESTRICTED_ENVS	_CS_V6_WIDTH_RESTRICTED_ENVS
+#define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS	_CS_V6_WIDTH_RESTRICTED_ENVS
+
+    _CS_GNU_LIBC_VERSION,
+#define _CS_GNU_LIBC_VERSION	_CS_GNU_LIBC_VERSION
+    _CS_GNU_LIBPTHREAD_VERSION,
+#define _CS_GNU_LIBPTHREAD_VERSION	_CS_GNU_LIBPTHREAD_VERSION
+
+    _CS_V5_WIDTH_RESTRICTED_ENVS,
+#define _CS_V5_WIDTH_RESTRICTED_ENVS	_CS_V5_WIDTH_RESTRICTED_ENVS
+#define _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS	_CS_V5_WIDTH_RESTRICTED_ENVS
+
+    _CS_V7_WIDTH_RESTRICTED_ENVS,
+#define _CS_V7_WIDTH_RESTRICTED_ENVS	_CS_V7_WIDTH_RESTRICTED_ENVS
+#define _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS	_CS_V7_WIDTH_RESTRICTED_ENVS
+
+    _CS_LFS_CFLAGS = 1000,
+#define _CS_LFS_CFLAGS	_CS_LFS_CFLAGS
+    _CS_LFS_LDFLAGS,
+#define _CS_LFS_LDFLAGS	_CS_LFS_LDFLAGS
+    _CS_LFS_LIBS,
+#define _CS_LFS_LIBS		_CS_LFS_LIBS
+    _CS_LFS_LINTFLAGS,
+#define _CS_LFS_LINTFLAGS	_CS_LFS_LINTFLAGS
+    _CS_LFS64_CFLAGS,
+#define _CS_LFS64_CFLAGS	_CS_LFS64_CFLAGS
+    _CS_LFS64_LDFLAGS,
+#define _CS_LFS64_LDFLAGS	_CS_LFS64_LDFLAGS
+    _CS_LFS64_LIBS,
+#define _CS_LFS64_LIBS	_CS_LFS64_LIBS
+    _CS_LFS64_LINTFLAGS,
+#define _CS_LFS64_LINTFLAGS	_CS_LFS64_LINTFLAGS
+
+    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
+#define _CS_XBS5_ILP32_OFF32_CFLAGS _CS_XBS5_ILP32_OFF32_CFLAGS
+    _CS_XBS5_ILP32_OFF32_LDFLAGS,
+#define _CS_XBS5_ILP32_OFF32_LDFLAGS _CS_XBS5_ILP32_OFF32_LDFLAGS
+    _CS_XBS5_ILP32_OFF32_LIBS,
+#define _CS_XBS5_ILP32_OFF32_LIBS _CS_XBS5_ILP32_OFF32_LIBS
+    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
+#define _CS_XBS5_ILP32_OFF32_LINTFLAGS _CS_XBS5_ILP32_OFF32_LINTFLAGS
+    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
+#define _CS_XBS5_ILP32_OFFBIG_CFLAGS _CS_XBS5_ILP32_OFFBIG_CFLAGS
+    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
+#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS _CS_XBS5_ILP32_OFFBIG_LDFLAGS
+    _CS_XBS5_ILP32_OFFBIG_LIBS,
+#define _CS_XBS5_ILP32_OFFBIG_LIBS _CS_XBS5_ILP32_OFFBIG_LIBS
+    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
+#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS _CS_XBS5_ILP32_OFFBIG_LINTFLAGS
+    _CS_XBS5_LP64_OFF64_CFLAGS,
+#define _CS_XBS5_LP64_OFF64_CFLAGS _CS_XBS5_LP64_OFF64_CFLAGS
+    _CS_XBS5_LP64_OFF64_LDFLAGS,
+#define _CS_XBS5_LP64_OFF64_LDFLAGS _CS_XBS5_LP64_OFF64_LDFLAGS
+    _CS_XBS5_LP64_OFF64_LIBS,
+#define _CS_XBS5_LP64_OFF64_LIBS _CS_XBS5_LP64_OFF64_LIBS
+    _CS_XBS5_LP64_OFF64_LINTFLAGS,
+#define _CS_XBS5_LP64_OFF64_LINTFLAGS _CS_XBS5_LP64_OFF64_LINTFLAGS
+    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
+#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS _CS_XBS5_LPBIG_OFFBIG_CFLAGS
+    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
+#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS _CS_XBS5_LPBIG_OFFBIG_LDFLAGS
+    _CS_XBS5_LPBIG_OFFBIG_LIBS,
+#define _CS_XBS5_LPBIG_OFFBIG_LIBS _CS_XBS5_LPBIG_OFFBIG_LIBS
+    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
+#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS
+
+    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
+#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS _CS_POSIX_V6_ILP32_OFF32_CFLAGS
+    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
+#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS _CS_POSIX_V6_ILP32_OFF32_LDFLAGS
+    _CS_POSIX_V6_ILP32_OFF32_LIBS,
+#define _CS_POSIX_V6_ILP32_OFF32_LIBS _CS_POSIX_V6_ILP32_OFF32_LIBS
+    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
+#define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
+    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
+#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
+    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
+#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
+    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
+#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS _CS_POSIX_V6_ILP32_OFFBIG_LIBS
+    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
+#define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
+    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
+#define _CS_POSIX_V6_LP64_OFF64_CFLAGS _CS_POSIX_V6_LP64_OFF64_CFLAGS
+    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
+#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS _CS_POSIX_V6_LP64_OFF64_LDFLAGS
+    _CS_POSIX_V6_LP64_OFF64_LIBS,
+#define _CS_POSIX_V6_LP64_OFF64_LIBS _CS_POSIX_V6_LP64_OFF64_LIBS
+    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
+#define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS _CS_POSIX_V6_LP64_OFF64_LINTFLAGS
+    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
+#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
+    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
+    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS _CS_POSIX_V6_LPBIG_OFFBIG_LIBS
+    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
+
+    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
+#define _CS_POSIX_V7_ILP32_OFF32_CFLAGS _CS_POSIX_V7_ILP32_OFF32_CFLAGS
+    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
+#define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS _CS_POSIX_V7_ILP32_OFF32_LDFLAGS
+    _CS_POSIX_V7_ILP32_OFF32_LIBS,
+#define _CS_POSIX_V7_ILP32_OFF32_LIBS _CS_POSIX_V7_ILP32_OFF32_LIBS
+    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
+#define _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS
+    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
+#define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
+    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
+#define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
+    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
+#define _CS_POSIX_V7_ILP32_OFFBIG_LIBS _CS_POSIX_V7_ILP32_OFFBIG_LIBS
+    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
+#define _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS
+    _CS_POSIX_V7_LP64_OFF64_CFLAGS,
+#define _CS_POSIX_V7_LP64_OFF64_CFLAGS _CS_POSIX_V7_LP64_OFF64_CFLAGS
+    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
+#define _CS_POSIX_V7_LP64_OFF64_LDFLAGS _CS_POSIX_V7_LP64_OFF64_LDFLAGS
+    _CS_POSIX_V7_LP64_OFF64_LIBS,
+#define _CS_POSIX_V7_LP64_OFF64_LIBS _CS_POSIX_V7_LP64_OFF64_LIBS
+    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
+#define _CS_POSIX_V7_LP64_OFF64_LINTFLAGS _CS_POSIX_V7_LP64_OFF64_LINTFLAGS
+    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
+#define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
+    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
+    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS _CS_POSIX_V7_LPBIG_OFFBIG_LIBS
+    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS
+
+    _CS_V6_ENV,
+#define _CS_V6_ENV			_CS_V6_ENV
+    _CS_V7_ENV
+#define _CS_V7_ENV			_CS_V7_ENV
+  };
diff --git a/include/bits/dirent.h b/include/bits/dirent.h
new file mode 100644
index 0000000..3a5466b
--- /dev/null
+++ b/include/bits/dirent.h
@@ -0,0 +1,59 @@
+/* Directory entry structure `struct dirent'.  4.4BSD/Generic version.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _DIRENT_H
+# error "Never use <bits/dirent.h> directly; include <dirent.h> instead."
+#endif
+
+struct dirent
+  {
+#ifndef __USE_FILE_OFFSET64
+    __ino_t d_ino;		/* File serial number.  */
+#else
+    __ino64_t d_ino;
+#endif
+    unsigned short int d_reclen; /* Length of the whole `struct dirent'.  */
+    unsigned char d_type;	/* File type, possibly unknown.  */
+    unsigned char d_namlen;	/* Length of the file name.  */
+
+    /* Only this member is in the POSIX standard.  */
+    char d_name[1];		/* File name (actually longer).  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct dirent64
+  {
+    __ino64_t d_ino;
+    unsigned short int d_reclen;
+    unsigned char d_type;
+    unsigned char d_namlen;
+
+    char d_name[1];
+  };
+#endif
+
+#define d_fileno	d_ino	/* Backwards compatibility.  */
+
+#define _DIRENT_HAVE_D_RECLEN 1
+#define _DIRENT_HAVE_D_NAMLEN 1
+#define _DIRENT_HAVE_D_TYPE 1
+
+#ifdef __INO_T_MATCHES_INO64_T
+/* Inform libc code that these two types are effectively identical.  */
+# define _DIRENT_MATCHES_DIRENT64	1
+#endif
diff --git a/include/bits/dlfcn.h b/include/bits/dlfcn.h
new file mode 100644
index 0000000..836b246
--- /dev/null
+++ b/include/bits/dlfcn.h
@@ -0,0 +1,64 @@
+/* System dependent definitions for run-time dynamic loading.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _DLFCN_H
+# error "Never use <bits/dlfcn.h> directly; include <dlfcn.h> instead."
+#endif
+
+/* The MODE argument to `dlopen' contains one of the following: */
+#define RTLD_LAZY	0x00001	/* Lazy function call binding.  */
+#define RTLD_NOW	0x00002	/* Immediate function call binding.  */
+#define	RTLD_BINDING_MASK   0x3	/* Mask of binding time value.  */
+#define RTLD_NOLOAD	0x00004	/* Do not load the object.  */
+#define RTLD_DEEPBIND	0x00008	/* Use deep binding.  */
+
+/* If the following bit is set in the MODE argument to `dlopen',
+   the symbols of the loaded object and its dependencies are made
+   visible as if the object were linked directly into the program.  */
+#define RTLD_GLOBAL	0x00100
+
+/* Unix98 demands the following flag which is the inverse to RTLD_GLOBAL.
+   The implementation does this by default and so we can define the
+   value to zero.  */
+#define RTLD_LOCAL	0
+
+/* Do not delete object when closed.  */
+#define RTLD_NODELETE	0x01000
+
+#ifdef __USE_GNU
+/* To support profiling of shared objects it is a good idea to call
+   the function found using `dlsym' using the following macro since
+   these calls do not use the PLT.  But this would mean the dynamic
+   loader has no chance to find out when the function is called.  The
+   macro applies the necessary magic so that profiling is possible.
+   Rewrite
+	foo = (*fctp) (arg1, arg2);
+   into
+        foo = DL_CALL_FCT (fctp, (arg1, arg2));
+*/
+# define DL_CALL_FCT(fctp, args) \
+  (_dl_mcount_wrapper_check ((void *) (fctp)), (*(fctp)) args)
+
+__BEGIN_DECLS
+
+/* This function calls the profiling functions.  */
+extern void _dl_mcount_wrapper_check (void *__selfpc) __THROW;
+
+__END_DECLS
+
+#endif
diff --git a/include/bits/elfclass.h b/include/bits/elfclass.h
new file mode 100644
index 0000000..180227d
--- /dev/null
+++ b/include/bits/elfclass.h
@@ -0,0 +1,14 @@
+/* This file specifies the native word size of the machine, which indicates
+   the ELF file class used for executables and shared objects on this
+   machine.  */
+
+#ifndef _LINK_H
+# error "Never use <bits/elfclass.h> directly; include <link.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#define __ELF_NATIVE_CLASS __WORDSIZE
+
+/* The entries in the .hash table always have a size of 32 bits.  */
+typedef uint32_t Elf_Symndx;
diff --git a/include/bits/endian.h b/include/bits/endian.h
new file mode 100644
index 0000000..5a56c72
--- /dev/null
+++ b/include/bits/endian.h
@@ -0,0 +1,7 @@
+/* i386/x86_64 are little-endian.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
diff --git a/include/bits/environments.h b/include/bits/environments.h
new file mode 100644
index 0000000..46f8cb8
--- /dev/null
+++ b/include/bits/environments.h
@@ -0,0 +1,87 @@
+/* Copyright (C) 1999-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _UNISTD_H
+# error "Never include this file directly.  Use <unistd.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+/* This header should define the following symbols under the described
+   situations.  A value `1' means that the model is always supported,
+   `-1' means it is never supported.  Undefined means it cannot be
+   statically decided.
+
+   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
+   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
+
+   _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
+   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type
+
+   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
+   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
+   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
+   used in previous versions of the Unix standard and are available
+   only for compatibility.
+*/
+
+#if __WORDSIZE == 64
+
+/* We can never provide environments with 32-bit wide pointers.  */
+# define _POSIX_V7_ILP32_OFF32	-1
+# define _POSIX_V7_ILP32_OFFBIG	-1
+# define _POSIX_V6_ILP32_OFF32	-1
+# define _POSIX_V6_ILP32_OFFBIG	-1
+# define _XBS5_ILP32_OFF32	-1
+# define _XBS5_ILP32_OFFBIG	-1
+/* We also have no use (for now) for an environment with bigger pointers
+   and offsets.  */
+# define _POSIX_V7_LPBIG_OFFBIG	-1
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
+# define _POSIX_V7_LP64_OFF64	1
+# define _POSIX_V6_LP64_OFF64	1
+# define _XBS5_LP64_OFF64	1
+
+#else /* __WORDSIZE == 32 */
+
+/* By default we have 32-bit wide `int', `long int', pointers and `off_t'
+   and all platforms support LFS.  */
+# define _POSIX_V7_ILP32_OFF32	1
+# define _POSIX_V7_ILP32_OFFBIG	1
+# define _POSIX_V6_ILP32_OFF32	1
+# define _POSIX_V6_ILP32_OFFBIG	1
+# define _XBS5_ILP32_OFF32	1
+# define _XBS5_ILP32_OFFBIG	1
+
+/* We optionally provide an environment with the above size but an 64-bit
+   side `off_t'.  Therefore we don't define _POSIX_V7_ILP32_OFFBIG.  */
+
+/* We can never provide environments with 64-bit wide pointers.  */
+# define _POSIX_V7_LP64_OFF64	-1
+# define _POSIX_V7_LPBIG_OFFBIG	-1
+# define _POSIX_V6_LP64_OFF64	-1
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LP64_OFF64	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+/* CFLAGS.  */
+#define __ILP32_OFFBIG_CFLAGS   "-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
+
+#endif /* __WORDSIZE == 32 */
diff --git a/include/bits/errno.h b/include/bits/errno.h
new file mode 100644
index 0000000..a215a8a
--- /dev/null
+++ b/include/bits/errno.h
@@ -0,0 +1,331 @@
+/* This file generated by errnos.awk.  */
+
+/* The Hurd uses Mach error system 0x10, currently only subsystem 0. */
+#ifndef _HURD_ERRNO
+#define _HURD_ERRNO(n)	((0x10 << 26) | ((n) & 0x3fff))
+#endif
+
+#ifdef _ERRNO_H
+
+enum __error_t_codes
+{
+	/* The value zero always means success and it is perfectly fine for
+	   code to use 0 explicitly (or implicitly, e.g. via Boolean coercion).
+	   Having an enum entry for zero both makes the debugger print the name
+	   for error_t-typed zero values, and prevents the compiler from
+	   issuing warnings about 'case 0:' in a switch on an error_t-typed
+	   value.  */
+	ESUCCESS = 0,
+
+#undef EDOM
+#undef ERANGE
+	EPERM           = _HURD_ERRNO (1),
+#define	EPERM           _HURD_ERRNO (1) /* Operation not permitted */
+	ENOENT          = _HURD_ERRNO (2),
+#define	ENOENT          _HURD_ERRNO (2) /* No such file or directory */
+	ESRCH           = _HURD_ERRNO (3),
+#define	ESRCH           _HURD_ERRNO (3) /* No such process */
+	EINTR           = _HURD_ERRNO (4),
+#define	EINTR           _HURD_ERRNO (4) /* Interrupted system call */
+	EIO             = _HURD_ERRNO (5),
+#define	EIO             _HURD_ERRNO (5) /* Input/output error */
+	ENXIO           = _HURD_ERRNO (6),
+#define	ENXIO           _HURD_ERRNO (6) /* No such device or address */
+	E2BIG           = _HURD_ERRNO (7),
+#define	E2BIG           _HURD_ERRNO (7) /* Argument list too long */
+	ENOEXEC         = _HURD_ERRNO (8),
+#define	ENOEXEC         _HURD_ERRNO (8) /* Exec format error */
+	EBADF           = _HURD_ERRNO (9),
+#define	EBADF           _HURD_ERRNO (9) /* Bad file descriptor */
+	ECHILD          = _HURD_ERRNO (10),
+#define	ECHILD          _HURD_ERRNO (10)/* No child processes */
+	EDEADLK         = _HURD_ERRNO (11),
+#define	EDEADLK         _HURD_ERRNO (11)/* Resource deadlock avoided */
+	ENOMEM          = _HURD_ERRNO (12),
+#define	ENOMEM          _HURD_ERRNO (12)/* Cannot allocate memory */
+	EACCES          = _HURD_ERRNO (13),
+#define	EACCES          _HURD_ERRNO (13)/* Permission denied */
+	EFAULT          = _HURD_ERRNO (14),
+#define	EFAULT          _HURD_ERRNO (14)/* Bad address */
+	ENOTBLK         = _HURD_ERRNO (15),
+#define	ENOTBLK         _HURD_ERRNO (15)/* Block device required */
+	EBUSY           = _HURD_ERRNO (16),
+#define	EBUSY           _HURD_ERRNO (16)/* Device or resource busy */
+	EEXIST          = _HURD_ERRNO (17),
+#define	EEXIST          _HURD_ERRNO (17)/* File exists */
+	EXDEV           = _HURD_ERRNO (18),
+#define	EXDEV           _HURD_ERRNO (18)/* Invalid cross-device link */
+	ENODEV          = _HURD_ERRNO (19),
+#define	ENODEV          _HURD_ERRNO (19)/* No such device */
+	ENOTDIR         = _HURD_ERRNO (20),
+#define	ENOTDIR         _HURD_ERRNO (20)/* Not a directory */
+	EISDIR          = _HURD_ERRNO (21),
+#define	EISDIR          _HURD_ERRNO (21)/* Is a directory */
+	EINVAL          = _HURD_ERRNO (22),
+#define	EINVAL          _HURD_ERRNO (22)/* Invalid argument */
+	EMFILE          = _HURD_ERRNO (24),
+#define	EMFILE          _HURD_ERRNO (24)/* Too many open files */
+	ENFILE          = _HURD_ERRNO (23),
+#define	ENFILE          _HURD_ERRNO (23)/* Too many open files in system */
+	ENOTTY          = _HURD_ERRNO (25),
+#define	ENOTTY          _HURD_ERRNO (25)/* Inappropriate ioctl for device */
+	ETXTBSY         = _HURD_ERRNO (26),
+#define	ETXTBSY         _HURD_ERRNO (26)/* Text file busy */
+	EFBIG           = _HURD_ERRNO (27),
+#define	EFBIG           _HURD_ERRNO (27)/* File too large */
+	ENOSPC          = _HURD_ERRNO (28),
+#define	ENOSPC          _HURD_ERRNO (28)/* No space left on device */
+	ESPIPE          = _HURD_ERRNO (29),
+#define	ESPIPE          _HURD_ERRNO (29)/* Illegal seek */
+	EROFS           = _HURD_ERRNO (30),
+#define	EROFS           _HURD_ERRNO (30)/* Read-only file system */
+	EMLINK          = _HURD_ERRNO (31),
+#define	EMLINK          _HURD_ERRNO (31)/* Too many links */
+	EPIPE           = _HURD_ERRNO (32),
+#define	EPIPE           _HURD_ERRNO (32)/* Broken pipe */
+	EDOM            = _HURD_ERRNO (33),
+#define	EDOM            _HURD_ERRNO (33)/* Numerical argument out of domain */
+	ERANGE          = _HURD_ERRNO (34),
+#define	ERANGE          _HURD_ERRNO (34)/* Numerical result out of range */
+	EAGAIN          = _HURD_ERRNO (35),
+#define	EAGAIN          _HURD_ERRNO (35)/* Resource temporarily unavailable */
+#define EWOULDBLOCK EAGAIN /* Operation would block */
+	EINPROGRESS     = _HURD_ERRNO (36),
+#define	EINPROGRESS     _HURD_ERRNO (36)/* Operation now in progress */
+	EALREADY        = _HURD_ERRNO (37),
+#define	EALREADY        _HURD_ERRNO (37)/* Operation already in progress */
+	ENOTSOCK        = _HURD_ERRNO (38),
+#define	ENOTSOCK        _HURD_ERRNO (38)/* Socket operation on non-socket */
+	EMSGSIZE        = _HURD_ERRNO (40),
+#define	EMSGSIZE        _HURD_ERRNO (40)/* Message too long */
+	EPROTOTYPE      = _HURD_ERRNO (41),
+#define	EPROTOTYPE      _HURD_ERRNO (41)/* Protocol wrong type for socket */
+	ENOPROTOOPT     = _HURD_ERRNO (42),
+#define	ENOPROTOOPT     _HURD_ERRNO (42)/* Protocol not available */
+	EPROTONOSUPPORT = _HURD_ERRNO (43),
+#define	EPROTONOSUPPORT _HURD_ERRNO (43)/* Protocol not supported */
+	ESOCKTNOSUPPORT = _HURD_ERRNO (44),
+#define	ESOCKTNOSUPPORT _HURD_ERRNO (44)/* Socket type not supported */
+	EOPNOTSUPP      = _HURD_ERRNO (45),
+#define	EOPNOTSUPP      _HURD_ERRNO (45)/* Operation not supported */
+	EPFNOSUPPORT    = _HURD_ERRNO (46),
+#define	EPFNOSUPPORT    _HURD_ERRNO (46)/* Protocol family not supported */
+	EAFNOSUPPORT    = _HURD_ERRNO (47),
+#define	EAFNOSUPPORT    _HURD_ERRNO (47)/* Address family not supported by protocol */
+	EADDRINUSE      = _HURD_ERRNO (48),
+#define	EADDRINUSE      _HURD_ERRNO (48)/* Address already in use */
+	EADDRNOTAVAIL   = _HURD_ERRNO (49),
+#define	EADDRNOTAVAIL   _HURD_ERRNO (49)/* Cannot assign requested address */
+	ENETDOWN        = _HURD_ERRNO (50),
+#define	ENETDOWN        _HURD_ERRNO (50)/* Network is down */
+	ENETUNREACH     = _HURD_ERRNO (51),
+#define	ENETUNREACH     _HURD_ERRNO (51)/* Network is unreachable */
+	ENETRESET       = _HURD_ERRNO (52),
+#define	ENETRESET       _HURD_ERRNO (52)/* Network dropped connection on reset */
+	ECONNABORTED    = _HURD_ERRNO (53),
+#define	ECONNABORTED    _HURD_ERRNO (53)/* Software caused connection abort */
+	ECONNRESET      = _HURD_ERRNO (54),
+#define	ECONNRESET      _HURD_ERRNO (54)/* Connection reset by peer */
+	ENOBUFS         = _HURD_ERRNO (55),
+#define	ENOBUFS         _HURD_ERRNO (55)/* No buffer space available */
+	EISCONN         = _HURD_ERRNO (56),
+#define	EISCONN         _HURD_ERRNO (56)/* Transport endpoint is already connected */
+	ENOTCONN        = _HURD_ERRNO (57),
+#define	ENOTCONN        _HURD_ERRNO (57)/* Transport endpoint is not connected */
+	EDESTADDRREQ    = _HURD_ERRNO (39),
+#define	EDESTADDRREQ    _HURD_ERRNO (39)/* Destination address required */
+	ESHUTDOWN       = _HURD_ERRNO (58),
+#define	ESHUTDOWN       _HURD_ERRNO (58)/* Cannot send after transport endpoint shutdown */
+	ETOOMANYREFS    = _HURD_ERRNO (59),
+#define	ETOOMANYREFS    _HURD_ERRNO (59)/* Too many references: cannot splice */
+	ETIMEDOUT       = _HURD_ERRNO (60),
+#define	ETIMEDOUT       _HURD_ERRNO (60)/* Connection timed out */
+	ECONNREFUSED    = _HURD_ERRNO (61),
+#define	ECONNREFUSED    _HURD_ERRNO (61)/* Connection refused */
+	ELOOP           = _HURD_ERRNO (62),
+#define	ELOOP           _HURD_ERRNO (62)/* Too many levels of symbolic links */
+	ENAMETOOLONG    = _HURD_ERRNO (63),
+#define	ENAMETOOLONG    _HURD_ERRNO (63)/* File name too long */
+	EHOSTDOWN       = _HURD_ERRNO (64),
+#define	EHOSTDOWN       _HURD_ERRNO (64)/* Host is down */
+	EHOSTUNREACH    = _HURD_ERRNO (65),
+#define	EHOSTUNREACH    _HURD_ERRNO (65)/* No route to host */
+	ENOTEMPTY       = _HURD_ERRNO (66),
+#define	ENOTEMPTY       _HURD_ERRNO (66)/* Directory not empty */
+	EPROCLIM        = _HURD_ERRNO (67),
+#define	EPROCLIM        _HURD_ERRNO (67)/* Too many processes */
+	EUSERS          = _HURD_ERRNO (68),
+#define	EUSERS          _HURD_ERRNO (68)/* Too many users */
+	EDQUOT          = _HURD_ERRNO (69),
+#define	EDQUOT          _HURD_ERRNO (69)/* Disk quota exceeded */
+	ESTALE          = _HURD_ERRNO (70),
+#define	ESTALE          _HURD_ERRNO (70)/* Stale file handle */
+	EREMOTE         = _HURD_ERRNO (71),
+#define	EREMOTE         _HURD_ERRNO (71)/* Object is remote */
+	EBADRPC         = _HURD_ERRNO (72),
+#define	EBADRPC         _HURD_ERRNO (72)/* RPC struct is bad */
+	ERPCMISMATCH    = _HURD_ERRNO (73),
+#define	ERPCMISMATCH    _HURD_ERRNO (73)/* RPC version wrong */
+	EPROGUNAVAIL    = _HURD_ERRNO (74),
+#define	EPROGUNAVAIL    _HURD_ERRNO (74)/* RPC program not available */
+	EPROGMISMATCH   = _HURD_ERRNO (75),
+#define	EPROGMISMATCH   _HURD_ERRNO (75)/* RPC program version wrong */
+	EPROCUNAVAIL    = _HURD_ERRNO (76),
+#define	EPROCUNAVAIL    _HURD_ERRNO (76)/* RPC bad procedure for program */
+	ENOLCK          = _HURD_ERRNO (77),
+#define	ENOLCK          _HURD_ERRNO (77)/* No locks available */
+	EFTYPE          = _HURD_ERRNO (79),
+#define	EFTYPE          _HURD_ERRNO (79)/* Inappropriate file type or format */
+	EAUTH           = _HURD_ERRNO (80),
+#define	EAUTH           _HURD_ERRNO (80)/* Authentication error */
+	ENEEDAUTH       = _HURD_ERRNO (81),
+#define	ENEEDAUTH       _HURD_ERRNO (81)/* Need authenticator */
+	ENOSYS          = _HURD_ERRNO (78),
+#define	ENOSYS          _HURD_ERRNO (78)/* Function not implemented */
+	ENOTSUP         = _HURD_ERRNO (118),
+#define	ENOTSUP         _HURD_ERRNO (118)/* Not supported */
+	EILSEQ          = _HURD_ERRNO (106),
+#define	EILSEQ          _HURD_ERRNO (106)/* Invalid or incomplete multibyte or wide character */
+	EBACKGROUND     = _HURD_ERRNO (100),
+#define	EBACKGROUND     _HURD_ERRNO (100)/* Inappropriate operation for background process */
+	EDIED           = _HURD_ERRNO (101),
+#define	EDIED           _HURD_ERRNO (101)/* Translator died */
+	ED              = _HURD_ERRNO (102),
+#define	ED              _HURD_ERRNO (102)/* ? */
+	EGREGIOUS       = _HURD_ERRNO (103),
+#define	EGREGIOUS       _HURD_ERRNO (103)/* You really blew it this time */
+	EIEIO           = _HURD_ERRNO (104),
+#define	EIEIO           _HURD_ERRNO (104)/* Computer bought the farm */
+	EGRATUITOUS     = _HURD_ERRNO (105),
+#define	EGRATUITOUS     _HURD_ERRNO (105)/* Gratuitous error */
+	EBADMSG         = _HURD_ERRNO (107),
+#define	EBADMSG         _HURD_ERRNO (107)/* Bad message */
+	EIDRM           = _HURD_ERRNO (108),
+#define	EIDRM           _HURD_ERRNO (108)/* Identifier removed */
+	EMULTIHOP       = _HURD_ERRNO (109),
+#define	EMULTIHOP       _HURD_ERRNO (109)/* Multihop attempted */
+	ENODATA         = _HURD_ERRNO (110),
+#define	ENODATA         _HURD_ERRNO (110)/* No data available */
+	ENOLINK         = _HURD_ERRNO (111),
+#define	ENOLINK         _HURD_ERRNO (111)/* Link has been severed */
+	ENOMSG          = _HURD_ERRNO (112),
+#define	ENOMSG          _HURD_ERRNO (112)/* No message of desired type */
+	ENOSR           = _HURD_ERRNO (113),
+#define	ENOSR           _HURD_ERRNO (113)/* Out of streams resources */
+	ENOSTR          = _HURD_ERRNO (114),
+#define	ENOSTR          _HURD_ERRNO (114)/* Device not a stream */
+	EOVERFLOW       = _HURD_ERRNO (115),
+#define	EOVERFLOW       _HURD_ERRNO (115)/* Value too large for defined data type */
+	EPROTO          = _HURD_ERRNO (116),
+#define	EPROTO          _HURD_ERRNO (116)/* Protocol error */
+	ETIME           = _HURD_ERRNO (117),
+#define	ETIME           _HURD_ERRNO (117)/* Timer expired */
+	ECANCELED       = _HURD_ERRNO (119),
+#define	ECANCELED       _HURD_ERRNO (119)/* Operation canceled */
+
+	/* Errors from <mach/message.h>.  */
+	EMACH_SEND_IN_PROGRESS          = 0x10000001,
+	EMACH_SEND_INVALID_DATA         = 0x10000002,
+	EMACH_SEND_INVALID_DEST         = 0x10000003,
+	EMACH_SEND_TIMED_OUT            = 0x10000004,
+	EMACH_SEND_WILL_NOTIFY          = 0x10000005,
+	EMACH_SEND_NOTIFY_IN_PROGRESS   = 0x10000006,
+	EMACH_SEND_INTERRUPTED          = 0x10000007,
+	EMACH_SEND_MSG_TOO_SMALL        = 0x10000008,
+	EMACH_SEND_INVALID_REPLY        = 0x10000009,
+	EMACH_SEND_INVALID_RIGHT        = 0x1000000a,
+	EMACH_SEND_INVALID_NOTIFY       = 0x1000000b,
+	EMACH_SEND_INVALID_MEMORY       = 0x1000000c,
+	EMACH_SEND_NO_BUFFER            = 0x1000000d,
+	EMACH_SEND_NO_NOTIFY            = 0x1000000e,
+	EMACH_SEND_INVALID_TYPE         = 0x1000000f,
+	EMACH_SEND_INVALID_HEADER       = 0x10000010,
+	EMACH_RCV_IN_PROGRESS           = 0x10004001,
+	EMACH_RCV_INVALID_NAME          = 0x10004002,
+	EMACH_RCV_TIMED_OUT             = 0x10004003,
+	EMACH_RCV_TOO_LARGE             = 0x10004004,
+	EMACH_RCV_INTERRUPTED           = 0x10004005,
+	EMACH_RCV_PORT_CHANGED          = 0x10004006,
+	EMACH_RCV_INVALID_NOTIFY        = 0x10004007,
+	EMACH_RCV_INVALID_DATA          = 0x10004008,
+	EMACH_RCV_PORT_DIED             = 0x10004009,
+	EMACH_RCV_IN_SET                = 0x1000400a,
+	EMACH_RCV_HEADER_ERROR          = 0x1000400b,
+	EMACH_RCV_BODY_ERROR            = 0x1000400c,
+
+	/* Errors from <mach/kern_return.h>.  */
+	EKERN_INVALID_ADDRESS           = 1,
+	EKERN_PROTECTION_FAILURE        = 2,
+	EKERN_NO_SPACE                  = 3,
+	EKERN_INVALID_ARGUMENT          = 4,
+	EKERN_FAILURE                   = 5,
+	EKERN_RESOURCE_SHORTAGE         = 6,
+	EKERN_NOT_RECEIVER              = 7,
+	EKERN_NO_ACCESS                 = 8,
+	EKERN_MEMORY_FAILURE            = 9,
+	EKERN_MEMORY_ERROR              = 10,
+	EKERN_NOT_IN_SET                = 12,
+	EKERN_NAME_EXISTS               = 13,
+	EKERN_ABORTED                   = 14,
+	EKERN_INVALID_NAME              = 15,
+	EKERN_INVALID_TASK              = 16,
+	EKERN_INVALID_RIGHT             = 17,
+	EKERN_INVALID_VALUE             = 18,
+	EKERN_UREFS_OVERFLOW            = 19,
+	EKERN_INVALID_CAPABILITY        = 20,
+	EKERN_RIGHT_EXISTS              = 21,
+	EKERN_INVALID_HOST              = 22,
+	EKERN_MEMORY_PRESENT            = 23,
+	EKERN_WRITE_PROTECTION_FAILURE  = 24,
+	EKERN_TERMINATED                = 26,
+	EKERN_TIMEDOUT                  = 27,
+	EKERN_INTERRUPTED               = 28,
+
+	/* Errors from <mach/mig_errors.h>.  */
+	EMIG_TYPE_ERROR         = -300  /* client type check failure */,
+	EMIG_REPLY_MISMATCH     = -301  /* wrong reply message ID */,
+	EMIG_REMOTE_ERROR       = -302  /* server detected error */,
+	EMIG_BAD_ID             = -303  /* bad request message ID */,
+	EMIG_BAD_ARGUMENTS      = -304  /* server type check failure */,
+	EMIG_NO_REPLY           = -305  /* no reply should be sent */,
+	EMIG_EXCEPTION          = -306  /* server raised exception */,
+	EMIG_ARRAY_TOO_LARGE    = -307  /* array not large enough */,
+	EMIG_SERVER_DIED        = -308  /* server died */,
+	EMIG_DESTROY_REQUEST    = -309  /* destroy request with no reply */,
+
+	/* Errors from <device/device_types.h>.  */
+	ED_IO_ERROR             = 2500  /* hardware IO error */,
+	ED_WOULD_BLOCK          = 2501  /* would block, but D_NOWAIT set */,
+	ED_NO_SUCH_DEVICE       = 2502  /* no such device */,
+	ED_ALREADY_OPEN         = 2503  /* exclusive-use device already open */,
+	ED_DEVICE_DOWN          = 2504  /* device has been shut down */,
+	ED_INVALID_OPERATION    = 2505  /* bad operation for device */,
+	ED_INVALID_RECNUM       = 2506  /* invalid record (block) number */,
+	ED_INVALID_SIZE         = 2507  /* invalid IO size */,
+	ED_NO_MEMORY            = 2508  /* memory allocation failure */,
+	ED_READ_ONLY            = 2509  /* device cannot be written to */
+
+};
+
+#define	_HURD_ERRNOS	120
+
+/* User-visible type of error codes.  It is ok to use `int' or
+   `kern_return_t' for these, but with `error_t' the debugger prints
+   symbolic values.  */
+#ifdef __USE_GNU
+typedef enum __error_t_codes error_t;
+#define __error_t_defined	1
+#endif
+
+/* Return the current thread's location for `errno'.
+   The syntax of this function allows redeclarations like `int errno'.  */
+extern int *__errno_location (void) __THROW __attribute__ ((__const__));
+
+#define errno			(*__errno_location ())
+
+#endif /* <errno.h> included.  */
+
+#if !defined (_ERRNO_H) && defined (__need_Emath)
+#define	EDOM            _HURD_ERRNO (33)/* Numerical argument out of domain */
+#define	ERANGE          _HURD_ERRNO (34)/* Numerical result out of range */
+#endif /* <errno.h> not included and need math error codes.  */
diff --git a/include/bits/error.h b/include/bits/error.h
new file mode 100644
index 0000000..5408450
--- /dev/null
+++ b/include/bits/error.h
@@ -0,0 +1,73 @@
+/* Specializations for error functions.
+   Copyright (C) 2007-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_ERROR_H
+# error "Never include <bits/error.h> directly; use <error.h> instead."
+#endif
+
+
+extern void __REDIRECT (__error_alias, (int __status, int __errnum,
+					const char *__format, ...),
+			error)
+  __attribute__ ((__format__ (__printf__, 3, 4)));
+extern void __REDIRECT (__error_noreturn, (int __status, int __errnum,
+					   const char *__format, ...),
+			error)
+  __attribute__ ((__noreturn__, __format__ (__printf__, 3, 4)));
+
+
+/* If we know the function will never return make sure the compiler
+   realizes that, too.  */
+__extern_always_inline void
+error (int __status, int __errnum, const char *__format, ...)
+{
+  if (__builtin_constant_p (__status) && __status != 0)
+    __error_noreturn (__status, __errnum, __format, __va_arg_pack ());
+  else
+    __error_alias (__status, __errnum, __format, __va_arg_pack ());
+}
+
+
+extern void __REDIRECT (__error_at_line_alias, (int __status, int __errnum,
+						const char *__fname,
+						unsigned int __line,
+						const char *__format, ...),
+			error_at_line)
+  __attribute__ ((__format__ (__printf__, 5, 6)));
+extern void __REDIRECT (__error_at_line_noreturn, (int __status, int __errnum,
+						   const char *__fname,
+						   unsigned int __line,
+						   const char *__format,
+						   ...),
+			error_at_line)
+  __attribute__ ((__noreturn__, __format__ (__printf__, 5, 6)));
+
+
+/* If we know the function will never return make sure the compiler
+   realizes that, too.  */
+__extern_always_inline void
+error_at_line (int __status, int __errnum, const char *__fname,
+	       unsigned int __line, const char *__format, ...)
+{
+  if (__builtin_constant_p (__status) && __status != 0)
+    __error_at_line_noreturn (__status, __errnum, __fname, __line, __format,
+			      __va_arg_pack ());
+  else
+    __error_at_line_alias (__status, __errnum, __fname, __line,
+			   __format, __va_arg_pack ());
+}
diff --git a/include/bits/fcntl.h b/include/bits/fcntl.h
new file mode 100644
index 0000000..9460be7
--- /dev/null
+++ b/include/bits/fcntl.h
@@ -0,0 +1,230 @@
+/* O_*, F_*, FD_* bit values for GNU.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* File access modes.  These are understood by io servers; they can be
+   passed in `dir_lookup', and are returned by `io_get_openmodes'.
+   Consequently they can be passed to `open', `hurd_file_name_lookup', and
+   `file_name_lookup'; and are returned by `fcntl' with the F_GETFL
+   command.  */
+
+/* In GNU, read and write are bits (unlike BSD).  */
+#ifdef __USE_GNU
+# define O_READ		O_RDONLY /* Open for reading.  */
+# define O_WRITE	O_WRONLY /* Open for writing.  */
+# define O_EXEC		0x0004	/* Open for execution.  */
+# define O_NORW		0	/* Open without R/W access.  */
+#endif
+/* POSIX.1 standard names.  */
+#define	O_RDONLY	0x0001	/* Open read-only.  */
+#define	O_WRONLY	0x0002	/* Open write-only.  */
+#define	O_RDWR		(O_RDONLY|O_WRONLY) /* Open for reading and writing. */
+#define	O_ACCMODE	O_RDWR	/* Mask for file access modes.  */
+
+#define O_LARGEFILE	0
+
+
+/* File name translation flags.  These are understood by io servers;
+   they can be passed in `dir_lookup', and consequently to `open',
+   `hurd_file_name_lookup', and `file_name_lookup'.  */
+
+#define	O_CREAT		0x0010	/* Create file if it doesn't exist.  */
+#define	O_EXCL		0x0020	/* Fail if file already exists.  */
+#ifdef __USE_GNU
+# define O_NOLINK	0x0040	/* No name mappings on final component.  */
+# define O_NOTRANS	0x0080	/* No translator on final component. */
+#endif
+
+#ifdef __USE_XOPEN2K8
+# define O_NOFOLLOW	0x00100000 /* Produce ENOENT if file is a symlink.  */
+# define O_DIRECTORY	0x00200000 /* Produce ENOTDIR if not a directory.  */
+#endif
+
+
+/* I/O operating modes.  These are understood by io servers; they can be
+   passed in `dir_lookup' and set or fetched with `io_*_openmodes'.
+   Consequently they can be passed to `open', `hurd_file_name_lookup',
+   `file_name_lookup', and `fcntl' with the F_SETFL command; and are
+   returned by `fcntl' with the F_GETFL command.  */
+
+#define	O_APPEND	0x0100	/* Writes always append to the file.  */
+#define O_ASYNC		0x0200	/* Send SIGIO to owner when data is ready.  */
+#define O_FSYNC		0x0400	/* Synchronous writes.  */
+#define O_SYNC		O_FSYNC
+#ifdef __USE_GNU
+# define O_NOATIME	0x0800	/* Don't set access time on read (owner).  */
+#endif
+#ifdef	__USE_MISC
+# define O_SHLOCK	0x00020000 /* Open with shared file lock.  */
+# define O_EXLOCK	0x00040000 /* Open with exclusive file lock.  */
+#endif
+
+/* These are lesser flavors of partial synchronization that are
+   implied by our one flag (O_FSYNC).  */
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+
+/* The name O_NONBLOCK is unfortunately overloaded; it is both a file name
+   translation flag and an I/O operating mode.  O_NDELAY is the deprecated
+   BSD name for the same flag, overloaded in the same way.
+
+   When used in `dir_lookup' (and consequently `open', `hurd_file_name_lookup',
+   or `file_name_lookup'), O_NONBLOCK says the open should return immediately
+   instead of blocking for any significant length of time (e.g., to wait
+   for carrier detect on a serial line).  It is also saved as an I/O
+   operating mode, and after open has the following meaning.
+
+   When used in `io_*_openmodes' (and consequently `fcntl' with the F_SETFL
+   command), the O_NONBLOCK flag means to do nonblocking i/o: any i/o
+   operation that would block for any significant length of time will instead
+   fail with EAGAIN.  */
+
+#define	O_NONBLOCK	0x0008	/* Non-blocking open or non-blocking I/O.  */
+#ifdef __USE_BSD
+# define O_NDELAY	O_NONBLOCK /* Deprecated.  */
+#endif
+
+
+#ifdef __USE_GNU
+/* Mask of bits which are understood by io servers.  */
+# define O_HURD		(0xffff | O_EXLOCK | O_SHLOCK)
+#endif
+
+
+/* Open-time action flags.  These are understood by `hurd_file_name_lookup'
+   and consequently by `open' and `file_name_lookup'.  They are not preserved
+   once the file has been opened.  */
+
+#define	O_TRUNC		0x00010000 /* Truncate file to zero length.  */
+#ifdef __USE_XOPEN2K8
+# define O_CLOEXEC	0x00400000 /* Set FD_CLOEXEC.  */
+#endif
+
+
+/* Controlling terminal flags.  These are understood only by `open',
+   and are not preserved once the file has been opened.  */
+
+#ifdef __USE_GNU
+# define O_IGNORE_CTTY	0x00080000 /* Don't do any ctty magic at all.  */
+#endif
+/* `open' never assigns a controlling terminal in GNU.  */
+#define	O_NOCTTY	0	/* Don't assign a controlling terminal.  */
+
+
+#ifdef __USE_BSD
+/* Bits in the file status flags returned by F_GETFL.  */
+# define FREAD		O_RDONLY
+# define FWRITE		O_WRONLY
+
+/* Traditional BSD names the O_* bits.  */
+# define FASYNC		O_ASYNC
+# define FCREAT		O_CREAT
+# define FEXCL		O_EXCL
+# define FTRUNC		O_TRUNC
+# define FNOCTTY	O_NOCTTY
+# define FFSYNC		O_FSYNC
+# define FSYNC		O_SYNC
+# define FAPPEND	O_APPEND
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif
+
+
+/* Values for the second argument to `fcntl'.  */
+#define	F_DUPFD	  	0	/* Duplicate file descriptor.  */
+#define	F_GETFD		1	/* Get file descriptor flags.  */
+#define	F_SETFD		2	/* Set file descriptor flags.  */
+#define	F_GETFL		3	/* Get file status flags.  */
+#define	F_SETFL		4	/* Set file status flags.  */
+#if defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K8
+# define F_GETOWN	5	/* Get owner (receiver of SIGIO).  */
+# define F_SETOWN	6	/* Set owner (receiver of SIGIO).  */
+#endif
+#ifdef __USE_FILE_OFFSET64
+# define	F_GETLK		F_GETLK64
+# define	F_SETLK		F_SETLK64
+# define	F_SETLKW	F_SETLKW64
+#else
+# define	F_GETLK		7	/* Get record locking info.  */
+# define	F_SETLK		8	/* Set record locking info (non-blocking).  */
+# define	F_SETLKW	9	/* Set record locking info (blocking).  */
+#endif
+#define	F_GETLK64	10	/* Get record locking info.  */
+#define	F_SETLK64	11	/* Set record locking info (non-blocking).  */
+#define	F_SETLKW64	12	/* Set record locking info (blocking).  */
+
+#ifdef __USE_XOPEN2K8
+# define F_DUPFD_CLOEXEC 1030	/* Duplicate, set FD_CLOEXEC on new one.  */
+#endif
+
+
+/* File descriptor flags used with F_GETFD and F_SETFD.  */
+#define	FD_CLOEXEC	1	/* Close on exec.  */
+
+
+#include <bits/types.h>
+
+/* The structure describing an advisory lock.  This is the type of the third
+   argument to `fcntl' for the F_GETLK, F_SETLK, and F_SETLKW requests.  */
+struct flock
+  {
+    int l_type;		/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    int l_type;		/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Values for the `l_type' field of a `struct flock'.  */
+#define	F_RDLCK	1	/* Read lock.  */
+#define	F_WRLCK	2	/* Write lock.  */
+#define	F_UNLCK	3	/* Remove lock.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
diff --git a/include/bits/fcntl2.h b/include/bits/fcntl2.h
new file mode 100644
index 0000000..4f13b10
--- /dev/null
+++ b/include/bits/fcntl2.h
@@ -0,0 +1,172 @@
+/* Checking macros for fcntl functions.
+   Copyright (C) 2007-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_FCNTL_H
+# error "Never include <bits/fcntl2.h> directly; use <fcntl.h> instead."
+#endif
+
+/* Check that calls to open and openat with O_CREAT set have an
+   appropriate third/fourth parameter.  */
+#ifndef __USE_FILE_OFFSET64
+extern int __open_2 (const char *__path, int __oflag) __nonnull ((1));
+extern int __REDIRECT (__open_alias, (const char *__path, int __oflag, ...),
+		       open) __nonnull ((1));
+#else
+extern int __REDIRECT (__open_2, (const char *__path, int __oflag),
+		       __open64_2) __nonnull ((1));
+extern int __REDIRECT (__open_alias, (const char *__path, int __oflag, ...),
+		       open64) __nonnull ((1));
+#endif
+__errordecl (__open_too_many_args,
+	     "open can be called either with 2 or 3 arguments, not more");
+__errordecl (__open_missing_mode,
+	     "open with O_CREAT in second argument needs 3 arguments");
+
+__fortify_function int
+open (const char *__path, int __oflag, ...)
+{
+  if (__va_arg_pack_len () > 1)
+    __open_too_many_args ();
+
+  if (__builtin_constant_p (__oflag))
+    {
+      if ((__oflag & O_CREAT) != 0 && __va_arg_pack_len () < 1)
+	{
+	  __open_missing_mode ();
+	  return __open_2 (__path, __oflag);
+	}
+      return __open_alias (__path, __oflag, __va_arg_pack ());
+    }
+
+  if (__va_arg_pack_len () < 1)
+    return __open_2 (__path, __oflag);
+
+  return __open_alias (__path, __oflag, __va_arg_pack ());
+}
+
+
+#ifdef __USE_LARGEFILE64
+extern int __open64_2 (const char *__path, int __oflag) __nonnull ((1));
+extern int __REDIRECT (__open64_alias, (const char *__path, int __oflag,
+					...), open64) __nonnull ((1));
+__errordecl (__open64_too_many_args,
+	     "open64 can be called either with 2 or 3 arguments, not more");
+__errordecl (__open64_missing_mode,
+	     "open64 with O_CREAT in second argument needs 3 arguments");
+
+__fortify_function int
+open64 (const char *__path, int __oflag, ...)
+{
+  if (__va_arg_pack_len () > 1)
+    __open64_too_many_args ();
+
+  if (__builtin_constant_p (__oflag))
+    {
+      if ((__oflag & O_CREAT) != 0 && __va_arg_pack_len () < 1)
+	{
+	  __open64_missing_mode ();
+	  return __open64_2 (__path, __oflag);
+	}
+      return __open64_alias (__path, __oflag, __va_arg_pack ());
+    }
+
+  if (__va_arg_pack_len () < 1)
+    return __open64_2 (__path, __oflag);
+
+  return __open64_alias (__path, __oflag, __va_arg_pack ());
+}
+#endif
+
+
+#ifdef __USE_ATFILE
+# ifndef __USE_FILE_OFFSET64
+extern int __openat_2 (int __fd, const char *__path, int __oflag)
+     __nonnull ((2));
+extern int __REDIRECT (__openat_alias, (int __fd, const char *__path,
+					int __oflag, ...), openat)
+     __nonnull ((2));
+# else
+extern int __REDIRECT (__openat_2, (int __fd, const char *__path,
+				    int __oflag), __openat64_2)
+     __nonnull ((2));
+extern int __REDIRECT (__openat_alias, (int __fd, const char *__path,
+					int __oflag, ...), openat64)
+     __nonnull ((2));
+# endif
+__errordecl (__openat_too_many_args,
+	     "openat can be called either with 3 or 4 arguments, not more");
+__errordecl (__openat_missing_mode,
+	     "openat with O_CREAT in third argument needs 4 arguments");
+
+__fortify_function int
+openat (int __fd, const char *__path, int __oflag, ...)
+{
+  if (__va_arg_pack_len () > 1)
+    __openat_too_many_args ();
+
+  if (__builtin_constant_p (__oflag))
+    {
+      if ((__oflag & O_CREAT) != 0 && __va_arg_pack_len () < 1)
+	{
+	  __openat_missing_mode ();
+	  return __openat_2 (__fd, __path, __oflag);
+	}
+      return __openat_alias (__fd, __path, __oflag, __va_arg_pack ());
+    }
+
+  if (__va_arg_pack_len () < 1)
+    return __openat_2 (__fd, __path, __oflag);
+
+  return __openat_alias (__fd, __path, __oflag, __va_arg_pack ());
+}
+
+
+# ifdef __USE_LARGEFILE64
+extern int __openat64_2 (int __fd, const char *__path, int __oflag)
+     __nonnull ((2));
+extern int __REDIRECT (__openat64_alias, (int __fd, const char *__path,
+					  int __oflag, ...), openat64)
+     __nonnull ((2));
+__errordecl (__openat64_too_many_args,
+	     "openat64 can be called either with 3 or 4 arguments, not more");
+__errordecl (__openat64_missing_mode,
+	     "openat64 with O_CREAT in third argument needs 4 arguments");
+
+__fortify_function int
+openat64 (int __fd, const char *__path, int __oflag, ...)
+{
+  if (__va_arg_pack_len () > 1)
+    __openat64_too_many_args ();
+
+  if (__builtin_constant_p (__oflag))
+    {
+      if ((__oflag & O_CREAT) != 0 && __va_arg_pack_len () < 1)
+	{
+	  __openat64_missing_mode ();
+	  return __openat64_2 (__fd, __path, __oflag);
+	}
+      return __openat64_alias (__fd, __path, __oflag, __va_arg_pack ());
+    }
+
+  if (__va_arg_pack_len () < 1)
+    return __openat64_2 (__fd, __path, __oflag);
+
+  return __openat64_alias (__fd, __path, __oflag, __va_arg_pack ());
+}
+# endif
+#endif
diff --git a/include/bits/fenv.h b/include/bits/fenv.h
new file mode 100644
index 0000000..d21b312
--- /dev/null
+++ b/include/bits/fenv.h
@@ -0,0 +1,150 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+/* Define bits representing the exception.  We use the bit positions
+   of the appropriate bits in the FPU control word.  */
+enum
+  {
+    FE_INVALID =
+#define FE_INVALID	0x01
+      FE_INVALID,
+    __FE_DENORM = 0x02,
+    FE_DIVBYZERO =
+#define FE_DIVBYZERO	0x04
+      FE_DIVBYZERO,
+    FE_OVERFLOW =
+#define FE_OVERFLOW	0x08
+      FE_OVERFLOW,
+    FE_UNDERFLOW =
+#define FE_UNDERFLOW	0x10
+      FE_UNDERFLOW,
+    FE_INEXACT =
+#define FE_INEXACT	0x20
+      FE_INEXACT
+  };
+
+#define FE_ALL_EXCEPT \
+	(FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+/* The ix87 FPU supports all of the four defined rounding modes.  We
+   use again the bit positions in the FPU control word as the values
+   for the appropriate macros.  */
+enum
+  {
+    FE_TONEAREST =
+#define FE_TONEAREST	0
+      FE_TONEAREST,
+    FE_DOWNWARD =
+#define FE_DOWNWARD	0x400
+      FE_DOWNWARD,
+    FE_UPWARD =
+#define FE_UPWARD	0x800
+      FE_UPWARD,
+    FE_TOWARDZERO =
+#define FE_TOWARDZERO	0xc00
+      FE_TOWARDZERO
+  };
+
+
+/* Type representing exception flags.  */
+typedef unsigned short int fexcept_t;
+
+
+/* Type representing floating-point environment.  This structure
+   corresponds to the layout of the block written by the `fstenv'
+   instruction and has additional fields for the contents of the MXCSR
+   register as written by the `stmxcsr' instruction.  */
+typedef struct
+  {
+    unsigned short int __control_word;
+    unsigned short int __glibc_reserved1;
+    unsigned short int __status_word;
+    unsigned short int __glibc_reserved2;
+    unsigned short int __tags;
+    unsigned short int __glibc_reserved3;
+    unsigned int __eip;
+    unsigned short int __cs_selector;
+    unsigned int __opcode:11;
+    unsigned int __glibc_reserved4:5;
+    unsigned int __data_offset;
+    unsigned short int __data_selector;
+    unsigned short int __glibc_reserved5;
+#ifdef __x86_64__
+    unsigned int __mxcsr;
+#endif
+  }
+fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((const fenv_t *) -1)
+
+#ifdef __USE_GNU
+/* Floating-point environment where none of the exception is masked.  */
+# define FE_NOMASK_ENV	((const fenv_t *) -2)
+#endif
+
+
+#ifdef __USE_EXTERN_INLINES
+__BEGIN_DECLS
+
+/* Optimized versions.  */
+extern int __REDIRECT_NTH (__feraiseexcept_renamed, (int), feraiseexcept);
+__extern_inline int
+__NTH (feraiseexcept (int __excepts))
+{
+  if (__builtin_constant_p (__excepts)
+      && (__excepts & ~(FE_INVALID | FE_DIVBYZERO)) == 0)
+    {
+      if ((FE_INVALID & __excepts) != 0)
+	{
+	  /* One example of an invalid operation is 0.0 / 0.0.  */
+	  float __f = 0.0;
+
+# ifdef __SSE_MATH__
+	  __asm__ __volatile__ ("divss %0, %0 " : : "x" (__f));
+# else
+	  __asm__ __volatile__ ("fdiv %%st, %%st(0); fwait"
+				: "=t" (__f) : "0" (__f));
+# endif
+	  (void) &__f;
+	}
+      if ((FE_DIVBYZERO & __excepts) != 0)
+	{
+	  float __f = 1.0;
+	  float __g = 0.0;
+
+# ifdef __SSE_MATH__
+	  __asm__ __volatile__ ("divss %1, %0" : : "x" (__f), "x" (__g));
+# else
+	  __asm__ __volatile__ ("fdivp %%st, %%st(1); fwait"
+				: "=t" (__f) : "0" (__f), "u" (__g) : "st(1)");
+# endif
+	  (void) &__f;
+	}
+
+      return 0;
+    }
+
+  return __feraiseexcept_renamed (__excepts);
+}
+
+__END_DECLS
+#endif
diff --git a/include/bits/fenvinline.h b/include/bits/fenvinline.h
new file mode 100644
index 0000000..42f77b5
--- /dev/null
+++ b/include/bits/fenvinline.h
@@ -0,0 +1,8 @@
+/* This file provides inline versions of floating-pint environment
+   handling functions.  If there were any.  */
+
+#ifndef __NO_MATH_INLINES
+
+/* Here is where the code would go.  */
+
+#endif
diff --git a/include/bits/huge_val.h b/include/bits/huge_val.h
new file mode 100644
index 0000000..111922a
--- /dev/null
+++ b/include/bits/huge_val.h
@@ -0,0 +1,53 @@
+/* `HUGE_VAL' constant for IEEE 754 machines (where it is infinity).
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_val.h> directly; include <math.h> instead."
+#endif
+
+/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VAL	(__builtin_huge_val())
+#elif __GNUC_PREREQ(2,96)
+# define HUGE_VAL	(__extension__ 0x1.0p2047)
+#elif defined __GNUC__
+
+# define HUGE_VAL \
+  (__extension__							      \
+   ((union { unsigned __l __attribute__((__mode__(__DI__))); double __d; })   \
+    { __l: 0x7ff0000000000000ULL }).__d)
+
+#else /* not GCC */
+
+# include <endian.h>
+
+typedef union { unsigned char __c[8]; double __d; } __huge_val_t;
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __HUGE_VAL_bytes	{ 0x7f, 0xf0, 0, 0, 0, 0, 0, 0 }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __HUGE_VAL_bytes	{ 0, 0, 0, 0, 0, 0, 0xf0, 0x7f }
+# endif
+
+static __huge_val_t __huge_val = { __HUGE_VAL_bytes };
+# define HUGE_VAL	(__huge_val.__d)
+
+#endif	/* GCC.  */
diff --git a/include/bits/huge_valf.h b/include/bits/huge_valf.h
new file mode 100644
index 0000000..a8025a9
--- /dev/null
+++ b/include/bits/huge_valf.h
@@ -0,0 +1,51 @@
+/* `HUGE_VALF' constant for IEEE 754 machines (where it is infinity).
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_valf.h> directly; include <math.h> instead."
+#endif
+
+/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VALF	(__builtin_huge_valf())
+#elif __GNUC_PREREQ(2,96)
+# define HUGE_VALF	(__extension__ 0x1.0p255f)
+#elif defined __GNUC__
+
+#   define HUGE_VALF \
+  (__extension__							      \
+   ((union { unsigned __l __attribute__((__mode__(__SI__))); float __d; })    \
+    { __l: 0x7f800000UL }).__d)
+
+#else /* not GCC */
+
+typedef union { unsigned char __c[4]; float __f; } __huge_valf_t;
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __HUGE_VALF_bytes	{ 0x7f, 0x80, 0, 0 }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __HUGE_VALF_bytes	{ 0, 0, 0x80, 0x7f }
+# endif
+
+static __huge_valf_t __huge_valf = { __HUGE_VALF_bytes };
+# define HUGE_VALF	(__huge_valf.__f)
+
+#endif	/* GCC.  */
diff --git a/include/bits/huge_vall.h b/include/bits/huge_vall.h
new file mode 100644
index 0000000..ec77810
--- /dev/null
+++ b/include/bits/huge_vall.h
@@ -0,0 +1,41 @@
+/* `HUGE_VALL' constant for ix86 (where it is infinity).
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_vall.h> directly; include <math.h> instead."
+#endif
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VALL	(__builtin_huge_vall())
+#elif __GNUC_PREREQ(2,96)
+# define HUGE_VALL	(__extension__ 0x1.0p32767L)
+#else
+
+# define __HUGE_VALL_bytes	{ 0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0 }
+
+# define __huge_vall_t	union { unsigned char __c[12]; long double __ld; }
+# ifdef __GNUC__
+#  define HUGE_VALL	(__extension__ \
+			 ((__huge_vall_t) { __c: __HUGE_VALL_bytes }).__ld)
+# else	/* Not GCC.  */
+static __huge_vall_t __huge_vall = { __HUGE_VALL_bytes };
+#  define HUGE_VALL	(__huge_vall.__ld)
+#  endif /* GCC.  */
+
+#endif /* GCC 2.95 */
diff --git a/include/bits/hwcap.h b/include/bits/hwcap.h
new file mode 100644
index 0000000..16a26a4
--- /dev/null
+++ b/include/bits/hwcap.h
@@ -0,0 +1,23 @@
+/* Defines for bits in AT_HWCAP.
+   Copyright (C) 2012-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_AUXV_H
+# error "Never include <bits/hwcap.h> directly; use <sys/auxv.h> instead."
+#endif
+
+/* No bits defined for this architecture.  */
diff --git a/include/bits/in.h b/include/bits/in.h
new file mode 100644
index 0000000..11d858a
--- /dev/null
+++ b/include/bits/in.h
@@ -0,0 +1,96 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Generic version.  */
+
+#ifndef _NETINET_IN_H
+# error "Never use <bits/in.h> directly; include <netinet/in.h> instead."
+#endif
+
+/* To select the IP level.  */
+#define SOL_IP		0
+
+/* Options for use with `getsockopt' and `setsockopt' at the IP level.
+   The first word in the comment at the right is the data type used;
+   "bool" means a boolean value stored in an `int'.  */
+#define	IP_OPTIONS	1	/* ip_opts; IP per-packet options.  */
+#define	IP_HDRINCL	2	/* int; Header is included with data.  */
+#define	IP_TOS		3	/* int; IP type of service and precedence.  */
+#define	IP_TTL		4	/* int; IP time to live.  */
+#define	IP_RECVOPTS	5	/* bool; Receive all IP options w/datagram.  */
+#define	IP_RECVRETOPTS	6	/* bool; Receive IP options for response.  */
+#define	IP_RECVDSTADDR	7	/* bool; Receive IP dst addr w/datagram.  */
+#define	IP_RETOPTS	8	/* ip_opts; Set/get IP per-packet options.  */
+#define IP_MULTICAST_IF 9	/* in_addr; set/get IP multicast i/f */
+#define IP_MULTICAST_TTL 10	/* u_char; set/get IP multicast ttl */
+#define IP_MULTICAST_LOOP 11	/* i_char; set/get IP multicast loopback */
+#define IP_ADD_MEMBERSHIP 12	/* ip_mreq; add an IP group membership */
+#define IP_DROP_MEMBERSHIP 13	/* ip_mreq; drop an IP group membership */
+
+/* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
+   The `ip_dst' field is used for the first-hop gateway when using a
+   source route (this gets put into the header proper).  */
+struct ip_opts
+  {
+    struct in_addr ip_dst;	/* First hop; zero without source route.  */
+    char ip_opts[40];		/* Actually variable in size.  */
+  };
+
+/* Socket-level values for IPv6.  */
+#define SOL_IPV6		41
+#define SOL_ICMPV6		58
+
+/* IPV6 socket options.  */
+#define IPV6_ADDRFORM		1
+#define IPV6_PKTINFO		2
+#define IPV6_HOPOPTS		3
+#define IPV6_DSTOPTS		4
+#define IPV6_RTHDR		5
+#define IPV6_PKTOPTIONS		6
+#define IPV6_CHECKSUM		7
+#define IPV6_HOPLIMIT		8
+
+#define IPV6_RXINFO		IPV6_PKTINFO
+#define IPV6_TXINFO		IPV6_PKTINFO
+#define SCM_SRCINFO		IPV6_PKTINFO
+#define SCM_SRCRT		IPV6_RXSRCRT
+
+#define IPV6_UNICAST_HOPS	16
+#define IPV6_MULTICAST_IF	17
+#define IPV6_MULTICAST_HOPS	18
+#define IPV6_MULTICAST_LOOP	19
+#define IPV6_JOIN_GROUP		20
+#define IPV6_LEAVE_GROUP	21
+#define IPV6_ROUTER_ALERT      22
+#define IPV6_MTU_DISCOVER      23
+#define IPV6_MTU               24
+#define IPV6_RECVERR           25
+#define IPV6_V6ONLY            26
+#define IPV6_JOIN_ANYCAST      27
+#define IPV6_LEAVE_ANYCAST     28
+
+/* Obsolete synonyms for the above.  */
+#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+#define IPV6_RXHOPOPTS		IPV6_HOPOPTS
+#define IPV6_RXDSTOPTS		IPV6_DSTOPTS
+
+/* Routing header options for IPv6.  */
+#define IPV6_RTHDR_LOOSE	0	/* Hop doesn't need to be neighbour. */
+#define IPV6_RTHDR_STRICT	1	/* Hop must be a neighbour.  */
+
+#define IPV6_RTHDR_TYPE_0	0	/* IPv6 Routing header type 0.  */
diff --git a/include/bits/inf.h b/include/bits/inf.h
new file mode 100644
index 0000000..07d080e
--- /dev/null
+++ b/include/bits/inf.h
@@ -0,0 +1,29 @@
+/* `INFINITY' constant for IEEE 754 machines.
+   Copyright (C) 2004-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/inf.h> directly; include <math.h> instead."
+#endif
+
+/* IEEE positive infinity.  */
+
+#if __GNUC_PREREQ(3,3)
+# define INFINITY	(__builtin_inff())
+#else
+# define INFINITY	HUGE_VALF
+#endif
diff --git a/include/bits/ioctl-types.h b/include/bits/ioctl-types.h
new file mode 100644
index 0000000..288f38c
--- /dev/null
+++ b/include/bits/ioctl-types.h
@@ -0,0 +1,113 @@
+/* Structure types for pre-termios terminal ioctls.  Generic Unix version.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_IOCTL_H
+# error "Never use <bits/ioctl-types.h> directly; include <sys/ioctl.h> instead."
+#endif
+
+#if defined TIOCGETC || defined TIOCSETC
+/* Type of ARG for TIOCGETC and TIOCSETC requests.  */
+struct tchars
+{
+  char t_intrc;			/* Interrupt character.  */
+  char t_quitc;			/* Quit character.  */
+  char t_startc;		/* Start-output character.  */
+  char t_stopc;			/* Stop-output character.  */
+  char t_eofc;			/* End-of-file character.  */
+  char t_brkc;			/* Input delimiter character.  */
+};
+
+#define	_IOT_tchars	/* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (char), 6, 0, 0, 0, 0)
+#endif
+
+#if defined TIOCGLTC || defined TIOCSLTC
+/* Type of ARG for TIOCGLTC and TIOCSLTC requests.  */
+struct ltchars
+{
+  char t_suspc;			/* Suspend character.  */
+  char t_dsuspc;		/* Delayed suspend character.  */
+  char t_rprntc;		/* Reprint-line character.  */
+  char t_flushc;		/* Flush-output character.  */
+  char t_werasc;		/* Word-erase character.  */
+  char t_lnextc;		/* Literal-next character.  */
+};
+
+#define	_IOT_ltchars	/* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (char), 6, 0, 0, 0, 0)
+#endif
+
+/* Type of ARG for TIOCGETP and TIOCSETP requests (and gtty and stty).  */
+struct sgttyb
+{
+  char sg_ispeed;		/* Input speed.  */
+  char sg_ospeed;		/* Output speed.  */
+  char sg_erase;		/* Erase character.  */
+  char sg_kill;			/* Kill character.  */
+  short int sg_flags;		/* Mode flags.  */
+};
+
+#define	_IOT_sgttyb	/* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (char), 4, _IOTS (short int), 1, 0, 0)
+
+#if defined TIOCGWINSZ || defined TIOCSWINSZ
+/* Type of ARG for TIOCGWINSZ and TIOCSWINSZ requests.  */
+struct winsize
+{
+  unsigned short int ws_row;	/* Rows, in characters.  */
+  unsigned short int ws_col;	/* Columns, in characters.  */
+
+  /* These are not actually used.  */
+  unsigned short int ws_xpixel;	/* Horizontal pixels.  */
+  unsigned short int ws_ypixel;	/* Vertical pixels.  */
+};
+
+#define	_IOT_winsize	/* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (unsigned short int), 4, 0, 0, 0, 0)
+#endif
+
+#if defined TIOCGSIZE || defined TIOCSSIZE
+/* The BSD-style ioctl constructor macros use `sizeof', which can't be used
+   in a preprocessor conditional.  Since the commands are always unique
+   regardless of the size bits, we can safely define away `sizeof' for the
+   purpose of the conditional.  */
+#  define sizeof(type) 0
+#  if defined TIOCGWINSZ && TIOCGSIZE == TIOCGWINSZ
+/* Many systems that have TIOCGWINSZ define TIOCGSIZE for source
+   compatibility with Sun; they define `struct ttysize' to have identical
+   layout as `struct winsize' and #define TIOCGSIZE to be TIOCGWINSZ
+   (likewise TIOCSSIZE and TIOCSWINSZ).  */
+struct ttysize
+{
+  unsigned short int ts_lines;
+  unsigned short int ts_cols;
+  unsigned short int ts_xxx;
+  unsigned short int ts_yyy;
+};
+#define	_IOT_ttysize	_IOT_winsize
+#  else
+/* Suns use a different layout for `struct ttysize', and TIOCGSIZE and
+   TIOCGWINSZ are separate commands that do the same thing with different
+   structures (likewise TIOCSSIZE and TIOCSWINSZ).  */
+struct ttysize
+{
+  int ts_lines, ts_cols;	/* Lines and columns, in characters.  */
+};
+#  endif
+#  undef sizeof			/* See above.  */
+#endif
diff --git a/include/bits/ioctls.h b/include/bits/ioctls.h
new file mode 100644
index 0000000..efa7bdf
--- /dev/null
+++ b/include/bits/ioctls.h
@@ -0,0 +1,432 @@
+/* Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef __BITS_IOCTLS_H
+#define __BITS_IOCTLS_H	1
+
+#if !defined _HURD_IOCTL_H && !defined _SYS_IOCTL_H
+# error "Never use <bits/ioctls.h> directly; include <hurd/ioctl.h> instead."
+#endif
+
+/* These macros are also defined in <bits/termios.h> (with numerically
+   identical values) but this serves to shut up cpp's complaining. */
+
+#ifdef NL0
+# undef NL0
+#endif
+#ifdef NL1
+# undef NL1
+#endif
+#ifdef TAB0
+# undef TAB0
+#endif
+#ifdef TAB1
+# undef TAB1
+#endif
+#ifdef TAB2
+# undef TAB2
+#endif
+#ifdef CR0
+# undef CR0
+#endif
+#ifdef CR1
+# undef CR1
+#endif
+#ifdef CR2
+# undef CR2
+#endif
+#ifdef CR3
+# undef CR3
+#endif
+#ifdef FF0
+# undef FF0
+#endif
+#ifdef FF1
+# undef FF1
+#endif
+#ifdef BS0
+# undef BS0
+#endif
+#ifdef BS1
+# undef BS1
+#endif
+#ifdef MDMBUF
+# undef MDMBUF
+#endif
+#ifdef ECHO
+# undef ECHO
+#endif
+#ifdef TOSTOP
+# undef TOSTOP
+#endif
+#ifdef FLUSHO
+# undef FLUSHO
+#endif
+#ifdef PENDIN
+# undef PENDIN
+#endif
+#ifdef NOFLSH
+# undef NOFLSH
+#endif
+
+/* Hurd ioctl request are made up of several fields:
+
+    10987654321098765432109876543210
+    IOt0t1t2cc0c0cc1c1cc2ggggccccccc
+
+     bits [31,30]: inout direction (enum __ioctl_dir)
+     bits [29,11]: type encoding as follows; zero count indicates omitted datum
+	  [29,28]: datum #0 type (enum __ioctl_datum)
+	  [27,26]: datum #1 type (enum __ioctl_datum)
+	  [24,25]: datum #2 type (enum __ioctl_datum)
+	  [23,19]: datum #0 count	[0,31]
+	  [18,14]: datum #1 count [0,31]
+	  [13,11]: datum #2 count [0,3]
+     bits [07,10]: group (letter - 'f': ['f','v'])
+     bits [00,06]: command	[0,127]
+
+   The following macros construct and dissect these fields.  */
+
+enum __ioctl_dir
+  {
+    IOC_VOID = 0,		/* No parameters.  */
+    IOC_OUT = 1,		/* Data is written into the user's buffer.  */
+    IOC_IN = 2,			/* Data is read from the user's buffer.  */
+    IOC_INOUT = (IOC_IN|IOC_OUT)
+  };
+
+enum __ioctl_datum { IOC_8, IOC_16, IOC_32, IOC_64 };
+
+/* Construct an ioctl from constructed type plus other fields.  */
+#define	_IOC(inout, group, num, type) \
+  ((num) | ((((group) - 'f') | ((type) | (inout) << 19) << 4) << 7))
+
+/* Dissect an ioctl into its component fields.  */
+#define _IOC_INOUT(request)	(((unsigned int) (request) >> 30) & IOC_INOUT)
+#define _IOC_GROUP(request)	('f' + (((unsigned int) (request) >> 7) & 0xf))
+#define _IOC_COMMAND(request)	((unsigned int) (request) & 0x7f)
+#define _IOC_TYPE(request)	(((unsigned int) (request) >> 11) & 0x7ffff)
+#define _IOC_NOTYPE(request)	((unsigned int) (request) & 0x3ff)
+
+/* Construct a type information field from
+   the broken-out type and count fields.  */
+#define	_IOT(t0, c0, t1, c1, t2, c2) \
+  ((c2) | (((c1) | ((c0) | ((t2) | ((t1) | (t0) << 2) << 2) << 5) << 5) << 3))
+
+/* Dissect a type information field into the type and count fields.  */
+#define	_IOT_TYPE0(type)	(((unsigned int) (type) >> 17) & 3)
+#define	_IOT_TYPE1(type)	(((unsigned int) (type) >> 15) & 3)
+#define	_IOT_TYPE2(type)	(((unsigned int) (type) >> 13) & 3)
+#define	_IOT_COUNT0(type)	(((unsigned int) (type) >> 8) & 0x1f)
+#define	_IOT_COUNT1(type)	(((unsigned int) (type) >> 3) & 0x1f)
+#define	_IOT_COUNT2(type)	(((unsigned int) (type) >> 0) & 7)
+
+/* Construct an ioctl from all the broken-out fields.  */
+#define	_IOCT(inout, group, num, t0, c0, t1, c1, t2, c2)		      \
+  _IOC ((inout), (group), (num), _IOT ((t0), (c0), (t1), (c1), (t2), (c2)))
+
+/* Construct an individual type field for TYPE.  */
+#define _IOTS(type)	\
+  (sizeof (type) == 8 ? IOC_64 : (enum __ioctl_datum) (sizeof (type) >> 1))
+
+/* Construct a type information field for
+   a single argument of the scalar TYPE.  */
+#define	_IOT_SIMPLE(type)	_IOT (_IOTS (type), 1, 0, 0, 0, 0)
+
+/* Basic C types.  */
+#define	_IOT__IOTBASE_char	_IOT_SIMPLE (char)
+#define	_IOT__IOTBASE_short	_IOT_SIMPLE (short)
+#define	_IOT__IOTBASE_int	_IOT_SIMPLE (int)
+#define	_IOT__IOTBASE_long	_IOT_SIMPLE (long)
+#define	_IOT_char		_IOT_SIMPLE (char)
+#define	_IOT_short		_IOT_SIMPLE (short)
+#define	_IOT_int		_IOT_SIMPLE (int)
+#define	_IOT_long		_IOT_SIMPLE (long)
+
+#define	_IOT__IOTBASE_int8_t	_IOT_SIMPLE (int8_t)
+#define	_IOT__IOTBASE_uint8_t	_IOT_SIMPLE (uint8_t)
+#define	_IOT__IOTBASE_int16_t	_IOT_SIMPLE (int16_t)
+#define	_IOT__IOTBASE_uint16_t	_IOT_SIMPLE (uint16_t)
+#define	_IOT__IOTBASE_int32_t	_IOT_SIMPLE (int32_t)
+#define	_IOT__IOTBASE_uint32_t	_IOT_SIMPLE (uint32_t)
+#define	_IOT__IOTBASE_int64_t	_IOT_SIMPLE (int64_t)
+#define	_IOT__IOTBASE_uint64_t	_IOT_SIMPLE (uint64_t)
+
+#define	_IOT__IOTBASE_size_t	_IOT_SIMPLE (size_t)
+#define	_IOT__IOTBASE_ssize_t	_IOT_SIMPLE (ssize_t)
+
+
+/* Standard flavors of ioctls.
+   _IOT_foobar is defined either in this file,
+   or where struct foobar is defined.  */
+#define	_IO(g, n)	_IOC (IOC_VOID, (g), (n), 0)
+#define	_IOIW(g, n, t)	_IOC (IOC_VOID, (g), (n), _IOC_ENCODE_TYPE (t))
+#define	_IOR(g, n, t)	_IOC (IOC_OUT, (g), (n), _IOC_ENCODE_TYPE (t))
+#define	_IOW(g, n, t)	_IOC (IOC_IN, (g), (n), _IOC_ENCODE_TYPE (t))
+#define	_IOWR(g, n, t)	_IOC (IOC_INOUT, (g), (n), _IOC_ENCODE_TYPE (t))
+
+/* These macros do some preprocessor gymnastics to turn a TYPESPEC of
+   `struct foobar' into the identifier `_IOT_foobar', which is generally
+   defined using `_IOT' (above) in whatever file defines `struct foobar'.
+   For a TYPESPEC that does not begin with `struct' produces a different
+   identifier: `int' produces `_IOT__IOTBASE_int'.  These identifiers
+   are defined for the basic C types above.  */
+#define _IOC_ENCODE_TYPE(typespec)	_IOC_ENCODE_TYPE_1(_IOTBASE_##typespec)
+#define _IOTBASE_struct
+#define _IOC_ENCODE_TYPE_1(typespec)	_IOC_ENCODE_TYPE_2(typespec)
+#define _IOC_ENCODE_TYPE_2(typespec)	_IOT_##typespec
+
+/* Also, ignore signedness.  */
+#define	_IOTBASE_unsigned
+#define	_IOTBASE_signed
+
+
+/* ioctls verbatim from 4.4 <sys/ioctl.h>.  */
+
+#define	TIOCMODG	_IOR('t', 3, int)	/* get modem control state */
+#define	TIOCMODS	_IOW('t', 4, int)	/* set modem control state */
+#define		TIOCM_LE	0001		/* line enable */
+#define		TIOCM_DTR	0002		/* data terminal ready */
+#define		TIOCM_RTS	0004		/* request to send */
+#define		TIOCM_ST	0010		/* secondary transmit */
+#define		TIOCM_SR	0020		/* secondary receive */
+#define		TIOCM_CTS	0040		/* clear to send */
+#define		TIOCM_CAR	0100		/* carrier detect */
+#define		TIOCM_CD	TIOCM_CAR
+#define		TIOCM_RNG	0200		/* ring */
+#define		TIOCM_RI	TIOCM_RNG
+#define		TIOCM_DSR	0400		/* data set ready */
+						/* 8-10 compat */
+#define	TIOCEXCL	_IO('t', 13)		/* set exclusive use of tty */
+#define	TIOCNXCL	_IO('t', 14)		/* reset exclusive use of tty */
+						/* 15 unused */
+#define	TIOCFLUSH	_IOW('t', 16, int)	/* flush buffers */
+						/* 17-18 compat */
+#define	TIOCGETA	_IOR('t', 19, struct termios) /* get termios struct */
+#define	TIOCSETA	_IOW('t', 20, struct termios) /* set termios struct */
+#define	TIOCSETAW	_IOW('t', 21, struct termios) /* drain output, set */
+#define	TIOCSETAF	_IOW('t', 22, struct termios) /* drn out, fls in, set */
+#define	TIOCGETD	_IOR('t', 26, int)	/* get line discipline */
+#define	TIOCSETD	_IOW('t', 27, int)	/* set line discipline */
+						/* 127-124 compat */
+#define	TIOCSBRK	_IO('t', 123)		/* set break bit */
+#define	TIOCCBRK	_IO('t', 122)		/* clear break bit */
+#define	TIOCSDTR	_IO('t', 121)		/* set data terminal ready */
+#define	TIOCCDTR	_IO('t', 120)		/* clear data terminal ready */
+#define	TIOCGPGRP	_IOR('t', 119, int)	/* get pgrp of tty */
+#define	TIOCSPGRP	_IOW('t', 118, int)	/* set pgrp of tty */
+						/* 117-116 compat */
+#define	TIOCOUTQ	_IOR('t', 115, int)	/* output queue size */
+#define	TIOCSTI		_IOW('t', 114, char)	/* simulate terminal input */
+#define	TIOCNOTTY	_IO('t', 113)		/* void tty association */
+#define	TIOCPKT		_IOW('t', 112, int)	/* pty: set/clear packet mode */
+#define		TIOCPKT_DATA		0x00	/* data packet */
+#define		TIOCPKT_FLUSHREAD	0x01	/* flush packet */
+#define		TIOCPKT_FLUSHWRITE	0x02	/* flush packet */
+#define		TIOCPKT_STOP		0x04	/* stop output */
+#define		TIOCPKT_START		0x08	/* start output */
+#define		TIOCPKT_NOSTOP		0x10	/* no more ^S, ^Q */
+#define		TIOCPKT_DOSTOP		0x20	/* now do ^S ^Q */
+#define		TIOCPKT_IOCTL		0x40	/* state change of pty driver */
+#define	TIOCSTOP	_IO('t', 111)		/* stop output, like ^S */
+#define	TIOCSTART	_IO('t', 110)		/* start output, like ^Q */
+#define	TIOCMSET	_IOW('t', 109, int)	/* set all modem bits */
+#define	TIOCMBIS	_IOW('t', 108, int)	/* bis modem bits */
+#define	TIOCMBIC	_IOW('t', 107, int)	/* bic modem bits */
+#define	TIOCMGET	_IOR('t', 106, int)	/* get all modem bits */
+#define	TIOCREMOTE	_IOW('t', 105, int)	/* remote input editing */
+#define	TIOCGWINSZ	_IOR('t', 104, struct winsize)	/* get window size */
+#define	TIOCSWINSZ	_IOW('t', 103, struct winsize)	/* set window size */
+#define	TIOCUCNTL	_IOW('t', 102, int)	/* pty: set/clr usr cntl mode */
+#define		UIOCCMD(n)	_IO('u', n)		/* usr cntl op "n" */
+#define	TIOCCONS	_IOW('t', 98, int)		/* become virtual console */
+#define	TIOCSCTTY	_IO('t', 97)		/* become controlling tty */
+#define	TIOCEXT		_IOW('t', 96, int)	/* pty: external processing */
+#define	TIOCSIG		_IO('t', 95)		/* pty: generate signal */
+#define TIOCDRAIN	_IO('t', 94)		/* wait till output drained */
+
+#define TTYDISC		0		/* termios tty line discipline */
+#define	TABLDISC	3		/* tablet discipline */
+#define	SLIPDISC	4		/* serial IP discipline */
+
+
+#define	FIOCLEX		_IO('f', 1)		/* set close on exec on fd */
+#define	FIONCLEX	_IO('f', 2)		/* remove close on exec */
+#define	FIONREAD	_IOR('f', 127, int)	/* get # bytes to read */
+#define	FIONBIO		_IOW('f', 126, int)	/* set/clear non-blocking i/o */
+#define	FIOASYNC	_IOW('f', 125, int)	/* set/clear async i/o */
+#define	FIOSETOWN	_IOW('f', 124, int)	/* set owner */
+#define	FIOGETOWN	_IOR('f', 123, int)	/* get owner */
+
+/* socket i/o controls */
+#define	SIOCSHIWAT	_IOW('s',  0, int)		/* set high watermark */
+#define	SIOCGHIWAT	_IOR('s',  1, int)		/* get high watermark */
+#define	SIOCSLOWAT	_IOW('s',  2, int)		/* set low watermark */
+#define	SIOCGLOWAT	_IOR('s',  3, int)		/* get low watermark */
+#define	SIOCATMARK	_IOR('s',  7, int)		/* at oob mark? */
+#define	SIOCSPGRP	_IOW('s',  8, int)		/* set process group */
+#define	SIOCGPGRP	_IOR('s',  9, int)		/* get process group */
+
+#define	SIOCADDRT	_IOW('r', 10, struct ortentry)	/* add route */
+#define	SIOCDELRT	_IOW('r', 11, struct ortentry)	/* delete route */
+
+#define	SIOCSIFADDR	_IOW('i', 12, struct ifreq)	/* set ifnet address */
+#define	OSIOCGIFADDR	_IOWR('i',13, struct ifreq)	/* get ifnet address */
+#define	SIOCGIFADDR	_IOWR('i',33, struct ifreq)	/* get ifnet address */
+#define	SIOCGIFHWADDR	_IOWR('i',39, struct ifreq)	/* get hwaddress */
+#define	SIOCSIFDSTADDR	_IOW('i', 14, struct ifreq)	/* set p-p address */
+#define	OSIOCGIFDSTADDR	_IOWR('i',15, struct ifreq)	/* get p-p address */
+#define	SIOCGIFDSTADDR	_IOWR('i',34, struct ifreq)	/* get p-p address */
+#define	SIOCSIFFLAGS	_IOW('i', 16, struct ifreq_short)/* set ifnet flags */
+#define	SIOCGIFFLAGS	_IOWR('i',17, struct ifreq_short)/* get ifnet flags */
+#define	OSIOCGIFBRDADDR	_IOWR('i',18, struct ifreq)	/* get broadcast addr */
+#define	SIOCGIFBRDADDR	_IOWR('i',35, struct ifreq)	/* get broadcast addr */
+#define	SIOCSIFBRDADDR	_IOW('i',19, struct ifreq)	/* set broadcast addr */
+#define	OSIOCGIFCONF	_IOWR('i',20, struct ifconf)	/* get ifnet list */
+#define	SIOCGIFCONF	_IOWR('i',36, struct ifconf)	/* get ifnet list */
+#define	OSIOCGIFNETMASK	_IOWR('i',21, struct ifreq)	/* get net addr mask */
+#define	SIOCGIFNETMASK	_IOWR('i',37, struct ifreq)	/* get net addr mask */
+#define	SIOCSIFNETMASK	_IOW('i',22, struct ifreq)	/* set net addr mask */
+#define	SIOCGIFMETRIC	_IOWR('i',23, struct ifreq_int)	/* get IF metric */
+#define	SIOCSIFMETRIC	_IOW('i',24, struct ifreq_int)	/* set IF metric */
+#define	SIOCDIFADDR	_IOW('i',25, struct ifreq)	/* delete IF addr */
+#define	SIOCAIFADDR	_IOW('i',26, struct ifaliasreq)	/* add/chg IF alias */
+
+#define	SIOCSARP	_IOW('i', 30, struct arpreq)	/* set arp entry */
+#define	OSIOCGARP	_IOWR('i',31, struct arpreq)	/* get arp entry */
+#define	SIOCGARP	_IOWR('i',38, struct arpreq)	/* get arp entry */
+#define	SIOCDARP	_IOW('i', 32, struct arpreq)	/* delete arp entry */
+
+#define SIOCGIFMTU	_IOWR('i', 51, struct ifreq_int)/* get IF mtu */
+#define SIOCSIFMTU	_IOW('i', 52, struct ifreq_int)	/* set IF mtu */
+
+#define SIOCGIFINDEX	_IOWR('i', 90, struct ifreq_int)/* get IF index */
+#define SIOCGIFNAME	_IOWR('i', 91, struct ifreq_int)/* set IF name */
+
+
+/* Compatibility with 4.3 BSD terminal driver.
+   From 4.4 <sys/ioctl_compat.h>.  */
+
+#ifdef USE_OLD_TTY
+# undef  TIOCGETD
+# define TIOCGETD	_IOR('t', 0, int)	/* get line discipline */
+# undef  TIOCSETD
+# define TIOCSETD	_IOW('t', 1, int)	/* set line discipline */
+#else
+# define OTIOCGETD	_IOR('t', 0, int)	/* get line discipline */
+# define OTIOCSETD	_IOW('t', 1, int)	/* set line discipline */
+#endif
+#define	TIOCHPCL	_IO('t', 2)		/* hang up on last close */
+#define	TIOCGETP	_IOR('t', 8,struct sgttyb)/* get parameters -- gtty */
+#define	TIOCSETP	_IOW('t', 9,struct sgttyb)/* set parameters -- stty */
+#define	TIOCSETN	_IOW('t',10,struct sgttyb)/* as above, but no flushtty*/
+#define	TIOCSETC	_IOW('t',17,struct tchars)/* set special characters */
+#define	TIOCGETC	_IOR('t',18,struct tchars)/* get special characters */
+#define		TANDEM		0x00000001	/* send stopc on out q full */
+#define		CBREAK		0x00000002	/* half-cooked mode */
+#define		LCASE		0x00000004	/* simulate lower case */
+#define		ECHO		0x00000008	/* echo input */
+#define		CRMOD		0x00000010	/* map \r to \r\n on output */
+#define		RAW		0x00000020	/* no i/o processing */
+#define		ODDP		0x00000040	/* get/send odd parity */
+#define		EVENP		0x00000080	/* get/send even parity */
+#define		ANYP		0x000000c0	/* get any parity/send none */
+#define		NLDELAY		0x00000300	/* \n delay */
+#define			NL0	0x00000000
+#define			NL1	0x00000100	/* tty 37 */
+#define			NL2	0x00000200	/* vt05 */
+#define			NL3	0x00000300
+#define		TBDELAY		0x00000c00	/* horizontal tab delay */
+#define			TAB0	0x00000000
+#define			TAB1	0x00000400	/* tty 37 */
+#define			TAB2	0x00000800
+#define		XTABS		0x00000c00	/* expand tabs on output */
+#define		CRDELAY		0x00003000	/* \r delay */
+#define			CR0	0x00000000
+#define			CR1	0x00001000	/* tn 300 */
+#define			CR2	0x00002000	/* tty 37 */
+#define			CR3	0x00003000	/* concept 100 */
+#define		VTDELAY		0x00004000	/* vertical tab delay */
+#define			FF0	0x00000000
+#define			FF1	0x00004000	/* tty 37 */
+#define		BSDELAY		0x00008000	/* \b delay */
+#define			BS0	0x00000000
+#define			BS1	0x00008000
+#define		ALLDELAY	(NLDELAY|TBDELAY|CRDELAY|VTDELAY|BSDELAY)
+#define		CRTBS		0x00010000	/* do backspacing for crt */
+#define		PRTERA		0x00020000	/* \ ... / erase */
+#define		CRTERA		0x00040000	/* " \b " to wipe out char */
+#define		TILDE		0x00080000	/* hazeltine tilde kludge */
+#define		MDMBUF		0x00100000	/*start/stop output on carrier*/
+#define		LITOUT		0x00200000	/* literal output */
+#define		TOSTOP		0x00400000	/*SIGSTOP on background output*/
+#define		FLUSHO		0x00800000	/* flush output to terminal */
+#define		NOHANG		0x01000000	/* (no-op) was no SIGHUP on carrier drop */
+#define		L001000		0x02000000
+#define		CRTKIL		0x04000000	/* kill line with " \b " */
+#define		PASS8		0x08000000
+#define		CTLECH		0x10000000	/* echo control chars as ^X */
+#define		PENDIN		0x20000000	/* tp->t_rawq needs reread */
+#define		DECCTQ		0x40000000	/* only ^Q starts after ^S */
+#define		NOFLSH		0x80000000	/* no output flush on signal */
+#define	TIOCLBIS	_IOW('t', 127, int)	/* bis local mode bits */
+#define	TIOCLBIC	_IOW('t', 126, int)	/* bic local mode bits */
+#define	TIOCLSET	_IOW('t', 125, int)	/* set entire local mode word */
+#define	TIOCLGET	_IOR('t', 124, int)	/* get local modes */
+#define		LCRTBS		(CRTBS>>16)
+#define		LPRTERA		(PRTERA>>16)
+#define		LCRTERA		(CRTERA>>16)
+#define		LTILDE		(TILDE>>16)
+#define		LMDMBUF		(MDMBUF>>16)
+#define		LLITOUT		(LITOUT>>16)
+#define		LTOSTOP		(TOSTOP>>16)
+#define		LFLUSHO		(FLUSHO>>16)
+#define		LNOHANG		(NOHANG>>16)
+#define		LCRTKIL		(CRTKIL>>16)
+#define		LPASS8		(PASS8>>16)
+#define		LCTLECH		(CTLECH>>16)
+#define		LPENDIN		(PENDIN>>16)
+#define		LDECCTQ		(DECCTQ>>16)
+#define		LNOFLSH		(NOFLSH>>16)
+#define	TIOCSLTC	_IOW('t',117,struct ltchars)/* set local special chars*/
+#define	TIOCGLTC	_IOR('t',116,struct ltchars)/* get local special chars*/
+#define OTIOCCONS	_IO('t', 98)	/* for hp300 -- sans int arg */
+#define	OTTYDISC	0
+#define	NETLDISC	1
+#define	NTTYDISC	2
+
+/* From 4.4 <sys/ttydev.h>.   */
+#ifdef USE_OLD_TTY
+# define B0	0
+# define B50	1
+# define B75	2
+# define B110	3
+# define B134	4
+# define B150	5
+# define B200	6
+# define B300	7
+# define B600	8
+# define B1200	9
+# define B1800	10
+# define B2400	11
+# define B4800	12
+# define B9600	13
+# define EXTA	14
+# define EXTB	15
+#endif /* USE_OLD_TTY */
+
+#endif /* bits/ioctls.h */
diff --git a/include/bits/ipc.h b/include/bits/ipc.h
new file mode 100644
index 0000000..0688e5d
--- /dev/null
+++ b/include/bits/ipc.h
@@ -0,0 +1,51 @@
+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* Create key if key does not exist. */
+#define IPC_EXCL	02000		/* Fail if key exists.  */
+#define IPC_NOWAIT	04000		/* Return error on wait.  */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* Remove identifier.  */
+#define IPC_SET		1		/* Set `ipc_perm' options.  */
+#define IPC_STAT	2		/* Get `ipc_perm' options.  */
+#ifdef __USE_GNU
+# define IPC_INFO	3		/* See ipcs.  */
+#endif
+
+/* Special key values.  */
+#define IPC_PRIVATE	((__key_t) 0)	/* Private key.  */
+
+
+/* Data structure used to pass permission information to IPC operations.  */
+struct ipc_perm
+  {
+    __key_t __key;			/* Key.  */
+    unsigned short int uid;		/* Owner's user ID.  */
+    unsigned short int gid;		/* Owner's group ID.  */
+    unsigned short int cuid;		/* Creator's user ID.  */
+    unsigned short int cgid;		/* Creator's group ID.  */
+    unsigned short int mode;		/* Read/write permission.  */
+    unsigned short int __seq;		/* Sequence number.  */
+  };
diff --git a/include/bits/ipctypes.h b/include/bits/ipctypes.h
new file mode 100644
index 0000000..592eeb1
--- /dev/null
+++ b/include/bits/ipctypes.h
@@ -0,0 +1,36 @@
+/* bits/ipctypes.h -- Define some types used by SysV IPC/MSG/SHM.  Generic.
+   Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Never include <bits/ipctypes.h> directly.
+ */
+
+#ifndef _BITS_IPCTYPES_H
+#define _BITS_IPCTYPES_H	1
+
+#include <bits/types.h>
+
+/* Used in `struct shmid_ds'.  */
+# if __WORDSIZE == 32
+typedef unsigned short int __ipc_pid_t;
+# else
+typedef int __ipc_pid_t;
+# endif
+
+
+#endif /* bits/ipctypes.h */
diff --git a/include/bits/libc-lock.h b/include/bits/libc-lock.h
new file mode 100644
index 0000000..c9872c6
--- /dev/null
+++ b/include/bits/libc-lock.h
@@ -0,0 +1,215 @@
+/* libc-internal interface for mutex locks.  Hurd version using Mach cthreads.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_LIBC_LOCK_H
+#define _BITS_LIBC_LOCK_H 1
+
+#if (_LIBC - 0) || (_CTHREADS_ - 0)
+# if (_LIBC - 0)
+#  include <tls.h>
+# endif
+#include <cthreads.h>
+
+typedef struct mutex __libc_lock_t;
+typedef struct
+{
+  struct mutex mutex;
+  void *owner;
+  int count;
+} __libc_lock_recursive_t;
+typedef __libc_lock_recursive_t __rtld_lock_recursive_t;
+
+extern char __libc_lock_self0[0];
+#define __libc_lock_owner_self() (__LIBC_NO_TLS() ? &__libc_lock_self0 : THREAD_SELF)
+
+#else
+typedef struct __libc_lock_opaque__ __libc_lock_t;
+typedef struct __libc_lock_recursive_opaque__ __libc_lock_recursive_t;
+#endif
+
+/* Define a lock variable NAME with storage class CLASS.  The lock must be
+   initialized with __libc_lock_init before it can be used (or define it
+   with __libc_lock_define_initialized, below).  Use `extern' for CLASS to
+   declare a lock defined in another module.  In public structure
+   definitions you must use a pointer to the lock structure (i.e., NAME
+   begins with a `*'), because its storage size will not be known outside
+   of libc.  */
+#define __libc_lock_define(CLASS,NAME) \
+  CLASS __libc_lock_t NAME;
+
+/* Define an initialized lock variable NAME with storage class CLASS.  */
+#define __libc_lock_define_initialized(CLASS,NAME) \
+  CLASS __libc_lock_t NAME = MUTEX_INITIALIZER;
+
+/* Initialize the named lock variable, leaving it in a consistent, unlocked
+   state.  */
+#define __libc_lock_init(NAME) __mutex_init (&(NAME))
+
+/* Finalize the named lock variable, which must be locked.  It cannot be
+   used again until __libc_lock_init is called again on it.  This must be
+   called on a lock variable before the containing storage is reused.  */
+#define __libc_lock_fini(NAME) __mutex_unlock (&(NAME))
+#define __libc_lock_fini_recursive(NAME) __mutex_unlock (&(NAME).mutex)
+#define __rtld_lock_fini_recursive(NAME) __mutex_unlock (&(NAME).mutex)
+
+
+/* Lock the named lock variable.  */
+#define __libc_lock_lock(NAME) __mutex_lock (&(NAME))
+
+/* Lock the named lock variable.  */
+#define __libc_lock_trylock(NAME) (!__mutex_trylock (&(NAME)))
+
+/* Unlock the named lock variable.  */
+#define __libc_lock_unlock(NAME) __mutex_unlock (&(NAME))
+
+
+#define __libc_lock_define_recursive(CLASS,NAME) \
+  CLASS __libc_lock_recursive_t NAME;
+#define _LIBC_LOCK_RECURSIVE_INITIALIZER { MUTEX_INITIALIZER, 0, 0 }
+#define __libc_lock_define_initialized_recursive(CLASS,NAME) \
+  CLASS __libc_lock_recursive_t NAME = _LIBC_LOCK_RECURSIVE_INITIALIZER;
+
+#define __rtld_lock_define_recursive(CLASS,NAME) \
+  __libc_lock_define_recursive (CLASS, NAME)
+#define _RTLD_LOCK_RECURSIVE_INITIALIZER \
+  _LIBC_LOCK_RECURSIVE_INITIALIZER
+#define __rtld_lock_define_initialized_recursive(CLASS,NAME) \
+  __libc_lock_define_initialized_recursive (CLASS, NAME)
+
+#define __libc_lock_init_recursive(NAME) \
+  ({ __libc_lock_recursive_t *const __lock = &(NAME); \
+     __lock->owner = 0; mutex_init (&__lock->mutex); })
+
+#define __libc_lock_trylock_recursive(NAME)				      \
+  ({ __libc_lock_recursive_t *const __lock = &(NAME);			      \
+     void *__self = __libc_lock_owner_self ();				      \
+     __mutex_trylock (&__lock->mutex)					      \
+     ? (__lock->owner = __self, __lock->count = 1, 0)			      \
+     : __lock->owner == __self ? (++__lock->count, 0) : 1; })
+
+#define __libc_lock_lock_recursive(NAME)				      \
+  ({ __libc_lock_recursive_t *const __lock = &(NAME);			      \
+     void *__self = __libc_lock_owner_self ();				      \
+     if (__mutex_trylock (&__lock->mutex)				      \
+	 || (__lock->owner != __self					      \
+	     && (__mutex_lock (&__lock->mutex), 1)))			      \
+       __lock->owner = __self, __lock->count = 1;			      \
+     else								      \
+       ++__lock->count;							      \
+  })
+#define __libc_lock_unlock_recursive(NAME)				      \
+  ({ __libc_lock_recursive_t *const __lock = &(NAME);			      \
+     if (--__lock->count == 0)						      \
+       {								      \
+	 __lock->owner = 0;						      \
+	 __mutex_unlock (&__lock->mutex);				      \
+       }								      \
+  })
+
+
+#define __rtld_lock_initialize(NAME) \
+  (void) ((NAME) = (__rtld_lock_recursive_t) _RTLD_LOCK_RECURSIVE_INITIALIZER)
+#define __rtld_lock_trylock_recursive(NAME) \
+  __libc_lock_trylock_recursive (NAME)
+#define __rtld_lock_lock_recursive(NAME) \
+  __libc_lock_lock_recursive(NAME)
+#define __rtld_lock_unlock_recursive(NAME) \
+  __libc_lock_unlock_recursive (NAME)
+
+
+/* XXX for now */
+#define __libc_rwlock_define		__libc_lock_define
+#define __libc_rwlock_define_initialized __libc_lock_define_initialized
+#define __libc_rwlock_init		__libc_lock_init
+#define __libc_rwlock_fini		__libc_lock_fini
+#define __libc_rwlock_rdlock		__libc_lock_lock
+#define __libc_rwlock_wrlock		__libc_lock_lock
+#define __libc_rwlock_tryrdlock		__libc_lock_trylock
+#define __libc_rwlock_trywrlock		__libc_lock_trylock
+#define __libc_rwlock_unlock		__libc_lock_unlock
+
+
+/* Start a critical region with a cleanup function */
+#define __libc_cleanup_region_start(DOIT, FCT, ARG)			    \
+{									    \
+  typeof (***(FCT)) *__save_FCT = (DOIT) ? (FCT) : 0;			    \
+  typeof (ARG) __save_ARG = ARG;					    \
+  /* close brace is in __libc_cleanup_region_end below. */
+
+/* End a critical region started with __libc_cleanup_region_start. */
+#define __libc_cleanup_region_end(DOIT)					    \
+  if ((DOIT) && __save_FCT != 0)					    \
+    (*__save_FCT)(__save_ARG);						    \
+}
+
+/* Sometimes we have to exit the block in the middle.  */
+#define __libc_cleanup_end(DOIT)					    \
+  if ((DOIT) && __save_FCT != 0)					    \
+    (*__save_FCT)(__save_ARG);						    \
+
+#define __libc_cleanup_push(fct, arg) __libc_cleanup_region_start (1, fct, arg)
+#define __libc_cleanup_pop(execute) __libc_cleanup_region_end (execute)
+
+#if (_CTHREADS_ - 0)
+
+/* Use mutexes as once control variables. */
+
+struct __libc_once
+  {
+    __libc_lock_t lock;
+    int done;
+  };
+
+#define __libc_once_define(CLASS,NAME) \
+  CLASS struct __libc_once NAME = { MUTEX_INITIALIZER, 0 }
+
+/* Call handler iff the first call.  */
+#define __libc_once(ONCE_CONTROL, INIT_FUNCTION) \
+  do {									      \
+    __libc_lock_lock (ONCE_CONTROL.lock);				      \
+    if (!ONCE_CONTROL.done)						      \
+      (INIT_FUNCTION) ();						      \
+    ONCE_CONTROL.done = 1;						      \
+    __libc_lock_unlock (ONCE_CONTROL.lock);				      \
+  } while (0)
+
+/* Get once control variable.  */
+#define __libc_once_get(ONCE_CONTROL)	((ONCE_CONTROL).done != 0)
+
+#ifdef _LIBC
+/* We need portable names for some functions.  E.g., when they are
+   used as argument to __libc_cleanup_region_start.  */
+#define __libc_mutex_unlock __mutex_unlock
+#endif
+
+/* Type for key of thread specific data.  */
+typedef cthread_key_t __libc_key_t;
+
+#define __libc_key_create(KEY,DEST) cthread_keycreate (KEY)
+#define __libc_setspecific(KEY,VAL) cthread_setspecific (KEY, VAL)
+void *__libc_getspecific (__libc_key_t key);
+
+#endif /* _CTHREADS_ */
+
+/* Hide the definitions which are only supposed to be used inside libc in
+   a separate file.  This file is not present in the installation!  */
+#ifdef _LIBC
+# include <bits/libc-lockP.h>
+#endif
+
+#endif	/* bits/libc-lock.h */
diff --git a/include/bits/libio-ldbl.h b/include/bits/libio-ldbl.h
new file mode 100644
index 0000000..cb08f3d
--- /dev/null
+++ b/include/bits/libio-ldbl.h
@@ -0,0 +1,24 @@
+/* -mlong-double-64 compatibility mode for libio functions.
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _IO_STDIO_H
+# error "Never include <bits/libio-ldbl.h> directly; use <libio.h> instead."
+#endif
+
+__LDBL_REDIR_DECL (_IO_vfscanf)
+__LDBL_REDIR_DECL (_IO_vfprintf)
diff --git a/include/bits/link.h b/include/bits/link.h
new file mode 100644
index 0000000..4ebc5c1
--- /dev/null
+++ b/include/bits/link.h
@@ -0,0 +1,147 @@
+/* Copyright (C) 2004-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+
+#ifndef __x86_64__
+/* Registers for entry into PLT on IA-32.  */
+typedef struct La_i86_regs
+{
+  uint32_t lr_edx;
+  uint32_t lr_ecx;
+  uint32_t lr_eax;
+  uint32_t lr_ebp;
+  uint32_t lr_esp;
+} La_i86_regs;
+
+/* Return values for calls from PLT on IA-32.  */
+typedef struct La_i86_retval
+{
+  uint32_t lrv_eax;
+  uint32_t lrv_edx;
+  long double lrv_st0;
+  long double lrv_st1;
+} La_i86_retval;
+
+
+__BEGIN_DECLS
+
+extern Elf32_Addr la_i86_gnu_pltenter (Elf32_Sym *__sym, unsigned int __ndx,
+				       uintptr_t *__refcook,
+				       uintptr_t *__defcook,
+				       La_i86_regs *__regs,
+				       unsigned int *__flags,
+				       const char *__symname,
+				       long int *__framesizep);
+extern unsigned int la_i86_gnu_pltexit (Elf32_Sym *__sym, unsigned int __ndx,
+					uintptr_t *__refcook,
+					uintptr_t *__defcook,
+					const La_i86_regs *__inregs,
+					La_i86_retval *__outregs,
+					const char *symname);
+
+__END_DECLS
+
+#else
+
+/* Registers for entry into PLT on x86-64.  */
+# if __GNUC_PREREQ (4,0)
+typedef float La_x86_64_xmm __attribute__ ((__vector_size__ (16)));
+typedef float La_x86_64_ymm
+    __attribute__ ((__vector_size__ (32), __aligned__ (16)));
+# else
+typedef float La_x86_64_xmm __attribute__ ((__mode__ (__V4SF__)));
+# endif
+
+typedef union
+{
+# if __GNUC_PREREQ (4,0)
+  La_x86_64_ymm ymm[2];
+# endif
+  La_x86_64_xmm xmm[4];
+} La_x86_64_vector __attribute__ ((__aligned__ (16)));
+
+typedef struct La_x86_64_regs
+{
+  uint64_t lr_rdx;
+  uint64_t lr_r8;
+  uint64_t lr_r9;
+  uint64_t lr_rcx;
+  uint64_t lr_rsi;
+  uint64_t lr_rdi;
+  uint64_t lr_rbp;
+  uint64_t lr_rsp;
+  La_x86_64_xmm lr_xmm[8];
+  La_x86_64_vector lr_vector[8];
+} La_x86_64_regs;
+
+/* Return values for calls from PLT on x86-64.  */
+typedef struct La_x86_64_retval
+{
+  uint64_t lrv_rax;
+  uint64_t lrv_rdx;
+  La_x86_64_xmm lrv_xmm0;
+  La_x86_64_xmm lrv_xmm1;
+  long double lrv_st0;
+  long double lrv_st1;
+  La_x86_64_vector lrv_vector0;
+  La_x86_64_vector lrv_vector1;
+} La_x86_64_retval;
+
+#define La_x32_regs La_x86_64_regs
+#define La_x32_retval La_x86_64_retval
+
+__BEGIN_DECLS
+
+extern Elf64_Addr la_x86_64_gnu_pltenter (Elf64_Sym *__sym,
+					  unsigned int __ndx,
+					  uintptr_t *__refcook,
+					  uintptr_t *__defcook,
+					  La_x86_64_regs *__regs,
+					  unsigned int *__flags,
+					  const char *__symname,
+					  long int *__framesizep);
+extern unsigned int la_x86_64_gnu_pltexit (Elf64_Sym *__sym,
+					   unsigned int __ndx,
+					   uintptr_t *__refcook,
+					   uintptr_t *__defcook,
+					   const La_x86_64_regs *__inregs,
+					   La_x86_64_retval *__outregs,
+					   const char *__symname);
+
+extern Elf32_Addr la_x32_gnu_pltenter (Elf32_Sym *__sym,
+				       unsigned int __ndx,
+				       uintptr_t *__refcook,
+				       uintptr_t *__defcook,
+				       La_x32_regs *__regs,
+				       unsigned int *__flags,
+				       const char *__symname,
+				       long int *__framesizep);
+extern unsigned int la_x32_gnu_pltexit (Elf32_Sym *__sym,
+					unsigned int __ndx,
+					uintptr_t *__refcook,
+					uintptr_t *__defcook,
+					const La_x32_regs *__inregs,
+					La_x32_retval *__outregs,
+					const char *__symname);
+
+__END_DECLS
+
+#endif
diff --git a/include/bits/local_lim.h b/include/bits/local_lim.h
new file mode 100644
index 0000000..570b5ce
--- /dev/null
+++ b/include/bits/local_lim.h
@@ -0,0 +1,43 @@
+/* Minimum guaranteed maximum values for system limits.  Hurd version.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* GNU has no arbitrary fixed limits on most of these things, so we
+   don't define the macros.  Some things are unlimited.  Some are in
+   fact limited but the limit is run-time dependent and fetched with
+   `sysconf' or `pathconf'.  */
+
+/* This one value is actually constrained by the `struct dirent'
+   layout, in which the `d_namlen' member is only 8 bits wide.  */
+
+#define NAME_MAX	255
+
+/* POSIX.1 requires that we define NGROUPS_MAX (though none of the others
+   is required).  GNU allows any number of supplementary groups,
+   dynamically allocated.  So we pick a number which seems vaguely
+   suitable, and `sysconf' will return a number at least as large.  */
+
+#define NGROUPS_MAX	256
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
diff --git a/include/bits/locale.h b/include/bits/locale.h
new file mode 100644
index 0000000..481228f
--- /dev/null
+++ b/include/bits/locale.h
@@ -0,0 +1,40 @@
+/* Definition of locale category symbol values.
+   Copyright (C) 2001-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _LOCALE_H && !defined _LANGINFO_H
+# error "Never use <bits/locale.h> directly; include <locale.h> instead."
+#endif
+
+#ifndef _BITS_LOCALE_H
+#define _BITS_LOCALE_H	1
+
+#define __LC_CTYPE		 0
+#define __LC_NUMERIC		 1
+#define __LC_TIME		 2
+#define __LC_COLLATE		 3
+#define __LC_MONETARY		 4
+#define __LC_MESSAGES		 5
+#define __LC_ALL		 6
+#define __LC_PAPER		 7
+#define __LC_NAME		 8
+#define __LC_ADDRESS		 9
+#define __LC_TELEPHONE		10
+#define __LC_MEASUREMENT	11
+#define __LC_IDENTIFICATION	12
+
+#endif	/* bits/locale.h */
diff --git a/include/bits/math-finite.h b/include/bits/math-finite.h
new file mode 100644
index 0000000..e9a2b12
--- /dev/null
+++ b/include/bits/math-finite.h
@@ -0,0 +1,454 @@
+/* Entry points to finite-math-only compiler runs.
+   Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/math-finite.h> directly; include <math.h> instead."
+#endif
+
+/* acos.  */
+extern double __REDIRECT_NTH (acos, (double), __acos_finite);
+extern float __REDIRECT_NTH (acosf, (float), __acosf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (acosl, (long double), __acos_finite);
+# else
+extern long double __REDIRECT_NTH (acosl, (long double), __acosl_finite);
+# endif
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+/* acosh.  */
+extern double __REDIRECT_NTH (acosh, (double), __acosh_finite);
+extern float __REDIRECT_NTH (acoshf, (float), __acoshf_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (acoshl, (long double), __acosh_finite);
+#  else
+extern long double __REDIRECT_NTH (acoshl, (long double), __acoshl_finite);
+#  endif
+# endif
+#endif
+
+/* asin.  */
+extern double __REDIRECT_NTH (asin, (double), __asin_finite);
+extern float __REDIRECT_NTH (asinf, (float), __asinf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (asinl, (long double), __asin_finite);
+# else
+extern long double __REDIRECT_NTH (asinl, (long double), __asinl_finite);
+# endif
+#endif
+
+/* atan2.  */
+extern double __REDIRECT_NTH (atan2, (double, double), __atan2_finite);
+extern float __REDIRECT_NTH (atan2f, (float, float), __atan2f_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (atan2l, (long double, long double),
+				   __atan2_finite);
+# else
+extern long double __REDIRECT_NTH (atan2l, (long double, long double),
+				   __atan2l_finite);
+# endif
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+/* atanh.  */
+extern double __REDIRECT_NTH (atanh, (double), __atanh_finite);
+extern float __REDIRECT_NTH (atanhf, (float), __atanhf_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (atanhl, (long double), __atanh_finite);
+#  else
+extern long double __REDIRECT_NTH (atanhl, (long double), __atanhl_finite);
+#  endif
+# endif
+#endif
+
+/* cosh.  */
+extern double __REDIRECT_NTH (cosh, (double), __cosh_finite);
+extern float __REDIRECT_NTH (coshf, (float), __coshf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (coshl, (long double), __cosh_finite);
+# else
+extern long double __REDIRECT_NTH (coshl, (long double), __coshl_finite);
+# endif
+#endif
+
+/* exp.  */
+extern double __REDIRECT_NTH (exp, (double), __exp_finite);
+extern float __REDIRECT_NTH (expf, (float), __expf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (expl, (long double), __exp_finite);
+# else
+extern long double __REDIRECT_NTH (expl, (long double), __expl_finite);
+# endif
+#endif
+
+#ifdef __USE_GNU
+/* exp10.  */
+extern double __REDIRECT_NTH (exp10, (double), __exp10_finite);
+extern float __REDIRECT_NTH (exp10f, (float), __exp10f_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (exp10l, (long double), __exp10_finite);
+#  else
+extern long double __REDIRECT_NTH (exp10l, (long double), __exp10l_finite);
+#  endif
+# endif
+
+/* pow10.  */
+extern double __REDIRECT_NTH (pow10, (double), __exp10_finite);
+extern float __REDIRECT_NTH (pow10f, (float), __exp10f_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (pow10l, (long double), __exp10_finite);
+#  else
+extern long double __REDIRECT_NTH (pow10l, (long double), __exp10l_finite);
+#  endif
+# endif
+#endif
+
+#ifdef __USE_ISOC99
+/* exp2.  */
+extern double __REDIRECT_NTH (exp2, (double), __exp2_finite);
+extern float __REDIRECT_NTH (exp2f, (float), __exp2f_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (exp2l, (long double), __exp2_finite);
+#  else
+extern long double __REDIRECT_NTH (exp2l, (long double), __exp2l_finite);
+#  endif
+# endif
+#endif
+
+/* fmod.  */
+extern double __REDIRECT_NTH (fmod, (double, double), __fmod_finite);
+extern float __REDIRECT_NTH (fmodf, (float, float), __fmodf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (fmodl, (long double, long double),
+				   __fmod_finite);
+# else
+extern long double __REDIRECT_NTH (fmodl, (long double, long double),
+				   __fmodl_finite);
+# endif
+#endif
+
+#ifdef __USE_ISOC99
+/* hypot.  */
+extern double __REDIRECT_NTH (hypot, (double, double), __hypot_finite);
+extern float __REDIRECT_NTH (hypotf, (float, float), __hypotf_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (hypotl, (long double, long double),
+				   __hypot_finite);
+#  else
+extern long double __REDIRECT_NTH (hypotl, (long double, long double),
+				   __hypotl_finite);
+#  endif
+# endif
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN
+/* j0.  */
+extern double __REDIRECT_NTH (j0, (double), __j0_finite);
+extern float __REDIRECT_NTH (j0f, (float), __j0f_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (j0l, (long double), __j0_finite);
+#  else
+extern long double __REDIRECT_NTH (j0l, (long double), __j0l_finite);
+#  endif
+# endif
+
+/* y0.  */
+extern double __REDIRECT_NTH (y0, (double), __y0_finite);
+extern float __REDIRECT_NTH (y0f, (float), __y0f_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (y0l, (long double), __y0_finite);
+#  else
+extern long double __REDIRECT_NTH (y0l, (long double), __y0l_finite);
+#  endif
+# endif
+
+/* j1.  */
+extern double __REDIRECT_NTH (j1, (double), __j1_finite);
+extern float __REDIRECT_NTH (j1f, (float), __j1f_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (j1l, (long double), __j1_finite);
+#  else
+extern long double __REDIRECT_NTH (j1l, (long double), __j1l_finite);
+#  endif
+# endif
+
+/* y1.  */
+extern double __REDIRECT_NTH (y1, (double), __y1_finite);
+extern float __REDIRECT_NTH (y1f, (float), __y1f_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (y1l, (long double), __y1_finite);
+#  else
+extern long double __REDIRECT_NTH (y1l, (long double), __y1l_finite);
+#  endif
+# endif
+
+/* jn.  */
+extern double __REDIRECT_NTH (jn, (int, double), __jn_finite);
+extern float __REDIRECT_NTH (jnf, (int, float), __jnf_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (jnl, (int, long double), __jn_finite);
+#  else
+extern long double __REDIRECT_NTH (jnl, (int, long double), __jnl_finite);
+#  endif
+# endif
+
+/* yn.  */
+extern double __REDIRECT_NTH (yn, (int, double), __yn_finite);
+extern float __REDIRECT_NTH (ynf, (int, float), __ynf_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (ynl, (int, long double), __yn_finite);
+#  else
+extern long double __REDIRECT_NTH (ynl, (int, long double), __ynl_finite);
+#  endif
+# endif
+#endif
+
+#ifdef __USE_MISC
+/* lgamma_r.  */
+extern double __REDIRECT_NTH (lgamma_r, (double, int *), __lgamma_r_finite);
+extern float __REDIRECT_NTH (lgammaf_r, (float, int *), __lgammaf_r_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (lgammal_r, (long double, int *),
+				   __lgamma_r_finite);
+#  else
+extern long double __REDIRECT_NTH (lgammal_r, (long double, int *),
+				   __lgammal_r_finite);
+#  endif
+# endif
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
+/* lgamma.  */
+__extern_always_inline double __NTH (lgamma (double __d))
+{
+# ifdef __USE_ISOC99
+  int __local_signgam = 0;
+  return lgamma_r (__d, &__local_signgam);
+# else
+  return lgamma_r (__d, &signgam);
+# endif
+}
+__extern_always_inline float __NTH (lgammaf (float __d))
+{
+# ifdef __USE_ISOC99
+  int __local_signgam = 0;
+  return lgammaf_r (__d, &__local_signgam);
+# else
+  return lgammaf_r (__d, &signgam);
+# endif
+}
+# ifdef __MATH_DECLARE_LDOUBLE
+__extern_always_inline long double __NTH (lgammal (long double __d))
+{
+# ifdef __USE_ISOC99
+  int __local_signgam = 0;
+  return lgammal_r (__d, &__local_signgam);
+# else
+  return lgammal_r (__d, &signgam);
+# endif
+}
+# endif
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN
+/* gamma.  */
+__extern_always_inline double __NTH (gamma (double __d))
+{
+# ifdef __USE_ISOC99
+  int __local_signgam = 0;
+  return lgamma_r (__d, &__local_signgam);
+# else
+  return lgamma_r (__d, &signgam);
+# endif
+}
+__extern_always_inline float __NTH (gammaf (float __d))
+{
+# ifdef __USE_ISOC99
+  int __local_signgam = 0;
+  return lgammaf_r (__d, &__local_signgam);
+# else
+  return lgammaf_r (__d, &signgam);
+# endif
+}
+# ifdef __MATH_DECLARE_LDOUBLE
+__extern_always_inline long double __NTH (gammal (long double __d))
+{
+#  ifdef __USE_ISOC99
+  int __local_signgam = 0;
+  return lgammal_r (__d, &__local_signgam);
+#  else
+  return lgammal_r (__d, &signgam);
+#  endif
+}
+# endif
+#endif
+
+/* log.  */
+extern double __REDIRECT_NTH (log, (double), __log_finite);
+extern float __REDIRECT_NTH (logf, (float), __logf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (logl, (long double), __log_finite);
+# else
+extern long double __REDIRECT_NTH (logl, (long double), __logl_finite);
+# endif
+#endif
+
+/* log10.  */
+extern double __REDIRECT_NTH (log10, (double), __log10_finite);
+extern float __REDIRECT_NTH (log10f, (float), __log10f_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (log10l, (long double), __log10_finite);
+# else
+extern long double __REDIRECT_NTH (log10l, (long double), __log10l_finite);
+# endif
+#endif
+
+#ifdef __USE_ISOC99
+/* log2.  */
+extern double __REDIRECT_NTH (log2, (double), __log2_finite);
+extern float __REDIRECT_NTH (log2f, (float), __log2f_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (log2l, (long double), __log2_finite);
+#  else
+extern long double __REDIRECT_NTH (log2l, (long double), __log2l_finite);
+#  endif
+# endif
+#endif
+
+/* ldexp.  */
+extern double __REDIRECT_NTH (ldexp, (double, int), scalbn);
+extern float __REDIRECT_NTH (ldexpf, (float, int), scalbnf);
+#ifdef __MATH_DECLARE_LDOUBLE
+extern long double __REDIRECT_NTH (ldexpl, (long double, int), scalbnl);
+#endif
+
+/* pow.  */
+extern double __REDIRECT_NTH (pow, (double, double), __pow_finite);
+extern float __REDIRECT_NTH (powf, (float, float), __powf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (powl, (long double, long double),
+				   __pow_finite);
+# else
+extern long double __REDIRECT_NTH (powl, (long double, long double),
+				   __powl_finite);
+# endif
+#endif
+
+/* remainder.  */
+extern double __REDIRECT_NTH (remainder, (double, double), __remainder_finite);
+extern float __REDIRECT_NTH (remainderf, (float, float), __remainderf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (remainderl, (long double, long double),
+				   __remainder_finite);
+# else
+extern long double __REDIRECT_NTH (remainderl, (long double, long double),
+				   __remainderl_finite);
+# endif
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED
+/* scalb.  */
+extern double __REDIRECT_NTH (scalb, (double, double), __scalb_finite);
+extern float __REDIRECT_NTH (scalbf, (float, float), __scalbf_finite);
+# ifdef __MATH_DECLARE_LDOUBLE
+#  ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (scalbl, (long double, long double),
+				   __scalb_finite);
+#  else
+extern long double __REDIRECT_NTH (scalbl, (long double, long double),
+				   __scalbl_finite);
+#  endif
+# endif
+#endif
+
+/* sinh.  */
+extern double __REDIRECT_NTH (sinh, (double), __sinh_finite);
+extern float __REDIRECT_NTH (sinhf, (float), __sinhf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (sinhl, (long double), __sinh_finite);
+# else
+extern long double __REDIRECT_NTH (sinhl, (long double), __sinhl_finite);
+# endif
+#endif
+
+/* sqrt.  */
+extern double __REDIRECT_NTH (sqrt, (double), __sqrt_finite);
+extern float __REDIRECT_NTH (sqrtf, (float), __sqrtf_finite);
+#ifdef __MATH_DECLARE_LDOUBLE
+# ifdef __NO_LONG_DOUBLE_MATH
+extern long double __REDIRECT_NTH (sqrtl, (long double), __sqrt_finite);
+# else
+extern long double __REDIRECT_NTH (sqrtl, (long double), __sqrtl_finite);
+# endif
+#endif
+
+#ifdef __USE_ISOC99
+/* tgamma.  */
+extern double __gamma_r_finite (double, int *);
+__extern_always_inline double __NTH (tgamma (double __d))
+{
+  int __local_signgam = 0;
+  double __res = __gamma_r_finite (__d, &__local_signgam);
+  return __local_signgam < 0 ? -__res : __res;
+}
+extern float __gammaf_r_finite (float, int *);
+__extern_always_inline float __NTH (tgammaf (float __d))
+{
+  int __local_signgam = 0;
+  float __res = __gammaf_r_finite (__d, &__local_signgam);
+  return __local_signgam < 0 ? -__res : __res;
+}
+# ifdef __MATH_DECLARE_LDOUBLE
+extern long double __gammal_r_finite (long double, int *);
+__extern_always_inline long double __NTH (tgammal (long double __d))
+{
+  int __local_signgam = 0;
+#  ifdef __NO_LONG_DOUBLE_MATH
+  long double __res = __gamma_r_finite (__d, &__local_signgam);
+#  else
+  long double __res = __gammal_r_finite (__d, &__local_signgam);
+#  endif
+  return __local_signgam < 0 ? -__res : __res;
+}
+# endif
+#endif
diff --git a/include/bits/mathcalls.h b/include/bits/mathcalls.h
new file mode 100644
index 0000000..4cb39e8
--- /dev/null
+++ b/include/bits/mathcalls.h
@@ -0,0 +1,372 @@
+/* Prototype declarations for math functions; helper file for <math.h>.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* NOTE: Because of the special way this file is used by <math.h>, this
+   file must NOT be protected from multiple inclusion as header files
+   usually are.
+
+   This file provides prototype declarations for the math functions.
+   Most functions are declared using the macro:
+
+   __MATHCALL (NAME,[_r], (ARGS...));
+
+   This means there is a function `NAME' returning `double' and a function
+   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
+   prototype, that is actually `double' in the prototype for `NAME' and
+   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
+   called `NAME_r' and `NAMEf_r'.
+
+   Functions returning other types like `int' are declared using the macro:
+
+   __MATHDECL (TYPE, NAME,[_r], (ARGS...));
+
+   This is just like __MATHCALL but for a function returning `TYPE'
+   instead of `_Mdouble_'.  In all of these cases, there is still
+   both a `NAME' and a `NAMEf' that takes `float' arguments.
+
+   Note that there must be no whitespace before the argument passed for
+   NAME, to make token pasting work with -traditional.  */
+
+#ifndef _MATH_H
+# error "Never include <bits/mathcalls.h> directly; include <math.h> instead."
+#endif
+
+
+/* Trigonometric functions.  */
+
+_Mdouble_BEGIN_NAMESPACE
+/* Arc cosine of X.  */
+__MATHCALL (acos,, (_Mdouble_ __x));
+/* Arc sine of X.  */
+__MATHCALL (asin,, (_Mdouble_ __x));
+/* Arc tangent of X.  */
+__MATHCALL (atan,, (_Mdouble_ __x));
+/* Arc tangent of Y/X.  */
+__MATHCALL (atan2,, (_Mdouble_ __y, _Mdouble_ __x));
+
+/* Cosine of X.  */
+__MATHCALL (cos,, (_Mdouble_ __x));
+/* Sine of X.  */
+__MATHCALL (sin,, (_Mdouble_ __x));
+/* Tangent of X.  */
+__MATHCALL (tan,, (_Mdouble_ __x));
+
+/* Hyperbolic functions.  */
+
+/* Hyperbolic cosine of X.  */
+__MATHCALL (cosh,, (_Mdouble_ __x));
+/* Hyperbolic sine of X.  */
+__MATHCALL (sinh,, (_Mdouble_ __x));
+/* Hyperbolic tangent of X.  */
+__MATHCALL (tanh,, (_Mdouble_ __x));
+_Mdouble_END_NAMESPACE
+
+#ifdef __USE_GNU
+/* Cosine and sine of X.  */
+__MATHDECL (void,sincos,,
+	    (_Mdouble_ __x, _Mdouble_ *__sinx, _Mdouble_ *__cosx));
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Hyperbolic arc cosine of X.  */
+__MATHCALL (acosh,, (_Mdouble_ __x));
+/* Hyperbolic arc sine of X.  */
+__MATHCALL (asinh,, (_Mdouble_ __x));
+/* Hyperbolic arc tangent of X.  */
+__MATHCALL (atanh,, (_Mdouble_ __x));
+__END_NAMESPACE_C99
+#endif
+
+/* Exponential and logarithmic functions.  */
+
+_Mdouble_BEGIN_NAMESPACE
+/* Exponential function of X.  */
+__MATHCALL (exp,, (_Mdouble_ __x));
+
+/* Break VALUE into a normalized fraction and an integral power of 2.  */
+__MATHCALL (frexp,, (_Mdouble_ __x, int *__exponent));
+
+/* X times (two to the EXP power).  */
+__MATHCALL (ldexp,, (_Mdouble_ __x, int __exponent));
+
+/* Natural logarithm of X.  */
+__MATHCALL (log,, (_Mdouble_ __x));
+
+/* Base-ten logarithm of X.  */
+__MATHCALL (log10,, (_Mdouble_ __x));
+
+/* Break VALUE into integral and fractional parts.  */
+__MATHCALL (modf,, (_Mdouble_ __x, _Mdouble_ *__iptr)) __nonnull ((2));
+_Mdouble_END_NAMESPACE
+
+#ifdef __USE_GNU
+/* A function missing in all standards: compute exponent to base ten.  */
+__MATHCALL (exp10,, (_Mdouble_ __x));
+/* Another name occasionally used.  */
+__MATHCALL (pow10,, (_Mdouble_ __x));
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Return exp(X) - 1.  */
+__MATHCALL (expm1,, (_Mdouble_ __x));
+
+/* Return log(1 + X).  */
+__MATHCALL (log1p,, (_Mdouble_ __x));
+
+/* Return the base 2 signed integral exponent of X.  */
+__MATHCALL (logb,, (_Mdouble_ __x));
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Compute base-2 exponential of X.  */
+__MATHCALL (exp2,, (_Mdouble_ __x));
+
+/* Compute base-2 logarithm of X.  */
+__MATHCALL (log2,, (_Mdouble_ __x));
+__END_NAMESPACE_C99
+#endif
+
+
+/* Power functions.  */
+
+_Mdouble_BEGIN_NAMESPACE
+/* Return X to the Y power.  */
+__MATHCALL (pow,, (_Mdouble_ __x, _Mdouble_ __y));
+
+/* Return the square root of X.  */
+__MATHCALL (sqrt,, (_Mdouble_ __x));
+_Mdouble_END_NAMESPACE
+
+#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Return `sqrt(X*X + Y*Y)'.  */
+__MATHCALL (hypot,, (_Mdouble_ __x, _Mdouble_ __y));
+__END_NAMESPACE_C99
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Return the cube root of X.  */
+__MATHCALL (cbrt,, (_Mdouble_ __x));
+__END_NAMESPACE_C99
+#endif
+
+
+/* Nearest integer, absolute value, and remainder functions.  */
+
+_Mdouble_BEGIN_NAMESPACE
+/* Smallest integral value not less than X.  */
+__MATHCALLX (ceil,, (_Mdouble_ __x), (__const__));
+
+/* Absolute value of X.  */
+__MATHCALLX (fabs,, (_Mdouble_ __x), (__const__));
+
+/* Largest integer not greater than X.  */
+__MATHCALLX (floor,, (_Mdouble_ __x), (__const__));
+
+/* Floating-point modulo remainder of X/Y.  */
+__MATHCALL (fmod,, (_Mdouble_ __x, _Mdouble_ __y));
+
+
+/* Return 0 if VALUE is finite or NaN, +1 if it
+   is +Infinity, -1 if it is -Infinity.  */
+__MATHDECL_1 (int,__isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));
+
+/* Return nonzero if VALUE is finite and not NaN.  */
+__MATHDECL_1 (int,__finite,, (_Mdouble_ __value)) __attribute__ ((__const__));
+_Mdouble_END_NAMESPACE
+
+#ifdef __USE_MISC
+/* Return 0 if VALUE is finite or NaN, +1 if it
+   is +Infinity, -1 if it is -Infinity.  */
+__MATHDECL_1 (int,isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));
+
+/* Return nonzero if VALUE is finite and not NaN.  */
+__MATHDECL_1 (int,finite,, (_Mdouble_ __value)) __attribute__ ((__const__));
+
+/* Return the remainder of X/Y.  */
+__MATHCALL (drem,, (_Mdouble_ __x, _Mdouble_ __y));
+
+
+/* Return the fractional part of X after dividing out `ilogb (X)'.  */
+__MATHCALL (significand,, (_Mdouble_ __x));
+#endif /* Use misc.  */
+
+#if defined __USE_MISC || defined __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Return X with its signed changed to Y's.  */
+__MATHCALLX (copysign,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Return representation of qNaN for double type.  */
+__MATHCALLX (nan,, (const char *__tagb), (__const__));
+__END_NAMESPACE_C99
+#endif
+
+
+/* Return nonzero if VALUE is not a number.  */
+__MATHDECL_1 (int,__isnan,, (_Mdouble_ __value)) __attribute__ ((__const__));
+
+#if defined __USE_MISC || defined __USE_XOPEN
+/* Return nonzero if VALUE is not a number.  */
+__MATHDECL_1 (int,isnan,, (_Mdouble_ __value)) __attribute__ ((__const__));
+
+/* Bessel functions.  */
+__MATHCALL (j0,, (_Mdouble_));
+__MATHCALL (j1,, (_Mdouble_));
+__MATHCALL (jn,, (int, _Mdouble_));
+__MATHCALL (y0,, (_Mdouble_));
+__MATHCALL (y1,, (_Mdouble_));
+__MATHCALL (yn,, (int, _Mdouble_));
+#endif
+
+
+#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Error and gamma functions.  */
+__MATHCALL (erf,, (_Mdouble_));
+__MATHCALL (erfc,, (_Mdouble_));
+__MATHCALL (lgamma,, (_Mdouble_));
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* True gamma function.  */
+__MATHCALL (tgamma,, (_Mdouble_));
+__END_NAMESPACE_C99
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN
+/* Obsolete alias for `lgamma'.  */
+__MATHCALL (gamma,, (_Mdouble_));
+#endif
+
+#ifdef __USE_MISC
+/* Reentrant version of lgamma.  This function uses the global variable
+   `signgam'.  The reentrant version instead takes a pointer and stores
+   the value through it.  */
+__MATHCALL (lgamma,_r, (_Mdouble_, int *__signgamp));
+#endif
+
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Return the integer nearest X in the direction of the
+   prevailing rounding mode.  */
+__MATHCALL (rint,, (_Mdouble_ __x));
+
+/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
+__MATHCALLX (nextafter,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
+# if defined __USE_ISOC99 && !defined __LDBL_COMPAT
+__MATHCALLX (nexttoward,, (_Mdouble_ __x, long double __y), (__const__));
+# endif
+
+/* Return the remainder of integer divison X / Y with infinite precision.  */
+__MATHCALL (remainder,, (_Mdouble_ __x, _Mdouble_ __y));
+
+# if defined __USE_MISC || defined __USE_ISOC99
+/* Return X times (2 to the Nth power).  */
+__MATHCALL (scalbn,, (_Mdouble_ __x, int __n));
+# endif
+
+/* Return the binary exponent of X, which must be nonzero.  */
+__MATHDECL (int,ilogb,, (_Mdouble_ __x));
+#endif
+
+#ifdef __USE_ISOC99
+/* Return X times (2 to the Nth power).  */
+__MATHCALL (scalbln,, (_Mdouble_ __x, long int __n));
+
+/* Round X to integral value in floating-point format using current
+   rounding direction, but do not raise inexact exception.  */
+__MATHCALL (nearbyint,, (_Mdouble_ __x));
+
+/* Round X to nearest integral value, rounding halfway cases away from
+   zero.  */
+__MATHCALLX (round,, (_Mdouble_ __x), (__const__));
+
+/* Round X to the integral value in floating-point format nearest but
+   not larger in magnitude.  */
+__MATHCALLX (trunc,, (_Mdouble_ __x), (__const__));
+
+/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
+   and magnitude congruent `mod 2^n' to the magnitude of the integral
+   quotient x/y, with n >= 3.  */
+__MATHCALL (remquo,, (_Mdouble_ __x, _Mdouble_ __y, int *__quo));
+
+
+/* Conversion functions.  */
+
+/* Round X to nearest integral value according to current rounding
+   direction.  */
+__MATHDECL (long int,lrint,, (_Mdouble_ __x));
+__extension__
+__MATHDECL (long long int,llrint,, (_Mdouble_ __x));
+
+/* Round X to nearest integral value, rounding halfway cases away from
+   zero.  */
+__MATHDECL (long int,lround,, (_Mdouble_ __x));
+__extension__
+__MATHDECL (long long int,llround,, (_Mdouble_ __x));
+
+
+/* Return positive difference between X and Y.  */
+__MATHCALL (fdim,, (_Mdouble_ __x, _Mdouble_ __y));
+
+/* Return maximum numeric value from X and Y.  */
+__MATHCALLX (fmax,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
+
+/* Return minimum numeric value from X and Y.  */
+__MATHCALLX (fmin,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
+
+
+/* Classify given number.  */
+__MATHDECL_1 (int, __fpclassify,, (_Mdouble_ __value))
+     __attribute__ ((__const__));
+
+/* Test for negative number.  */
+__MATHDECL_1 (int, __signbit,, (_Mdouble_ __value))
+     __attribute__ ((__const__));
+
+
+/* Multiply-add function computed as a ternary operation.  */
+__MATHCALL (fma,, (_Mdouble_ __x, _Mdouble_ __y, _Mdouble_ __z));
+#endif /* Use ISO C99.  */
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_GNU
+/* Test for signaling NaN.  */
+__MATHDECL_1 (int, __issignaling,, (_Mdouble_ __value))
+     __attribute__ ((__const__));
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED
+/* Return X times (2 to the Nth power).  */
+__MATHCALL (scalb,, (_Mdouble_ __x, _Mdouble_ __n));
+#endif
diff --git a/include/bits/mathdef.h b/include/bits/mathdef.h
new file mode 100644
index 0000000..07c2d66
--- /dev/null
+++ b/include/bits/mathdef.h
@@ -0,0 +1,59 @@
+/* Copyright (C) 2001-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _MATH_H && !defined _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+#endif
+
+#if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+# define _MATH_H_MATHDEF	1
+
+# if defined __x86_64__ || (defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0)
+/* The x86-64 architecture computes values with the precission of the
+   used type.  Similarly for -m32 -mfpmath=sse.  */
+typedef float float_t;		/* `float' expressions are evaluated as `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated
+				   as `double'.  */
+# else
+/* The ix87 FPUs evaluate all values in the 80 bit floating-point format
+   which is also available for the user as `long double'.  Therefore we
+   define:  */
+typedef long double float_t;	/* `float' expressions are evaluated as
+				   `long double'.  */
+typedef long double double_t;	/* `double' expressions are evaluated as
+				   `long double'.  */
+# endif
+
+/* The values returned by `ilogb' for 0 and NaN respectively.  */
+# define FP_ILOGB0	(-2147483647 - 1)
+# define FP_ILOGBNAN	(-2147483647 - 1)
+
+/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
+   builtins are supported.  */
+# if __FP_FAST_FMA
+#  define FP_FAST_FMA 1
+# endif
+
+# if __FP_FAST_FMAF
+#  define FP_FAST_FMAF 1
+# endif
+
+# if __FP_FAST_FMAL
+#  define FP_FAST_FMAL 1
+# endif
+
+#endif	/* ISO C99 */
diff --git a/include/bits/mathinline.h b/include/bits/mathinline.h
new file mode 100644
index 0000000..b4b28f3
--- /dev/null
+++ b/include/bits/mathinline.h
@@ -0,0 +1,973 @@
+/* Inline math functions for i387 and SSE.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/mathinline.h> directly; include <math.h> instead."
+#endif
+
+#ifndef __extern_always_inline
+# define __MATH_INLINE __inline
+#else
+# define __MATH_INLINE __extern_always_inline
+#endif
+
+
+#if defined __USE_ISOC99 && defined __GNUC__ && __GNUC__ >= 2
+/* GCC 2.97 and up have builtins that actually can be used.  */
+# if !__GNUC_PREREQ (2,97)
+/* ISO C99 defines some macros to perform unordered comparisons.  The
+   ix87 FPU supports this with special opcodes and we should use them.
+   These must not be inline functions since we have to be able to handle
+   all floating-point types.  */
+#  undef isgreater
+#  undef isgreaterequal
+#  undef isless
+#  undef islessequal
+#  undef islessgreater
+#  undef isunordered
+#  ifdef __i686__
+/* For the PentiumPro and more recent processors we can provide
+   better code.  */
+#   define isgreater(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; seta %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+	__result; })
+#   define isgreaterequal(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; setae %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+	__result; })
+
+#   define isless(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; seta %%al"			      \
+		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st");	      \
+	__result; })
+
+#   define islessequal(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; setae %%al"			      \
+		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st");	      \
+	__result; })
+
+#   define islessgreater(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; setne %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+	__result; })
+
+#   define isunordered(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; setp %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+	__result; })
+#  else
+/* This is the dumb, portable code for i386 and above.  */
+#   define isgreater(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define isgreaterequal(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define isless(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define islessequal(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define islessgreater(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x44, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define isunordered(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; sahf; setp %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+	__result; })
+#  endif /* __i686__ */
+# endif	/* GCC 2.97 */
+
+/* The gcc, version 2.7 or below, has problems with all this inlining
+   code.  So disable it for this version of the compiler.  */
+# if __GNUC_PREREQ (2, 8)
+__BEGIN_NAMESPACE_C99
+
+/* Test for negative number.  Used in the signbit() macro.  */
+__MATH_INLINE int
+__NTH (__signbitf (float __x))
+{
+#  ifdef __SSE2_MATH__
+  int __m;
+  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
+  return (__m & 0x8) != 0;
+#  else
+  __extension__ union { float __f; int __i; } __u = { __f: __x };
+  return __u.__i < 0;
+#  endif
+}
+__MATH_INLINE int
+__NTH (__signbit (double __x))
+{
+#  ifdef __SSE2_MATH__
+  int __m;
+  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
+  return (__m & 0x80) != 0;
+#  else
+  __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
+  return __u.__i[1] < 0;
+#  endif
+}
+__MATH_INLINE int
+__NTH (__signbitl (long double __x))
+{
+  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
+  return (__u.__i[2] & 0x8000) != 0;
+}
+
+__END_NAMESPACE_C99
+# endif
+#endif
+
+
+/* The gcc, version 2.7 or below, has problems with all this inlining
+   code.  So disable it for this version of the compiler.  */
+#if __GNUC_PREREQ (2, 8)
+# if !__GNUC_PREREQ (3, 4) && !defined __NO_MATH_INLINES \
+     && defined __OPTIMIZE__
+/* GCC 3.4 introduced builtins for all functions below, so
+   there's no need to define any of these inline functions.  */
+
+#  ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+
+/* Round to nearest integer.  */
+#   ifdef __SSE_MATH__
+__MATH_INLINE long int
+__NTH (lrintf (float __x))
+{
+  long int __res;
+  /* Mark as volatile since the result is dependent on the state of
+     the SSE control register (the rounding mode).  Otherwise GCC might
+     remove these assembler instructions since it does not know about
+     the rounding mode change and cannot currently be told.  */
+  __asm __volatile__ ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
+  return __res;
+}
+#   endif
+#   ifdef __SSE2_MATH__
+__MATH_INLINE long int
+__NTH (lrint (double __x))
+{
+  long int __res;
+  /* Mark as volatile since the result is dependent on the state of
+     the SSE control register (the rounding mode).  Otherwise GCC might
+     remove these assembler instructions since it does not know about
+     the rounding mode change and cannot currently be told.  */
+  __asm __volatile__ ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
+  return __res;
+}
+#   endif
+#   ifdef __x86_64__
+__extension__
+__MATH_INLINE long long int
+__NTH (llrintf (float __x))
+{
+  long long int __res;
+  /* Mark as volatile since the result is dependent on the state of
+     the SSE control register (the rounding mode).  Otherwise GCC might
+     remove these assembler instructions since it does not know about
+     the rounding mode change and cannot currently be told.  */
+  __asm __volatile__ ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
+  return __res;
+}
+__extension__
+__MATH_INLINE long long int
+__NTH (llrint (double __x))
+{
+  long long int __res;
+  /* Mark as volatile since the result is dependent on the state of
+     the SSE control register (the rounding mode).  Otherwise GCC might
+     remove these assembler instructions since it does not know about
+     the rounding mode change and cannot currently be told.  */
+  __asm __volatile__ ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
+  return __res;
+}
+#   endif
+
+#   if defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ > 0 \
+       && defined __SSE2_MATH__
+/* Determine maximum of two values.  */
+__MATH_INLINE float
+__NTH (fmaxf (float __x, float __y))
+{
+#    ifdef __AVX__
+  float __res;
+  __asm ("vmaxss %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
+  return __res;
+#    else
+  __asm ("maxss %1, %0" : "+x" (__x) : "xm" (__y));
+  return __x;
+#    endif
+}
+__MATH_INLINE double
+__NTH (fmax (double __x, double __y))
+{
+#    ifdef __AVX__
+  float __res;
+  __asm ("vmaxsd %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
+  return __res;
+#    else
+  __asm ("maxsd %1, %0" : "+x" (__x) : "xm" (__y));
+  return __x;
+#    endif
+}
+
+/* Determine minimum of two values.  */
+__MATH_INLINE float
+__NTH (fminf (float __x, float __y))
+{
+#    ifdef __AVX__
+  float __res;
+  __asm ("vminss %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
+  return __res;
+#    else
+  __asm ("minss %1, %0" : "+x" (__x) : "xm" (__y));
+  return __x;
+#    endif
+}
+__MATH_INLINE double
+__NTH (fmin (double __x, double __y))
+{
+#    ifdef __AVX__
+  float __res;
+  __asm ("vminsd %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
+  return __res;
+#    else
+  __asm ("minsd %1, %0" : "+x" (__x) : "xm" (__y));
+  return __x;
+#    endif
+}
+#   endif
+
+__END_NAMESPACE_C99
+#  endif
+
+#  if defined __SSE4_1__ && defined __SSE2_MATH__
+#   if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+
+/* Round to nearest integer.  */
+__MATH_INLINE double
+__NTH (rint (double __x))
+{
+  double __res;
+  /* Mark as volatile since the result is dependent on the state of
+     the SSE control register (the rounding mode).  Otherwise GCC might
+     remove these assembler instructions since it does not know about
+     the rounding mode change and cannot currently be told.  */
+  __asm __volatile__ ("roundsd $4, %1, %0" : "=x" (__res) : "xm" (__x));
+  return __res;
+}
+__MATH_INLINE float
+__NTH (rintf (float __x))
+{
+  float __res;
+  /* Mark as volatile since the result is dependent on the state of
+     the SSE control register (the rounding mode).  Otherwise GCC might
+     remove these assembler instructions since it does not know about
+     the rounding mode change and cannot currently be told.  */
+  __asm __volatile__ ("roundss $4, %1, %0" : "=x" (__res) : "xm" (__x));
+  return __res;
+}
+
+#    ifdef __USE_ISOC99
+/* Round to nearest integer without raising inexact exception.  */
+__MATH_INLINE double
+__NTH (nearbyint (double __x))
+{
+  double __res;
+  /* Mark as volatile since the result is dependent on the state of
+     the SSE control register (the rounding mode).  Otherwise GCC might
+     remove these assembler instructions since it does not know about
+     the rounding mode change and cannot currently be told.  */
+  __asm __volatile__ ("roundsd $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
+  return __res;
+}
+__MATH_INLINE float
+__NTH (nearbyintf (float __x))
+{
+  float __res;
+  /* Mark as volatile since the result is dependent on the state of
+     the SSE control register (the rounding mode).  Otherwise GCC might
+     remove these assembler instructions since it does not know about
+     the rounding mode change and cannot currently be told.  */
+  __asm __volatile__ ("roundss $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
+  return __res;
+}
+#    endif
+
+__END_NAMESPACE_C99
+#   endif
+
+__BEGIN_NAMESPACE_STD
+/* Smallest integral value not less than X.  */
+__MATH_INLINE double
+__NTH (ceil (double __x))
+{
+  double __res;
+  __asm ("roundsd $2, %1, %0" : "=x" (__res) : "xm" (__x));
+  return __res;
+}
+__END_NAMESPACE_STD
+
+__BEGIN_NAMESPACE_C99
+__MATH_INLINE float
+__NTH (ceilf (float __x))
+{
+  float __res;
+  __asm ("roundss $2, %1, %0" : "=x" (__res) : "xm" (__x));
+  return __res;
+}
+__END_NAMESPACE_C99
+
+__BEGIN_NAMESPACE_STD
+/* Largest integer not greater than X.  */
+__MATH_INLINE double
+__NTH (floor (double __x))
+{
+  double __res;
+  __asm ("roundsd $1, %1, %0" : "=x" (__res) : "xm" (__x));
+  return __res;
+}
+__END_NAMESPACE_STD
+
+__BEGIN_NAMESPACE_C99
+__MATH_INLINE float
+__NTH (floorf (float __x))
+{
+  float __res;
+  __asm ("roundss $1, %1, %0" : "=x" (__res) : "xm" (__x));
+  return __res;
+}
+__END_NAMESPACE_C99
+#  endif
+# endif
+#endif
+
+#ifndef __SSE2_MATH__
+# if ((!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) \
+     && defined __OPTIMIZE__)
+
+/* The inline functions do not set errno or raise necessarily the
+   correct exceptions.  */
+#  undef math_errhandling
+
+/* A macro to define float, double, and long double versions of various
+   math functions for the ix87 FPU.  FUNC is the function name (which will
+   be suffixed with f and l for the float and long double version,
+   respectively).  OP is the name of the FPU operation.
+   We define two sets of macros.  The set with the additional NP
+   doesn't add a prototype declaration.  */
+
+#  if defined __USE_MISC || defined __USE_ISOC99
+#   define __inline_mathop(func, op) \
+  __inline_mathop_ (double, func, op)					      \
+  __inline_mathop_ (float, __CONCAT(func,f), op)			      \
+  __inline_mathop_ (long double, __CONCAT(func,l), op)
+#   define __inline_mathopNP(func, op) \
+  __inline_mathopNP_ (double, func, op)					      \
+  __inline_mathopNP_ (float, __CONCAT(func,f), op)			      \
+  __inline_mathopNP_ (long double, __CONCAT(func,l), op)
+#  else
+#   define __inline_mathop(func, op) \
+  __inline_mathop_ (double, func, op)
+#   define __inline_mathopNP(func, op) \
+  __inline_mathopNP_ (double, func, op)
+#  endif
+
+#  define __inline_mathop_(float_type, func, op) \
+  __inline_mathop_decl_ (float_type, func, op, "0" (__x))
+#  define __inline_mathopNP_(float_type, func, op) \
+  __inline_mathop_declNP_ (float_type, func, op, "0" (__x))
+
+
+#  if defined __USE_MISC || defined __USE_ISOC99
+#   define __inline_mathop_decl(func, op, params...) \
+  __inline_mathop_decl_ (double, func, op, params)			      \
+  __inline_mathop_decl_ (float, __CONCAT(func,f), op, params)		      \
+  __inline_mathop_decl_ (long double, __CONCAT(func,l), op, params)
+#   define __inline_mathop_declNP(func, op, params...) \
+  __inline_mathop_declNP_ (double, func, op, params)			      \
+  __inline_mathop_declNP_ (float, __CONCAT(func,f), op, params)		      \
+  __inline_mathop_declNP_ (long double, __CONCAT(func,l), op, params)
+#  else
+#   define __inline_mathop_decl(func, op, params...) \
+  __inline_mathop_decl_ (double, func, op, params)
+#   define __inline_mathop_declNP(func, op, params...) \
+  __inline_mathop_declNP_ (double, func, op, params)
+#  endif
+
+#  define __inline_mathop_decl_(float_type, func, op, params...) \
+  __MATH_INLINE float_type func (float_type) __THROW;			      \
+  __inline_mathop_declNP_ (float_type, func, op, params)
+
+#  define __inline_mathop_declNP_(float_type, func, op, params...) \
+  __MATH_INLINE float_type __NTH (func (float_type __x))		      \
+  {									      \
+    register float_type __result;					      \
+    __asm __volatile__ (op : "=t" (__result) : params);			      \
+    return __result;							      \
+  }
+
+
+#  if defined __USE_MISC || defined __USE_ISOC99
+#   define __inline_mathcode(func, arg, code) \
+  __inline_mathcode_ (double, func, arg, code)				      \
+  __inline_mathcode_ (float, __CONCAT(func,f), arg, code)		      \
+  __inline_mathcode_ (long double, __CONCAT(func,l), arg, code)
+#   define __inline_mathcodeNP(func, arg, code) \
+  __inline_mathcodeNP_ (double, func, arg, code)			      \
+  __inline_mathcodeNP_ (float, __CONCAT(func,f), arg, code)		      \
+  __inline_mathcodeNP_ (long double, __CONCAT(func,l), arg, code)
+#   define __inline_mathcode2(func, arg1, arg2, code) \
+  __inline_mathcode2_ (double, func, arg1, arg2, code)			      \
+  __inline_mathcode2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
+  __inline_mathcode2_ (long double, __CONCAT(func,l), arg1, arg2, code)
+#   define __inline_mathcodeNP2(func, arg1, arg2, code) \
+  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)		      \
+  __inline_mathcodeNP2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
+  __inline_mathcodeNP2_ (long double, __CONCAT(func,l), arg1, arg2, code)
+#   define __inline_mathcode3(func, arg1, arg2, arg3, code) \
+  __inline_mathcode3_ (double, func, arg1, arg2, arg3, code)		      \
+  __inline_mathcode3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)	      \
+  __inline_mathcode3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
+#   define __inline_mathcodeNP3(func, arg1, arg2, arg3, code) \
+  __inline_mathcodeNP3_ (double, func, arg1, arg2, arg3, code)		      \
+  __inline_mathcodeNP3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)     \
+  __inline_mathcodeNP3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
+#  else
+#   define __inline_mathcode(func, arg, code) \
+  __inline_mathcode_ (double, func, (arg), code)
+#   define __inline_mathcodeNP(func, arg, code) \
+  __inline_mathcodeNP_ (double, func, (arg), code)
+#   define __inline_mathcode2(func, arg1, arg2, code) \
+  __inline_mathcode2_ (double, func, arg1, arg2, code)
+#   define __inline_mathcodeNP2(func, arg1, arg2, code) \
+  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)
+#   define __inline_mathcode3(func, arg1, arg2, arg3, code) \
+  __inline_mathcode3_ (double, func, arg1, arg2, arg3, code)
+#   define __inline_mathcodeNP3(func, arg1, arg2, arg3, code) \
+  __inline_mathcodeNP3_ (double, func, arg1, arg2, arg3, code)
+#  endif
+
+#  define __inline_mathcode_(float_type, func, arg, code) \
+  __MATH_INLINE float_type func (float_type) __THROW;			      \
+  __inline_mathcodeNP_(float_type, func, arg, code)
+
+#  define __inline_mathcodeNP_(float_type, func, arg, code) \
+  __MATH_INLINE float_type __NTH (func (float_type arg))		      \
+  {									      \
+    code;								      \
+  }
+
+
+#  define __inline_mathcode2_(float_type, func, arg1, arg2, code) \
+  __MATH_INLINE float_type func (float_type, float_type) __THROW;	      \
+  __inline_mathcodeNP2_ (float_type, func, arg1, arg2, code)
+
+#  define __inline_mathcodeNP2_(float_type, func, arg1, arg2, code) \
+  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2))    \
+  {									      \
+    code;								      \
+  }
+
+#  define __inline_mathcode3_(float_type, func, arg1, arg2, arg3, code) \
+  __MATH_INLINE float_type func (float_type, float_type, float_type) __THROW; \
+  __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code)
+
+#  define __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code) \
+  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2,     \
+					float_type arg3))		      \
+  {									      \
+    code;								      \
+  }
+# endif
+
+
+# if !defined __NO_MATH_INLINES && defined __OPTIMIZE__
+/* Miscellaneous functions  */
+
+/* __FAST_MATH__ is defined by gcc -ffast-math.  */
+#  ifdef __FAST_MATH__
+#   ifdef __USE_GNU
+#    define __sincos_code \
+  register long double __cosr;						      \
+  register long double __sinr;						      \
+  register unsigned int __swtmp;					      \
+  __asm __volatile__							      \
+    ("fsincos\n\t"							      \
+     "fnstsw	%w2\n\t"						      \
+     "testl	$0x400, %2\n\t"						      \
+     "jz	1f\n\t"							      \
+     "fldpi\n\t"							      \
+     "fadd	%%st(0)\n\t"						      \
+     "fxch	%%st(1)\n\t"						      \
+     "2: fprem1\n\t"							      \
+     "fnstsw	%w2\n\t"						      \
+     "testl	$0x400, %2\n\t"						      \
+     "jnz	2b\n\t"							      \
+     "fstp	%%st(1)\n\t"						      \
+     "fsincos\n\t"							      \
+     "1:"								      \
+     : "=t" (__cosr), "=u" (__sinr), "=a" (__swtmp) : "0" (__x));	      \
+  *__sinx = __sinr;							      \
+  *__cosx = __cosr
+
+__MATH_INLINE void
+__NTH (__sincos (double __x, double *__sinx, double *__cosx))
+{
+  __sincos_code;
+}
+
+__MATH_INLINE void
+__NTH (__sincosf (float __x, float *__sinx, float *__cosx))
+{
+  __sincos_code;
+}
+
+__MATH_INLINE void
+__NTH (__sincosl (long double __x, long double *__sinx, long double *__cosx))
+{
+  __sincos_code;
+}
+#   endif
+
+
+/* Optimized inline implementation, sometimes with reduced precision
+   and/or argument range.  */
+
+#   if __GNUC_PREREQ (3, 5)
+#    define __expm1_code \
+  register long double __temp;						      \
+  __temp = __builtin_expm1l (__x);					      \
+  return __temp ? __temp : __x
+#   else
+#    define __expm1_code \
+  register long double __value;						      \
+  register long double __exponent;					      \
+  register long double __temp;						      \
+  __asm __volatile__							      \
+    ("fldl2e			# e^x - 1 = 2^(x * log2(e)) - 1\n\t"	      \
+     "fmul	%%st(1)		# x * log2(e)\n\t"			      \
+     "fst	%%st(1)\n\t"						      \
+     "frndint			# int(x * log2(e))\n\t"			      \
+     "fxch\n\t"								      \
+     "fsub	%%st(1)		# fract(x * log2(e))\n\t"		      \
+     "f2xm1			# 2^(fract(x * log2(e))) - 1\n\t"	      \
+     "fscale			# 2^(x * log2(e)) - 2^(int(x * log2(e)))\n\t" \
+     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
+  __asm __volatile__							      \
+    ("fscale			# 2^int(x * log2(e))\n\t"		      \
+     : "=t" (__temp) : "0" (1.0), "u" (__exponent));			      \
+  __temp -= 1.0;							      \
+  __temp += __value;							      \
+  return __temp ? __temp : __x
+#   endif
+__inline_mathcodeNP_ (long double, __expm1l, __x, __expm1_code)
+
+#   if __GNUC_PREREQ (3, 4)
+__inline_mathcodeNP_ (long double, __expl, __x, return __builtin_expl (__x))
+#   else
+#    define __exp_code \
+  register long double __value;						      \
+  register long double __exponent;					      \
+  __asm __volatile__							      \
+    ("fldl2e			# e^x = 2^(x * log2(e))\n\t"		      \
+     "fmul	%%st(1)		# x * log2(e)\n\t"			      \
+     "fst	%%st(1)\n\t"						      \
+     "frndint			# int(x * log2(e))\n\t"			      \
+     "fxch\n\t"								      \
+     "fsub	%%st(1)		# fract(x * log2(e))\n\t"		      \
+     "f2xm1			# 2^(fract(x * log2(e))) - 1\n\t"	      \
+     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
+  __value += 1.0;							      \
+  __asm __volatile__							      \
+    ("fscale"								      \
+     : "=t" (__value) : "0" (__value), "u" (__exponent));		      \
+  return __value
+__inline_mathcodeNP (exp, __x, __exp_code)
+__inline_mathcodeNP_ (long double, __expl, __x, __exp_code)
+#   endif
+
+
+#   if !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP (tan, __x, \
+  register long double __value;						      \
+  register long double __value2 __attribute__ ((__unused__));		      \
+  __asm __volatile__							      \
+    ("fptan"								      \
+     : "=t" (__value2), "=u" (__value) : "0" (__x));			      \
+  return __value)
+#   endif
+#  endif /* __FAST_MATH__ */
+
+
+#  if __GNUC_PREREQ (3, 4)
+__inline_mathcodeNP2_ (long double, __atan2l, __y, __x,
+		       return __builtin_atan2l (__y, __x))
+#  else
+#   define __atan2_code \
+  register long double __value;						      \
+  __asm __volatile__							      \
+    ("fpatan"								      \
+     : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)");		      \
+  return __value
+#   ifdef __FAST_MATH__
+__inline_mathcodeNP2 (atan2, __y, __x, __atan2_code)
+#   endif
+__inline_mathcodeNP2_ (long double, __atan2l, __y, __x, __atan2_code)
+#  endif
+
+
+#  if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP2 (fmod, __x, __y, \
+  register long double __value;						      \
+  __asm __volatile__							      \
+    ("1:	fprem\n\t"						      \
+     "fnstsw	%%ax\n\t"						      \
+     "sahf\n\t"								      \
+     "jp	1b"							      \
+     : "=t" (__value) : "0" (__x), "u" (__y) : "ax", "cc");		      \
+  return __value)
+#  endif
+
+
+#  ifdef __FAST_MATH__
+#   if !__GNUC_PREREQ (3,3)
+__inline_mathopNP (sqrt, "fsqrt")
+__inline_mathopNP_ (long double, __sqrtl, "fsqrt")
+#    define __libc_sqrtl(n) __sqrtl (n)
+#   else
+#    define __libc_sqrtl(n) __builtin_sqrtl (n)
+#   endif
+#  endif
+
+#  if __GNUC_PREREQ (2, 8)
+__inline_mathcodeNP_ (double, fabs, __x, return __builtin_fabs (__x))
+#   if defined __USE_MISC || defined __USE_ISOC99
+__inline_mathcodeNP_ (float, fabsf, __x, return __builtin_fabsf (__x))
+__inline_mathcodeNP_ (long double, fabsl, __x, return __builtin_fabsl (__x))
+#   endif
+__inline_mathcodeNP_ (long double, __fabsl, __x, return __builtin_fabsl (__x))
+#  else
+__inline_mathop (fabs, "fabs")
+__inline_mathop_ (long double, __fabsl, "fabs")
+# endif
+
+#  ifdef __FAST_MATH__
+#   if !__GNUC_PREREQ (3, 4)
+/* The argument range of this inline version is reduced.  */
+__inline_mathopNP (sin, "fsin")
+/* The argument range of this inline version is reduced.  */
+__inline_mathopNP (cos, "fcos")
+
+__inline_mathop_declNP (log, "fldln2; fxch; fyl2x", "0" (__x) : "st(1)")
+#   endif
+
+#   if !__GNUC_PREREQ (3, 5)
+__inline_mathop_declNP (log10, "fldlg2; fxch; fyl2x", "0" (__x) : "st(1)")
+
+__inline_mathcodeNP (asin, __x, return __atan2l (__x, __libc_sqrtl (1.0 - __x * __x)))
+__inline_mathcodeNP (acos, __x, return __atan2l (__libc_sqrtl (1.0 - __x * __x), __x))
+#   endif
+
+#   if !__GNUC_PREREQ (3, 4)
+__inline_mathop_declNP (atan, "fld1; fpatan", "0" (__x) : "st(1)")
+#   endif
+#  endif /* __FAST_MATH__ */
+
+__inline_mathcode_ (long double, __sgn1l, __x, \
+  __extension__ union { long double __xld; unsigned int __xi[3]; } __n =      \
+    { __xld: __x };							      \
+  __n.__xi[2] = (__n.__xi[2] & 0x8000) | 0x3fff;			      \
+  __n.__xi[1] = 0x80000000;						      \
+  __n.__xi[0] = 0;							      \
+  return __n.__xld)
+
+
+#  ifdef __FAST_MATH__
+/* The argument range of the inline version of sinhl is slightly reduced.  */
+__inline_mathcodeNP (sinh, __x, \
+  register long double __exm1 = __expm1l (__fabsl (__x));		      \
+  return 0.5 * (__exm1 / (__exm1 + 1.0) + __exm1) * __sgn1l (__x))
+
+__inline_mathcodeNP (cosh, __x, \
+  register long double __ex = __expl (__x);				      \
+  return 0.5 * (__ex + 1.0 / __ex))
+
+__inline_mathcodeNP (tanh, __x, \
+  register long double __exm1 = __expm1l (-__fabsl (__x + __x));	      \
+  return __exm1 / (__exm1 + 2.0) * __sgn1l (-__x))
+#  endif
+
+__inline_mathcodeNP (floor, __x, \
+  register long double __value;						      \
+  register int __ignore;						      \
+  unsigned short int __cw;						      \
+  unsigned short int __cwtmp;						      \
+  __asm __volatile ("fnstcw %3\n\t"					      \
+		    "movzwl %3, %1\n\t"					      \
+		    "andl $0xf3ff, %1\n\t"				      \
+		    "orl $0x0400, %1\n\t"	/* rounding down */	      \
+		    "movw %w1, %2\n\t"					      \
+		    "fldcw %2\n\t"					      \
+		    "frndint\n\t"					      \
+		    "fldcw %3"						      \
+		    : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp),	      \
+		      "=m" (__cw)					      \
+		    : "0" (__x));					      \
+  return __value)
+
+__inline_mathcodeNP (ceil, __x, \
+  register long double __value;						      \
+  register int __ignore;						      \
+  unsigned short int __cw;						      \
+  unsigned short int __cwtmp;						      \
+  __asm __volatile ("fnstcw %3\n\t"					      \
+		    "movzwl %3, %1\n\t"					      \
+		    "andl $0xf3ff, %1\n\t"				      \
+		    "orl $0x0800, %1\n\t"	/* rounding up */	      \
+		    "movw %w1, %2\n\t"					      \
+		    "fldcw %2\n\t"					      \
+		    "frndint\n\t"					      \
+		    "fldcw %3"						      \
+		    : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp),	      \
+		      "=m" (__cw)					      \
+		    : "0" (__x));					      \
+  return __value)
+
+#  ifdef __FAST_MATH__
+#   define __ldexp_code \
+  register long double __value;						      \
+  __asm __volatile__							      \
+    ("fscale"								      \
+     : "=t" (__value) : "0" (__x), "u" ((long double) __y));		      \
+  return __value
+
+__MATH_INLINE double
+__NTH (ldexp (double __x, int __y))
+{
+  __ldexp_code;
+}
+#  endif
+
+
+/* Optimized versions for some non-standardized functions.  */
+#  if defined __USE_ISOC99 || defined __USE_MISC
+
+#   ifdef __FAST_MATH__
+__inline_mathcodeNP (expm1, __x, __expm1_code)
+
+/* We cannot rely on M_SQRT being defined.  So we do it for ourself
+   here.  */
+#    define __M_SQRT2	1.41421356237309504880L	/* sqrt(2) */
+
+#    if !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP (log1p, __x, \
+  register long double __value;						      \
+  if (__fabsl (__x) >= 1.0 - 0.5 * __M_SQRT2)				      \
+    __value = logl (1.0 + __x);						      \
+  else									      \
+    __asm __volatile__							      \
+      ("fldln2\n\t"							      \
+       "fxch\n\t"							      \
+       "fyl2xp1"							      \
+       : "=t" (__value) : "0" (__x) : "st(1)");				      \
+  return __value)
+#    endif
+
+
+/* The argument range of the inline version of asinhl is slightly reduced.  */
+__inline_mathcodeNP (asinh, __x, \
+  register long double  __y = __fabsl (__x);				      \
+  return (log1pl (__y * __y / (__libc_sqrtl (__y * __y + 1.0) + 1.0) + __y)   \
+	  * __sgn1l (__x)))
+
+__inline_mathcodeNP (acosh, __x, \
+  return logl (__x + __libc_sqrtl (__x - 1.0) * __libc_sqrtl (__x + 1.0)))
+
+__inline_mathcodeNP (atanh, __x, \
+  register long double __y = __fabsl (__x);				      \
+  return -0.5 * log1pl (-(__y + __y) / (1.0 + __y)) * __sgn1l (__x))
+
+/* The argument range of the inline version of hypotl is slightly reduced.  */
+__inline_mathcodeNP2 (hypot, __x, __y,
+		      return __libc_sqrtl (__x * __x + __y * __y))
+
+#    if !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP(logb, __x, \
+  register long double __value;						      \
+  register long double __junk;						      \
+  __asm __volatile__							      \
+    ("fxtract\n\t"							      \
+     : "=t" (__junk), "=u" (__value) : "0" (__x));			      \
+  return __value)
+#    endif
+
+#   endif
+#  endif
+
+#  ifdef __USE_ISOC99
+#   ifdef __FAST_MATH__
+
+#    if !__GNUC_PREREQ (3, 5)
+__inline_mathop_declNP (log2, "fld1; fxch; fyl2x", "0" (__x) : "st(1)")
+#    endif
+
+__MATH_INLINE float
+__NTH (ldexpf (float __x, int __y))
+{
+  __ldexp_code;
+}
+
+__MATH_INLINE long double
+__NTH (ldexpl (long double __x, int __y))
+{
+  __ldexp_code;
+}
+
+__inline_mathopNP (rint, "frndint")
+#   endif /* __FAST_MATH__ */
+
+#   define __lrint_code \
+  long int __lrintres;							      \
+  __asm__ __volatile__							      \
+    ("fistpl %0"							      \
+     : "=m" (__lrintres) : "t" (__x) : "st");				      \
+  return __lrintres
+__MATH_INLINE long int
+__NTH (lrintf (float __x))
+{
+  __lrint_code;
+}
+__MATH_INLINE long int
+__NTH (lrint (double __x))
+{
+  __lrint_code;
+}
+__MATH_INLINE long int
+__NTH (lrintl (long double __x))
+{
+  __lrint_code;
+}
+#   undef __lrint_code
+
+#   define __llrint_code \
+  long long int __llrintres;						      \
+  __asm__ __volatile__							      \
+    ("fistpll %0"							      \
+     : "=m" (__llrintres) : "t" (__x) : "st");				      \
+  return __llrintres
+__extension__
+__MATH_INLINE long long int
+__NTH (llrintf (float __x))
+{
+  __llrint_code;
+}
+__extension__
+__MATH_INLINE long long int
+__NTH (llrint (double __x))
+{
+  __llrint_code;
+}
+__extension__
+__MATH_INLINE long long int
+__NTH (llrintl (long double __x))
+{
+  __llrint_code;
+}
+#   undef __llrint_code
+
+# endif
+
+
+#  ifdef __USE_MISC
+
+#   if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP2 (drem, __x, __y, \
+  register double __value;						      \
+  register int __clobbered;						      \
+  __asm __volatile__							      \
+    ("1:	fprem1\n\t"						      \
+     "fstsw	%%ax\n\t"						      \
+     "sahf\n\t"								      \
+     "jp	1b"							      \
+     : "=t" (__value), "=&a" (__clobbered) : "0" (__x), "u" (__y) : "cc");    \
+  return __value)
+#  endif
+
+
+/* This function is used in the `isfinite' macro.  */
+__MATH_INLINE int
+__NTH (__finite (double __x))
+{
+  return (__extension__
+	  (((((union { double __d; int __i[2]; }) {__d: __x}).__i[1]
+	     | 0x800fffffu) + 1) >> 31));
+}
+
+#  endif /* __USE_MISC  */
+
+/* Undefine some of the large macros which are not used anymore.  */
+#  undef __atan2_code
+#  ifdef __FAST_MATH__
+#   undef __expm1_code
+#   undef __exp_code
+#   undef __sincos_code
+#  endif /* __FAST_MATH__ */
+
+# endif /* __NO_MATH_INLINES  */
+
+
+/* This code is used internally in the GNU libc.  */
+# ifdef __LIBC_INTERNAL_MATH_INLINES
+__inline_mathop (__ieee754_sqrt, "fsqrt")
+__inline_mathcode2 (__ieee754_atan2, __y, __x,
+		    register long double __value;
+		    __asm __volatile__ ("fpatan\n\t"
+					: "=t" (__value)
+					: "0" (__x), "u" (__y) : "st(1)");
+		    return __value;)
+# endif
+
+#endif /* !__SSE2_MATH__ */
diff --git a/include/bits/mman.h b/include/bits/mman.h
new file mode 100644
index 0000000..360f0d0
--- /dev/null
+++ b/include/bits/mman.h
@@ -0,0 +1,96 @@
+/* Definitions for BSD-style memory management.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* These are the bits used by 4.4 BSD and its derivatives.  On systems
+   (such as GNU) where these facilities are not system services but can be
+   emulated in the C library, these are the definitions we emulate.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define	PROT_NONE	 0x00	/* No access.  */
+#define	PROT_READ	 0x04	/* Pages can be read.  */
+#define	PROT_WRITE	 0x02	/* Pages can be written.  */
+#define	PROT_EXEC	 0x01	/* Pages can be executed.  */
+
+/* Flags contain mapping type, sharing type and options.  */
+
+/* Mapping type (must choose one and only one of these).  */
+#ifdef __USE_BSD
+# define MAP_FILE	 0x0001	/* Mapped from a file or device.  */
+# define MAP_ANON	 0x0002	/* Allocated from anonymous virtual memory.  */
+# define MAP_TYPE	 0x000f	/* Mask for type field.  */
+# ifdef __USE_MISC
+#  define MAP_ANONYMOUS  MAP_ANON /* Linux name. */
+# endif
+#endif
+
+/* Sharing types (must choose one and only one of these).  */
+#ifdef __USE_BSD
+# define MAP_COPY	 0x0020	/* Virtual copy of region at mapping time.  */
+#endif
+#define	MAP_SHARED	 0x0010	/* Share changes.  */
+#define	MAP_PRIVATE	 0x0000	/* Changes private; copy pages on write.  */
+
+/* Other flags.  */
+#define	MAP_FIXED	 0x0100	/* Map address must be exactly as requested. */
+#ifdef __USE_BSD
+# define MAP_NOEXTEND	 0x0200	/* For MAP_FILE, don't change file size.  */
+# define MAP_HASSEMPHORE 0x0400	/* Region may contain semaphores.  */
+# define MAP_INHERIT	 0x0800	/* Region is retained after exec.  */
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		0		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1		/* Mapping address may change.  */
+# define MREMAP_FIXED	2		/* Fifth argument sets new address.  */
+#endif
+
+/* Flags for `mlockall' (can be OR'd together).  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
diff --git a/include/bits/monetary-ldbl.h b/include/bits/monetary-ldbl.h
new file mode 100644
index 0000000..9cd2a24
--- /dev/null
+++ b/include/bits/monetary-ldbl.h
@@ -0,0 +1,27 @@
+/* -mlong-double-64 compatibility mode for monetary functions.
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MONETARY_H
+# error "Never include <bits/monetary-ldbl.h> directly; use <monetary.h> instead."
+#endif
+
+__LDBL_REDIR_DECL (strfmon)
+
+#ifdef __USE_GNU
+__LDBL_REDIR_DECL (strfmon_l)
+#endif
diff --git a/include/bits/mqueue.h b/include/bits/mqueue.h
new file mode 100644
index 0000000..c04e780
--- /dev/null
+++ b/include/bits/mqueue.h
@@ -0,0 +1,30 @@
+/* Copyright (C) 2004-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MQUEUE_H
+# error "Never use <bits/mqueue.h> directly; include <mqueue.h> instead."
+#endif
+
+typedef int mqd_t;
+
+struct mq_attr
+{
+  long int mq_flags;	/* Message queue flags.  */
+  long int mq_maxmsg;	/* Maximum number of messages.  */
+  long int mq_msgsize;	/* Maximum message size.  */
+  long int mq_curmsgs;	/* Number of messages currently queued.  */
+};
diff --git a/include/bits/mqueue2.h b/include/bits/mqueue2.h
new file mode 100644
index 0000000..d1a5ea9
--- /dev/null
+++ b/include/bits/mqueue2.h
@@ -0,0 +1,57 @@
+/* Checking macros for mq functions.
+   Copyright (C) 2007-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_FCNTL_H
+# error "Never include <bits/mqueue2.h> directly; use <mqueue.h> instead."
+#endif
+
+/* Check that calls to mq_open with O_CREAT set have an appropriate third and fourth
+   parameter.  */
+extern mqd_t mq_open (const char *__name, int __oflag, ...)
+     __THROW __nonnull ((1));
+extern mqd_t __mq_open_2 (const char *__name, int __oflag)
+     __THROW __nonnull ((1));
+extern mqd_t __REDIRECT_NTH (__mq_open_alias, (const char *__name,
+					       int __oflag, ...), mq_open)
+     __nonnull ((1));
+__errordecl (__mq_open_wrong_number_of_args,
+	     "mq_open can be called either with 2 or 4 arguments");
+__errordecl (__mq_open_missing_mode_and_attr,
+	     "mq_open with O_CREAT in second argument needs 4 arguments");
+
+__fortify_function mqd_t
+__NTH (mq_open (const char *__name, int __oflag, ...))
+{
+  if (__va_arg_pack_len () != 0 && __va_arg_pack_len () != 2)
+    __mq_open_wrong_number_of_args ();
+
+  if (__builtin_constant_p (__oflag))
+    {
+      if ((__oflag & O_CREAT) != 0 && __va_arg_pack_len () == 0)
+	{
+	  __mq_open_missing_mode_and_attr ();
+	  return __mq_open_2 (__name, __oflag);
+	}
+      return __mq_open_alias (__name, __oflag, __va_arg_pack ());
+    }
+
+  if (__va_arg_pack_len () == 0)
+    return __mq_open_2 (__name, __oflag);
+
+  return __mq_open_alias (__name, __oflag, __va_arg_pack ());
+}
diff --git a/include/bits/msq.h b/include/bits/msq.h
new file mode 100644
index 0000000..cd3f1d8
--- /dev/null
+++ b/include/bits/msq.h
@@ -0,0 +1,76 @@
+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_MSG_H
+# error "Never use <bits/msq.h> directly; include <sys/msg.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <bits/ipctypes.h>
+
+/* Define options for message queue functions.  */
+#define MSG_NOERROR	010000	/* no error if message is too big */
+#ifdef __USE_GNU
+# define MSG_EXCEPT	020000	/* recv any msg except of specified type */
+#endif
+
+/* Types used in the structure definition.  */
+typedef unsigned short int msgqnum_t;
+typedef unsigned short int msglen_t;
+
+
+/* Structure of record for one message inside the kernel.
+   The type `struct msg' is opaque.  */
+struct msqid_ds
+{
+  struct ipc_perm msg_perm;	/* structure describing operation permission */
+  struct msg *__msg_first;	/* pointer to first message on queue */
+  struct msg *__msg_last;	/* pointer to last message on queue */
+  __time_t msg_stime;		/* time of last msgsnd command */
+  __time_t msg_rtime;		/* time of last msgrcv command */
+  __time_t msg_ctime;		/* time of last change */
+  struct wait_queue *__wwait;	/* ??? */
+  struct wait_queue *__rwait;	/* ??? */
+  unsigned short int __msg_cbytes;/* current number of bytes on queue */
+  msgqnum_t msg_qnum;		/* number of messages currently on queue */
+  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
+  __ipc_pid_t msg_lspid;	/* pid of last msgsnd() */
+  __ipc_pid_t msg_lrpid;	/* pid of last msgrcv() */
+};
+
+#ifdef __USE_MISC
+
+# define msg_cbytes	__msg_cbytes
+
+/* ipcs ctl commands */
+# define MSG_STAT 11
+# define MSG_INFO 12
+
+/* buffer for msgctl calls IPC_INFO, MSG_INFO */
+struct msginfo
+  {
+    int msgpool;
+    int msgmap;
+    int msgmax;
+    int msgmnb;
+    int msgmni;
+    int msgssz;
+    int msgtql;
+    unsigned short int msgseg;
+  };
+
+#endif /* __USE_MISC */
diff --git a/include/bits/mutex-attr.h b/include/bits/mutex-attr.h
new file mode 100644
index 0000000..f3d0752
--- /dev/null
+++ b/include/bits/mutex-attr.h
@@ -0,0 +1,41 @@
+/* Mutex attribute type.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_MUTEX_ATTR_H
+#define _BITS_MUTEX_ATTR_H	1
+
+enum __pthread_mutex_protocol;
+enum __pthread_process_shared;
+enum __pthread_mutex_type;
+
+/* This structure describes the attributes of a POSIX mutex
+   attribute.  */
+struct __pthread_mutexattr
+{
+  int __prioceiling;
+  enum __pthread_mutex_protocol __protocol;
+  enum __pthread_process_shared __pshared;
+  enum __pthread_mutex_type __mutex_type;
+};
+
+/* Attributes for a recursive mutex.  */
+extern const struct __pthread_mutexattr __pthread_errorcheck_mutexattr;
+extern const struct __pthread_mutexattr __pthread_recursive_mutexattr;
+
+#endif /* bits/mutex-attr.h */
diff --git a/include/bits/mutex.h b/include/bits/mutex.h
new file mode 100644
index 0000000..3120237
--- /dev/null
+++ b/include/bits/mutex.h
@@ -0,0 +1,75 @@
+/* Mutex type.  Generic version.
+
+   Copyright (C) 2000, 2002, 2005, 2006, 2007, 2008, 2009
+     Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_MUTEX_H
+
+#ifndef __need_pthread_mutex
+# define _BITS_MUTEX_H	1
+#endif
+
+#ifndef __pthread_mutex_defined
+# if defined __need_pthread_mutex || defined _BITS_MUTEX_H
+#  undef __need_pthread_mutex
+#  define __pthread_mutex_defined
+
+#  include <bits/spin-lock.h>
+#  include <bits/mutex-attr.h>
+
+/* User visible part of a mutex.  */
+struct __pthread_mutex
+  {
+    __pthread_spinlock_t __held;
+    __pthread_spinlock_t __lock;
+    /* In cthreads, mutex_init does not initialized thre third
+       pointer, as such, we cannot rely on its value for anything.  */
+    char *__cthreadscompat1;
+    struct __pthread *__queue;
+    struct __pthread_mutexattr *__attr;
+    void *__data;
+    /*  Up to this point, we are completely compatible with cthreads
+	and what libc expects.  */
+    void *__owner;
+    unsigned __locks;
+    /* If NULL then the default attributes apply.  */
+  };
+
+/* Initializer for a mutex.  N.B.  this also happens to be compatible
+   with the cthread mutex initializer.  */
+#  define __PTHREAD_MUTEX_INITIALIZER \
+    { __PTHREAD_SPIN_LOCK_INITIALIZER, __PTHREAD_SPIN_LOCK_INITIALIZER, 0, 0, 0, 0, 0, 0 }
+
+#  define __PTHREAD_ERRORCHECK_MUTEXATTR ((struct __pthread_mutexattr *) ((unsigned long) __PTHREAD_MUTEX_ERRORCHECK + 1))
+
+#  define __PTHREAD_ERRORCHECK_MUTEX_INITIALIZER \
+    { __PTHREAD_SPIN_LOCK_INITIALIZER, __PTHREAD_SPIN_LOCK_INITIALIZER, 0, 0,	\
+	__PTHREAD_ERRORCHECK_MUTEXATTR, 0, 0, 0 }
+
+#  define __PTHREAD_RECURSIVE_MUTEXATTR ((struct __pthread_mutexattr *) ((unsigned long) __PTHREAD_MUTEX_RECURSIVE + 1))
+
+#  define __PTHREAD_RECURSIVE_MUTEX_INITIALIZER \
+    { __PTHREAD_SPIN_LOCK_INITIALIZER, __PTHREAD_SPIN_LOCK_INITIALIZER, 0, 0,	\
+	__PTHREAD_RECURSIVE_MUTEXATTR, 0, 0, 0 }
+
+# endif
+#endif /* Not __pthread_mutex_defined.  */
+
+#endif /* bits/mutex.h */
diff --git a/include/bits/nan.h b/include/bits/nan.h
new file mode 100644
index 0000000..f0704da
--- /dev/null
+++ b/include/bits/nan.h
@@ -0,0 +1,52 @@
+/* `NAN' constant for IEEE 754 machines.
+   Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/nan.h> directly; include <math.h> instead."
+#endif
+
+
+/* IEEE Not A Number.  */
+
+#if __GNUC_PREREQ(3,3)
+
+# define NAN	(__builtin_nanf (""))
+
+#elif defined __GNUC__
+
+# define NAN \
+  (__extension__							      \
+   ((union { unsigned __l __attribute__ ((__mode__ (__SI__))); float __d; })  \
+    { __l: 0x7fc00000UL }).__d)
+
+#else
+
+# include <endian.h>
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __qnan_bytes		{ 0x7f, 0xc0, 0, 0 }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __qnan_bytes		{ 0, 0, 0xc0, 0x7f }
+# endif
+
+static union { unsigned char __c[4]; float __d; } __qnan_union
+  __attribute__ ((__unused__)) = { __qnan_bytes };
+# define NAN	(__qnan_union.__d)
+
+#endif	/* GCC.  */
diff --git a/include/bits/netdb.h b/include/bits/netdb.h
new file mode 100644
index 0000000..daf5a41
--- /dev/null
+++ b/include/bits/netdb.h
@@ -0,0 +1,32 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NETDB_H
+# error "Never include <bits/netdb.h> directly; use <netdb.h> instead."
+#endif
+
+
+/* Description of data base entry for a single network.  NOTE: here a
+   poor assumption is made.  The network number is expected to fit
+   into an unsigned long int variable.  */
+struct netent
+{
+  char *n_name;			/* Official name of network.  */
+  char **n_aliases;		/* Alias list.  */
+  int n_addrtype;		/* Net address type.  */
+  uint32_t n_net;		/* Network number.  */
+};
diff --git a/include/bits/once.h b/include/bits/once.h
new file mode 100644
index 0000000..05895b9
--- /dev/null
+++ b/include/bits/once.h
@@ -0,0 +1,34 @@
+/* Dynamic package initialization data structures.  Generic version.
+   Copyright (C) 2002, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_ONCE_H
+#define _BITS_ONCE_H	1
+
+#include <bits/spin-lock.h>
+
+struct __pthread_once
+{
+  int __run;
+  __pthread_spinlock_t __lock;
+};
+
+#define __PTHREAD_ONCE_INIT \
+	{ 0, __PTHREAD_SPIN_LOCK_INITIALIZER }
+
+#endif /* bits/once.h */
diff --git a/include/bits/param.h b/include/bits/param.h
new file mode 100644
index 0000000..dac789c
--- /dev/null
+++ b/include/bits/param.h
@@ -0,0 +1,85 @@
+/* Old-style Unix parameters and limits.  Hurd version.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_PARAM_H
+# error "Never use <bits/param.h> directly; include <sys/param.h> instead."
+#endif
+
+/* This file is deprecated and is provided only for compatibility with
+   Unix systems.  It is unwise to include this file on programs which
+   are intended only for GNU systems.
+
+   Parts from:
+
+ * Copyright (c) 1982, 1986, 1989 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)param.h	7.23 (Berkeley) 5/6/91
+ */
+
+
+/* What versions of BSD we are compatible with.  */
+#define	BSD	199306		/* System version (year & month). */
+#define BSD4_3	1
+#define BSD4_4	1
+
+#define	GNU	1994100		/* GNU version (year, month, and release).  */
+
+
+/* BSD names for some <limits.h> values.  We do not define the BSD names
+   for the values which are not statically limited, such as NOFILE.  */
+
+
+/* There is nothing quite equivalent in GNU to Unix "mounts", but there is
+   no limit on the number of simultaneously attached filesystems.  */
+#define NMOUNT		INT_MAX
+
+
+/* Scale factor for scaled integers used to count %cpu time and load avgs.
+
+   The number of CPU `tick's that map to a unique `%age' can be expressed
+   by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
+   can be calculated (assuming 32 bits) can be closely approximated using
+   the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).  */
+
+#define	FSHIFT	11		/* Bits to right of fixed binary point.  */
+#define FSCALE	(1<<FSHIFT)
diff --git a/include/bits/poll.h b/include/bits/poll.h
new file mode 100644
index 0000000..9cf0117
--- /dev/null
+++ b/include/bits/poll.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_POLL_H
+# error "Never use <bits/poll.h> directly; include <sys/poll.h> instead."
+#endif
+
+/* Event types that can be polled for.  These bits may be set in `events'
+   to indicate the interesting event types; they will appear in `revents'
+   to indicate the status of the file descriptor.  */
+#define POLLIN		01              /* There is data to read.  */
+#define POLLPRI		02              /* There is urgent data to read.  */
+#define POLLOUT		04              /* Writing now will not block.  */
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K8
+/* These values are defined in XPG4.2 and later.  */
+# define POLLRDNORM	POLLIN		/* Normal data may be read.  */
+# define POLLRDBAND	POLLPRI		/* Priority data may be read.  */
+# define POLLWRNORM	POLLOUT		/* Writing now will not block.  */
+# define POLLWRBAND	POLLOUT		/* Priority data may be written.  */
+#endif
+
+/* Event types always implicitly polled for.  These bits need not be set in
+   `events', but they will appear in `revents' to indicate the status of
+   the file descriptor.  */
+#define POLLERR         010             /* Error condition.  */
+#define POLLHUP         020             /* Hung up.  */
+#define POLLNVAL        040             /* Invalid polling request.  */
diff --git a/include/bits/poll2.h b/include/bits/poll2.h
new file mode 100644
index 0000000..cc303ce
--- /dev/null
+++ b/include/bits/poll2.h
@@ -0,0 +1,81 @@
+/* Checking macros for poll functions.
+   Copyright (C) 2012-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_POLL_H
+# error "Never include <bits/poll2.h> directly; use <sys/poll.h> instead."
+#endif
+
+
+__BEGIN_DECLS
+
+extern int __REDIRECT (__poll_alias, (struct pollfd *__fds, nfds_t __nfds,
+				      int __timeout), poll);
+extern int __poll_chk (struct pollfd *__fds, nfds_t __nfds, int __timeout,
+		       __SIZE_TYPE__ __fdslen);
+extern int __REDIRECT (__poll_chk_warn, (struct pollfd *__fds, nfds_t __nfds,
+					 int __timeout, __SIZE_TYPE__ __fdslen),
+		       __poll_chk)
+  __warnattr ("poll called with fds buffer too small file nfds entries");
+
+__fortify_function int
+poll (struct pollfd *__fds, nfds_t __nfds, int __timeout)
+{
+  if (__bos (__fds) != (__SIZE_TYPE__) -1)
+    {
+      if (! __builtin_constant_p (__nfds))
+	return __poll_chk (__fds, __nfds, __timeout, __bos (__fds));
+      else if (__bos (__fds) / sizeof (*__fds) < __nfds)
+	return __poll_chk_warn (__fds, __nfds, __timeout, __bos (__fds));
+    }
+
+  return __poll_alias (__fds, __nfds, __timeout);
+}
+
+
+#ifdef __USE_GNU
+extern int __REDIRECT (__ppoll_alias, (struct pollfd *__fds, nfds_t __nfds,
+				       const struct timespec *__timeout,
+				       const __sigset_t *__ss), ppoll);
+extern int __ppoll_chk (struct pollfd *__fds, nfds_t __nfds,
+			const struct timespec *__timeout,
+			const __sigset_t *__ss, __SIZE_TYPE__ __fdslen);
+extern int __REDIRECT (__ppoll_chk_warn, (struct pollfd *__fds, nfds_t __nfds,
+					  const struct timespec *__timeout,
+					  const __sigset_t *__ss,
+					  __SIZE_TYPE__ __fdslen),
+		       __ppoll_chk)
+  __warnattr ("ppoll called with fds buffer too small file nfds entries");
+
+__fortify_function int
+ppoll (struct pollfd *__fds, nfds_t __nfds, const struct timespec *__timeout,
+       const __sigset_t *__ss)
+{
+  if (__bos (__fds) != (__SIZE_TYPE__) -1)
+    {
+      if (! __builtin_constant_p (__nfds))
+	return __ppoll_chk (__fds, __nfds, __timeout, __ss, __bos (__fds));
+      else if (__bos (__fds) / sizeof (*__fds) < __nfds)
+	return __ppoll_chk_warn (__fds, __nfds, __timeout, __ss,
+				 __bos (__fds));
+    }
+
+  return __ppoll_alias (__fds, __nfds, __timeout, __ss);
+}
+#endif
+
+__END_DECLS
diff --git a/include/bits/posix1_lim.h b/include/bits/posix1_lim.h
new file mode 100644
index 0000000..97f018d
--- /dev/null
+++ b/include/bits/posix1_lim.h
@@ -0,0 +1,175 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
+ *
+ *	Never include this file directly; use <limits.h> instead.
+ */
+
+#ifndef	_BITS_POSIX1_LIM_H
+#define	_BITS_POSIX1_LIM_H	1
+
+
+/* These are the standard-mandated minimum values.  */
+
+/* Minimum number of operations in one list I/O call.  */
+#define _POSIX_AIO_LISTIO_MAX	2
+
+/* Minimal number of outstanding asynchronous I/O operations.  */
+#define _POSIX_AIO_MAX		1
+
+/* Maximum length of arguments to `execve', including environment.  */
+#define	_POSIX_ARG_MAX		4096
+
+/* Maximum simultaneous processes per real user ID.  */
+#ifdef __USE_XOPEN2K
+# define _POSIX_CHILD_MAX	25
+#else
+# define _POSIX_CHILD_MAX	6
+#endif
+
+/* Minimal number of timer expiration overruns.  */
+#define _POSIX_DELAYTIMER_MAX	32
+
+/* Maximum length of a host name (not including the terminating null)
+   as returned from the GETHOSTNAME function.  */
+#define _POSIX_HOST_NAME_MAX	255
+
+/* Maximum link count of a file.  */
+#define	_POSIX_LINK_MAX		8
+
+/* Maximum length of login name.  */
+#define	_POSIX_LOGIN_NAME_MAX	9
+
+/* Number of bytes in a terminal canonical input queue.  */
+#define	_POSIX_MAX_CANON	255
+
+/* Number of bytes for which space will be
+   available in a terminal input queue.  */
+#define	_POSIX_MAX_INPUT	255
+
+/* Maximum number of message queues open for a process.  */
+#define _POSIX_MQ_OPEN_MAX	8
+
+/* Maximum number of supported message priorities.  */
+#define _POSIX_MQ_PRIO_MAX	32
+
+/* Number of bytes in a filename.  */
+#define	_POSIX_NAME_MAX		14
+
+/* Number of simultaneous supplementary group IDs per process.  */
+#ifdef __USE_XOPEN2K
+# define _POSIX_NGROUPS_MAX	8
+#else
+# define _POSIX_NGROUPS_MAX	0
+#endif
+
+/* Number of files one process can have open at once.  */
+#ifdef __USE_XOPEN2K
+# define _POSIX_OPEN_MAX	20
+#else
+# define _POSIX_OPEN_MAX	16
+#endif
+
+#if !defined __USE_XOPEN2K || defined __USE_GNU
+/* Number of descriptors that a process may examine with `pselect' or
+   `select'.  */
+# define _POSIX_FD_SETSIZE	_POSIX_OPEN_MAX
+#endif
+
+/* Number of bytes in a pathname.  */
+#define	_POSIX_PATH_MAX		256
+
+/* Number of bytes than can be written atomically to a pipe.  */
+#define	_POSIX_PIPE_BUF		512
+
+/* The number of repeated occurrences of a BRE permitted by the
+   REGEXEC and REGCOMP functions when using the interval notation.  */
+#define _POSIX_RE_DUP_MAX	255
+
+/* Minimal number of realtime signals reserved for the application.  */
+#define _POSIX_RTSIG_MAX	8
+
+/* Number of semaphores a process can have.  */
+#define _POSIX_SEM_NSEMS_MAX	256
+
+/* Maximal value of a semaphore.  */
+#define _POSIX_SEM_VALUE_MAX	32767
+
+/* Number of pending realtime signals.  */
+#define _POSIX_SIGQUEUE_MAX	32
+
+/* Largest value of a `ssize_t'.  */
+#define	_POSIX_SSIZE_MAX	32767
+
+/* Number of streams a process can have open at once.  */
+#define	_POSIX_STREAM_MAX	8
+
+/* The number of bytes in a symbolic link.  */
+#define _POSIX_SYMLINK_MAX	255
+
+/* The number of symbolic links that can be traversed in the
+   resolution of a pathname in the absence of a loop.  */
+#define _POSIX_SYMLOOP_MAX	8
+
+/* Number of timer for a process.  */
+#define _POSIX_TIMER_MAX	32
+
+/* Maximum number of characters in a tty name.  */
+#define	_POSIX_TTY_NAME_MAX	9
+
+/* Maximum length of a timezone name (element of `tzname').  */
+#ifdef __USE_XOPEN2K
+# define _POSIX_TZNAME_MAX	6
+#else
+# define _POSIX_TZNAME_MAX	3
+#endif
+
+#if !defined __USE_XOPEN2K || defined __USE_GNU
+/* Maximum number of connections that can be queued on a socket.  */
+# define _POSIX_QLIMIT		1
+
+/* Maximum number of bytes that can be buffered on a socket for send
+   or receive.  */
+# define _POSIX_HIWAT		_POSIX_PIPE_BUF
+
+/* Maximum number of elements in an `iovec' array.  */
+# define _POSIX_UIO_MAXIOV	16
+#endif
+
+/* Maximum clock resolution in nanoseconds.  */
+#define _POSIX_CLOCKRES_MIN	20000000
+
+
+/* Get the implementation-specific values for the above.  */
+#include <bits/local_lim.h>
+
+
+#ifndef	SSIZE_MAX
+# define SSIZE_MAX	LONG_MAX
+#endif
+
+
+/* This value is a guaranteed minimum maximum.
+   The current maximum can be got from `sysconf'.  */
+
+#ifndef	NGROUPS_MAX
+# define NGROUPS_MAX	8
+#endif
+
+#endif	/* bits/posix1_lim.h  */
diff --git a/include/bits/posix2_lim.h b/include/bits/posix2_lim.h
new file mode 100644
index 0000000..0dbdf1e
--- /dev/null
+++ b/include/bits/posix2_lim.h
@@ -0,0 +1,90 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Never include this file directly; include <limits.h> instead.
+ */
+
+#ifndef	_BITS_POSIX2_LIM_H
+#define	_BITS_POSIX2_LIM_H	1
+
+
+/* The maximum `ibase' and `obase' values allowed by the `bc' utility.  */
+#define	_POSIX2_BC_BASE_MAX		99
+
+/* The maximum number of elements allowed in an array by the `bc' utility.  */
+#define	_POSIX2_BC_DIM_MAX		2048
+
+/* The maximum `scale' value allowed by the `bc' utility.  */
+#define	_POSIX2_BC_SCALE_MAX		99
+
+/* The maximum length of a string constant accepted by the `bc' utility.  */
+#define	_POSIX2_BC_STRING_MAX		1000
+
+/* The maximum number of weights that can be assigned to an entry of
+   the LC_COLLATE `order' keyword in the locale definition file.  */
+#define	_POSIX2_COLL_WEIGHTS_MAX	2
+
+/* The maximum number of expressions that can be nested
+   within parentheses by the `expr' utility.  */
+#define	_POSIX2_EXPR_NEST_MAX		32
+
+/* The maximum length, in bytes, of an input line.  */
+#define	_POSIX2_LINE_MAX		2048
+
+/* The maximum number of repeated occurrences of a regular expression
+   permitted when using the interval notation `\{M,N\}'.  */
+#define	_POSIX2_RE_DUP_MAX		255
+
+/* The maximum number of bytes in a character class name.  We have no
+   fixed limit, 2048 is a high number.  */
+#define	_POSIX2_CHARCLASS_NAME_MAX	14
+
+
+/* These values are implementation-specific,
+   and may vary within the implementation.
+   Their precise values can be obtained from sysconf.  */
+
+#ifndef	BC_BASE_MAX
+#define	BC_BASE_MAX		_POSIX2_BC_BASE_MAX
+#endif
+#ifndef	BC_DIM_MAX
+#define	BC_DIM_MAX		_POSIX2_BC_DIM_MAX
+#endif
+#ifndef	BC_SCALE_MAX
+#define	BC_SCALE_MAX		_POSIX2_BC_SCALE_MAX
+#endif
+#ifndef	BC_STRING_MAX
+#define	BC_STRING_MAX		_POSIX2_BC_STRING_MAX
+#endif
+#ifndef	COLL_WEIGHTS_MAX
+#define	COLL_WEIGHTS_MAX	255
+#endif
+#ifndef	EXPR_NEST_MAX
+#define	EXPR_NEST_MAX		_POSIX2_EXPR_NEST_MAX
+#endif
+#ifndef	LINE_MAX
+#define	LINE_MAX		_POSIX2_LINE_MAX
+#endif
+#ifndef	CHARCLASS_NAME_MAX
+#define	CHARCLASS_NAME_MAX	2048
+#endif
+
+/* This value is defined like this in regex.h.  */
+#define	RE_DUP_MAX (0x7fff)
+
+#endif	/* bits/posix2_lim.h */
diff --git a/include/bits/posix_opt.h b/include/bits/posix_opt.h
new file mode 100644
index 0000000..9ab9c9f
--- /dev/null
+++ b/include/bits/posix_opt.h
@@ -0,0 +1,196 @@
+/* Define POSIX options for GNU/Hurd.
+   Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _UNISTD_H
+#error "Never include this file directly; use <unistd.h> instead."
+#endif
+
+#ifndef	_BITS_POSIX_OPT_H
+#define	_BITS_POSIX_OPT_H	1
+
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is not supported.  */
+#undef	_POSIX_PRIORITY_SCHEDULING
+
+/* Synchronizing file data is supported, but msync is missing.  */
+#undef _POSIX_SYNCHRONIZED_IO
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	200809L
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	200809L
+
+/* Locking of all memory could be supported in future.  */
+#define	_POSIX_MEMLOCK	0
+
+/* Locking of ranges of memory is supported.  */
+#define	_POSIX_MEMLOCK_RANGE	200809L
+
+/* Setting of memory protections is supported.  */
+#define	_POSIX_MEMORY_PROTECTION	200809L
+
+/* Elements of the `c_cc' member of `struct termios' structure
+   can be disabled by using the value _POSIX_VDISABLE.  */
+#define _POSIX_VDISABLE			((unsigned char) -1)
+
+
+/* Different Hurd filesystems might do these differently.
+   You must query the particular file with `pathconf' or `fpathconf'.  */
+#undef _POSIX_CHOWN_RESTRICTED	/* Only root can change owner of file?  */
+#undef _POSIX_NO_TRUNC		/* Overlong file names get error?  */
+#undef _POSIX_SYNC_IO		/* File supports O_SYNC et al?  */
+
+/* X/Open realtime support is not supported.  */
+#undef _XOPEN_REALTIME
+
+/* X/Open thread realtime support is not supported.  */
+#undef _XOPEN_REALTIME_THREADS
+
+/* XPG4.2 shared memory is supported.  */
+#define _XOPEN_SHM      1
+
+/* Tell we have POSIX threads.  */
+#define _POSIX_THREADS	200112L
+
+/* We have the reentrant functions described in POSIX.  */
+#define _POSIX_REENTRANT_FUNCTIONS      1
+#define _POSIX_THREAD_SAFE_FUNCTIONS	200809L
+
+/* We do not provide priority scheduling for threads.  */
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	-1
+
+/* We support user-defined stack sizes.  */
+#define _POSIX_THREAD_ATTR_STACKSIZE	200112L
+
+/* We support user-defined stacks.  */
+#define _POSIX_THREAD_ATTR_STACKADDR	200112L
+
+/* We do not support priority inheritence.  */
+#define _POSIX_THREAD_PRIO_INHERIT		-1
+
+/* We do not support priority protection.  */
+#define _POSIX_THREAD_PRIO_PROTECT		-1
+
+#ifdef __USE_XOPEN2K8
+/* We do not support priority inheritence for robust mutexes.  */
+# define _POSIX_THREAD_ROBUST_PRIO_INHERIT	-1
+
+/* We do not support priority protection for robust mutexes.  */
+# define _POSIX_THREAD_ROBUST_PRIO_PROTECT	-1
+#endif
+
+/* We support POSIX.1b semaphores.  */
+#define _POSIX_SEMAPHORES			200112L
+
+/* Real-time signals are not yet supported.  */
+#define _POSIX_REALTIME_SIGNALS	-1
+
+/* Asynchronous I/O might supported with the existing ABI.  */
+#define _POSIX_ASYNCHRONOUS_IO	0
+#undef _POSIX_ASYNC_IO
+/* Alternative name for Unix98.  */
+#define _LFS_ASYNCHRONOUS_IO	_POSIX_ASYNCHRONOUS_IO
+/* Support for prioritization is not available.  */
+#undef _POSIX_PRIORITIZED_IO
+
+/* The LFS support in asynchronous I/O is also available.  */
+#define _LFS64_ASYNCHRONOUS_IO	_POSIX_ASYNCHRONOUS_IO
+
+/* The rest of the LFS is also available.  */
+#define _LFS_LARGEFILE		1
+#define _LFS64_LARGEFILE	1
+#define _LFS64_STDIO		1
+
+/* POSIX.4 shared memory objects are supported (using regular files).  */
+#define _POSIX_SHARED_MEMORY_OBJECTS	_POSIX_MAPPED_FILES
+
+/* CPU-time clocks support needs to be checked at runtime.  */
+#define _POSIX_CPUTIME	0
+
+/* Clock support in threads must be also checked at runtime.  */
+#define _POSIX_THREAD_CPUTIME	0
+
+/* GNU libc provides regular expression handling.  */
+#define _POSIX_REGEXP	1
+
+/* Reader/Writer locks are available.  */
+#define _POSIX_READER_WRITER_LOCKS	200112L
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* We support the Timeouts option.  */
+#define _POSIX_TIMEOUTS	200112L
+
+/* We support spinlocks.  */
+#define _POSIX_SPIN_LOCKS	200112L
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200809L
+
+/* We do not have POSIX timers, but could in future without ABI change.  */
+#define _POSIX_TIMERS	0
+
+/* We support barrier functions.  */
+#define _POSIX_BARRIERS	200112L
+
+/* POSIX message queues could be available in future.  */
+#define	_POSIX_MESSAGE_PASSING	0
+
+/* Thread process-shared synchronization is not supported.  */
+#define _POSIX_THREAD_PROCESS_SHARED	-1
+
+/* The monotonic clock might be available.  */
+#define _POSIX_MONOTONIC_CLOCK	0
+
+/* The clock selection interfaces are available.  */
+#define _POSIX_CLOCK_SELECTION	200809L
+
+/* Advisory information interfaces could be available in future.  */
+#define _POSIX_ADVISORY_INFO	0
+
+/* IPv6 support is available.  */
+#define _POSIX_IPV6	200809L
+
+/* Raw socket support is available.  */
+#define _POSIX_RAW_SOCKETS	200809L
+
+/* We have at least one terminal.  */
+#define _POSIX2_CHAR_TERM	200809L
+
+/* Neither process nor thread sporadic server interfaces is available.  */
+#define _POSIX_SPORADIC_SERVER	-1
+#define _POSIX_THREAD_SPORADIC_SERVER	-1
+
+/* trace.h is not available.  */
+#define _POSIX_TRACE	-1
+#define _POSIX_TRACE_EVENT_FILTER	-1
+#define _POSIX_TRACE_INHERIT	-1
+#define _POSIX_TRACE_LOG	-1
+
+/* Typed memory objects are not available.  */
+#define _POSIX_TYPED_MEMORY_OBJECTS	-1
+
+#endif /* bits/posix_opt.h */
diff --git a/include/bits/printf-ldbl.h b/include/bits/printf-ldbl.h
new file mode 100644
index 0000000..5669fae
--- /dev/null
+++ b/include/bits/printf-ldbl.h
@@ -0,0 +1,23 @@
+/* -mlong-double-64 compatibility mode for <printf.h> functions.
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _PRINTF_H
+# error "Never include <bits/printf-ldbl.h> directly; use <printf.h> instead."
+#endif
+
+__LDBL_REDIR_DECL (printf_size)
diff --git a/include/bits/pthread-np.h b/include/bits/pthread-np.h
new file mode 100644
index 0000000..4487ffd
--- /dev/null
+++ b/include/bits/pthread-np.h
@@ -0,0 +1,38 @@
+/* Non-portable functions. Hurd on Mach version.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * Never include this file directly; use <pthread.h> or <cthreads.h> instead.
+ */
+
+#ifndef _BITS_PTHREAD_NP_H
+#define _BITS_PTHREAD_NP_H	1
+
+/* Same as pthread_cond_wait, but for Hurd-specific cancellation.
+   See hurd_thread_cancel.  */
+extern int pthread_hurd_cond_wait_np (pthread_cond_t *__restrict __cond,
+				      pthread_mutex_t *__restrict __mutex);
+
+/* Same as pthread_cond_timedwait, but for Hurd-specific cancellation.
+   See hurd_thread_cancel.  */
+extern int pthread_hurd_cond_timedwait_np (pthread_cond_t *__restrict __cond,
+					   pthread_mutex_t *__restrict __mutex,
+					   const struct timespec *__abstime);
+
+#endif /* bits/pthread-np.h */
diff --git a/include/bits/pthread.h b/include/bits/pthread.h
new file mode 100644
index 0000000..80e6b09
--- /dev/null
+++ b/include/bits/pthread.h
@@ -0,0 +1,38 @@
+/* Pthread data structures.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_PTHREAD_H
+#define _BITS_PTHREAD_H	1
+
+typedef int __pthread_t;
+
+/* Return true if __T1 and __T2 both name the same thread.  Otherwise,
+   false.  */
+extern int
+__pthread_equal (__pthread_t __t1, __pthread_t __t2);
+
+#ifdef __USE_EXTERN_INLINES
+__extern_inline int
+__pthread_equal (__pthread_t __t1, __pthread_t __t2)
+{
+  return __t1 == __t2;
+}
+#endif
+
+#endif /* bits/pthread.h */
diff --git a/include/bits/pthreadtypes.h b/include/bits/pthreadtypes.h
new file mode 100644
index 0000000..70368ff
--- /dev/null
+++ b/include/bits/pthreadtypes.h
@@ -0,0 +1,29 @@
+/* 
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#if !defined _BITS_TYPES_H && !defined _PTHREAD_H
+# error "Never include <bits/pthreadtypes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H    1
+
+#include <pthread/pthreadtypes.h>
+
+#endif /* bits/pthreadtypes.h */
diff --git a/include/bits/resource.h b/include/bits/resource.h
new file mode 100644
index 0000000..5574a7a
--- /dev/null
+++ b/include/bits/resource.h
@@ -0,0 +1,192 @@
+/* Bit values & structures for resource limits.  4.4 BSD/generic GNU version.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* These are the values for 4.4 BSD and GNU.  Earlier BSD systems have a
+   subset of these kinds of resource limit.  In systems where `getrlimit'
+   and `setrlimit' are not system calls, these are the values used by the C
+   library to emulate them.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+  {
+    /* Per-process CPU limit, in seconds.  */
+    RLIMIT_CPU,
+#define	RLIMIT_CPU	RLIMIT_CPU
+    /* Largest file that can be created, in bytes.  */
+    RLIMIT_FSIZE,
+#define	RLIMIT_FSIZE	RLIMIT_FSIZE
+    /* Maximum size of data segment, in bytes.  */
+    RLIMIT_DATA,
+#define	RLIMIT_DATA	RLIMIT_DATA
+    /* Maximum size of stack segment, in bytes.  */
+    RLIMIT_STACK,
+#define	RLIMIT_STACK	RLIMIT_STACK
+    /* Largest core file that can be created, in bytes.  */
+    RLIMIT_CORE,
+#define	RLIMIT_CORE	RLIMIT_CORE
+    /* Largest resident set size, in bytes.
+       This affects swapping; processes that are exceeding their
+       resident set size will be more likely to have physical memory
+       taken from them.  */
+    RLIMIT_RSS,
+#define	RLIMIT_RSS	RLIMIT_RSS
+    /* Locked-in-memory address space.  */
+    RLIMIT_MEMLOCK,
+#define	RLIMIT_MEMLOCK	RLIMIT_MEMLOCK
+    /* Number of processes.  */
+    RLIMIT_NPROC,
+#define	RLIMIT_NPROC	RLIMIT_NPROC
+    /* Number of open files.  */
+    RLIMIT_OFILE,
+    RLIMIT_NOFILE = RLIMIT_OFILE, /* Another name for the same thing.  */
+#define	RLIMIT_OFILE	RLIMIT_OFILE
+#define	RLIMIT_NOFILE	RLIMIT_NOFILE
+    /* Maximum size of all socket buffers.  */
+    RLIMIT_SBSIZE,
+#define RLIMIT_SBSIZE	RLIMIT_SBSIZE
+    /* Maximum size in bytes of the process address space.  */
+    RLIMIT_AS,
+    RLIMIT_VMEM = RLIMIT_AS,	/* Another name for the same thing.  */
+#define RLIMIT_AS	RLIMIT_AS
+#define RLIMIT_VMEM	RLIMIT_AS
+
+    RLIMIT_NLIMITS,		/* Number of limit flavors.  */
+    RLIM_NLIMITS = RLIMIT_NLIMITS /* Traditional name for same.  */
+  };
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY 0x7fffffff
+#else
+# define RLIM_INFINITY 0x7fffffffffffffffLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0x7fffffffffffffffLL
+#endif
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+/* The macro definitions are necessary because some programs want
+   to test for operating system features with #ifdef RUSAGE_SELF.
+   In ISO C the reflexive definition is a no-op.  */
+  {
+    /* The calling process.  */
+    RUSAGE_SELF = 0,
+#define RUSAGE_SELF     RUSAGE_SELF
+    /* All of its terminated child processes.  */
+    RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+  };
+
+#define __need_timeval
+#include <bits/time.h>           /* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN        -20     /* Minimum priority a process can have.  */
+#define PRIO_MAX        20      /* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+  {
+    PRIO_PROCESS = 0,           /* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+    PRIO_PGRP = 1,              /* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+    PRIO_USER = 2               /* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+  };
diff --git a/include/bits/rwlock-attr.h b/include/bits/rwlock-attr.h
new file mode 100644
index 0000000..e78b91e
--- /dev/null
+++ b/include/bits/rwlock-attr.h
@@ -0,0 +1,32 @@
+/* Thread rwlock attribute type.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_RWLOCK_ATTR_H
+#define _BITS_RWLOCK_ATTR_H	1
+
+enum __pthread_process_shared;
+
+/* This structure describes the attributes of a POSIX thread rwlock.
+   Note that not all of them are supported on all systems.  */
+struct __pthread_rwlockattr
+{
+  enum __pthread_process_shared __pshared;
+};
+
+#endif /* bits/rwlock-attr.h */
diff --git a/include/bits/rwlock.h b/include/bits/rwlock.h
new file mode 100644
index 0000000..bc27726
--- /dev/null
+++ b/include/bits/rwlock.h
@@ -0,0 +1,46 @@
+/* rwlock type.  Generic version.
+   Copyright (C) 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_RWLOCK_H
+#define _BITS_RWLOCK_H
+
+#include <bits/spin-lock.h>
+
+/* User visible part of a rwlock.  If __held is not held and readers
+   is 0, then the lock is unlocked.  If __held is held and readers is
+   0, then the lock is held by a writer.  If __held is held and
+   readers is greater than 0, then the lock is held by READERS
+   readers.  */
+struct __pthread_rwlock
+  {
+    __pthread_spinlock_t __held;
+    __pthread_spinlock_t __lock;
+    int __readers;
+    struct __pthread *__readerqueue;
+    struct __pthread *__writerqueue;
+    struct __pthread_rwlockattr *__attr;
+    void *__data;
+  };
+
+/* Initializer for a rwlock.  */
+#define __PTHREAD_RWLOCK_INITIALIZER \
+    { __PTHREAD_SPIN_LOCK_INITIALIZER, __PTHREAD_SPIN_LOCK_INITIALIZER, 0, 0, 0, 0, 0 }
+
+
+#endif /* bits/rwlock.h */
diff --git a/include/bits/sched.h b/include/bits/sched.h
new file mode 100644
index 0000000..e79db04
--- /dev/null
+++ b/include/bits/sched.h
@@ -0,0 +1,151 @@
+/* Definitions of constants and data structure for POSIX 1003.1b-1993
+   scheduling interface.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef __need_schedparam
+
+#ifndef _SCHED_H
+# error "Never include <bits/sched.h> directly; use <sched.h> instead."
+#endif
+
+
+/* Scheduling algorithms.  */
+#define SCHED_OTHER	0
+#define SCHED_FIFO	1
+#define SCHED_RR	2
+
+/* Data structure to describe a process' schedulability.  */
+struct sched_param
+{
+  int __sched_priority;
+};
+
+#endif	/* need schedparam */
+
+#if !defined __defined_schedparam \
+    && (defined __need_schedparam || defined _SCHED_H)
+# define __defined_schedparam	1
+/* Data structure to describe a process' schedulability.  */
+struct __sched_param
+  {
+    int __sched_priority;
+  };
+# undef __need_schedparam
+#endif
+
+
+#if defined _SCHED_H && !defined __cpu_set_t_defined
+# define __cpu_set_t_defined
+/* Size definition for CPU sets.  */
+# define __CPU_SETSIZE	1024
+# define __NCPUBITS	(8 * sizeof (__cpu_mask))
+
+/* Type for array elements in 'cpu_set_t'.  */
+typedef unsigned long int __cpu_mask;
+
+/* Basic access functions.  */
+# define __CPUELT(cpu)	((cpu) / __NCPUBITS)
+# define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))
+
+/* Data structure to describe CPU mask.  */
+typedef struct
+{
+  __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
+} cpu_set_t;
+
+/* Access functions for CPU masks.  */
+# if __GNUC_PREREQ (2, 91)
+#  define __CPU_ZERO_S(setsize, cpusetp) \
+  do __builtin_memset (cpusetp, '\0', setsize); while (0)
+# else
+#  define __CPU_ZERO_S(setsize, cpusetp) \
+  do {									      \
+    size_t __i;								      \
+    size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+    __cpu_mask *__bits = (cpusetp)->__bits;				      \
+    for (__i = 0; __i < __imax; ++__i)					      \
+      __bits[__i] = 0;							      \
+  } while (0)
+# endif
+# define __CPU_SET_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
+	 |= __CPUMASK (__cpu))						      \
+      : 0; }))
+# define __CPU_CLR_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
+	 &= ~__CPUMASK (__cpu))						      \
+      : 0; }))
+# define __CPU_ISSET_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? ((((const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]      \
+	  & __CPUMASK (__cpu))) != 0					      \
+      : 0; }))
+
+# define __CPU_COUNT_S(setsize, cpusetp) \
+  __sched_cpucount (setsize, cpusetp)
+
+# if __GNUC_PREREQ (2, 91)
+#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+  (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)
+# else
+#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+  (__extension__							      \
+   ({ const __cpu_mask *__arr1 = (cpusetp1)->__bits;			      \
+      const __cpu_mask *__arr2 = (cpusetp2)->__bits;			      \
+      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+      size_t __i;							      \
+      for (__i = 0; __i < __imax; ++__i)				      \
+	if (__arr1[__i] != __arr2[__i])					      \
+	  break;							      \
+      __i == __imax; }))
+# endif
+
+# define __CPU_OP_S(setsize, destset, srcset1, srcset2, op) \
+  (__extension__							      \
+   ({ cpu_set_t *__dest = (destset);					      \
+      const __cpu_mask *__arr1 = (srcset1)->__bits;			      \
+      const __cpu_mask *__arr2 = (srcset2)->__bits;			      \
+      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+      size_t __i;							      \
+      for (__i = 0; __i < __imax; ++__i)				      \
+	((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i];    \
+      __dest; }))
+
+# define __CPU_ALLOC_SIZE(count) \
+  ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))
+# define __CPU_ALLOC(count) __sched_cpualloc (count)
+# define __CPU_FREE(cpuset) __sched_cpufree (cpuset)
+
+__BEGIN_DECLS
+
+extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
+     __THROW;
+extern cpu_set_t *__sched_cpualloc (size_t __count) __THROW __wur;
+extern void __sched_cpufree (cpu_set_t *__set) __THROW;
+
+__END_DECLS
+
+#endif
diff --git a/include/bits/select.h b/include/bits/select.h
new file mode 100644
index 0000000..6e9c4f1
--- /dev/null
+++ b/include/bits/select.h
@@ -0,0 +1,63 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SELECT_H
+# error "Never use <bits/select.h> directly; include <sys/select.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+# if __WORDSIZE == 64
+#  define __FD_ZERO_STOS "stosq"
+# else
+#  define __FD_ZERO_STOS "stosl"
+# endif
+
+# define __FD_ZERO(fdsp) \
+  do {									      \
+    int __d0, __d1;							      \
+    __asm__ __volatile__ ("cld; rep; " __FD_ZERO_STOS			      \
+			  : "=c" (__d0), "=D" (__d1)			      \
+			  : "a" (0), "0" (sizeof (fd_set)		      \
+					  / sizeof (__fd_mask)),	      \
+			    "1" (&__FDS_BITS (fdsp)[0])			      \
+			  : "memory");					      \
+  } while (0)
+
+#else	/* ! GNU CC */
+
+/* We don't use `memset' because this would require a prototype and
+   the array isn't too big.  */
+# define __FD_ZERO(set)  \
+  do {									      \
+    unsigned int __i;							      \
+    fd_set *__arr = (set);						      \
+    for (__i = 0; __i < sizeof (fd_set) / sizeof (__fd_mask); ++__i)	      \
+      __FDS_BITS (__arr)[__i] = 0;					      \
+  } while (0)
+
+#endif	/* GNU CC */
+
+#define __FD_SET(d, set) \
+  ((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))
+#define __FD_CLR(d, set) \
+  ((void) (__FDS_BITS (set)[__FD_ELT (d)] &= ~__FD_MASK (d)))
+#define __FD_ISSET(d, set) \
+  ((__FDS_BITS (set)[__FD_ELT (d)] & __FD_MASK (d)) != 0)
diff --git a/include/bits/select2.h b/include/bits/select2.h
new file mode 100644
index 0000000..8906ba1
--- /dev/null
+++ b/include/bits/select2.h
@@ -0,0 +1,35 @@
+/* Checking macros for select functions.
+   Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SELECT_H
+# error "Never include <bits/select2.h> directly; use <sys/select.h> instead."
+#endif
+
+/* Helper functions to issue warnings and errors when needed.  */
+extern long int __fdelt_chk (long int __d);
+extern long int __fdelt_warn (long int __d)
+  __warnattr ("bit outside of fd_set selected");
+#undef __FD_ELT
+#define	__FD_ELT(d) \
+  __extension__								    \
+  ({ long int __d = (d);						    \
+     (__builtin_constant_p (__d)					    \
+      ? (0 <= __d && __d < __FD_SETSIZE					    \
+	 ? (__d / __NFDBITS)						    \
+	 : __fdelt_warn (__d))						    \
+      : __fdelt_chk (__d)); })
diff --git a/include/bits/sem.h b/include/bits/sem.h
new file mode 100644
index 0000000..4f2e02c
--- /dev/null
+++ b/include/bits/sem.h
@@ -0,0 +1,87 @@
+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SEM_H
+# error "Never include <bits/sem.h> directly; use <sys/sem.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* Flags for `semop'.  */
+#define SEM_UNDO	0x1000		/* undo the operation on exit */
+
+/* Commands for `semctl'.  */
+#define GETPID		11		/* get sempid */
+#define GETVAL		12		/* get semval */
+#define GETALL		13		/* get all semval's */
+#define GETNCNT		14		/* get semncnt */
+#define GETZCNT		15		/* get semzcnt */
+#define SETVAL		16		/* set semval */
+#define SETALL		17		/* set all semval's */
+
+
+/* Data structure describing a set of semaphores.  */
+struct semid_ds
+{
+  struct ipc_perm sem_perm;		/* operation permission struct */
+  __time_t sem_otime;			/* last semop() time */
+  __time_t sem_ctime;			/* last time changed by semctl() */
+  struct sem *__sembase;		/* ptr to first semaphore in array */
+  struct __sem_queue *__sem_pending;	/* pending operations */
+  struct __sem_queue *__sem_pending_last;/* last pending operation */
+  struct __sem_undo *__undo;		/* ondo requests on this array */
+  unsigned short int sem_nsems;		/* number of semaphores in set */
+};
+
+
+/* The user should define a union like the following to use it for arguments
+   for `semctl'.
+
+   union semun
+   {
+     int val;				<= value for SETVAL
+     struct semid_ds *buf;		<= buffer for IPC_STAT & IPC_SET
+     unsigned short int *array;		<= array for GETALL & SETALL
+     struct seminfo *__buf;		<= buffer for IPC_INFO
+   };
+
+   Previous versions of this file used to define this union but this is
+   incorrect.  One can test the macro _SEM_SEMUN_UNDEFINED to see whether
+   one must define the union or not.  */
+#define _SEM_SEMUN_UNDEFINED	1
+
+#ifdef __USE_MISC
+
+/* ipcs ctl cmds */
+# define SEM_STAT 18
+# define SEM_INFO 19
+
+struct  seminfo
+{
+  int semmap;
+  int semmni;
+  int semmns;
+  int semmnu;
+  int semmsl;
+  int semopm;
+  int semume;
+  int semusz;
+  int semvmx;
+  int semaem;
+};
+
+#endif /* __USE_MISC */
diff --git a/include/bits/semaphore.h b/include/bits/semaphore.h
new file mode 100644
index 0000000..4c78409
--- /dev/null
+++ b/include/bits/semaphore.h
@@ -0,0 +1,44 @@
+/* Semaphore type.  Generic version.
+   Copyright (C) 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_SEMAPHORE_H
+#define _BITS_SEMAPHORE_H	1
+
+#ifndef _SEMAPHORE_H
+#error Never include <bits/semaphore.h> directly.
+#endif
+
+#include <bits/spin-lock.h>
+#include <bits/pthread.h>
+
+/* User visible part of a semaphore.  */
+struct __semaphore
+  {
+    __pthread_spinlock_t __lock;
+    struct __pthread *__queue;
+    int __pshared;
+    int __value;
+    void *__data;
+  };
+
+/* Initializer for a semaphore.  */
+#define __SEMAPHORE_INITIALIZER(pshared, value) \
+  { __PTHREAD_SPIN_LOCK_INITIALIZER, NULL, (pshared), (value), NULL }
+
+#endif /* bits/mutex.h */
diff --git a/include/bits/setjmp.h b/include/bits/setjmp.h
new file mode 100644
index 0000000..a261eb7
--- /dev/null
+++ b/include/bits/setjmp.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 2001-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Define the machine-dependent type `jmp_buf'.  x86-64 version.  */
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H  1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#ifndef _ASM
+
+# if __WORDSIZE == 64
+typedef long int __jmp_buf[8];
+# elif defined  __x86_64__
+__extension__ typedef long long int __jmp_buf[8];
+# else
+typedef int __jmp_buf[6];
+# endif
+
+#endif
+
+#endif  /* bits/setjmp.h */
diff --git a/include/bits/setjmp2.h b/include/bits/setjmp2.h
new file mode 100644
index 0000000..fb335a8
--- /dev/null
+++ b/include/bits/setjmp2.h
@@ -0,0 +1,40 @@
+/* Checking macros for setjmp functions.
+   Copyright (C) 2009-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SETJMP_H
+# error "Never include <bits/setjmp2.h> directly; use <setjmp.h> instead."
+#endif
+
+/* Variant of the longjmp functions which perform some sanity checking.  */
+#ifdef __REDIRECT_NTH
+extern void __REDIRECT_NTHNL (longjmp,
+			      (struct __jmp_buf_tag __env[1], int __val),
+			      __longjmp_chk) __attribute__ ((__noreturn__));
+extern void __REDIRECT_NTHNL (_longjmp,
+			      (struct __jmp_buf_tag __env[1], int __val),
+			      __longjmp_chk) __attribute__ ((__noreturn__));
+extern void __REDIRECT_NTHNL (siglongjmp,
+			      (struct __jmp_buf_tag __env[1], int __val),
+			      __longjmp_chk) __attribute__ ((__noreturn__));
+#else
+extern void __longjmp_chk (struct __jmp_buf_tag __env[1], int __val),
+     __THROWNL __attribute__ ((__noreturn__));
+# define longjmp __longjmp_chk
+# define _longjmp __longjmp_chk
+# define siglongjmp __longjmp_chk
+#endif
diff --git a/include/bits/shm.h b/include/bits/shm.h
new file mode 100644
index 0000000..a652a6e
--- /dev/null
+++ b/include/bits/shm.h
@@ -0,0 +1,95 @@
+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SHM_H
+# error "Never include <bits/shm.h> directly; use <sys/shm.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <bits/ipctypes.h>
+
+/* Permission flag for shmget.  */
+#define SHM_R		0400		/* or S_IRUGO from <linux/stat.h> */
+#define SHM_W		0200		/* or S_IWUGO from <linux/stat.h> */
+
+/* Flags for `shmat'.  */
+#define SHM_RDONLY	010000		/* attach read-only else read-write */
+#define SHM_RND		020000		/* round attach address to SHMLBA */
+#define SHM_REMAP	040000		/* take-over region on attach */
+
+/* Commands for `shmctl'.  */
+#define SHM_LOCK	11		/* lock segment (root only) */
+#define SHM_UNLOCK	12		/* unlock segment (root only) */
+
+__BEGIN_DECLS
+
+/* Segment low boundary address multiple.  */
+#define SHMLBA		(__getpagesize ())
+extern int __getpagesize (void) __THROW __attribute__ ((__const__));
+
+
+/* Type to count number of attaches.  */
+typedef unsigned short int shmatt_t;
+
+/* Data structure describing a shared memory segment.  */
+struct shmid_ds
+  {
+    struct ipc_perm shm_perm;		/* operation permission struct */
+    int shm_segsz;			/* size of segment in bytes */
+    __time_t shm_atime;			/* time of last shmat() */
+    __time_t shm_dtime;			/* time of last shmdt() */
+    __time_t shm_ctime;			/* time of last change by shmctl() */
+    __ipc_pid_t shm_cpid;		/* pid of creator */
+    __ipc_pid_t shm_lpid;		/* pid of last shmop */
+    shmatt_t shm_nattch;		/* number of current attaches */
+    unsigned short int __shm_npages;	/* size of segment (pages) */
+    unsigned long int *__shm_pages;	/* array of ptrs to frames -> SHMMAX */
+    struct vm_area_struct *__attaches;	/* descriptors for attaches */
+  };
+
+#ifdef __USE_MISC
+
+/* ipcs ctl commands */
+# define SHM_STAT 	13
+# define SHM_INFO 	14
+
+/* shm_mode upper byte flags */
+# define SHM_DEST	01000	/* segment will be destroyed on last detach */
+# define SHM_LOCKED	02000   /* segment will not be swapped */
+
+struct	shminfo
+  {
+    int shmmax;
+    int shmmin;
+    int shmmni;
+    int shmseg;
+    int shmall;
+  };
+
+struct shm_info
+  {
+    int used_ids;
+    unsigned long int shm_tot;	/* total allocated shm */
+    unsigned long int shm_rss;	/* total resident shm */
+    unsigned long int shm_swp;	/* total swapped shm */
+    unsigned long int swap_attempts;
+    unsigned long int swap_successes;
+  };
+
+#endif /* __USE_MISC */
+
+__END_DECLS
diff --git a/include/bits/sigaction.h b/include/bits/sigaction.h
new file mode 100644
index 0000000..7204fc6
--- /dev/null
+++ b/include/bits/sigaction.h
@@ -0,0 +1,81 @@
+/* Copyright (C) 1991-2015 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
+#endif
+
+/* These definitions match those used by the 4.4 BSD kernel.
+   If the operating system has a `sigaction' system call that correctly
+   implements the POSIX.1 behavior, there should be a system-dependent
+   version of this file that defines `struct sigaction' and the `SA_*'
+   constants appropriately.  */
+
+/* Structure describing the action to be taken when a signal arrives.  */
+struct sigaction
+  {
+    /* Signal handler.  */
+#ifdef __USE_POSIX199309
+    union
+      {
+	/* Used if SA_SIGINFO is not set.  */
+	__sighandler_t sa_handler;
+	/* Used if SA_SIGINFO is set.  */
+	void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+# define sa_handler	__sigaction_handler.sa_handler
+# define sa_sigaction	__sigaction_handler.sa_sigaction
+#else
+    __sighandler_t sa_handler;
+#endif
+
+    /* Additional set of signals to be blocked.  */
+    __sigset_t sa_mask;
+
+    /* Special flags.  */
+    int sa_flags;
+  };
+
+/* Bits in `sa_flags'.  */
+#if defined __USE_UNIX98 || defined __USE_MISC
+# define SA_ONSTACK	0x0001	/* Take signal on signal stack.  */
+#endif
+#if defined __USE_UNIX98 || defined __USE_MISC || defined __USE_XOPEN2K8
+# define SA_RESTART	0x0002	/* Restart syscall on signal return.  */
+# define SA_NODEFER	0x0010	/* Don't automatically block the signal when
+				    its handler is being executed.  */
+# define SA_RESETHAND	0x0004	/* Reset to SIG_DFL on entry to handler.  */
+# define SA_SIGINFO	0x0040	/* Signal handler with SA_SIGINFO args */
+#endif
+#define	SA_NOCLDSTOP	0x0008	/* Don't send SIGCHLD when children stop.  */
+
+#ifdef __USE_MISC
+# define SA_INTERRUPT	0	/* Historical no-op ("not SA_RESTART").  */
+
+/* Some aliases for the SA_ constants.  */
+# define SA_NOMASK    SA_NODEFER
+# define SA_ONESHOT   SA_RESETHAND
+# define SA_STACK     SA_ONSTACK
+#endif
+
+
+/* Values for the HOW argument to `sigprocmask'.  */
+#define	SIG_BLOCK	1	/* Block signals.  */
+#define	SIG_UNBLOCK	2	/* Unblock signals.  */
+#define	SIG_SETMASK	3	/* Set the set of blocked signals.  */
diff --git a/include/bits/sigcontext.h b/include/bits/sigcontext.h
new file mode 100644
index 0000000..321bbb4
--- /dev/null
+++ b/include/bits/sigcontext.h
@@ -0,0 +1,123 @@
+/* Machine-dependent signal context structure for GNU Hurd.  i386 version.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef sc_pc
+
+/* Signal handlers are actually called:
+   void handler (int sig, int code, struct sigcontext *scp);  */
+
+#include <mach/machine/fp_reg.h>
+
+/* State of this thread when the signal was taken.  */
+struct sigcontext
+  {
+    /* These first members are machine-independent.  */
+
+    int sc_onstack;		/* Nonzero if running on sigstack.  */
+    __sigset_t sc_mask;		/* Blocked signals to restore.  */
+
+    /* MiG reply port this thread is using.  */
+    unsigned int sc_reply_port;
+
+    /* Port this thread is doing an interruptible RPC on.  */
+    unsigned int sc_intr_port;
+
+    /* Error code associated with this signal (interpreted as `error_t').  */
+    int sc_error;
+
+    /* All following members are machine-dependent.  The rest of this
+       structure is written to be laid out identically to:
+       {
+	 struct i386_thread_state basic;
+	 struct i386_float_state fpu;
+       }
+       trampoline.c knows this, so it must be changed if this changes.  */
+
+#define sc_i386_thread_state sc_gs /* Beginning of correspondence.  */
+    /* Segment registers.  */
+    int sc_gs;
+    int sc_fs;
+    int sc_es;
+    int sc_ds;
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    int sc_edi;
+    int sc_esi;
+    int sc_ebp;
+    int sc_esp;			/* Not used; sc_uesp is used instead.  */
+    int sc_ebx;
+    int sc_edx;
+    int sc_ecx;
+    int sc_eax;
+
+    int sc_eip;			/* Instruction pointer.  */
+    int sc_cs;			/* Code segment register.  */
+
+    int sc_efl;			/* Processor flags.  */
+
+    int sc_uesp;		/* This stack pointer is used.  */
+    int sc_ss;			/* Stack segment register.  */
+
+    /* Following mimics struct i386_float_state.  Structures and symbolic
+       values can be found in <mach/i386/fp_reg.h>.  */
+#define sc_i386_float_state sc_fpkind
+    int sc_fpkind;		/* FP_NO, FP_387, etc.  */
+    int sc_fpused;		/* If zero, ignore rest of float state.  */
+    struct i386_fp_save sc_fpsave;
+    struct i386_fp_regs sc_fpregs;
+    int sc_fpexcsr;		/* FPSR including exception bits.  */
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp	sc_uesp		/* Stack pointer.  */
+#define sc_fp	sc_ebp		/* Frame pointer.  */
+#define sc_pc	sc_eip		/* Process counter.  */
+#define sc_ps	sc_efl
+
+
+/* The deprecated sigcode values below are passed as an extra, non-portable
+   argument to regular signal handlers.  You should use SA_SIGINFO handlers
+   instead, which use the standard POSIX signal codes.  */
+
+/* Codes for SIGFPE.  */
+#define FPE_INTOVF_TRAP		0x1 /* integer overflow */
+#define FPE_INTDIV_FAULT	0x2 /* integer divide by zero */
+#define FPE_FLTOVF_FAULT	0x3 /* floating overflow */
+#define FPE_FLTDIV_FAULT	0x4 /* floating divide by zero */
+#define FPE_FLTUND_FAULT	0x5 /* floating underflow */
+#define FPE_SUBRNG_FAULT	0x7 /* BOUNDS instruction failed */
+#define FPE_FLTDNR_FAULT	0x8 /* denormalized operand */
+#define FPE_FLTINX_FAULT	0x9 /* floating loss of precision */
+#define FPE_EMERR_FAULT		0xa /* mysterious emulation error 33 */
+#define FPE_EMBND_FAULT		0xb /* emulation BOUNDS instruction failed */
+
+/* Codes for SIGILL.  */
+#define ILL_INVOPR_FAULT	0x1 /* invalid operation */
+#define ILL_STACK_FAULT		0x2 /* fault on microkernel stack access */
+#define ILL_FPEOPR_FAULT	0x3 /* invalid floating operation */
+
+/* Codes for SIGTRAP.  */
+#define DBG_SINGLE_TRAP		0x1 /* single step */
+#define DBG_BRKPNT_FAULT	0x2 /* breakpoint instruction */
+
+#endif /* sc_pc */
diff --git a/include/bits/siginfo.h b/include/bits/siginfo.h
new file mode 100644
index 0000000..f77d952
--- /dev/null
+++ b/include/bits/siginfo.h
@@ -0,0 +1,210 @@
+/* siginfo_t, sigevent and constants.  Stub version.
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _SIGNAL_H && !defined __need_siginfo_t \
+    && !defined __need_sigevent_t
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#if (!defined __have_sigval_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t \
+	 || defined __need_sigevent_t))
+# define __have_sigval_t 1
+
+/* Type for data associated with a signal.  */
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+#endif
+
+#if (!defined __have_siginfo_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t))
+# define __have_siginfo_t	1
+
+typedef struct siginfo
+  {
+    int si_signo;		/* Signal number.  */
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+    int si_code;		/* Signal code.  */
+    __pid_t si_pid;		/* Sending process ID.  */
+    __uid_t si_uid;		/* Real user ID of sending process.  */
+    void *si_addr;		/* Address of faulting instruction.  */
+    int si_status;		/* Exit value or signal.  */
+    long int si_band;		/* Band event for SIGPOLL.  */
+    union sigval si_value;	/* Signal value.  */
+  } siginfo_t;
+
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCIO = -4,		/* Sent by AIO completion.  */
+# define SI_ASYNCIO	SI_ASYNCIO
+  SI_MESGQ,			/* Sent by real time mesq state change.  */
+# define SI_MESGQ	SI_MESGQ
+  SI_TIMER,			/* Sent by timer expiration.  */
+# define SI_TIMER	SI_TIMER
+  SI_QUEUE,			/* Sent by sigqueue.  */
+# define SI_QUEUE	SI_QUEUE
+  SI_USER			/* Sent by kill, sigsend, raise.  */
+# define SI_USER	SI_USER
+};
+
+
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+# define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+# define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+# define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap. */
+# define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+# define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+# define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+# define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK			/* Internal stack error.  */
+# define ILL_BADSTK	ILL_BADSTK
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTDIV = 1,		/* Integer divide by zero.  */
+# define FPE_INTDIV	FPE_INTDIV
+  FPE_INTOVF,			/* Integer overflow.  */
+# define FPE_INTOVF	FPE_INTOVF
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+# define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+# define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+# define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+# define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+# define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+# define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+# define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+# define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+# define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existant physical address.  */
+# define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+# define BUS_OBJERR	BUS_OBJERR
+};
+
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+# define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+# define TRAP_TRACE	TRAP_TRACE
+};
+
+/* `si_code' values for SIGCHLD signal.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+# define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+# define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+# define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+# define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+# define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+# define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+# define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+# define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+# define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+# define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+# define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+# define POLL_HUP	POLL_HUP
+};
+
+# undef __need_siginfo_t
+#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
+
+
+#if (defined _SIGNAL_H || defined __need_sigevent_t) \
+    && !defined __have_sigevent_t
+# define __have_sigevent_t	1
+
+/* Structure to transport application-defined values with signals.  */
+# define SIGEV_MAX_SIZE	64
+# define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE / sizeof (int)) - 3)
+
+typedef struct sigevent
+  {
+    sigval_t sigev_value;
+    int sigev_signo;
+    int sigev_notify;
+    void (*sigev_notify_function) (sigval_t);	    /* Function to start.  */
+    void *sigev_notify_attributes;		    /* Really pthread_attr_t.*/
+  } sigevent_t;
+
+/* `sigev_notify' values.  */
+enum
+{
+  SIGEV_SIGNAL = 0,		/* Notify via signal.  */
+# define SIGEV_SIGNAL	SIGEV_SIGNAL
+  SIGEV_NONE,			/* Other notification: meaningless.  */
+# define SIGEV_NONE	SIGEV_NONE
+  SIGEV_THREAD			/* Deliver via thread creation.  */
+# define SIGEV_THREAD	SIGEV_THREAD
+};
+
+#endif	/* have _SIGNAL_H.  */
diff --git a/include/bits/signum.h b/include/bits/signum.h
new file mode 100644
index 0000000..598a4fe
--- /dev/null
+++ b/include/bits/signum.h
@@ -0,0 +1,73 @@
+/* Signal number definitions.  BSD version.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifdef	_SIGNAL_H
+
+/* This file defines the fake signal functions and signal
+   number constants for 4.2 or 4.3 BSD-derived Unix system.  */
+
+/* Fake signal functions.  */
+#define	SIG_ERR	((__sighandler_t) -1) /* Error return.  */
+#define	SIG_DFL	((__sighandler_t) 0) /* Default action.  */
+#define	SIG_IGN	((__sighandler_t) 1) /* Ignore signal.  */
+
+#ifdef __USE_UNIX98
+# define SIG_HOLD      ((__sighandler_t) 2)    /* Add signal to hold mask.  */
+#endif
+
+
+/* Signals.  */
+#define	SIGHUP		1	/* Hangup (POSIX).  */
+#define	SIGINT		2	/* Interrupt (ANSI).  */
+#define	SIGQUIT		3	/* Quit (POSIX).  */
+#define	SIGILL		4	/* Illegal instruction (ANSI).  */
+#define	SIGABRT		SIGIOT	/* Abort (ANSI).  */
+#define	SIGTRAP		5	/* Trace trap (POSIX).  */
+#define	SIGIOT		6	/* IOT trap (4.2 BSD).  */
+#define	SIGEMT		7	/* EMT trap (4.2 BSD).  */
+#define	SIGFPE		8	/* Floating-point exception (ANSI).  */
+#define	SIGKILL		9	/* Kill, unblockable (POSIX).  */
+#define	SIGBUS		10	/* Bus error (4.2 BSD).  */
+#define	SIGSEGV		11	/* Segmentation violation (ANSI).  */
+#define	SIGSYS		12	/* Bad argument to system call (4.2 BSD).  */
+#define	SIGPIPE		13	/* Broken pipe (POSIX).  */
+#define	SIGALRM		14	/* Alarm clock (POSIX).  */
+#define	SIGTERM		15	/* Termination (ANSI).  */
+#define	SIGURG		16	/* Urgent condition on socket (4.2 BSD).  */
+#define	SIGSTOP		17	/* Stop, unblockable (POSIX).  */
+#define	SIGTSTP		18	/* Keyboard stop (POSIX).  */
+#define	SIGCONT		19	/* Continue (POSIX).  */
+#define	SIGCHLD		20	/* Child status has changed (POSIX).  */
+#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
+#define	SIGTTIN		21	/* Background read from tty (POSIX).  */
+#define	SIGTTOU		22	/* Background write to tty (POSIX).  */
+#define	SIGIO		23	/* I/O now possible (4.2 BSD).  */
+#define	SIGPOLL		SIGIO	/* Same as SIGIO? (SVID).  */
+#define	SIGXCPU		24	/* CPU limit exceeded (4.2 BSD).  */
+#define	SIGXFSZ		25	/* File size limit exceeded (4.2 BSD).  */
+#define	SIGVTALRM	26	/* Virtual alarm clock (4.2 BSD).  */
+#define	SIGPROF		27	/* Profiling alarm clock (4.2 BSD).  */
+#define	SIGWINCH	28	/* Window size change (4.3 BSD, Sun).  */
+#define SIGINFO		29	/* Information request (4.4 BSD).  */
+#define	SIGUSR1		30	/* User-defined signal 1 (POSIX).  */
+#define	SIGUSR2		31	/* User-defined signal 2 (POSIX).  */
+#define SIGLOST		32	/* Resource lost (Sun); server died (GNU).  */
+
+#endif	/* <signal.h> included.  */
+
+#define	_NSIG		33	/* Biggest signal number + 1.  */
diff --git a/include/bits/sigset.h b/include/bits/sigset.h
new file mode 100644
index 0000000..23a6c1f
--- /dev/null
+++ b/include/bits/sigset.h
@@ -0,0 +1,82 @@
+/* __sig_atomic_t, __sigset_t, and related definitions.  Generic/BSD version.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SIGSET_H_types
+#define	_SIGSET_H_types	1
+
+typedef int __sig_atomic_t;
+
+/* A `sigset_t' has a bit for each signal.  */
+typedef unsigned long int __sigset_t;
+
+#endif
+
+
+/* We only want to define these functions if <signal.h> was actually
+   included; otherwise we were included just to define the types.  Since we
+   are namespace-clean, it wouldn't hurt to define extra macros.  But
+   trouble can be caused by functions being defined (e.g., any global
+   register vars declared later will cause compilation errors).  */
+
+#if !defined _SIGSET_H_fns && defined _SIGNAL_H
+#define _SIGSET_H_fns 1
+
+#ifndef _EXTERN_INLINE
+# define _EXTERN_INLINE __extern_inline
+#endif
+
+/* Return a mask that includes SIG only.  The cast to `sigset_t' avoids
+   overflow if `sigset_t' is wider than `int'.  */
+#define	__sigmask(sig)	(((__sigset_t) 1) << ((sig) - 1))
+
+#define	__sigemptyset(set)	((*(set) = (__sigset_t) 0), 0)
+#define	__sigfillset(set)	((*(set) = ~(__sigset_t) 0), 0)
+
+#ifdef _GNU_SOURCE
+# define __sigisemptyset(set)	(*(set) == (__sigset_t) 0)
+# define __sigandset(dest, left, right) \
+				((*(dest) = (*(left) & *(right))), 0)
+# define __sigorset(dest, left, right) \
+				((*(dest) = (*(left) | *(right))), 0)
+#endif
+
+/* These functions needn't check for a bogus signal number -- error
+   checking is done in the non __ versions.  */
+
+extern int __sigismember (const __sigset_t *, int);
+extern int __sigaddset (__sigset_t *, int);
+extern int __sigdelset (__sigset_t *, int);
+
+#ifdef __USE_EXTERN_INLINES
+# define __SIGSETFN(NAME, BODY, CONST)					      \
+  _EXTERN_INLINE int							      \
+  NAME (CONST __sigset_t *__set, int __sig)				      \
+  {									      \
+    __sigset_t __mask = __sigmask (__sig);				      \
+    return BODY;							      \
+  }
+
+__SIGSETFN (__sigismember, (*__set & __mask) ? 1 : 0, const)
+__SIGSETFN (__sigaddset, ((*__set |= __mask), 0), )
+__SIGSETFN (__sigdelset, ((*__set &= ~__mask), 0), )
+
+# undef __SIGSETFN
+#endif
+
+
+#endif /* ! _SIGSET_H_fns.  */
diff --git a/include/bits/sigstack.h b/include/bits/sigstack.h
new file mode 100644
index 0000000..465156c
--- /dev/null
+++ b/include/bits/sigstack.h
@@ -0,0 +1,54 @@
+/* sigstack, sigaltstack definitions.
+   Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SIGNAL_H
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+
+/* Structure describing a signal stack (obsolete).  */
+struct sigstack
+  {
+    __ptr_t ss_sp;		/* Signal stack pointer.  */
+    int ss_onstack;		/* Nonzero if executing on this stack.  */
+  };
+
+
+/* Alternate, preferred interface.  */
+typedef struct sigaltstack
+  {
+    __ptr_t ss_sp;
+    size_t ss_size;
+    int ss_flags;
+  } stack_t;
+
+
+/* Possible values for `ss_flags.'.  */
+enum
+{
+  SS_ONSTACK = 0x0001,
+#define SS_ONSTACK	SS_ONSTACK
+  SS_DISABLE = 0x0004
+#define SS_DISABLE	SS_DISABLE
+};
+
+/* Minumum stack size for a signal handler.  */
+#define MINSIGSTKSZ	8192
+
+/* System default stack size.  */
+#define SIGSTKSZ	(MINSIGSTKSZ + 32768)
diff --git a/include/bits/sigthread.h b/include/bits/sigthread.h
new file mode 100644
index 0000000..adf6e3f
--- /dev/null
+++ b/include/bits/sigthread.h
@@ -0,0 +1,34 @@
+/* Signal handling function for threaded programs.  Generic version.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_SIGTHREAD_H
+#define _BITS_SIGTHREAD_H	1
+
+#if !defined _SIGNAL_H && !defined _PTHREAD_H
+# error "Never include this file directly.  Use <pthread.h> instead"
+#endif
+
+/* Modify the signal mask for the calling thread.  The arguments have the
+   same meaning as for sigprocmask; in fact, this and sigprocmask might be
+   the same function.  We declare this the same on all platforms, since it
+   doesn't use any thread-related types.  */
+extern int pthread_sigmask (int __how, const __sigset_t *__newmask,
+			    __sigset_t *__oldmask) __THROW;
+
+
+#endif	/* bits/sigthread.h */
diff --git a/include/bits/sockaddr.h b/include/bits/sockaddr.h
new file mode 100644
index 0000000..ab84c1b
--- /dev/null
+++ b/include/bits/sockaddr.h
@@ -0,0 +1,42 @@
+/* Definition of `struct sockaddr_*' common members.  4.4 BSD version.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Never include this file directly; use <sys/socket.h> instead.
+ */
+
+#ifndef _BITS_SOCKADDR_H
+#define _BITS_SOCKADDR_H	1
+
+
+/* POSIX.1g specifies this type name for the `sa_family' member.  */
+typedef unsigned char sa_family_t;
+
+/* This macro is used to declare the initial common members
+   of the data types used for socket addresses, `struct sockaddr',
+   `struct sockaddr_in', `struct sockaddr_un', etc.  */
+
+#define	__SOCKADDR_COMMON(sa_prefix)	\
+  unsigned char sa_prefix##len;		\
+  sa_family_t sa_prefix##family
+
+#define __SOCKADDR_COMMON_SIZE	(2 * sizeof (unsigned char))
+
+#define _HAVE_SA_LEN	1	/* We have the sa_len field.  */
+
+#endif	/* bits/sockaddr.h */
diff --git a/include/bits/socket.h b/include/bits/socket.h
new file mode 100644
index 0000000..e5f783b
--- /dev/null
+++ b/include/bits/socket.h
@@ -0,0 +1,362 @@
+/* System-specific socket constants and types.  Hurd version.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef __BITS_SOCKET_H
+#define __BITS_SOCKET_H	1
+
+#ifndef _SYS_SOCKET_H
+# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
+#endif
+
+#define	__need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+#include <limits.h>		/* XXX Is this allowed?  */
+#include <bits/types.h>
+
+/* Type for length arguments in socket calls.  */
+#ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+# define __socklen_t_defined
+#endif
+
+
+/* Types of sockets.  */
+enum __socket_type
+{
+  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
+				   byte streams.  */
+#define SOCK_STREAM SOCK_STREAM
+  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
+				   of fixed maximum length.  */
+#define SOCK_DGRAM SOCK_DGRAM
+  SOCK_RAW = 3,			/* Raw protocol interface.  */
+#define SOCK_RAW SOCK_RAW
+  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
+#define SOCK_RDM SOCK_RDM
+  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
+				   datagrams of fixed maximum length.  */
+#define SOCK_SEQPACKET SOCK_SEQPACKET
+
+#define SOCK_MAX (SOCK_SEQPACKET + 1)
+  /* Mask which covers at least up to SOCK_MASK-1.  The
+     remaining bits are used as flags. */
+#define SOCK_TYPE_MASK 0xf
+
+  /* Flags to be ORed into the type parameter of socket and socketpair and
+     used for the flags parameter of accept4.  */
+
+  SOCK_CLOEXEC = 0x00400000,	/* Atomically set close-on-exec flag for the
+				   new descriptor(s).  */
+#define SOCK_CLOEXEC SOCK_CLOEXEC
+
+  /* Changed from the O_NONBLOCK value (0x8, which is unusable for us as it is
+     conflicting with the original SOCK_* flags' values) to the Linux value
+     (04000).  TODO: is there a ``better'' value?  */
+  SOCK_NONBLOCK = 0x0800	/* Atomically mark descriptor(s) as
+				   non-blocking.  */
+#define SOCK_NONBLOCK SOCK_NONBLOCK
+};
+
+/* Protocol families.  */
+#define	PF_UNSPEC	0	/* Unspecified.  */
+#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
+#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
+#define	PF_FILE		PF_LOCAL /* POSIX name for PF_LOCAL.  */
+#define	PF_INET		2	/* IP protocol family.  */
+#define	PF_IMPLINK	3	/* ARPAnet IMP protocol.  */
+#define	PF_PUP		4	/* PUP protocols.  */
+#define	PF_CHAOS	5	/* MIT Chaos protocols.  */
+#define	PF_NS		6	/* Xerox NS protocols.  */
+#define	PF_ISO		7	/* ISO protocols.  */
+#define	PF_OSI		PF_ISO
+#define	PF_ECMA		8	/* ECMA protocols.  */
+#define	PF_DATAKIT	9	/* AT&T Datakit protocols.  */
+#define	PF_CCITT	10	/* CCITT protocols (X.25 et al).  */
+#define	PF_SNA		11	/* IBM SNA protocol.  */
+#define	PF_DECnet	12	/* DECnet protocols.  */
+#define	PF_DLI		13	/* Direct data link interface.  */
+#define	PF_LAT		14	/* DEC Local Area Transport protocol.  */
+#define	PF_HYLINK	15	/* NSC Hyperchannel protocol.  */
+#define	PF_APPLETALK	16	/* Don't use this.  */
+#define	PF_ROUTE	17	/* Internal Routing Protocol.  */
+#define	PF_LINK		18	/* Link layer interface.  */
+#define	PF_XTP		19	/* eXpress Transfer Protocol (no AF).  */
+#define	PF_COIP		20	/* Connection-oriented IP, aka ST II.  */
+#define	PF_CNT		21	/* Computer Network Technology.  */
+#define PF_RTIP		22	/* Help Identify RTIP packets.  **/
+#define	PF_IPX		23	/* Novell Internet Protocol.  */
+#define	PF_SIP		24	/* Simple Internet Protocol.  */
+#define PF_PIP		25	/* Help Identify PIP packets.  */
+#define PF_INET6	26	/* IP version 6.  */
+#define	PF_MAX		27
+
+/* Address families.  */
+#define	AF_UNSPEC	PF_UNSPEC
+#define	AF_LOCAL	PF_LOCAL
+#define	AF_UNIX		PF_UNIX
+#define	AF_FILE		PF_FILE
+#define	AF_INET		PF_INET
+#define	AF_IMPLINK	PF_IMPLINK
+#define	AF_PUP		PF_PUP
+#define	AF_CHAOS	PF_CHAOS
+#define	AF_NS		PF_NS
+#define	AF_ISO		PF_ISO
+#define	AF_OSI		PF_OSI
+#define	AF_ECMA		PF_ECMA
+#define	AF_DATAKIT	PF_DATAKIT
+#define	AF_CCITT	PF_CCITT
+#define	AF_SNA		PF_SNA
+#define	AF_DECnet	PF_DECnet
+#define	AF_DLI		PF_DLI
+#define	AF_LAT		PF_LAT
+#define	AF_HYLINK	PF_HYLINK
+#define	AF_APPLETALK	PF_APPLETALK
+#define	AF_ROUTE	PF_ROUTE
+#define	AF_LINK		PF_LINK
+#define	pseudo_AF_XTP	PF_XTP
+#define	AF_COIP		PF_COIP
+#define	AF_CNT		PF_CNT
+#define pseudo_AF_RTIP	PF_RTIP
+#define	AF_IPX		PF_IPX
+#define	AF_SIP		PF_SIP
+#define pseudo_AF_PIP	PF_PIP
+#define AF_INET6	PF_INET6
+#define	AF_MAX		PF_MAX
+
+/* Maximum queue length specifiable by listen.  */
+#define SOMAXCONN	128	/* 5 on the origional 4.4 BSD.  */
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+/* Structure describing a generic socket address.  */
+struct sockaddr
+  {
+    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
+    char sa_data[14];		/* Address data.  */
+  };
+
+
+/* Structure large enough to hold any socket address (with the historical
+   exception of AF_UNIX).  We reserve 128 bytes.  */
+#if ULONG_MAX > 0xffffffff
+# define __ss_aligntype	__uint64_t
+#else
+# define __ss_aligntype	__uint32_t
+#endif
+#define _SS_SIZE	128
+#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
+
+struct sockaddr_storage
+  {
+    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
+    __ss_aligntype __ss_align;	/* Force desired alignment.  */
+    char __ss_padding[_SS_PADSIZE];
+  };
+
+
+/* Bits in the FLAGS argument to `send', `recv', et al.  */
+enum
+  {
+    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
+#define MSG_OOB MSG_OOB
+    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
+#define MSG_PEEK MSG_PEEK
+    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
+#define MSG_DONTROUTE MSG_DONTROUTE
+    MSG_EOR		= 0x08,	/* Data completes record.  */
+#define MSG_EOR MSG_EOR
+    MSG_TRUNC		= 0x10,	/* Data discarded before delivery.  */
+#define MSG_TRUNC MSG_TRUNC
+    MSG_CTRUNC		= 0x20,	/* Control data lost before delivery.  */
+#define MSG_CTRUNC MSG_CTRUNC
+    MSG_WAITALL		= 0x40,	/* Wait for full request or error.  */
+#define MSG_WAITALL MSG_WAITALL
+    MSG_DONTWAIT	= 0x80,	/* This message should be nonblocking.  */
+#define MSG_DONTWAIT MSG_DONTWAIT
+    MSG_NOSIGNAL	= 0x0400	/* Do not generate SIGPIPE on EPIPE.  */
+#define MSG_NOSIGNAL MSG_NOSIGNAL
+  };
+
+
+/* Structure describing messages sent by
+   `sendmsg' and received by `recvmsg'.  */
+struct msghdr
+  {
+    void *msg_name;		/* Address to send to/receive from.  */
+    socklen_t msg_namelen;	/* Length of address data.  */
+
+    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
+    int msg_iovlen;		/* Number of elements in the vector.  */
+
+    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
+    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
+
+    int msg_flags;		/* Flags in received message.  */
+  };
+
+/* Structure used for storage of ancillary data object information.  */
+struct cmsghdr
+  {
+    socklen_t cmsg_len;		/* Length of data in cmsg_data plus length
+				   of cmsghdr structure.  */
+    int cmsg_level;		/* Originating protocol.  */
+    int cmsg_type;		/* Protocol specific type.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+    __extension__ unsigned char __cmsg_data __flexarr; /* Ancillary data.  */
+#endif
+  };
+
+/* Ancillary data object manipulation macros.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
+#else
+# define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
+#endif
+
+#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
+
+#define CMSG_FIRSTHDR(mhdr) \
+  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
+   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
+
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
+			   & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
+			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
+				      struct cmsghdr *__cmsg) __THROW;
+#ifdef __USE_EXTERN_INLINES
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+_EXTERN_INLINE struct cmsghdr *
+__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
+{
+  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
+    /* The kernel header does this so there may be a reason.  */
+    return NULL;
+
+  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
+			       + CMSG_ALIGN (__cmsg->cmsg_len));
+  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
+					+ __mhdr->msg_controllen)
+      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
+	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
+    /* No more entries.  */
+    return NULL;
+  return __cmsg;
+}
+#endif	/* Use `extern inline'.  */
+
+/* Socket level message types.  */
+enum
+  {
+    SCM_RIGHTS = 0x01,		/* Access rights (array of int).  */
+#define SCM_RIGHTS SCM_RIGHTS
+    SCM_TIMESTAMP = 0x02,	/* Timestamp (struct timeval).  */
+#define SCM_TIMESTAMP SCM_TIMESTAMP
+    SCM_CREDS = 0x03		/* Process creds (struct cmsgcred).  */
+#define SCM_CREDS SCM_CREDS
+  };
+
+/* Unfortunately, BSD practice dictates this structure be of fixed size.
+   If there are more than CMGROUP_MAX groups, the list is truncated.
+   (On GNU systems, the `cmcred_euid' field is just the first in the
+   list of effective UIDs.)  */
+#define CMGROUP_MAX	16
+
+/* Structure delivered by SCM_CREDS.  This describes the identity of the
+   sender of the data simultaneously received on the socket.  By BSD
+   convention, this is included only when a sender on a AF_LOCAL socket
+   sends cmsg data of this type and size; the sender's structure is
+   ignored, and the system fills in the various IDs of the sender process.  */
+struct cmsgcred
+  {
+    __pid_t cmcred_pid;
+    __uid_t cmcred_uid;
+    __uid_t cmcred_euid;
+    __gid_t cmcred_gid;
+    int cmcred_ngroups;
+    __gid_t cmcred_groups[CMGROUP_MAX];
+  };
+
+/* Protocol number used to manipulate socket-level options
+   with `getsockopt' and `setsockopt'.  */
+#define	SOL_SOCKET	0xffff
+
+/* Socket-level options for `getsockopt' and `setsockopt'.  */
+enum
+  {
+    SO_DEBUG = 0x0001,		/* Record debugging information.  */
+#define SO_DEBUG SO_DEBUG
+    SO_ACCEPTCONN = 0x0002,	/* Accept connections on socket.  */
+#define SO_ACCEPTCONN SO_ACCEPTCONN
+    SO_REUSEADDR = 0x0004,	/* Allow reuse of local addresses.  */
+#define SO_REUSEADDR SO_REUSEADDR
+    SO_KEEPALIVE = 0x0008,	/* Keep connections alive and send
+				   SIGPIPE when they die.  */
+#define SO_KEEPALIVE SO_KEEPALIVE
+    SO_DONTROUTE = 0x0010,	/* Don't do local routing.  */
+#define SO_DONTROUTE SO_DONTROUTE
+    SO_BROADCAST = 0x0020,	/* Allow transmission of
+				   broadcast messages.  */
+#define SO_BROADCAST SO_BROADCAST
+    SO_USELOOPBACK = 0x0040,	/* Use the software loopback to avoid
+				   hardware use when possible.  */
+#define SO_USELOOPBACK SO_USELOOPBACK
+    SO_LINGER = 0x0080,		/* Block on close of a reliable
+				   socket to transmit pending data.  */
+#define SO_LINGER SO_LINGER
+    SO_OOBINLINE = 0x0100,	/* Receive out-of-band data in-band.  */
+#define SO_OOBINLINE SO_OOBINLINE
+    SO_REUSEPORT = 0x0200,	/* Allow local address and port reuse.  */
+#define SO_REUSEPORT SO_REUSEPORT
+    SO_SNDBUF = 0x1001,		/* Send buffer size.  */
+#define SO_SNDBUF SO_SNDBUF
+    SO_RCVBUF = 0x1002,		/* Receive buffer.  */
+#define SO_RCVBUF SO_RCVBUF
+    SO_SNDLOWAT = 0x1003,	/* Send low-water mark.  */
+#define SO_SNDLOWAT SO_SNDLOWAT
+    SO_RCVLOWAT = 0x1004,	/* Receive low-water mark.  */
+#define SO_RCVLOWAT SO_RCVLOWAT
+    SO_SNDTIMEO = 0x1005,	/* Send timeout.  */
+#define SO_SNDTIMEO SO_SNDTIMEO
+    SO_RCVTIMEO = 0x1006,	/* Receive timeout.  */
+#define SO_RCVTIMEO SO_RCVTIMEO
+    SO_ERROR = 0x1007,		/* Get and clear error status.  */
+#define SO_ERROR SO_ERROR
+    SO_STYLE = 0x1008,		/* Get socket connection style.  */
+#define SO_STYLE SO_STYLE
+    SO_TYPE = SO_STYLE		/* Compatible name for SO_STYLE.  */
+#define SO_TYPE SO_TYPE
+  };
+
+/* Structure used to manipulate the SO_LINGER option.  */
+struct linger
+  {
+    int l_onoff;		/* Nonzero to linger on close.  */
+    int l_linger;		/* Time to linger.  */
+  };
+
+#endif	/* bits/socket.h */
diff --git a/include/bits/socket2.h b/include/bits/socket2.h
new file mode 100644
index 0000000..74e1648
--- /dev/null
+++ b/include/bits/socket2.h
@@ -0,0 +1,77 @@
+/* Checking macros for socket functions.
+   Copyright (C) 2005-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SOCKET_H
+# error "Never include <bits/socket2.h> directly; use <sys/socket.h> instead."
+#endif
+
+extern ssize_t __recv_chk (int __fd, void *__buf, size_t __n, size_t __buflen,
+			   int __flags);
+extern ssize_t __REDIRECT (__recv_alias, (int __fd, void *__buf, size_t __n,
+					  int __flags), recv);
+extern ssize_t __REDIRECT (__recv_chk_warn,
+			   (int __fd, void *__buf, size_t __n, size_t __buflen,
+			    int __flags), __recv_chk)
+     __warnattr ("recv called with bigger length than size of destination "
+		 "buffer");
+
+__fortify_function ssize_t
+recv (int __fd, void *__buf, size_t __n, int __flags)
+{
+  if (__bos0 (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n))
+	return __recv_chk (__fd, __buf, __n, __bos0 (__buf), __flags);
+
+      if (__n > __bos0 (__buf))
+	return __recv_chk_warn (__fd, __buf, __n, __bos0 (__buf), __flags);
+    }
+  return __recv_alias (__fd, __buf, __n, __flags);
+}
+
+extern ssize_t __recvfrom_chk (int __fd, void *__restrict __buf, size_t __n,
+			       size_t __buflen, int __flags,
+			       __SOCKADDR_ARG __addr,
+			       socklen_t *__restrict __addr_len);
+extern ssize_t __REDIRECT (__recvfrom_alias,
+			   (int __fd, void *__restrict __buf, size_t __n,
+			    int __flags, __SOCKADDR_ARG __addr,
+			    socklen_t *__restrict __addr_len), recvfrom);
+extern ssize_t __REDIRECT (__recvfrom_chk_warn,
+			   (int __fd, void *__restrict __buf, size_t __n,
+			    size_t __buflen, int __flags,
+			    __SOCKADDR_ARG __addr,
+			    socklen_t *__restrict __addr_len), __recvfrom_chk)
+     __warnattr ("recvfrom called with bigger length than size of "
+		 "destination buffer");
+
+__fortify_function ssize_t
+recvfrom (int __fd, void *__restrict __buf, size_t __n, int __flags,
+	  __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len)
+{
+  if (__bos0 (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n))
+	return __recvfrom_chk (__fd, __buf, __n, __bos0 (__buf), __flags,
+			       __addr, __addr_len);
+      if (__n > __bos0 (__buf))
+	return __recvfrom_chk_warn (__fd, __buf, __n, __bos0 (__buf), __flags,
+				    __addr, __addr_len);
+    }
+  return __recvfrom_alias (__fd, __buf, __n, __flags, __addr, __addr_len);
+}
diff --git a/include/bits/spin-lock-inline.h b/include/bits/spin-lock-inline.h
new file mode 100644
index 0000000..e5ed3de
--- /dev/null
+++ b/include/bits/spin-lock-inline.h
@@ -0,0 +1,98 @@
+/* Machine-specific definitions for spin locks.  i386 version.
+   Copyright (C) 2000, 2005, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * Never include this file directly; use <pthread.h> or <cthreads.h> instead.
+ */
+
+#ifndef _BITS_SPIN_LOCK_INLINE_H
+#define _BITS_SPIN_LOCK_INLINE_H	1
+
+#include <features.h>
+#include <bits/spin-lock.h>
+
+__BEGIN_DECLS
+
+#if defined __USE_EXTERN_INLINES || defined _FORCE_INLINES
+
+# ifndef __EBUSY
+#  include <errno.h>
+#  define __EBUSY EBUSY
+# endif
+
+# ifndef __PT_SPIN_INLINE
+#  define __PT_SPIN_INLINE __extern_inline
+# endif
+
+__PT_SPIN_INLINE int __pthread_spin_destroy (__pthread_spinlock_t *__lock);
+
+__PT_SPIN_INLINE int
+__pthread_spin_destroy (__pthread_spinlock_t *__lock)
+{
+  return 0;
+}
+
+__PT_SPIN_INLINE int __pthread_spin_init (__pthread_spinlock_t *__lock,
+					  int __pshared);
+
+__PT_SPIN_INLINE int
+__pthread_spin_init (__pthread_spinlock_t *__lock, int __pshared)
+{
+  *__lock = __PTHREAD_SPIN_LOCK_INITIALIZER;
+  return 0;
+}
+
+__PT_SPIN_INLINE int __pthread_spin_trylock (__pthread_spinlock_t *__lock);
+
+__PT_SPIN_INLINE int
+__pthread_spin_trylock (__pthread_spinlock_t *__lock)
+{
+  int __locked;
+  __asm__ __volatile ("xchgl %0, %1"
+		      : "=&r" (__locked), "=m" (*__lock) : "0" (1) : "memory");
+  return __locked ? __EBUSY : 0;
+}
+
+__extern_inline int __pthread_spin_lock (__pthread_spinlock_t *__lock);
+extern int _pthread_spin_lock (__pthread_spinlock_t *__lock);
+
+__extern_inline int
+__pthread_spin_lock (__pthread_spinlock_t *__lock)
+{
+  if (__pthread_spin_trylock (__lock))
+    return _pthread_spin_lock (__lock);
+  return 0;
+}
+
+__PT_SPIN_INLINE int __pthread_spin_unlock (__pthread_spinlock_t *__lock);
+
+__PT_SPIN_INLINE int
+__pthread_spin_unlock (__pthread_spinlock_t *__lock)
+{
+  int __unlocked;
+  __asm__ __volatile ("xchgl %0, %1"
+		      : "=&r" (__unlocked), "=m" (*__lock) : "0" (0) : "memory");
+  return 0;
+}
+
+#endif /* Use extern inlines or force inlines.  */
+
+__END_DECLS
+
+#endif /* bits/spin-lock.h */
diff --git a/include/bits/spin-lock.h b/include/bits/spin-lock.h
new file mode 100644
index 0000000..5ae81e1
--- /dev/null
+++ b/include/bits/spin-lock.h
@@ -0,0 +1,39 @@
+/* Machine-specific definitions for spin locks.  i386 version.
+   Copyright (C) 2000, 2005, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * Never include this file directly; use <pthread.h> or <cthreads.h> instead.
+ */
+
+#ifndef _BITS_SPIN_LOCK_H
+#define _BITS_SPIN_LOCK_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* The type of a spin lock object.  */
+typedef __volatile int __pthread_spinlock_t;
+
+/* Initializer for a spin lock object.  */
+# define __PTHREAD_SPIN_LOCK_INITIALIZER ((__pthread_spinlock_t) 0)
+
+__END_DECLS
+
+#endif /* bits/spin-lock.h */
diff --git a/include/bits/stab.def b/include/bits/stab.def
new file mode 100644
index 0000000..7e68c0d
--- /dev/null
+++ b/include/bits/stab.def
@@ -0,0 +1,233 @@
+/* Table of DBX symbol codes for the GNU system.
+   Copyright (C) 1988, 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This contains contribution from Cygnus Support.  */
+
+/* Global variable.  Only the name is significant.
+   To find the address, look in the corresponding external symbol.  */
+__define_stab (N_GSYM, 0x20, "GSYM")
+
+/* Function name for BSD Fortran.  Only the name is significant.
+   To find the address, look in the corresponding external symbol.  */
+__define_stab (N_FNAME, 0x22, "FNAME")
+
+/* Function name or text-segment variable for C.  Value is its address.
+   Desc is supposedly starting line number, but GCC doesn't set it
+   and DBX seems not to miss it.  */
+__define_stab (N_FUN, 0x24, "FUN")
+
+/* Data-segment variable with internal linkage.  Value is its address.
+   "Static Sym".  */
+__define_stab (N_STSYM, 0x26, "STSYM")
+
+/* BSS-segment variable with internal linkage.  Value is its address.  */
+__define_stab (N_LCSYM, 0x28, "LCSYM")
+
+/* Name of main routine.  Only the name is significant.
+   This is not used in C.  */
+__define_stab (N_MAIN, 0x2a, "MAIN")
+
+/* Global symbol in Pascal.
+   Supposedly the value is its line number; I'm skeptical.  */
+__define_stab (N_PC, 0x30, "PC")
+
+/* Number of symbols:  0, files,,funcs,lines according to Ultrix V4.0. */
+__define_stab (N_NSYMS, 0x32, "NSYMS")
+
+/* "No DST map for sym: name, ,0,type,ignored"  according to Ultrix V4.0. */
+__define_stab (N_NOMAP, 0x34, "NOMAP")
+
+/* New stab from Solaris.  I don't know what it means, but it
+   don't seem to contain useful information.  */
+__define_stab (N_OBJ, 0x38, "OBJ")
+
+/* New stab from Solaris.  I don't know what it means, but it
+   don't seem to contain useful information.  Possibly related to the
+   optimization flags used in this module.  */
+__define_stab (N_OPT, 0x3c, "OPT")
+
+/* Register variable.  Value is number of register.  */
+__define_stab (N_RSYM, 0x40, "RSYM")
+
+/* Modula-2 compilation unit.  Can someone say what info it contains?  */
+__define_stab (N_M2C, 0x42, "M2C")
+
+/* Line number in text segment.  Desc is the line number;
+   value is corresponding address.  */
+__define_stab (N_SLINE, 0x44, "SLINE")
+
+/* Similar, for data segment.  */
+__define_stab (N_DSLINE, 0x46, "DSLINE")
+
+/* Similar, for bss segment.  */
+__define_stab (N_BSLINE, 0x48, "BSLINE")
+
+/* Sun's source-code browser stabs.  ?? Don't know what the fields are.
+   Supposedly the field is "path to associated .cb file".  THIS VALUE
+   OVERLAPS WITH N_BSLINE!  */
+__define_stab (N_BROWS, 0x48, "BROWS")
+
+/* GNU Modula-2 definition module dependency.  Value is the modification time
+   of the definition file.  Other is non-zero if it is imported with the
+   GNU M2 keyword %INITIALIZE.  Perhaps N_M2C can be used if there
+   are enough empty fields? */
+__define_stab(N_DEFD, 0x4a, "DEFD")
+
+/* THE FOLLOWING TWO STAB VALUES CONFLICT.  Happily, one is for Modula-2
+   and one is for C++.   Still,... */
+/* GNU C++ exception variable.  Name is variable name.  */
+__define_stab (N_EHDECL, 0x50, "EHDECL")
+/* Modula2 info "for imc":  name,,0,0,0  according to Ultrix V4.0.  */
+__define_stab (N_MOD2, 0x50, "MOD2")
+
+/* GNU C++ `catch' clause.  Value is its address.  Desc is nonzero if
+   this entry is immediately followed by a CAUGHT stab saying what exception
+   was caught.  Multiple CAUGHT stabs means that multiple exceptions
+   can be caught here.  If Desc is 0, it means all exceptions are caught
+   here.  */
+__define_stab (N_CATCH, 0x54, "CATCH")
+
+/* Structure or union element.  Value is offset in the structure.  */
+__define_stab (N_SSYM, 0x60, "SSYM")
+
+/* Name of main source file.
+   Value is starting text address of the compilation.  */
+__define_stab (N_SO, 0x64, "SO")
+
+/* Automatic variable in the stack.  Value is offset from frame pointer.
+   Also used for type descriptions.  */
+__define_stab (N_LSYM, 0x80, "LSYM")
+
+/* Beginning of an include file.  Only Sun uses this.
+   In an object file, only the name is significant.
+   The Sun linker puts data into some of the other fields.  */
+__define_stab (N_BINCL, 0x82, "BINCL")
+
+/* Name of sub-source file (#include file).
+   Value is starting text address of the compilation.  */
+__define_stab (N_SOL, 0x84, "SOL")
+
+/* Parameter variable.  Value is offset from argument pointer.
+   (On most machines the argument pointer is the same as the frame pointer.  */
+__define_stab (N_PSYM, 0xa0, "PSYM")
+
+/* End of an include file.  No name.
+   This and N_BINCL act as brackets around the file's output.
+   In an object file, there is no significant data in this entry.
+   The Sun linker puts data into some of the fields.  */
+__define_stab (N_EINCL, 0xa2, "EINCL")
+
+/* Alternate entry point.  Value is its address.  */
+__define_stab (N_ENTRY, 0xa4, "ENTRY")
+
+/* Beginning of lexical block.
+   The desc is the nesting level in lexical blocks.
+   The value is the address of the start of the text for the block.
+   The variables declared inside the block *precede* the N_LBRAC symbol.  */
+__define_stab (N_LBRAC, 0xc0, "LBRAC")
+
+/* Place holder for deleted include file.  Replaces a N_BINCL and everything
+   up to the corresponding N_EINCL.  The Sun linker generates these when
+   it finds multiple identical copies of the symbols from an include file.
+   This appears only in output from the Sun linker.  */
+__define_stab (N_EXCL, 0xc2, "EXCL")
+
+/* Modula-2 scope information.  Can someone say what info it contains?  */
+__define_stab (N_SCOPE, 0xc4, "SCOPE")
+
+/* End of a lexical block.  Desc matches the N_LBRAC's desc.
+   The value is the address of the end of the text for the block.  */
+__define_stab (N_RBRAC, 0xe0, "RBRAC")
+
+/* Begin named common block.  Only the name is significant.  */
+__define_stab (N_BCOMM, 0xe2, "BCOMM")
+
+/* End named common block.  Only the name is significant
+   (and it should match the N_BCOMM).  */
+__define_stab (N_ECOMM, 0xe4, "ECOMM")
+
+/* End common (local name): value is address.
+   I'm not sure how this is used.  */
+__define_stab (N_ECOML, 0xe8, "ECOML")
+
+/* These STAB's are used on Gould systems for Non-Base register symbols
+   or something like that.  FIXME.  I have assigned the values at random
+   since I don't have a Gould here.  Fixups from Gould folk welcome... */
+__define_stab (N_NBTEXT, 0xF0, "NBTEXT")
+__define_stab (N_NBDATA, 0xF2, "NBDATA")
+__define_stab (N_NBBSS,  0xF4, "NBBSS")
+__define_stab (N_NBSTS,  0xF6, "NBSTS")
+__define_stab (N_NBLCS,  0xF8, "NBLCS")
+
+/* Second symbol entry containing a length-value for the preceding entry.
+   The value is the length.  */
+__define_stab (N_LENG, 0xfe, "LENG")
+
+/* The above information, in matrix format.
+
+			STAB MATRIX
+	_________________________________________________
+	| 00 - 1F are not dbx stab symbols		|
+	| In most cases, the low bit is the EXTernal bit|
+
+	| 00 UNDEF  | 02 ABS	| 04 TEXT   | 06 DATA	|
+	| 01  |EXT  | 03  |EXT	| 05  |EXT  | 07  |EXT	|
+
+	| 08 BSS    | 0A INDR	| 0C FN_SEQ | 0E   	|
+	| 09  |EXT  | 0B 	| 0D	    | 0F	|
+
+	| 10 	    | 12 COMM	| 14 SETA   | 16 SETT	|
+	| 11	    | 13	| 15 	    | 17	|
+
+	| 18 SETD   | 1A SETB	| 1C SETV   | 1E WARNING|
+	| 19	    | 1B	| 1D 	    | 1F FN	|
+
+	|_______________________________________________|
+	| Debug entries with bit 01 set are unused.	|
+	| 20 GSYM   | 22 FNAME	| 24 FUN    | 26 STSYM	|
+	| 28 LCSYM  | 2A MAIN	| 2C	    | 2E	|
+	| 30 PC	    | 32 NSYMS	| 34 NOMAP  | 36	|
+	| 38 OBJ    | 3A	| 3C OPT    | 3E	|
+	| 40 RSYM   | 42 M2C	| 44 SLINE  | 46 DSLINE |
+	| 48 BSLINE*| 4A DEFD	| 4C        | 4E	|
+	| 50 EHDECL*| 52	| 54 CATCH  | 56        |
+	| 58        | 5A        | 5C        | 5E	|
+	| 60 SSYM   | 62	| 64 SO	    | 66 	|
+	| 68 	    | 6A	| 6C	    | 6E	|
+	| 70	    | 72	| 74	    | 76	|
+	| 78	    | 7A	| 7C	    | 7E	|
+	| 80 LSYM   | 82 BINCL	| 84 SOL    | 86	|
+	| 88	    | 8A	| 8C	    | 8E	|
+	| 90	    | 92	| 94	    | 96	|
+	| 98	    | 9A	| 9C	    | 9E	|
+	| A0 PSYM   | A2 EINCL	| A4 ENTRY  | A6	|
+	| A8	    | AA	| AC	    | AE	|
+	| B0	    | B2	| B4	    | B6	|
+	| B8	    | BA	| BC	    | BE	|
+	| C0 LBRAC  | C2 EXCL	| C4 SCOPE  | C6	|
+	| C8	    | CA	| CC	    | CE	|
+	| D0	    | D2	| D4	    | D6	|
+	| D8	    | DA	| DC	    | DE	|
+	| E0 RBRAC  | E2 BCOMM	| E4 ECOMM  | E6	|
+	| E8 ECOML  | EA	| EC	    | EE	|
+	| F0	    | F2	| F4	    | F6	|
+	| F8	    | FA	| FC	    | FE LENG	|
+	+-----------------------------------------------+
+ * 50 EHDECL is also MOD2.
+ * 48 BSLINE is also BROWS.
+ */
diff --git a/include/bits/stat.h b/include/bits/stat.h
new file mode 100644
index 0000000..f60a58a
--- /dev/null
+++ b/include/bits/stat.h
@@ -0,0 +1,261 @@
+/* Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _SYS_STAT_H && !defined _FCNTL_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+#ifndef _BITS_STAT_H
+#define _BITS_STAT_H	1
+
+#include <bits/types.h>
+
+/* NOTE: The size of this structure (32 ints) is known in
+   <hurd/hurd_types.defs>, since it is used in the `io_stat' RPC.  MiG
+   does not cope at all well with the passed C structure not being of
+   the expected size.  There are some filler words at the end to allow
+   for future expansion.  To increase the size of the structure used
+   in the RPC and retain binary compatibility, we would need to assign
+   a new message number.  */
+
+struct stat
+  {
+    int st_fstype;		/* File system type.  */
+    __fsid_t st_fsid;		/* File system ID.  */
+#define	st_dev	st_fsid
+
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;		/* File number.  */
+#else
+    __ino64_t st_ino;		/* File number.  */
+#endif
+    unsigned int st_gen;	/* To detect reuse of file numbers.  */
+    __dev_t st_rdev;		/* Device if special file.  */
+    __mode_t st_mode;		/* File mode.  */
+    __nlink_t st_nlink;		/* Number of links.  */
+
+    __uid_t st_uid;		/* Owner.  */
+    __gid_t st_gid;		/* Owning group.  */
+
+#ifndef __USE_FILE_OFFSET64
+    __off_t st_size;		/* Size in bytes.  */
+#else
+    __off64_t st_size;		/* Size in bytes.  */
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+
+    __blksize_t st_blksize;	/* Optimal size for I/O.  */
+
+#ifndef __USE_FILE_OFFSET64
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.
+				   Not related to `st_blksize'.  */
+#else
+    __blkcnt64_t st_blocks;	/* Number of 512-byte blocks allocated.
+				   Not related to `st_blksize'.  */
+#endif
+
+    __uid_t st_author;		/* File author.  */
+
+    unsigned int st_flags;	/* User-defined flags.
+				   High 16 bits can be set only by root.  */
+
+#ifndef __USE_FILE_OFFSET64
+# define _SPARE_SIZE	((sizeof (__fsid_t) == sizeof (int)) ? 12 : 11)
+#else
+# define _SPARE_SIZE	((sizeof (__fsid_t) == sizeof (int)) ? 9 : 8)
+#endif
+    int st_spare[_SPARE_SIZE];	/* Room for future expansion.  */
+#undef _SPARE_SIZE
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    int st_fstype;		/* File system type.  */
+    __fsid_t st_fsid;		/* File system ID.  */
+# define st_dev	st_fsid
+
+    __ino64_t st_ino;		/* File number.  */
+    unsigned int st_gen;	/* To detect reuse of file numbers.  */
+    __dev_t st_rdev;		/* Device if special file.  */
+    __mode_t st_mode;		/* File mode.  */
+    __nlink_t st_nlink;		/* Number of links.  */
+
+    __uid_t st_uid;		/* Owner.  */
+    __gid_t st_gid;		/* Owning group.  */
+
+    __off64_t st_size;		/* Size in bytes.  */
+
+#if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+
+    __blksize_t st_blksize;	/* Optimal size for I/O.  */
+
+    __blkcnt64_t st_blocks;	/* Number of 512-byte blocks allocated.
+				   Not related to `st_blksize'.  */
+
+    __uid_t st_author;		/* File author.  */
+
+    unsigned int st_flags;	/* User-defined flags.
+				   High 16 bits can be set only by root.  */
+
+#define _SPARE_SIZE	((sizeof (__fsid_t) == sizeof (int)) ? 9 : 8)
+    int st_spare[_SPARE_SIZE];	/* Room for future expansion.  */
+#undef _SPARE_SIZE
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define	_STATBUF_ST_BLKSIZE
+/* Nanosecond resolution time values are supported.  */
+#define _STATBUF_ST_NSEC
+
+/* Encoding of the file mode.  */
+
+#define	__S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define	__S_IFDIR	0040000	/* Directory.  */
+#define	__S_IFCHR	0020000	/* Character device.  */
+#define	__S_IFBLK	0060000	/* Block device.  */
+#define	__S_IFREG	0100000	/* Regular file.  */
+#define	__S_IFLNK	0120000	/* Symbolic link.  */
+#define	__S_IFSOCK	0140000	/* Socket.  */
+#define	__S_IFIFO	0010000	/* FIFO.  */
+
+/* POSIX.1b objects.  */
+#define __S_TYPEISMQ(buf) (0)
+#define __S_TYPEISSEM(buf) (0)
+#define __S_TYPEISSHM(buf) (0)
+
+/* Protection bits.  */
+
+#define	__S_ISUID	04000	/* Set user ID on execution.  */
+#define	__S_ISGID	02000	/* Set group ID on execution.  */
+#define	__S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define	__S_IREAD	00400	/* Read by owner.  */
+#define	__S_IWRITE	00200	/* Write by owner.  */
+#define	__S_IEXEC	00100	/* Execute by owner.  */
+
+
+#ifdef	__USE_GNU
+/* If set, there is no benefit in caching the contents of this file.  */
+#define S_INOCACHE	000000200000
+
+/* If the S_IUSEUNK bit is set, then the S_IUNKNOWN bits (see below)
+   control access for unknown users.  If S_IUSEUNK is clear, then unknown
+   users are treated as "others" for purposes of access control.  */
+#define S_IUSEUNK	000000400000
+/* Mask of protection bits for unknown users (no effective IDs at all).  */
+#define S_IUNKNOWN      000007000000
+/* Shift S_IREAD, S_IWRITE, S_IEXEC left this many bits to produce the
+   protection bits for unknown users.  */
+#define S_IUNKSHIFT	12
+
+/* Read only bits: */
+
+/* There is a passive translator set for this file */
+#define S_IPTRANS	000010000000
+/* There is an active translator running on this file */
+#define S_IATRANS	000020000000
+/* This is the root of a filesystem (or single node translator) */
+#define S_IROOT		000040000000
+/* All the bits relevant to translators */
+#define S_ITRANS	000070000000
+
+/* Definitely no mmaps to this.  */
+#define S_IMMAP0	000100000000
+
+/* ALL the unused bits.  */
+#define	S_ISPARE	(~(S_IFMT|S_ITRANS|S_INOCACHE|S_IMMAP0|    \
+			   S_IUSEUNK|S_IUNKNOWN|07777))
+#endif
+
+#ifdef	__USE_BSD
+
+/* Default file creation mask (umask).  */
+# define CMASK		0022
+
+
+/* Definitions of flags stored in file flags word.  */
+
+/* Super-user and owner changeable flags.  */
+# define UF_SETTABLE	0x0000ffff	/* mask of owner changeable flags */
+# define UF_NODUMP	0x00000001	/* do not dump file */
+# define UF_IMMUTABLE	0x00000002	/* file may not be changed */
+# define UF_APPEND	0x00000004	/* writes to file may only append */
+# define UF_OPAQUE	0x00000008	/* directory is opaque wrt. union */
+# define UF_NOUNLINK	0x00000010	/* file may not be removed or renamed */
+
+/* Super-user changeable flags.  */
+# define SF_SETTABLE	0xffff0000	/* mask of superuser changeable flags */
+# define SF_ARCHIVED	0x00010000	/* file is archived */
+# define SF_IMMUTABLE	0x00020000	/* file may not be changed */
+# define SF_APPEND	0x00040000	/* writes to file may only append */
+# define SF_NOUNLINK	0x00100000	/* file may not be removed or renamed */
+# define SF_SNAPSHOT	0x00200000	/* snapshot inode */
+
+__BEGIN_DECLS
+
+/* Set file flags for FILE to FLAGS.  */
+extern int chflags (__const char *__file, unsigned long int __flags) __THROW;
+
+/* Set file flags of the file referred to by FD to FLAGS.  */
+extern int fchflags (int __fd, unsigned long int __flags) __THROW;
+
+__END_DECLS
+
+#endif
+
+#endif	/* bits/stat.h */
diff --git a/include/bits/statfs.h b/include/bits/statfs.h
new file mode 100644
index 0000000..ef15f91
--- /dev/null
+++ b/include/bits/statfs.h
@@ -0,0 +1,86 @@
+/* Definition of `struct statfs', information about a filesystem.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_STATFS_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* GNU Hurd NOTE: The size of this structure (16 ints) is known in
+   <hurd/hurd_types.defs>, since it is used in the `file_statfs' RPC.  MiG
+   does not cope at all well with the passed C structure not being of the
+   expected size.  There are some filler words at the end to allow for
+   future expansion.  To increase the size of the structure used in the RPC
+   and retain binary compatibility, we would need to assign a new message
+   number.
+
+   Note also that `struct statvfs' in <bits/statvfs.h> is laid out
+   identically to `struct statfs', so they can be used interchangeably.
+   Any changes made here must also be made in that file.  */
+
+struct statfs
+  {
+    unsigned int f_type;
+    unsigned int f_bsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsblkcnt_t f_files;
+    __fsblkcnt_t f_ffree;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsblkcnt64_t f_files;
+    __fsblkcnt64_t f_ffree;
+#endif
+    __fsid_t f_fsid;
+    unsigned int f_namelen;
+#ifndef __USE_FILE_OFFSET64
+    __fsfilcnt_t f_favail;
+#else
+    __fsfilcnt64_t f_favail;
+#endif
+    unsigned int f_frsize;
+    unsigned int f_flag;
+    unsigned int f_spare[3];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    unsigned int f_type;
+    unsigned int f_bsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsblkcnt64_t f_files;
+    __fsblkcnt64_t f_ffree;
+    __fsid_t f_fsid;
+    unsigned int f_namelen;
+    __fsfilcnt64_t f_favail;
+    unsigned int f_frsize;
+    unsigned int f_flag;
+    unsigned int f_spare[3];
+  };
+#endif
+
+/* Tell code we have this member.  */
+#define _STATFS_F_NAMELEN
diff --git a/include/bits/statvfs.h b/include/bits/statvfs.h
new file mode 100644
index 0000000..857c511
--- /dev/null
+++ b/include/bits/statvfs.h
@@ -0,0 +1,95 @@
+/* Definition of `struct statvfs', information about a filesystem.
+   Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_STATVFS_H
+# error "Never include <bits/statvfs.h> directly; use <sys/statvfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* GNU Hurd NOTE: This structure is carefully laid out such that we
+   can use the `file_statfs' RPC to implement `statvfs' and
+   `fstatvfs'.  Please keep this file in sync with <bits/statfs.h>,
+   and pay attention to the note in that file.  */
+
+struct statvfs
+  {
+    unsigned int __f_type;
+    unsigned int f_bsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+#endif
+    __fsid_t f_fsid;
+    unsigned int f_namemax;	/* NOTE: f_namelen in `struct statfs'.  */
+#ifndef __USE_FILE_OFFSET64
+    __fsfilcnt_t f_favail;
+#else
+    __fsfilcnt64_t f_favail;
+#endif
+    unsigned int f_frsize;
+    unsigned int f_flag;
+    unsigned int f_spare[3];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statvfs64
+  {
+    unsigned int __f_type;
+    unsigned int f_bsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsid_t f_fsid;
+    unsigned int f_namemax;
+    __fsfilcnt64_t f_favail;
+    unsigned int f_frsize;
+    unsigned int f_flag;
+    unsigned int f_spare[3];
+  };
+#endif
+
+/* Definitions for the flag in `f_flag'.
+   The values for the non-standard flags come from Linux.  */
+enum
+{
+  ST_RDONLY = 1,
+#define ST_RDONLY	ST_RDONLY
+  ST_NOSUID = 2
+#define ST_NOSUID	ST_NOSUID
+#ifdef __USE_GNU
+  ,
+  ST_NOEXEC = 8,
+# define ST_NOEXEC	ST_NOEXEC
+  ST_SYNCHRONOUS = 16,
+# define ST_SYNCHRONOUS	ST_SYNCHRONOUS
+  ST_NOATIME = 32		/* Do not update access times.  */
+# define ST_NOATIME	ST_NOATIME
+#endif
+};
diff --git a/include/bits/stdio-ldbl.h b/include/bits/stdio-ldbl.h
new file mode 100644
index 0000000..e8f714f
--- /dev/null
+++ b/include/bits/stdio-ldbl.h
@@ -0,0 +1,101 @@
+/* -mlong-double-64 compatibility mode for stdio functions.
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STDIO_H
+# error "Never include <bits/stdio-ldbl.h> directly; use <stdio.h> instead."
+#endif
+
+__BEGIN_NAMESPACE_STD
+__LDBL_REDIR_DECL (fprintf)
+__LDBL_REDIR_DECL (printf)
+__LDBL_REDIR_DECL (sprintf)
+__LDBL_REDIR_DECL (vfprintf)
+__LDBL_REDIR_DECL (vprintf)
+__LDBL_REDIR_DECL (vsprintf)
+#if defined __USE_ISOC99 && !defined __USE_GNU \
+    && !defined __REDIRECT \
+    && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
+__LDBL_REDIR1_DECL (fscanf, __nldbl___isoc99_fscanf)
+__LDBL_REDIR1_DECL (scanf, __nldbl___isoc99_scanf)
+__LDBL_REDIR1_DECL (sscanf, __nldbl___isoc99_sscanf)
+#else
+__LDBL_REDIR_DECL (fscanf)
+__LDBL_REDIR_DECL (scanf)
+__LDBL_REDIR_DECL (sscanf)
+#endif
+__END_NAMESPACE_STD
+
+#if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
+__BEGIN_NAMESPACE_C99
+__LDBL_REDIR_DECL (snprintf)
+__LDBL_REDIR_DECL (vsnprintf)
+__END_NAMESPACE_C99
+#endif
+
+#ifdef	__USE_ISOC99
+__BEGIN_NAMESPACE_C99
+# if !defined __USE_GNU && !defined __REDIRECT \
+     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
+__LDBL_REDIR1_DECL (vfscanf, __nldbl___isoc99_vfscanf)
+__LDBL_REDIR1_DECL (vscanf, __nldbl___isoc99_vscanf)
+__LDBL_REDIR1_DECL (vsscanf, __nldbl___isoc99_vsscanf)
+# else
+__LDBL_REDIR_DECL (vfscanf)
+__LDBL_REDIR_DECL (vsscanf)
+__LDBL_REDIR_DECL (vscanf)
+# endif
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_XOPEN2K8
+__LDBL_REDIR_DECL (vdprintf)
+__LDBL_REDIR_DECL (dprintf)
+#endif
+
+#ifdef __USE_GNU
+__LDBL_REDIR_DECL (vasprintf)
+__LDBL_REDIR_DECL (__asprintf)
+__LDBL_REDIR_DECL (asprintf)
+__LDBL_REDIR_DECL (obstack_printf)
+__LDBL_REDIR_DECL (obstack_vprintf)
+#endif
+
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+__LDBL_REDIR_DECL (__sprintf_chk)
+__LDBL_REDIR_DECL (__vsprintf_chk)
+# if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
+__LDBL_REDIR_DECL (__snprintf_chk)
+__LDBL_REDIR_DECL (__vsnprintf_chk)
+# endif
+# if __USE_FORTIFY_LEVEL > 1
+__LDBL_REDIR_DECL (__fprintf_chk)
+__LDBL_REDIR_DECL (__printf_chk)
+__LDBL_REDIR_DECL (__vfprintf_chk)
+__LDBL_REDIR_DECL (__vprintf_chk)
+#  ifdef __USE_XOPEN2K8
+__LDBL_REDIR_DECL (__dprintf_chk)
+__LDBL_REDIR_DECL (__vdprintf_chk)
+#  endif
+#  ifdef __USE_GNU
+__LDBL_REDIR_DECL (__asprintf_chk)
+__LDBL_REDIR_DECL (__vasprintf_chk)
+__LDBL_REDIR_DECL (__obstack_printf_chk)
+__LDBL_REDIR_DECL (__obstack_vprintf_chk)
+#  endif
+# endif
+#endif
diff --git a/include/bits/stdio-lock.h b/include/bits/stdio-lock.h
new file mode 100644
index 0000000..3b29cf8
--- /dev/null
+++ b/include/bits/stdio-lock.h
@@ -0,0 +1,66 @@
+/* Thread package specific definitions of stream lock type.  Generic version.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_STDIO_LOCK_H
+#define _BITS_STDIO_LOCK_H 1
+
+#include <bits/libc-lock.h>
+
+__libc_lock_define_recursive (typedef, _IO_lock_t)
+
+/* We need recursive (counting) mutexes.  */
+#ifdef _LIBC_LOCK_RECURSIVE_INITIALIZER
+# define _IO_lock_initializer _LIBC_LOCK_RECURSIVE_INITIALIZER
+#elif _IO_MTSAFE_IO
+ #error libio needs recursive mutexes for _IO_MTSAFE_IO
+#endif
+
+#define _IO_lock_init(_name)	__libc_lock_init_recursive (_name)
+#define _IO_lock_fini(_name)	__libc_lock_fini_recursive (_name)
+#define _IO_lock_lock(_name)	__libc_lock_lock_recursive (_name)
+#define _IO_lock_trylock(_name)	__libc_lock_trylock_recursive (_name)
+#define _IO_lock_unlock(_name)	__libc_lock_unlock_recursive (_name)
+
+
+#define _IO_cleanup_region_start(_fct, _fp) \
+  __libc_cleanup_region_start (((_fp)->_flags & _IO_USER_LOCK) == 0, _fct, _fp)
+#define _IO_cleanup_region_start_noarg(_fct) \
+  __libc_cleanup_region_start (1, _fct, NULL)
+#define _IO_cleanup_region_end(_doit) \
+  __libc_cleanup_region_end (_doit)
+
+#if defined _LIBC && !defined NOT_IN_libc
+# define _IO_acquire_lock(_fp) \
+  { \
+  _IO_FILE *_IO_acquire_lock_file = _fp; \
+  __libc_cleanup_region_start (1, (void (*) (void *)) _IO_acquire_lock_fct, &_IO_acquire_lock_file); \
+  _IO_flockfile (_IO_acquire_lock_file)
+
+# define _IO_acquire_lock_clear_flags2(_fp) \
+  { \
+  _IO_FILE *_IO_acquire_lock_file = _fp; \
+  __libc_cleanup_region_start (1, (void (*) (void *)) _IO_acquire_lock_clear_flags2_fct, &_IO_acquire_lock_file); \
+  _IO_flockfile (_IO_acquire_lock_file)
+
+# define _IO_release_lock(_fp) \
+  __libc_cleanup_region_end (1); \
+   }
+   
+#endif
+
+#endif /* bits/stdio-lock.h */
diff --git a/include/bits/stdio.h b/include/bits/stdio.h
new file mode 100644
index 0000000..4d872e2
--- /dev/null
+++ b/include/bits/stdio.h
@@ -0,0 +1,190 @@
+/* Optimizing macros and inline functions for stdio functions.
+   Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STDIO_H
+# error "Never include <bits/stdio.h> directly; use <stdio.h> instead."
+#endif
+
+#ifndef __extern_inline
+# define __STDIO_INLINE inline
+#else
+# define __STDIO_INLINE __extern_inline
+#endif
+
+
+#ifdef __USE_EXTERN_INLINES
+/* For -D_FORTIFY_SOURCE{,=2} bits/stdio2.h will define a different
+   inline.  */
+# if !(__USE_FORTIFY_LEVEL > 0 && defined __fortify_function)
+/* Write formatted output to stdout from argument list ARG.  */
+__STDIO_INLINE int
+vprintf (const char *__restrict __fmt, _G_va_list __arg)
+{
+  return vfprintf (stdout, __fmt, __arg);
+}
+# endif
+
+/* Read a character from stdin.  */
+__STDIO_INLINE int
+getchar (void)
+{
+  return _IO_getc (stdin);
+}
+
+
+# ifdef __USE_MISC
+/* Faster version when locking is not necessary.  */
+__STDIO_INLINE int
+fgetc_unlocked (FILE *__fp)
+{
+  return _IO_getc_unlocked (__fp);
+}
+# endif /* misc */
+
+
+# if defined __USE_POSIX || defined __USE_MISC
+/* This is defined in POSIX.1:1996.  */
+__STDIO_INLINE int
+getc_unlocked (FILE *__fp)
+{
+  return _IO_getc_unlocked (__fp);
+}
+
+/* This is defined in POSIX.1:1996.  */
+__STDIO_INLINE int
+getchar_unlocked (void)
+{
+  return _IO_getc_unlocked (stdin);
+}
+# endif	/* POSIX || misc */
+
+
+/* Write a character to stdout.  */
+__STDIO_INLINE int
+putchar (int __c)
+{
+  return _IO_putc (__c, stdout);
+}
+
+
+# ifdef __USE_MISC
+/* Faster version when locking is not necessary.  */
+__STDIO_INLINE int
+fputc_unlocked (int __c, FILE *__stream)
+{
+  return _IO_putc_unlocked (__c, __stream);
+}
+# endif /* misc */
+
+
+# if defined __USE_POSIX || defined __USE_MISC
+/* This is defined in POSIX.1:1996.  */
+__STDIO_INLINE int
+putc_unlocked (int __c, FILE *__stream)
+{
+  return _IO_putc_unlocked (__c, __stream);
+}
+
+/* This is defined in POSIX.1:1996.  */
+__STDIO_INLINE int
+putchar_unlocked (int __c)
+{
+  return _IO_putc_unlocked (__c, stdout);
+}
+# endif	/* POSIX || misc */
+
+
+# ifdef	__USE_GNU
+/* Like `getdelim', but reads up to a newline.  */
+__STDIO_INLINE _IO_ssize_t
+getline (char **__lineptr, size_t *__n, FILE *__stream)
+{
+  return __getdelim (__lineptr, __n, '\n', __stream);
+}
+# endif /* GNU */
+
+
+# ifdef __USE_MISC
+/* Faster versions when locking is not required.  */
+__STDIO_INLINE int
+__NTH (feof_unlocked (FILE *__stream))
+{
+  return _IO_feof_unlocked (__stream);
+}
+
+/* Faster versions when locking is not required.  */
+__STDIO_INLINE int
+__NTH (ferror_unlocked (FILE *__stream))
+{
+  return _IO_ferror_unlocked (__stream);
+}
+# endif /* misc */
+
+#endif /* Use extern inlines.  */
+
+
+#if defined __USE_MISC && defined __GNUC__ && defined __OPTIMIZE__ \
+    && !defined __cplusplus
+/* Perform some simple optimizations.  */
+# define fread_unlocked(ptr, size, n, stream) \
+  (__extension__ ((__builtin_constant_p (size) && __builtin_constant_p (n)    \
+		   && (size_t) (size) * (size_t) (n) <= 8		      \
+		   && (size_t) (size) != 0)				      \
+		  ? ({ char *__ptr = (char *) (ptr);			      \
+		       FILE *__stream = (stream);			      \
+		       size_t __cnt;					      \
+		       for (__cnt = (size_t) (size) * (size_t) (n);	      \
+			    __cnt > 0; --__cnt)				      \
+			 {						      \
+			   int __c = _IO_getc_unlocked (__stream);	      \
+			   if (__c == EOF)				      \
+			     break;					      \
+			   *__ptr++ = __c;				      \
+			 }						      \
+		       ((size_t) (size) * (size_t) (n) - __cnt)		      \
+			/ (size_t) (size); })				      \
+		  : (((__builtin_constant_p (size) && (size_t) (size) == 0)   \
+		      || (__builtin_constant_p (n) && (size_t) (n) == 0))     \
+			/* Evaluate all parameters once.  */		      \
+		     ? ((void) (ptr), (void) (stream), (void) (size),	      \
+			(void) (n), (size_t) 0)				      \
+		     : fread_unlocked (ptr, size, n, stream))))
+
+# define fwrite_unlocked(ptr, size, n, stream) \
+  (__extension__ ((__builtin_constant_p (size) && __builtin_constant_p (n)    \
+		   && (size_t) (size) * (size_t) (n) <= 8		      \
+		   && (size_t) (size) != 0)				      \
+		  ? ({ const char *__ptr = (const char *) (ptr);	      \
+		       FILE *__stream = (stream);			      \
+		       size_t __cnt;					      \
+		       for (__cnt = (size_t) (size) * (size_t) (n);	      \
+			    __cnt > 0; --__cnt)				      \
+			 if (_IO_putc_unlocked (*__ptr++, __stream) == EOF)   \
+			   break;					      \
+		       ((size_t) (size) * (size_t) (n) - __cnt)		      \
+			/ (size_t) (size); })				      \
+		  : (((__builtin_constant_p (size) && (size_t) (size) == 0)   \
+		      || (__builtin_constant_p (n) && (size_t) (n) == 0))     \
+			/* Evaluate all parameters once.  */		      \
+		     ? ((void) (ptr), (void) (stream), (void) (size),	      \
+			(void) (n), (size_t) 0)				      \
+		     : fwrite_unlocked (ptr, size, n, stream))))
+#endif
+
+/* Define helper macro.  */
+#undef __STDIO_INLINE
diff --git a/include/bits/stdio2.h b/include/bits/stdio2.h
new file mode 100644
index 0000000..efa8869
--- /dev/null
+++ b/include/bits/stdio2.h
@@ -0,0 +1,382 @@
+/* Checking macros for stdio functions.
+   Copyright (C) 2004-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STDIO_H
+# error "Never include <bits/stdio2.h> directly; use <stdio.h> instead."
+#endif
+
+extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
+			  const char *__restrict __format, ...) __THROW;
+extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
+			   const char *__restrict __format,
+			   _G_va_list __ap) __THROW;
+
+#ifdef __va_arg_pack
+__fortify_function int
+__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
+{
+  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
+				  __bos (__s), __fmt, __va_arg_pack ());
+}
+#elif !defined __cplusplus
+# define sprintf(str, ...) \
+  __builtin___sprintf_chk (str, __USE_FORTIFY_LEVEL - 1, __bos (str), \
+			   __VA_ARGS__)
+#endif
+
+__fortify_function int
+__NTH (vsprintf (char *__restrict __s, const char *__restrict __fmt,
+		 _G_va_list __ap))
+{
+  return __builtin___vsprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
+				   __bos (__s), __fmt, __ap);
+}
+
+#if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
+
+extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
+			   size_t __slen, const char *__restrict __format,
+			   ...) __THROW;
+extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
+			    size_t __slen, const char *__restrict __format,
+			    _G_va_list __ap) __THROW;
+
+# ifdef __va_arg_pack
+__fortify_function int
+__NTH (snprintf (char *__restrict __s, size_t __n,
+		 const char *__restrict __fmt, ...))
+{
+  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
+				   __bos (__s), __fmt, __va_arg_pack ());
+}
+# elif !defined __cplusplus
+#  define snprintf(str, len, ...) \
+  __builtin___snprintf_chk (str, len, __USE_FORTIFY_LEVEL - 1, __bos (str), \
+			    __VA_ARGS__)
+# endif
+
+__fortify_function int
+__NTH (vsnprintf (char *__restrict __s, size_t __n,
+		  const char *__restrict __fmt, _G_va_list __ap))
+{
+  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
+				    __bos (__s), __fmt, __ap);
+}
+
+#endif
+
+#if __USE_FORTIFY_LEVEL > 1
+
+extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
+			  const char *__restrict __format, ...);
+extern int __printf_chk (int __flag, const char *__restrict __format, ...);
+extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
+			   const char *__restrict __format, _G_va_list __ap);
+extern int __vprintf_chk (int __flag, const char *__restrict __format,
+			  _G_va_list __ap);
+
+# ifdef __va_arg_pack
+__fortify_function int
+fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
+{
+  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
+			__va_arg_pack ());
+}
+
+__fortify_function int
+printf (const char *__restrict __fmt, ...)
+{
+  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
+}
+# elif !defined __cplusplus
+#  define printf(...) \
+  __printf_chk (__USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+#  define fprintf(stream, ...) \
+  __fprintf_chk (stream, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+# endif
+
+__fortify_function int
+vprintf (const char *__restrict __fmt, _G_va_list __ap)
+{
+#ifdef __USE_EXTERN_INLINES
+  return __vfprintf_chk (stdout, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
+#else
+  return __vprintf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __ap);
+#endif
+}
+
+__fortify_function int
+vfprintf (FILE *__restrict __stream,
+	  const char *__restrict __fmt, _G_va_list __ap)
+{
+  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
+}
+
+# ifdef __USE_XOPEN2K8
+extern int __dprintf_chk (int __fd, int __flag, const char *__restrict __fmt,
+			  ...) __attribute__ ((__format__ (__printf__, 3, 4)));
+extern int __vdprintf_chk (int __fd, int __flag,
+			   const char *__restrict __fmt, _G_va_list __arg)
+     __attribute__ ((__format__ (__printf__, 3, 0)));
+
+#  ifdef __va_arg_pack
+__fortify_function int
+dprintf (int __fd, const char *__restrict __fmt, ...)
+{
+  return __dprintf_chk (__fd, __USE_FORTIFY_LEVEL - 1, __fmt,
+			__va_arg_pack ());
+}
+#  elif !defined __cplusplus
+#   define dprintf(fd, ...) \
+  __dprintf_chk (fd, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+#  endif
+
+__fortify_function int
+vdprintf (int __fd, const char *__restrict __fmt, _G_va_list __ap)
+{
+  return __vdprintf_chk (__fd, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
+}
+# endif
+
+# ifdef __USE_GNU
+
+extern int __asprintf_chk (char **__restrict __ptr, int __flag,
+			   const char *__restrict __fmt, ...)
+     __THROW __attribute__ ((__format__ (__printf__, 3, 4))) __wur;
+extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
+			    const char *__restrict __fmt, _G_va_list __arg)
+     __THROW __attribute__ ((__format__ (__printf__, 3, 0))) __wur;
+extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
+				 int __flag, const char *__restrict __format,
+				 ...)
+     __THROW __attribute__ ((__format__ (__printf__, 3, 4)));
+extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
+				  int __flag,
+				  const char *__restrict __format,
+				  _G_va_list __args)
+     __THROW __attribute__ ((__format__ (__printf__, 3, 0)));
+
+#  ifdef __va_arg_pack
+__fortify_function int
+__NTH (asprintf (char **__restrict __ptr, const char *__restrict __fmt, ...))
+{
+  return __asprintf_chk (__ptr, __USE_FORTIFY_LEVEL - 1, __fmt,
+			 __va_arg_pack ());
+}
+
+__fortify_function int
+__NTH (__asprintf (char **__restrict __ptr, const char *__restrict __fmt,
+		   ...))
+{
+  return __asprintf_chk (__ptr, __USE_FORTIFY_LEVEL - 1, __fmt,
+			 __va_arg_pack ());
+}
+
+__fortify_function int
+__NTH (obstack_printf (struct obstack *__restrict __obstack,
+		       const char *__restrict __fmt, ...))
+{
+  return __obstack_printf_chk (__obstack, __USE_FORTIFY_LEVEL - 1, __fmt,
+			       __va_arg_pack ());
+}
+#  elif !defined __cplusplus
+#   define asprintf(ptr, ...) \
+  __asprintf_chk (ptr, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+#   define __asprintf(ptr, ...) \
+  __asprintf_chk (ptr, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+#   define obstack_printf(obstack, ...) \
+  __obstack_printf_chk (obstack, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+#  endif
+
+__fortify_function int
+__NTH (vasprintf (char **__restrict __ptr, const char *__restrict __fmt,
+		  _G_va_list __ap))
+{
+  return __vasprintf_chk (__ptr, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
+}
+
+__fortify_function int
+__NTH (obstack_vprintf (struct obstack *__restrict __obstack,
+			const char *__restrict __fmt, _G_va_list __ap))
+{
+  return __obstack_vprintf_chk (__obstack, __USE_FORTIFY_LEVEL - 1, __fmt,
+				__ap);
+}
+
+# endif
+
+#endif
+
+#if !defined __USE_ISOC11 \
+    || (defined __cplusplus && __cplusplus <= 201103L && !defined __USE_GNU)
+extern char *__gets_chk (char *__str, size_t) __wur;
+extern char *__REDIRECT (__gets_warn, (char *__str), gets)
+     __wur __warnattr ("please use fgets or getline instead, gets can't "
+		       "specify buffer size");
+
+__fortify_function __wur char *
+gets (char *__str)
+{
+  if (__bos (__str) != (size_t) -1)
+    return __gets_chk (__str, __bos (__str));
+  return __gets_warn (__str);
+}
+#endif
+
+extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
+			  FILE *__restrict __stream) __wur;
+extern char *__REDIRECT (__fgets_alias,
+			 (char *__restrict __s, int __n,
+			  FILE *__restrict __stream), fgets) __wur;
+extern char *__REDIRECT (__fgets_chk_warn,
+			 (char *__restrict __s, size_t __size, int __n,
+			  FILE *__restrict __stream), __fgets_chk)
+     __wur __warnattr ("fgets called with bigger size than length "
+		       "of destination buffer");
+
+__fortify_function __wur char *
+fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
+{
+  if (__bos (__s) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n) || __n <= 0)
+	return __fgets_chk (__s, __bos (__s), __n, __stream);
+
+      if ((size_t) __n > __bos (__s))
+	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
+    }
+  return __fgets_alias (__s, __n, __stream);
+}
+
+extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
+			   size_t __size, size_t __n,
+			   FILE *__restrict __stream) __wur;
+extern size_t __REDIRECT (__fread_alias,
+			  (void *__restrict __ptr, size_t __size,
+			   size_t __n, FILE *__restrict __stream),
+			  fread) __wur;
+extern size_t __REDIRECT (__fread_chk_warn,
+			  (void *__restrict __ptr, size_t __ptrlen,
+			   size_t __size, size_t __n,
+			   FILE *__restrict __stream),
+			  __fread_chk)
+     __wur __warnattr ("fread called with bigger size * nmemb than length "
+		       "of destination buffer");
+
+__fortify_function __wur size_t
+fread (void *__restrict __ptr, size_t __size, size_t __n,
+       FILE *__restrict __stream)
+{
+  if (__bos0 (__ptr) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__size)
+	  || !__builtin_constant_p (__n)
+	  || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
+	return __fread_chk (__ptr, __bos0 (__ptr), __size, __n, __stream);
+
+      if (__size * __n > __bos0 (__ptr))
+	return __fread_chk_warn (__ptr, __bos0 (__ptr), __size, __n, __stream);
+    }
+  return __fread_alias (__ptr, __size, __n, __stream);
+}
+
+#ifdef __USE_GNU
+extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
+				   int __n, FILE *__restrict __stream) __wur;
+extern char *__REDIRECT (__fgets_unlocked_alias,
+			 (char *__restrict __s, int __n,
+			  FILE *__restrict __stream), fgets_unlocked) __wur;
+extern char *__REDIRECT (__fgets_unlocked_chk_warn,
+			 (char *__restrict __s, size_t __size, int __n,
+			  FILE *__restrict __stream), __fgets_unlocked_chk)
+     __wur __warnattr ("fgets_unlocked called with bigger size than length "
+		       "of destination buffer");
+
+__fortify_function __wur char *
+fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
+{
+  if (__bos (__s) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n) || __n <= 0)
+	return __fgets_unlocked_chk (__s, __bos (__s), __n, __stream);
+
+      if ((size_t) __n > __bos (__s))
+	return __fgets_unlocked_chk_warn (__s, __bos (__s), __n, __stream);
+    }
+  return __fgets_unlocked_alias (__s, __n, __stream);
+}
+#endif
+
+#ifdef __USE_MISC
+# undef fread_unlocked
+extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
+				    size_t __size, size_t __n,
+				    FILE *__restrict __stream) __wur;
+extern size_t __REDIRECT (__fread_unlocked_alias,
+			  (void *__restrict __ptr, size_t __size,
+			   size_t __n, FILE *__restrict __stream),
+			  fread_unlocked) __wur;
+extern size_t __REDIRECT (__fread_unlocked_chk_warn,
+			  (void *__restrict __ptr, size_t __ptrlen,
+			   size_t __size, size_t __n,
+			   FILE *__restrict __stream),
+			  __fread_unlocked_chk)
+     __wur __warnattr ("fread_unlocked called with bigger size * nmemb than "
+		       "length of destination buffer");
+
+__fortify_function __wur size_t
+fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
+		FILE *__restrict __stream)
+{
+  if (__bos0 (__ptr) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__size)
+	  || !__builtin_constant_p (__n)
+	  || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
+	return __fread_unlocked_chk (__ptr, __bos0 (__ptr), __size, __n,
+				     __stream);
+
+      if (__size * __n > __bos0 (__ptr))
+	return __fread_unlocked_chk_warn (__ptr, __bos0 (__ptr), __size, __n,
+					  __stream);
+    }
+
+# ifdef __USE_EXTERN_INLINES
+  if (__builtin_constant_p (__size)
+      && __builtin_constant_p (__n)
+      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
+      && __size * __n <= 8)
+    {
+      size_t __cnt = __size * __n;
+      char *__cptr = (char *) __ptr;
+      if (__cnt == 0)
+	return 0;
+
+      for (; __cnt > 0; --__cnt)
+	{
+	  int __c = _IO_getc_unlocked (__stream);
+	  if (__c == EOF)
+	    break;
+	  *__cptr++ = __c;
+	}
+      return (__cptr - (char *) __ptr) / __size;
+    }
+# endif
+  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
+}
+#endif
diff --git a/include/bits/stdio_lim.h b/include/bits/stdio_lim.h
new file mode 100644
index 0000000..8367585
--- /dev/null
+++ b/include/bits/stdio_lim.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _STDIO_H && !defined __need_FOPEN_MAX && !defined __need_IOV_MAX
+# error "Never include <bits/stdio_lim.h> directly; use <stdio.h> instead."
+#endif
+
+#ifdef _STDIO_H
+# define L_tmpnam 20
+# define TMP_MAX 238328
+# define FILENAME_MAX 1024
+
+# ifdef __USE_POSIX
+#  define L_ctermid 9
+#  if !defined __USE_XOPEN2K || defined __USE_GNU
+#   define L_cuserid 9
+#  endif
+# endif
+#endif
+
+#if defined __need_FOPEN_MAX || defined _STDIO_H
+# undef  FOPEN_MAX
+# define FOPEN_MAX 16
+#endif
+
+#if defined __need_IOV_MAX && !defined IOV_MAX
+# undef IOV_MAX
+#endif
diff --git a/include/bits/stdlib-bsearch.h b/include/bits/stdlib-bsearch.h
new file mode 100644
index 0000000..78b4446
--- /dev/null
+++ b/include/bits/stdlib-bsearch.h
@@ -0,0 +1,43 @@
+/* Perform binary search - inline version.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+__extern_inline void *
+bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
+	 __compar_fn_t __compar)
+{
+  size_t __l, __u, __idx;
+  const void *__p;
+  int __comparison;
+
+  __l = 0;
+  __u = __nmemb;
+  while (__l < __u)
+    {
+      __idx = (__l + __u) / 2;
+      __p = (void *) (((const char *) __base) + (__idx * __size));
+      __comparison = (*__compar) (__key, __p);
+      if (__comparison < 0)
+	__u = __idx;
+      else if (__comparison > 0)
+	__l = __idx + 1;
+      else
+	return (void *) __p;
+    }
+
+  return NULL;
+}
diff --git a/include/bits/stdlib-float.h b/include/bits/stdlib-float.h
new file mode 100644
index 0000000..fdee2d5
--- /dev/null
+++ b/include/bits/stdlib-float.h
@@ -0,0 +1,31 @@
+/* Floating-point inline functions for stdlib.h.
+   Copyright (C) 2012-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STDLIB_H
+# error "Never use <bits/stdlib-float.h> directly; include <stdlib.h> instead."
+#endif
+
+#ifdef __USE_EXTERN_INLINES
+__BEGIN_NAMESPACE_STD
+__extern_inline double
+__NTH (atof (const char *__nptr))
+{
+  return strtod (__nptr, (char **) NULL);
+}
+__END_NAMESPACE_STD
+#endif /* Optimizing and Inlining.  */
diff --git a/include/bits/stdlib-ldbl.h b/include/bits/stdlib-ldbl.h
new file mode 100644
index 0000000..feadbdf
--- /dev/null
+++ b/include/bits/stdlib-ldbl.h
@@ -0,0 +1,39 @@
+/* -mlong-double-64 compatibility mode for <stdlib.h> functions.
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STDLIB_H
+# error "Never include <bits/stdlib-ldbl.h> directly; use <stdlib.h> instead."
+#endif
+
+#ifdef	__USE_ISOC99
+__BEGIN_NAMESPACE_C99
+__LDBL_REDIR1_DECL (strtold, strtod)
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_GNU
+__LDBL_REDIR1_DECL (strtold_l, strtod_l)
+#endif
+
+#ifdef __USE_MISC
+__LDBL_REDIR1_DECL (qecvt, ecvt)
+__LDBL_REDIR1_DECL (qfcvt, fcvt)
+__LDBL_REDIR1_DECL (qgcvt, gcvt)
+__LDBL_REDIR1_DECL (qecvt_r, ecvt_r)
+__LDBL_REDIR1_DECL (qfcvt_r, fcvt_r)
+#endif
diff --git a/include/bits/stdlib.h b/include/bits/stdlib.h
new file mode 100644
index 0000000..7b5b57b
--- /dev/null
+++ b/include/bits/stdlib.h
@@ -0,0 +1,155 @@
+/* Checking macros for stdlib functions.
+   Copyright (C) 2005-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STDLIB_H
+# error "Never include <bits/stdlib.h> directly; use <stdlib.h> instead."
+#endif
+
+extern char *__realpath_chk (const char *__restrict __name,
+			     char *__restrict __resolved,
+			     size_t __resolvedlen) __THROW __wur;
+extern char *__REDIRECT_NTH (__realpath_alias,
+			     (const char *__restrict __name,
+			      char *__restrict __resolved), realpath) __wur;
+extern char *__REDIRECT_NTH (__realpath_chk_warn,
+			     (const char *__restrict __name,
+			      char *__restrict __resolved,
+			      size_t __resolvedlen), __realpath_chk) __wur
+     __warnattr ("second argument of realpath must be either NULL or at "
+		 "least PATH_MAX bytes long buffer");
+
+__fortify_function __wur char *
+__NTH (realpath (const char *__restrict __name, char *__restrict __resolved))
+{
+  if (__bos (__resolved) != (size_t) -1)
+    {
+#if defined _LIBC_LIMITS_H_ && defined PATH_MAX
+      if (__bos (__resolved) < PATH_MAX)
+	return __realpath_chk_warn (__name, __resolved, __bos (__resolved));
+#endif
+      return __realpath_chk (__name, __resolved, __bos (__resolved));
+    }
+
+  return __realpath_alias (__name, __resolved);
+}
+
+
+extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
+			    size_t __nreal) __THROW __nonnull ((2));
+extern int __REDIRECT_NTH (__ptsname_r_alias, (int __fd, char *__buf,
+					       size_t __buflen), ptsname_r)
+     __nonnull ((2));
+extern int __REDIRECT_NTH (__ptsname_r_chk_warn,
+			   (int __fd, char *__buf, size_t __buflen,
+			    size_t __nreal), __ptsname_r_chk)
+     __nonnull ((2)) __warnattr ("ptsname_r called with buflen bigger than "
+				 "size of buf");
+
+__fortify_function int
+__NTH (ptsname_r (int __fd, char *__buf, size_t __buflen))
+{
+  if (__bos (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__buflen))
+	return __ptsname_r_chk (__fd, __buf, __buflen, __bos (__buf));
+      if (__buflen > __bos (__buf))
+	return __ptsname_r_chk_warn (__fd, __buf, __buflen, __bos (__buf));
+    }
+  return __ptsname_r_alias (__fd, __buf, __buflen);
+}
+
+
+extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
+  __THROW __wur;
+extern int __REDIRECT_NTH (__wctomb_alias, (char *__s, wchar_t __wchar),
+			   wctomb) __wur;
+
+__fortify_function __wur int
+__NTH (wctomb (char *__s, wchar_t __wchar))
+{
+  /* We would have to include <limits.h> to get a definition of MB_LEN_MAX.
+     But this would only disturb the namespace.  So we define our own
+     version here.  */
+#define __STDLIB_MB_LEN_MAX	16
+#if defined MB_LEN_MAX && MB_LEN_MAX != __STDLIB_MB_LEN_MAX
+# error "Assumed value of MB_LEN_MAX wrong"
+#endif
+  if (__bos (__s) != (size_t) -1 && __STDLIB_MB_LEN_MAX > __bos (__s))
+    return __wctomb_chk (__s, __wchar, __bos (__s));
+  return __wctomb_alias (__s, __wchar);
+}
+
+
+extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
+			      const char *__restrict __src,
+			      size_t __len, size_t __dstlen) __THROW;
+extern size_t __REDIRECT_NTH (__mbstowcs_alias,
+			      (wchar_t *__restrict __dst,
+			       const char *__restrict __src,
+			       size_t __len), mbstowcs);
+extern size_t __REDIRECT_NTH (__mbstowcs_chk_warn,
+			      (wchar_t *__restrict __dst,
+			       const char *__restrict __src,
+			       size_t __len, size_t __dstlen), __mbstowcs_chk)
+     __warnattr ("mbstowcs called with dst buffer smaller than len "
+		 "* sizeof (wchar_t)");
+
+__fortify_function size_t
+__NTH (mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src,
+		 size_t __len))
+{
+  if (__bos (__dst) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+	return __mbstowcs_chk (__dst, __src, __len,
+			       __bos (__dst) / sizeof (wchar_t));
+
+      if (__len > __bos (__dst) / sizeof (wchar_t))
+	return __mbstowcs_chk_warn (__dst, __src, __len,
+				     __bos (__dst) / sizeof (wchar_t));
+    }
+  return __mbstowcs_alias (__dst, __src, __len);
+}
+
+
+extern size_t __wcstombs_chk (char *__restrict __dst,
+			      const wchar_t *__restrict __src,
+			      size_t __len, size_t __dstlen) __THROW;
+extern size_t __REDIRECT_NTH (__wcstombs_alias,
+			      (char *__restrict __dst,
+			       const wchar_t *__restrict __src,
+			       size_t __len), wcstombs);
+extern size_t __REDIRECT_NTH (__wcstombs_chk_warn,
+			      (char *__restrict __dst,
+			       const wchar_t *__restrict __src,
+			       size_t __len, size_t __dstlen), __wcstombs_chk)
+     __warnattr ("wcstombs called with dst buffer smaller than len");
+
+__fortify_function size_t
+__NTH (wcstombs (char *__restrict __dst, const wchar_t *__restrict __src,
+		 size_t __len))
+{
+  if (__bos (__dst) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+	return __wcstombs_chk (__dst, __src, __len, __bos (__dst));
+      if (__len > __bos (__dst))
+	return __wcstombs_chk_warn (__dst, __src, __len, __bos (__dst));
+    }
+  return __wcstombs_alias (__dst, __src, __len);
+}
diff --git a/include/bits/string.h b/include/bits/string.h
new file mode 100644
index 0000000..a401a0d
--- /dev/null
+++ b/include/bits/string.h
@@ -0,0 +1,1985 @@
+/* Optimized, inlined string functions.  i486/x86-64 version.
+   Copyright (C) 2001-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STRING_H
+# error "Never use <bits/string.h> directly; include <string.h> instead."
+#endif
+
+/* The ix86 processors can access unaligned multi-byte variables.  */
+#define _STRING_ARCH_unaligned	1
+
+/* Enable inline functions only for i486 or better when compiling for
+   ia32.  */
+#if !defined __x86_64__ && (defined __i486__ || defined __pentium__	      \
+			    || defined __pentiumpro__ || defined __pentium4__ \
+			    || defined __nocona__ || defined __atom__ 	      \
+			    || defined __core2__ || defined __corei7__	      \
+			    || defined __k6__ || defined __geode__	      \
+			    || defined __k8__ || defined __athlon__	      \
+			    || defined __amdfam10__)
+
+/* We only provide optimizations if the user selects them and if
+   GNU CC is used.  */
+# if !defined __NO_STRING_INLINES && defined __USE_STRING_INLINES \
+    && defined __GNUC__ && __GNUC__ >= 2
+
+# ifndef __STRING_INLINE
+#  ifndef __extern_inline
+#   define __STRING_INLINE inline
+#  else
+#   define __STRING_INLINE __extern_inline
+#  endif
+# endif
+
+/* The macros are used in some of the optimized implementations below.  */
+# define __STRING_SMALL_GET16(src, idx) \
+  ((((const unsigned char *) (src))[idx + 1] << 8)			      \
+   | ((const unsigned char *) (src))[idx])
+# define __STRING_SMALL_GET32(src, idx) \
+  (((((const unsigned char *) (src))[idx + 3] << 8			      \
+     | ((const unsigned char *) (src))[idx + 2]) << 8			      \
+    | ((const unsigned char *) (src))[idx + 1]) << 8			      \
+   | ((const unsigned char *) (src))[idx])
+
+
+/* Copy N bytes of SRC to DEST.  */
+# define _HAVE_STRING_ARCH_memcpy 1
+# define memcpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (n)				      \
+		  ? __memcpy_c ((dest), (src), (n))			      \
+		  : __memcpy_g ((dest), (src), (n))))
+# define __memcpy_c(dest, src, n) \
+  ((n) == 0								      \
+   ? (dest)								      \
+   : (((n) % 4 == 0)							      \
+      ? __memcpy_by4 (dest, src, n)					      \
+      : (((n) % 2 == 0)							      \
+	 ? __memcpy_by2 (dest, src, n)					      \
+	 : __memcpy_g (dest, src, n))))
+
+__STRING_INLINE void *__memcpy_by4 (void *__dest, const void *__src,
+				    size_t __n);
+
+__STRING_INLINE void *
+__memcpy_by4 (void *__dest, const void *__src, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register void *__tmp = __dest;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b"
+     : "=&r" (__d0), "=&r" (__tmp), "=&r" (__src), "=&r" (__d1)
+     : "1" (__tmp), "2" (__src), "3" (__n / 4)
+     : "memory", "cc");
+  return __dest;
+}
+
+__STRING_INLINE void *__memcpy_by2 (void *__dest, const void *__src,
+				    size_t __n);
+
+__STRING_INLINE void *
+__memcpy_by2 (void *__dest, const void *__src, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register void *__tmp = __dest;
+  __asm__ __volatile__
+    ("shrl	$1,%3\n\t"
+     "jz	2f\n"                 /* only a word */
+     "1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b\n"
+     "2:\n\t"
+     "movw	(%2),%w0\n\t"
+     "movw	%w0,(%1)"
+     : "=&q" (__d0), "=&r" (__tmp), "=&r" (__src), "=&r" (__d1)
+     : "1" (__tmp), "2" (__src), "3" (__n / 2)
+     : "memory", "cc");
+  return __dest;
+}
+
+__STRING_INLINE void *__memcpy_g (void *__dest, const void *__src, size_t __n);
+
+__STRING_INLINE void *
+__memcpy_g (void *__dest, const void *__src, size_t __n)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register void *__tmp = __dest;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "shrl	$1,%%ecx\n\t"
+     "jnc	1f\n\t"
+     "movsb\n"
+     "1:\n\t"
+     "shrl	$1,%%ecx\n\t"
+     "jnc	2f\n\t"
+     "movsw\n"
+     "2:\n\t"
+     "rep; movsl"
+     : "=&c" (__d0), "=&D" (__d1), "=&S" (__d2),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__dest)
+     : "0" (__n), "1" (__tmp), "2" (__src),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__src)
+     : "cc");
+  return __dest;
+}
+
+# define _HAVE_STRING_ARCH_memmove 1
+# ifndef _FORCE_INLINES
+/* Copy N bytes of SRC to DEST, guaranteeing
+   correct behavior for overlapping strings.  */
+#  define memmove(dest, src, n) __memmove_g (dest, src, n)
+
+__STRING_INLINE void *__memmove_g (void *, const void *, size_t)
+     __asm__ ("memmove");
+
+__STRING_INLINE void *
+__memmove_g (void *__dest, const void *__src, size_t __n)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register void *__tmp = __dest;
+  if (__dest < __src)
+    __asm__ __volatile__
+      ("cld\n\t"
+       "rep; movsb"
+       : "=&c" (__d0), "=&S" (__d1), "=&D" (__d2),
+	 "=m" ( *(struct { __extension__ char __x[__n]; } *)__dest)
+       : "0" (__n), "1" (__src), "2" (__tmp),
+	 "m" ( *(struct { __extension__ char __x[__n]; } *)__src));
+  else
+    __asm__ __volatile__
+      ("std\n\t"
+       "rep; movsb\n\t"
+       "cld"
+       : "=&c" (__d0), "=&S" (__d1), "=&D" (__d2),
+	 "=m" ( *(struct { __extension__ char __x[__n]; } *)__dest)
+       : "0" (__n), "1" (__n - 1 + (const char *) __src),
+	 "2" (__n - 1 + (char *) __tmp),
+	 "m" ( *(struct { __extension__ char __x[__n]; } *)__src));
+  return __dest;
+}
+# endif
+
+/* Compare N bytes of S1 and S2.  */
+# define _HAVE_STRING_ARCH_memcmp 1
+# ifndef _FORCE_INLINES
+#  ifndef __PIC__
+/* gcc has problems to spill registers when using PIC.  */
+__STRING_INLINE int
+memcmp (const void *__s1, const void *__s2, size_t __n)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register int __res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "testl %3,%3\n\t"
+     "repe; cmpsb\n\t"
+     "je	1f\n\t"
+     "sbbl	%0,%0\n\t"
+     "orl	$1,%0\n"
+     "1:"
+     : "=&a" (__res), "=&S" (__d0), "=&D" (__d1), "=&c" (__d2)
+     : "0" (0), "1" (__s1), "2" (__s2), "3" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s1),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s2)
+     : "cc");
+  return __res;
+}
+#  endif
+# endif
+
+/* Set N bytes of S to C.  */
+# define _HAVE_STRING_ARCH_memset 1
+# define _USE_STRING_ARCH_memset 1
+# define memset(s, c, n) \
+  (__extension__ (__builtin_constant_p (n) && (n) <= 16			      \
+		  ? ((n) == 1						      \
+		     ? __memset_c1 ((s), (c))				      \
+		     : __memset_gc ((s), (c), (n)))			      \
+		  : (__builtin_constant_p (c)				      \
+		     ? (__builtin_constant_p (n)			      \
+			? __memset_ccn ((s), (c), (n))			      \
+			: memset ((s), (c), (n)))			      \
+		     : (__builtin_constant_p (n)			      \
+			? __memset_gcn ((s), (c), (n))			      \
+			: memset ((s), (c), (n))))))
+
+# define __memset_c1(s, c) ({ void *__s = (s);				      \
+			      *((unsigned char *) __s) = (unsigned char) (c); \
+			      __s; })
+
+# define __memset_gc(s, c, n) \
+  ({ void *__s = (s);							      \
+     union {								      \
+       unsigned int __ui;						      \
+       unsigned short int __usi;					      \
+       unsigned char __uc;						      \
+     } *__u = __s;							      \
+     unsigned int __c = ((unsigned int) ((unsigned char) (c))) * 0x01010101;  \
+									      \
+     /* We apply a trick here.  `gcc' would implement the following	      \
+	assignments using immediate operands.  But this uses to much	      \
+	memory (7, instead of 4 bytes).  So we force the value in a	      \
+	registers.  */							      \
+     if ((n) == 3 || (n) >= 5)						      \
+       __asm__ __volatile__ ("" : "=r" (__c) : "0" (__c));		      \
+									      \
+     /* This `switch' statement will be removed at compile-time.  */	      \
+     switch (n)								      \
+       {								      \
+       case 15:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 11:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 7:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 3:								      \
+	 __u->__usi = (unsigned short int) __c;				      \
+	 __u = __extension__ ((void *) __u + 2);			      \
+	 __u->__uc = (unsigned char) __c;				      \
+	 break;								      \
+									      \
+       case 14:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 10:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 6:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 2:								      \
+	 __u->__usi = (unsigned short int) __c;				      \
+	 break;								      \
+									      \
+       case 13:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 9:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 5:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 1:								      \
+	 __u->__uc = (unsigned char) __c;				      \
+	 break;								      \
+									      \
+       case 16:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 12:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 8:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 4:								      \
+	 __u->__ui = __c;						      \
+       case 0:								      \
+	 break;								      \
+       }								      \
+									      \
+     __s; })
+
+# define __memset_ccn(s, c, n) \
+  (((n) % 4 == 0)							      \
+   ? __memset_ccn_by4 (s, ((unsigned int) ((unsigned char) (c))) * 0x01010101,\
+		       n)						      \
+   : (((n) % 2 == 0)							      \
+      ? __memset_ccn_by2 (s,						      \
+			  ((unsigned int) ((unsigned char) (c))) * 0x01010101,\
+			   n)						      \
+      : memset (s, c, n)))
+
+__STRING_INLINE void *__memset_ccn_by4 (void *__s, unsigned int __c,
+					size_t __n);
+
+__STRING_INLINE void *
+__memset_ccn_by4 (void *__s, unsigned int __c, size_t __n)
+{
+  register void *__tmp = __s;
+  register unsigned long int __d0;
+# ifdef __i686__
+  __asm__ __volatile__
+    ("cld\n\t"
+     "rep; stosl"
+     : "=&a" (__c), "=&D" (__tmp), "=&c" (__d0),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+# else
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movl	%0,(%1)\n\t"
+     "addl	$4,%1\n\t"
+     "decl	%2\n\t"
+     "jnz	1b\n"
+     : "=&r" (__c), "=&r" (__tmp), "=&r" (__d0),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+# endif
+  return __s;
+}
+
+__STRING_INLINE void *__memset_ccn_by2 (void *__s, unsigned int __c,
+					size_t __n);
+
+__STRING_INLINE void *
+__memset_ccn_by2 (void *__s, unsigned int __c, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register void *__tmp = __s;
+# ifdef __i686__
+  __asm__ __volatile__
+    ("cld\n\t"
+     "rep; stosl\n"
+     "stosw"
+     : "=&a" (__d0), "=&D" (__tmp), "=&c" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+# else
+  __asm__ __volatile__
+    ("1:\tmovl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%2\n\t"
+     "jnz	1b\n"
+     "movw	%w0,(%1)"
+     : "=&q" (__d0), "=&r" (__tmp), "=&r" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+#endif
+  return __s;
+}
+
+# define __memset_gcn(s, c, n) \
+  (((n) % 4 == 0)							      \
+   ? __memset_gcn_by4 (s, c, n)						      \
+   : (((n) % 2 == 0)							      \
+      ? __memset_gcn_by2 (s, c, n)					      \
+      : memset (s, c, n)))
+
+__STRING_INLINE void *__memset_gcn_by4 (void *__s, int __c, size_t __n);
+
+__STRING_INLINE void *
+__memset_gcn_by4 (void *__s, int __c, size_t __n)
+{
+  register void *__tmp = __s;
+  register unsigned long int __d0;
+  __asm__ __volatile__
+    ("movb	%b0,%h0\n"
+     "pushw	%w0\n\t"
+     "shll	$16,%0\n\t"
+     "popw	%w0\n"
+     "1:\n\t"
+     "movl	%0,(%1)\n\t"
+     "addl	$4,%1\n\t"
+     "decl	%2\n\t"
+     "jnz	1b\n"
+     : "=&q" (__c), "=&r" (__tmp), "=&r" (__d0),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+  return __s;
+}
+
+__STRING_INLINE void *__memset_gcn_by2 (void *__s, int __c, size_t __n);
+
+__STRING_INLINE void *
+__memset_gcn_by2 (void *__s, int __c, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register void *__tmp = __s;
+  __asm__ __volatile__
+    ("movb	%b0,%h0\n\t"
+     "pushw	%w0\n\t"
+     "shll	$16,%0\n\t"
+     "popw	%w0\n"
+     "1:\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%2\n\t"
+     "jnz	1b\n"
+     "movw	%w0,(%1)"
+     : "=&q" (__d0), "=&r" (__tmp), "=&r" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+  return __s;
+}
+
+
+/* Search N bytes of S for C.  */
+# define _HAVE_STRING_ARCH_memchr 1
+# ifndef _FORCE_INLINES
+__STRING_INLINE void *
+memchr (const void *__s, int __c, size_t __n)
+{
+  register unsigned long int __d0;
+#  ifdef __i686__
+  register unsigned long int __d1;
+#  endif
+  register unsigned char *__res;
+  if (__n == 0)
+    return NULL;
+#  ifdef __i686__
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "cmovne %2,%0"
+     : "=D" (__res), "=&c" (__d0), "=&r" (__d1)
+     : "a" (__c), "0" (__s), "1" (__n), "2" (1),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "cc");
+#  else
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "je	1f\n\t"
+     "movl	$1,%0\n"
+     "1:"
+     : "=D" (__res), "=&c" (__d0)
+     : "a" (__c), "0" (__s), "1" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "cc");
+#  endif
+  return __res - 1;
+}
+# endif
+
+# define _HAVE_STRING_ARCH_memrchr 1
+# ifndef _FORCE_INLINES
+__STRING_INLINE void *__memrchr (const void *__s, int __c, size_t __n);
+
+__STRING_INLINE void *
+__memrchr (const void *__s, int __c, size_t __n)
+{
+  register unsigned long int __d0;
+#  ifdef __i686__
+  register unsigned long int __d1;
+#  endif
+  register void *__res;
+  if (__n == 0)
+    return NULL;
+#  ifdef __i686__
+  __asm__ __volatile__
+    ("std\n\t"
+     "repne; scasb\n\t"
+     "cmovne %2,%0\n\t"
+     "cld\n\t"
+     "incl %0"
+     : "=D" (__res), "=&c" (__d0), "=&r" (__d1)
+     : "a" (__c), "0" (__s + __n - 1), "1" (__n), "2" (-1),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "cc");
+#  else
+  __asm__ __volatile__
+    ("std\n\t"
+     "repne; scasb\n\t"
+     "je 1f\n\t"
+     "orl $-1,%0\n"
+     "1:\tcld\n\t"
+     "incl %0"
+     : "=D" (__res), "=&c" (__d0)
+     : "a" (__c), "0" (__s + __n - 1), "1" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "cc");
+#  endif
+  return __res;
+}
+#  ifdef __USE_GNU
+#   define memrchr(s, c, n) __memrchr ((s), (c), (n))
+#  endif
+# endif
+
+/* Return pointer to C in S.  */
+# define _HAVE_STRING_ARCH_rawmemchr 1
+__STRING_INLINE void *__rawmemchr (const void *__s, int __c);
+
+# ifndef _FORCE_INLINES
+__STRING_INLINE void *
+__rawmemchr (const void *__s, int __c)
+{
+  register unsigned long int __d0;
+  register unsigned char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     : "=D" (__res), "=&c" (__d0)
+     : "a" (__c), "0" (__s), "1" (0xffffffff),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res - 1;
+}
+#  ifdef __USE_GNU
+__STRING_INLINE void *
+rawmemchr (const void *__s, int __c)
+{
+  return __rawmemchr (__s, __c);
+}
+#  endif /* use GNU */
+# endif
+
+
+/* Return the length of S.  */
+# define _HAVE_STRING_ARCH_strlen 1
+# define strlen(str) \
+  (__extension__ (__builtin_constant_p (str)				      \
+		  ? __builtin_strlen (str)				      \
+		  : __strlen_g (str)))
+__STRING_INLINE size_t __strlen_g (const char *__str);
+
+__STRING_INLINE size_t
+__strlen_g (const char *__str)
+{
+  register char __dummy;
+  register const char *__tmp = __str;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%b1\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%b1,%b1\n\t"
+     "jne	1b"
+     : "=r" (__tmp), "=&q" (__dummy)
+     : "0" (__str),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__str)
+     : "cc" );
+  return __tmp - __str - 1;
+}
+
+
+/* Copy SRC to DEST.  */
+# define _HAVE_STRING_ARCH_strcpy 1
+# define strcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (sizeof ((src)[0]) == 1 && strlen (src) + 1 <= 8	      \
+		     ? __strcpy_a_small ((dest), (src), strlen (src) + 1)     \
+		     : (char *) memcpy ((char *) (dest),		      \
+					(const char *) (src),		      \
+					strlen (src) + 1))		      \
+		  : __strcpy_g ((dest), (src))))
+
+# define __strcpy_a_small(dest, src, srclen) \
+  (__extension__ ({ char *__dest = (dest);				      \
+		    union {						      \
+		      unsigned int __ui;				      \
+		      unsigned short int __usi;				      \
+		      unsigned char __uc;				      \
+		      char __c;						      \
+		    } *__u = (void *) __dest;				      \
+		    switch (srclen)					      \
+		      {							      \
+		      case 1:						      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 2:						      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 0);	      \
+			break;						      \
+		      case 3:						      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 2);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 4:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			break;						      \
+		      case 5:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 6:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 4);	      \
+			break;						      \
+		      case 7:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 4);	      \
+			__u = __extension__ ((void *) __u + 2);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 8:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 4);	      \
+			break;						      \
+		      }							      \
+		    (char *) __dest; }))
+
+__STRING_INLINE char *__strcpy_g (char *__dest, const char *__src);
+
+__STRING_INLINE char *
+__strcpy_g (char *__dest, const char *__src)
+{
+  register char *__tmp = __dest;
+  register char __dummy;
+  __asm__ __volatile__
+    (
+     "1:\n\t"
+     "movb	(%0),%b2\n\t"
+     "leal	1(%0),%0\n\t"
+     "movb	%b2,(%1)\n\t"
+     "leal	1(%1),%1\n\t"
+     "testb	%b2,%b2\n\t"
+     "jne	1b"
+     : "=&r" (__src), "=&r" (__tmp), "=&q" (__dummy),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "0" (__src), "1" (__tmp),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__src)
+     : "cc");
+  return __dest;
+}
+
+
+# ifdef __USE_GNU
+#  define _HAVE_STRING_ARCH_stpcpy 1
+/* Copy SRC to DEST.  */
+#  define __stpcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (strlen (src) + 1 <= 8				      \
+		     ? __stpcpy_a_small ((dest), (src), strlen (src) + 1)     \
+		     : __stpcpy_c ((dest), (src), strlen (src) + 1))	      \
+		  : __stpcpy_g ((dest), (src))))
+#  define __stpcpy_c(dest, src, srclen) \
+  ((srclen) % 4 == 0							      \
+   ? __mempcpy_by4 (dest, src, srclen) - 1				      \
+   : ((srclen) % 2 == 0							      \
+      ? __mempcpy_by2 (dest, src, srclen) - 1				      \
+      : __mempcpy_byn (dest, src, srclen) - 1))
+
+/* In glibc itself we use this symbol for namespace reasons.  */
+#  define stpcpy(dest, src) __stpcpy ((dest), (src))
+
+#  define __stpcpy_a_small(dest, src, srclen) \
+  (__extension__ ({ union {						      \
+		      unsigned int __ui;				      \
+		      unsigned short int __usi;				      \
+		      unsigned char __uc;				      \
+		      char __c;						      \
+		    } *__u = (void *) (dest);				      \
+		    switch (srclen)					      \
+		      {							      \
+		      case 1:						      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 2:						      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 1);		      \
+			break;						      \
+		      case 3:						      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 2);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 4:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 3);		      \
+			break;						      \
+		      case 5:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 6:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 4);	      \
+			__u = __extension__ ((void *) __u + 1);		      \
+			break;						      \
+		      case 7:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 4);	      \
+			__u = __extension__ ((void *) __u + 2);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 8:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 4);	      \
+			__u = __extension__ ((void *) __u + 3);		      \
+			break;						      \
+		      }							      \
+		    (char *) __u; }))
+
+__STRING_INLINE char *__mempcpy_by4 (char *__dest, const char *__src,
+				     size_t __srclen);
+
+__STRING_INLINE char *
+__mempcpy_by4 (char *__dest, const char *__src, size_t __srclen)
+{
+  register char *__tmp = __dest;
+  register unsigned long int __d0, __d1;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b"
+     : "=&r" (__d0), "=r" (__tmp), "=&r" (__src), "=&r" (__d1)
+     : "1" (__tmp), "2" (__src), "3" (__srclen / 4)
+     : "memory", "cc");
+  return __tmp;
+}
+
+__STRING_INLINE char *__mempcpy_by2 (char *__dest, const char *__src,
+				     size_t __srclen);
+
+__STRING_INLINE char *
+__mempcpy_by2 (char *__dest, const char *__src, size_t __srclen)
+{
+  register char *__tmp = __dest;
+  register unsigned long int __d0, __d1;
+  __asm__ __volatile__
+    ("shrl	$1,%3\n\t"
+     "jz	2f\n"                 /* only a word */
+     "1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b\n"
+     "2:\n\t"
+     "movw	(%2),%w0\n\t"
+     "movw	%w0,(%1)"
+     : "=&q" (__d0), "=r" (__tmp), "=&r" (__src), "=&r" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "1" (__tmp), "2" (__src), "3" (__srclen / 2),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  return __tmp + 2;
+}
+
+__STRING_INLINE char *__mempcpy_byn (char *__dest, const char *__src,
+				     size_t __srclen);
+
+__STRING_INLINE char *
+__mempcpy_byn (char *__dest, const char *__src, size_t __srclen)
+{
+  register unsigned long __d0, __d1;
+  register char *__tmp = __dest;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "shrl	$1,%%ecx\n\t"
+     "jnc	1f\n\t"
+     "movsb\n"
+     "1:\n\t"
+     "shrl	$1,%%ecx\n\t"
+     "jnc	2f\n\t"
+     "movsw\n"
+     "2:\n\t"
+     "rep; movsl"
+     : "=D" (__tmp), "=&c" (__d0), "=&S" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "0" (__tmp), "1" (__srclen), "2" (__src),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  return __tmp;
+}
+
+__STRING_INLINE char *__stpcpy_g (char *__dest, const char *__src);
+
+__STRING_INLINE char *
+__stpcpy_g (char *__dest, const char *__src)
+{
+  register char *__tmp = __dest;
+  register char __dummy;
+  __asm__ __volatile__
+    (
+     "1:\n\t"
+     "movb	(%0),%b2\n\t"
+     "leal	1(%0),%0\n\t"
+     "movb	%b2,(%1)\n\t"
+     "leal	1(%1),%1\n\t"
+     "testb	%b2,%b2\n\t"
+     "jne	1b"
+     : "=&r" (__src), "=r" (__tmp), "=&q" (__dummy),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "0" (__src), "1" (__tmp),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__src)
+     : "cc");
+  return __tmp - 1;
+}
+# endif
+
+
+/* Copy no more than N characters of SRC to DEST.  */
+# define _HAVE_STRING_ARCH_strncpy 1
+# define strncpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? ((strlen (src) + 1 >= ((size_t) (n))		      \
+		      ? (char *) memcpy ((char *) (dest),		      \
+					 (const char *) (src), n)	      \
+		      : __strncpy_cg ((dest), (src), strlen (src) + 1, n)))   \
+		  : __strncpy_gg ((dest), (src), n)))
+# define __strncpy_cg(dest, src, srclen, n) \
+  (((srclen) % 4 == 0)							      \
+   ? __strncpy_by4 (dest, src, srclen, n)				      \
+   : (((srclen) % 2 == 0)						      \
+      ? __strncpy_by2 (dest, src, srclen, n)				      \
+      : __strncpy_byn (dest, src, srclen, n)))
+
+__STRING_INLINE char *__strncpy_by4 (char *__dest, const char __src[],
+				     size_t __srclen, size_t __n);
+
+__STRING_INLINE char *
+__strncpy_by4 (char *__dest, const char __src[], size_t __srclen, size_t __n)
+{
+  register char *__tmp = __dest;
+  register int __dummy1, __dummy2;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b"
+     : "=&r" (__dummy1), "=r" (__tmp), "=&r" (__src), "=&r" (__dummy2),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "1" (__tmp), "2" (__src), "3" (__srclen / 4),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  (void) memset (__tmp, '\0', __n - __srclen);
+  return __dest;
+}
+
+__STRING_INLINE char *__strncpy_by2 (char *__dest, const char __src[],
+				     size_t __srclen, size_t __n);
+
+__STRING_INLINE char *
+__strncpy_by2 (char *__dest, const char __src[], size_t __srclen, size_t __n)
+{
+  register char *__tmp = __dest;
+  register int __dummy1, __dummy2;
+  __asm__ __volatile__
+    ("shrl	$1,%3\n\t"
+     "jz	2f\n"                 /* only a word */
+     "1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b\n"
+     "2:\n\t"
+     "movw	(%2),%w0\n\t"
+     "movw	%w0,(%1)\n\t"
+     : "=&q" (__dummy1), "=r" (__tmp), "=&r" (__src), "=&r" (__dummy2),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "1" (__tmp), "2" (__src), "3" (__srclen / 2),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  (void) memset (__tmp + 2, '\0', __n - __srclen);
+  return __dest;
+}
+
+__STRING_INLINE char *__strncpy_byn (char *__dest, const char __src[],
+				     size_t __srclen, size_t __n);
+
+__STRING_INLINE char *
+__strncpy_byn (char *__dest, const char __src[], size_t __srclen, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register char *__tmp = __dest;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "shrl	$1,%1\n\t"
+     "jnc	1f\n\t"
+     "movsb\n"
+     "1:\n\t"
+     "shrl	$1,%1\n\t"
+     "jnc	2f\n\t"
+     "movsw\n"
+     "2:\n\t"
+     "rep; movsl"
+     : "=D" (__tmp), "=&c" (__d0), "=&S" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "1" (__srclen), "0" (__tmp),"2" (__src),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  (void) memset (__tmp, '\0', __n - __srclen);
+  return __dest;
+}
+
+__STRING_INLINE char *__strncpy_gg (char *__dest, const char *__src,
+				    size_t __n);
+
+__STRING_INLINE char *
+__strncpy_gg (char *__dest, const char *__src, size_t __n)
+{
+  register char *__tmp = __dest;
+  register char __dummy;
+  if (__n > 0)
+    __asm__ __volatile__
+      ("1:\n\t"
+       "movb	(%0),%2\n\t"
+       "incl	%0\n\t"
+       "movb	%2,(%1)\n\t"
+       "incl	%1\n\t"
+       "decl	%3\n\t"
+       "je	3f\n\t"
+       "testb	%2,%2\n\t"
+       "jne	1b\n\t"
+       "2:\n\t"
+       "movb	%2,(%1)\n\t"
+       "incl	%1\n\t"
+       "decl	%3\n\t"
+       "jne	2b\n\t"
+       "3:"
+       : "=&r" (__src), "=&r" (__tmp), "=&q" (__dummy), "=&r" (__n)
+       : "0" (__src), "1" (__tmp), "3" (__n)
+       : "memory", "cc");
+
+  return __dest;
+}
+
+
+/* Append SRC onto DEST.  */
+# define _HAVE_STRING_ARCH_strcat 1
+# define strcat(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? __strcat_c ((dest), (src), strlen (src) + 1)	      \
+		  : __strcat_g ((dest), (src))))
+
+__STRING_INLINE char *__strcat_c (char *__dest, const char __src[],
+				  size_t __srclen);
+
+__STRING_INLINE char *
+__strcat_c (char *__dest, const char __src[], size_t __srclen)
+{
+# ifdef __i686__
+  register unsigned long int __d0;
+  register char *__tmp;
+  __asm__ __volatile__
+    ("repne; scasb"
+     : "=D" (__tmp), "=&c" (__d0),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "0" (__dest), "1" (0xffffffff), "a" (0),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  --__tmp;
+# else
+  register char *__tmp = __dest - 1;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "incl	%0\n\t"
+     "cmpb	$0,(%0)\n\t"
+     "jne	1b\n"
+     : "=r" (__tmp),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "0" (__tmp),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+# endif
+  (void) memcpy (__tmp, __src, __srclen);
+  return __dest;
+}
+
+__STRING_INLINE char *__strcat_g (char *__dest, const char *__src);
+
+__STRING_INLINE char *
+__strcat_g (char *__dest, const char *__src)
+{
+  register char *__tmp = __dest - 1;
+  register char __dummy;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "incl	%1\n\t"
+     "cmpb	$0,(%1)\n\t"
+     "jne	1b\n"
+     "2:\n\t"
+     "movb	(%2),%b0\n\t"
+     "incl	%2\n\t"
+     "movb	%b0,(%1)\n\t"
+     "incl	%1\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	2b\n"
+     : "=&q" (__dummy), "=&r" (__tmp), "=&r" (__src),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "1"  (__tmp), "2"  (__src),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__src)
+     : "memory", "cc");
+  return __dest;
+}
+
+
+/* Append no more than N characters from SRC onto DEST.  */
+# define _HAVE_STRING_ARCH_strncat 1
+# define strncat(dest, src, n) \
+  (__extension__ ({ char *__dest = (dest);				      \
+		    __builtin_constant_p (src) && __builtin_constant_p (n)    \
+		    ? (strlen (src) < ((size_t) (n))			      \
+		       ? strcat (__dest, (src))				      \
+		       : (*(char *)__mempcpy (strchr (__dest, '\0'),	      \
+					       (const char *) (src),	      \
+					      (n)) = 0, __dest))	      \
+		    : __strncat_g (__dest, (src), (n)); }))
+
+__STRING_INLINE char *__strncat_g (char *__dest, const char __src[],
+				   size_t __n);
+
+__STRING_INLINE char *
+__strncat_g (char *__dest, const char __src[], size_t __n)
+{
+  register char *__tmp = __dest;
+  register char __dummy;
+# ifdef __i686__
+  __asm__ __volatile__
+    ("repne; scasb\n"
+     "movl %4, %3\n\t"
+     "decl %1\n\t"
+     "1:\n\t"
+     "subl	$1,%3\n\t"
+     "jc	2f\n\t"
+     "movb	(%2),%b0\n\t"
+     "movsb\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	1b\n\t"
+     "decl	%1\n"
+     "2:\n\t"
+     "movb	$0,(%1)"
+     : "=&a" (__dummy), "=&D" (__tmp), "=&S" (__src), "=&c" (__n)
+     :  "g" (__n), "0" (0), "1" (__tmp), "2" (__src), "3" (0xffffffff)
+     : "memory", "cc");
+# else
+  --__tmp;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "cmpb	$0,1(%1)\n\t"
+     "leal	1(%1),%1\n\t"
+     "jne	1b\n"
+     "2:\n\t"
+     "subl	$1,%3\n\t"
+     "jc	3f\n\t"
+     "movb	(%2),%b0\n\t"
+     "leal	1(%2),%2\n\t"
+     "movb	%b0,(%1)\n\t"
+     "leal	1(%1),%1\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	2b\n\t"
+     "decl	%1\n"
+     "3:\n\t"
+     "movb	$0,(%1)"
+     : "=&q" (__dummy), "=&r" (__tmp), "=&r" (__src), "=&r" (__n)
+     : "1" (__tmp), "2" (__src), "3" (__n)
+     : "memory", "cc");
+#endif
+  return __dest;
+}
+
+
+/* Compare S1 and S2.  */
+# define _HAVE_STRING_ARCH_strcmp 1
+# define strcmp(s1, s2) \
+  (__extension__ (__builtin_constant_p (s1) && __builtin_constant_p (s2)      \
+		  && (sizeof ((s1)[0]) != 1 || strlen (s1) >= 4)	      \
+		  && (sizeof ((s2)[0]) != 1 || strlen (s2) >= 4)	      \
+		  ? memcmp ((const char *) (s1), (const char *) (s2),	      \
+			    (strlen (s1) < strlen (s2)			      \
+			     ? strlen (s1) : strlen (s2)) + 1)		      \
+		  : (__builtin_constant_p (s1) && sizeof ((s1)[0]) == 1	      \
+		     && sizeof ((s2)[0]) == 1 && strlen (s1) < 4	      \
+		     ? (__builtin_constant_p (s2) && sizeof ((s2)[0]) == 1    \
+			? __strcmp_cc ((const unsigned char *) (s1),	      \
+				       (const unsigned char *) (s2),	      \
+				       strlen (s1))			      \
+			: __strcmp_cg ((const unsigned char *) (s1),	      \
+				       (const unsigned char *) (s2),	      \
+				       strlen (s1)))			      \
+		     : (__builtin_constant_p (s2) && sizeof ((s1)[0]) == 1    \
+			&& sizeof ((s2)[0]) == 1 && strlen (s2) < 4	      \
+			? (__builtin_constant_p (s1)			      \
+			   ? __strcmp_cc ((const unsigned char *) (s1),	      \
+					  (const unsigned char *) (s2),	      \
+					  strlen (s2))			      \
+			   : __strcmp_gc ((const unsigned char *) (s1),	      \
+					  (const unsigned char *) (s2),	      \
+					  strlen (s2)))			      \
+			: __strcmp_gg ((s1), (s2))))))
+
+# define __strcmp_cc(s1, s2, l) \
+  (__extension__ ({ register int __result = (s1)[0] - (s2)[0];		      \
+		    if (l > 0 && __result == 0)				      \
+		      {							      \
+			__result = (s1)[1] - (s2)[1];			      \
+			if (l > 1 && __result == 0)			      \
+			  {						      \
+			    __result = (s1)[2] - (s2)[2];		      \
+			    if (l > 2 && __result == 0)			      \
+			      __result = (s1)[3] - (s2)[3];		      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+# define __strcmp_cg(s1, s2, l1) \
+  (__extension__ ({ const unsigned char *__s2 = (s2);			      \
+		    register int __result = (s1)[0] - __s2[0];		      \
+		    if (l1 > 0 && __result == 0)			      \
+		      {							      \
+			__result = (s1)[1] - __s2[1];			      \
+			if (l1 > 1 && __result == 0)			      \
+			  {						      \
+			    __result = (s1)[2] - __s2[2];		      \
+			    if (l1 > 2 && __result == 0)		      \
+			      __result = (s1)[3] - __s2[3];		      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+# define __strcmp_gc(s1, s2, l2) \
+  (__extension__ ({ const unsigned char *__s1 = (s1);			      \
+		    register int __result = __s1[0] - (s2)[0];		      \
+		    if (l2 > 0 && __result == 0)			      \
+		      {							      \
+			__result = __s1[1] - (s2)[1];			      \
+			if (l2 > 1 && __result == 0)			      \
+			  {						      \
+			    __result = __s1[2] - (s2)[2];		      \
+			    if (l2 > 2 && __result == 0)		      \
+			      __result = __s1[3] - (s2)[3];		      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+__STRING_INLINE int __strcmp_gg (const char *__s1, const char *__s2);
+
+__STRING_INLINE int
+__strcmp_gg (const char *__s1, const char *__s2)
+{
+  register int __res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%1),%b0\n\t"
+     "leal	1(%1),%1\n\t"
+     "cmpb	%b0,(%2)\n\t"
+     "jne	2f\n\t"
+     "leal	1(%2),%2\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	1b\n\t"
+     "xorl	%0,%0\n\t"
+     "jmp	3f\n"
+     "2:\n\t"
+     "movl	$1,%0\n\t"
+     "jb	3f\n\t"
+     "negl	%0\n"
+     "3:"
+     : "=q" (__res), "=&r" (__s1), "=&r" (__s2)
+     : "1" (__s1), "2" (__s2),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s1),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s2)
+     : "cc");
+  return __res;
+}
+
+
+/* Compare N characters of S1 and S2.  */
+# define _HAVE_STRING_ARCH_strncmp 1
+# define strncmp(s1, s2, n) \
+  (__extension__ (__builtin_constant_p (s1) && strlen (s1) < ((size_t) (n))   \
+		  ? strcmp ((s1), (s2))					      \
+		  : (__builtin_constant_p (s2) && strlen (s2) < ((size_t) (n))\
+		     ? strcmp ((s1), (s2))				      \
+		     : __strncmp_g ((s1), (s2), (n)))))
+
+__STRING_INLINE int __strncmp_g (const char *__s1, const char *__s2,
+				 size_t __n);
+
+__STRING_INLINE int
+__strncmp_g (const char *__s1, const char *__s2, size_t __n)
+{
+  register int __res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "subl	$1,%3\n\t"
+     "jc	2f\n\t"
+     "movb	(%1),%b0\n\t"
+     "incl	%1\n\t"
+     "cmpb	%b0,(%2)\n\t"
+     "jne	3f\n\t"
+     "incl	%2\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	1b\n"
+     "2:\n\t"
+     "xorl	%0,%0\n\t"
+     "jmp	4f\n"
+     "3:\n\t"
+     "movl	$1,%0\n\t"
+     "jb	4f\n\t"
+     "negl	%0\n"
+     "4:"
+     : "=q" (__res), "=&r" (__s1), "=&r" (__s2), "=&r" (__n)
+     : "1"  (__s1), "2"  (__s2),  "3" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s1),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s2)
+     : "cc");
+  return __res;
+}
+
+
+/* Find the first occurrence of C in S.  */
+# define _HAVE_STRING_ARCH_strchr 1
+# define _USE_STRING_ARCH_strchr 1
+# define strchr(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? ((c) == '\0'					      \
+		     ? (char *) __rawmemchr ((s), (c))			      \
+		     : __strchr_c ((s), ((c) & 0xff) << 8))		      \
+		  : __strchr_g ((s), (c))))
+
+__STRING_INLINE char *__strchr_c (const char *__s, int __c);
+
+__STRING_INLINE char *
+__strchr_c (const char *__s, int __c)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n\t"
+     "xorl	%0,%0\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strchr_g (const char *__s, int __c);
+
+__STRING_INLINE char *
+__strchr_g (const char *__s, int __c)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("movb	%%al,%%ah\n"
+     "1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n\t"
+     "xorl	%0,%0\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+
+
+/* Find the first occurrence of C in S or the final NUL byte.  */
+# define _HAVE_STRING_ARCH_strchrnul 1
+# define __strchrnul(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? ((c) == '\0'					      \
+		     ? (char *) __rawmemchr ((s), c)			      \
+		     : __strchrnul_c ((s), ((c) & 0xff) << 8))		      \
+		  : __strchrnul_g ((s), c)))
+
+__STRING_INLINE char *__strchrnul_c (const char *__s, int __c);
+
+__STRING_INLINE char *
+__strchrnul_c (const char *__s, int __c)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strchrnul_g (const char *__s, int __c);
+
+__STRING_INLINE char *
+__strchrnul_g (const char *__s, int __c)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("movb	%%al,%%ah\n"
+     "1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+# ifdef __USE_GNU
+#  define strchrnul(s, c) __strchrnul ((s), (c))
+# endif
+
+
+# if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Find the first occurrence of C in S.  This is the BSD name.  */
+#  define _HAVE_STRING_ARCH_index 1
+#  define index(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? __strchr_c ((s), ((c) & 0xff) << 8)			      \
+		  : __strchr_g ((s), (c))))
+# endif
+
+
+/* Find the last occurrence of C in S.  */
+# define _HAVE_STRING_ARCH_strrchr 1
+# define strrchr(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? __strrchr_c ((s), ((c) & 0xff) << 8)		      \
+		  : __strrchr_g ((s), (c))))
+
+# ifdef __i686__
+__STRING_INLINE char *__strrchr_c (const char *__s, int __c);
+
+__STRING_INLINE char *
+__strrchr_c (const char *__s, int __c)
+{
+  register unsigned long int __d0, __d1;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "cmpb	%h2,%b2\n\t"
+     "cmove	%1,%0\n\t"
+     "testb	%b2,%b2\n\t"
+     "jne 1b"
+     : "=d" (__res), "=&S" (__d0), "=&a" (__d1)
+     : "0" (1), "1" (__s), "2" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res - 1;
+}
+
+__STRING_INLINE char *__strrchr_g (const char *__s, int __c);
+
+__STRING_INLINE char *
+__strrchr_g (const char *__s, int __c)
+{
+  register unsigned long int __d0, __d1;
+  register char *__res;
+  __asm__ __volatile__
+    ("movb	%b2,%h2\n"
+     "cld\n\t"
+     "1:\n\t"
+     "lodsb\n\t"
+     "cmpb	%h2,%b2\n\t"
+     "cmove	%1,%0\n\t"
+     "testb	%b2,%b2\n\t"
+     "jne 1b"
+     : "=d" (__res), "=&S" (__d0), "=&a" (__d1)
+     : "0" (1), "1" (__s), "2" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res - 1;
+}
+# else
+__STRING_INLINE char *__strrchr_c (const char *__s, int __c);
+
+__STRING_INLINE char *
+__strrchr_c (const char *__s, int __c)
+{
+  register unsigned long int __d0, __d1;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "jne	2f\n\t"
+     "leal	-1(%%esi),%0\n"
+     "2:\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne 1b"
+     : "=d" (__res), "=&S" (__d0), "=&a" (__d1)
+     : "0" (0), "1" (__s), "2" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strrchr_g (const char *__s, int __c);
+
+__STRING_INLINE char *
+__strrchr_g (const char *__s, int __c)
+{
+  register unsigned long int __d0, __d1;
+  register char *__res;
+  __asm__ __volatile__
+    ("movb	%%al,%%ah\n"
+     "cld\n\t"
+     "1:\n\t"
+     "lodsb\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "jne	2f\n\t"
+     "leal	-1(%%esi),%0\n"
+     "2:\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne 1b"
+     : "=r" (__res), "=&S" (__d0), "=&a" (__d1)
+     : "0" (0), "1" (__s), "2" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+# endif
+
+
+# if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Find the last occurrence of C in S.  This is the BSD name.  */
+#  define _HAVE_STRING_ARCH_rindex 1
+#  define rindex(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? __strrchr_c ((s), ((c) & 0xff) << 8)		      \
+		  : __strrchr_g ((s), (c))))
+# endif
+
+
+/* Return the length of the initial segment of S which
+   consists entirely of characters not in REJECT.  */
+# define _HAVE_STRING_ARCH_strcspn 1
+# define strcspn(s, reject) \
+  (__extension__ (__builtin_constant_p (reject) && sizeof ((reject)[0]) == 1  \
+		  ? ((reject)[0] == '\0'				      \
+		     ? strlen (s)					      \
+		     : ((reject)[1] == '\0'				      \
+			? __strcspn_c1 ((s), (((reject)[0] << 8) & 0xff00))   \
+			: __strcspn_cg ((s), (reject), strlen (reject))))     \
+		  : __strcspn_g ((s), (reject))))
+
+__STRING_INLINE size_t __strcspn_c1 (const char *__s, int __reject);
+
+# ifndef _FORCE_INLINES
+__STRING_INLINE size_t
+__strcspn_c1 (const char *__s, int __reject)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "leal	1(%0),%0\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__reject),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return (__res - 1) - __s;
+}
+# endif
+
+__STRING_INLINE size_t __strcspn_cg (const char *__s, const char __reject[],
+				     size_t __reject_len);
+
+__STRING_INLINE size_t
+__strcspn_cg (const char *__s, const char __reject[], size_t __reject_len)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register const char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%5,%%edi\n\t"
+     "movl	%6,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n"
+     "2:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "0" (__s), "d" (__reject), "g" (__reject_len)
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+
+__STRING_INLINE size_t __strcspn_g (const char *__s, const char *__reject);
+# ifdef __PIC__
+
+__STRING_INLINE size_t
+__strcspn_g (const char *__s, const char *__reject)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register const char *__res;
+  __asm__ __volatile__
+    ("pushl	%%ebx\n\t"
+     "movl	%4,%%edi\n\t"
+     "cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%ebx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%4,%%edi\n\t"
+     "movl	%%ebx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n"
+     "2:\n\t"
+     "popl	%%ebx"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "r" (__reject), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+# else
+__STRING_INLINE size_t
+__strcspn_g (const char *__s, const char *__reject)
+{
+  register unsigned long int __d0, __d1, __d2, __d3;
+  register const char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%edx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%ebx,%%edi\n\t"
+     "movl	%%edx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n"
+     "2:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2), "=&d" (__d3)
+     : "0" (__s), "1" (0), "2" (0xffffffff), "3" (__reject), "b" (__reject)
+     /* Clobber memory, otherwise GCC cannot handle this.  */
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+# endif
+
+
+/* Return the length of the initial segment of S which
+   consists entirely of characters in ACCEPT.  */
+# define _HAVE_STRING_ARCH_strspn 1
+# define strspn(s, accept) \
+  (__extension__ (__builtin_constant_p (accept) && sizeof ((accept)[0]) == 1  \
+		  ? ((accept)[0] == '\0'				      \
+		     ? ((void) (s), 0)					      \
+		     : ((accept)[1] == '\0'				      \
+			? __strspn_c1 ((s), (((accept)[0] << 8 ) & 0xff00))   \
+			: __strspn_cg ((s), (accept), strlen (accept))))      \
+		  : __strspn_g ((s), (accept))))
+
+# ifndef _FORCE_INLINES
+__STRING_INLINE size_t __strspn_c1 (const char *__s, int __accept);
+
+__STRING_INLINE size_t
+__strspn_c1 (const char *__s, int __accept)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  /* Please note that __accept never can be '\0'.  */
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%b1\n\t"
+     "leal	1(%0),%0\n\t"
+     "cmpb	%h1,%b1\n\t"
+     "je	1b"
+     : "=r" (__res), "=&q" (__d0)
+     : "0" (__s), "1" (__accept),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return (__res - 1) - __s;
+}
+# endif
+
+__STRING_INLINE size_t __strspn_cg (const char *__s, const char __accept[],
+				    size_t __accept_len);
+
+__STRING_INLINE size_t
+__strspn_cg (const char *__s, const char __accept[], size_t __accept_len)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register const char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%5,%%edi\n\t"
+     "movl	%6,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "je	1b\n"
+     "2:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "0" (__s), "g" (__accept), "g" (__accept_len),
+       /* Since we do not know how large the memory we access it, use a
+	  really large amount.  */
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s),
+       "m" ( *(struct { __extension__ char __x[__accept_len]; } *)__accept)
+     : "cc");
+  return (__res - 1) - __s;
+}
+
+__STRING_INLINE size_t __strspn_g (const char *__s, const char *__accept);
+# ifdef __PIC__
+
+__STRING_INLINE size_t
+__strspn_g (const char *__s, const char *__accept)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register const char *__res;
+  __asm__ __volatile__
+    ("pushl	%%ebx\n\t"
+     "cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%ebx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%edx,%%edi\n\t"
+     "movl	%%ebx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "je	1b\n"
+     "2:\n\t"
+     "popl	%%ebx"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "d" (__accept), "0" (__s), "1" (0), "2" (0xffffffff), "3" (__accept)
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+# else
+__STRING_INLINE size_t
+__strspn_g (const char *__s, const char *__accept)
+{
+  register unsigned long int __d0, __d1, __d2, __d3;
+  register const char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%edx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%ebx,%%edi\n\t"
+     "movl	%%edx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "je	1b\n"
+     "2:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2), "=&d" (__d3)
+     : "0" (__s), "1" (0), "2" (0xffffffff), "3" (__accept), "b" (__accept)
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+# endif
+
+
+/* Find the first occurrence in S of any character in ACCEPT.  */
+# define _HAVE_STRING_ARCH_strpbrk 1
+# define strpbrk(s, accept) \
+  (__extension__ (__builtin_constant_p (accept) && sizeof ((accept)[0]) == 1  \
+		  ? ((accept)[0] == '\0'				      \
+		     ? ((void) (s), (char *) 0)				      \
+		     : ((accept)[1] == '\0'				      \
+			? strchr ((s), (accept)[0])			      \
+			: __strpbrk_cg ((s), (accept), strlen (accept))))     \
+		  : __strpbrk_g ((s), (accept))))
+
+__STRING_INLINE char *__strpbrk_cg (const char *__s, const char __accept[],
+				    size_t __accept_len);
+
+__STRING_INLINE char *
+__strpbrk_cg (const char *__s, const char __accept[], size_t __accept_len)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%5,%%edi\n\t"
+     "movl	%6,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n\t"
+     "jmp	3f\n"
+     "2:\n\t"
+     "xorl	%0,%0\n"
+     "3:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "0" (__s), "d" (__accept), "g" (__accept_len)
+     : "memory", "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strpbrk_g (const char *__s, const char *__accept);
+# ifdef __PIC__
+
+__STRING_INLINE char *
+__strpbrk_g (const char *__s, const char *__accept)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register char *__res;
+  __asm__ __volatile__
+    ("pushl	%%ebx\n\t"
+     "movl	%%edx,%%edi\n\t"
+     "cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%ebx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%edx,%%edi\n\t"
+     "movl	%%ebx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n\t"
+     "jmp	3f\n"
+     "2:\n\t"
+     "xorl	%0,%0\n"
+     "3:\n\t"
+     "popl	%%ebx"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "d" (__accept), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "memory", "cc");
+  return __res;
+}
+# else
+__STRING_INLINE char *
+__strpbrk_g (const char *__s, const char *__accept)
+{
+  register unsigned long int __d0, __d1, __d2, __d3;
+  register char *__res;
+  __asm__ __volatile__
+    ("movl	%%ebx,%%edi\n\t"
+     "cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%edx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%ebx,%%edi\n\t"
+     "movl	%%edx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n\t"
+     "jmp	3f\n"
+     "2:\n\t"
+     "xorl	%0,%0\n"
+     "3:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&d" (__d2), "=&D" (__d3)
+     : "0" (__s), "1" (0), "2" (0xffffffff), "b" (__accept)
+     : "memory", "cc");
+  return __res;
+}
+# endif
+
+
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+# define _HAVE_STRING_ARCH_strstr 1
+# define strstr(haystack, needle) \
+  (__extension__ (__builtin_constant_p (needle) && sizeof ((needle)[0]) == 1  \
+		  ? ((needle)[0] == '\0'				      \
+		     ? (haystack)					      \
+		     : ((needle)[1] == '\0'				      \
+			? strchr ((haystack), (needle)[0])		      \
+			: __strstr_cg ((haystack), (needle),		      \
+				       strlen (needle))))		      \
+		  : __strstr_g ((haystack), (needle))))
+
+/* Please note that this function need not handle NEEDLEs with a
+   length shorter than two.  */
+__STRING_INLINE char *__strstr_cg (const char *__haystack,
+				   const char __needle[],
+				   size_t __needle_len);
+
+__STRING_INLINE char *
+__strstr_cg (const char *__haystack, const char __needle[],
+	     size_t __needle_len)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n" \
+     "1:\n\t"
+     "movl	%6,%%edi\n\t"
+     "movl	%5,%%eax\n\t"
+     "movl	%4,%%ecx\n\t"
+     "repe; cmpsb\n\t"
+     "je	2f\n\t"
+     "cmpb	$0,-1(%%esi)\n\t"
+     "leal	1(%%eax),%5\n\t"
+     "jne	1b\n\t"
+     "xorl	%%eax,%%eax\n"
+     "2:"
+     : "=&a" (__res), "=&S" (__d0), "=&D" (__d1), "=&c" (__d2)
+     : "g" (__needle_len), "1" (__haystack), "d" (__needle)
+     : "memory", "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strstr_g (const char *__haystack,
+				  const char *__needle);
+# ifdef __PIC__
+
+__STRING_INLINE char *
+__strstr_g (const char *__haystack, const char *__needle)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "pushl	%%ebx\n\t"
+     "decl	%%ecx\n\t"	/* NOTE! This also sets Z if searchstring='' */
+     "movl	%%ecx,%%ebx\n"
+     "1:\n\t"
+     "movl	%%edx,%%edi\n\t"
+     "movl	%%esi,%%eax\n\t"
+     "movl	%%ebx,%%ecx\n\t"
+     "repe; cmpsb\n\t"
+     "je	2f\n\t"		/* also works for empty string, see above */
+     "cmpb	$0,-1(%%esi)\n\t"
+     "leal	1(%%eax),%%esi\n\t"
+     "jne	1b\n\t"
+     "xorl	%%eax,%%eax\n"
+     "2:\n\t"
+     "popl	%%ebx"
+     : "=&a" (__res), "=&c" (__d0), "=&S" (__d1), "=&D" (__d2)
+     : "0" (0), "1" (0xffffffff), "2" (__haystack), "3" (__needle),
+       "d" (__needle)
+     : "memory", "cc");
+  return __res;
+}
+# else
+__STRING_INLINE char *
+__strstr_g (const char *__haystack, const char *__needle)
+{
+  register unsigned long int __d0, __d1, __d2, __d3;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "decl	%%ecx\n\t"	/* NOTE! This also sets Z if searchstring='' */
+     "movl	%%ecx,%%edx\n"
+     "1:\n\t"
+     "movl	%%ebx,%%edi\n\t"
+     "movl	%%esi,%%eax\n\t"
+     "movl	%%edx,%%ecx\n\t"
+     "repe; cmpsb\n\t"
+     "je	2f\n\t"		/* also works for empty string, see above */
+     "cmpb	$0,-1(%%esi)\n\t"
+     "leal	1(%%eax),%%esi\n\t"
+     "jne	1b\n\t"
+     "xorl	%%eax,%%eax\n"
+     "2:"
+     : "=&a" (__res), "=&c" (__d0), "=&S" (__d1), "=&D" (__d2), "=&d" (__d3)
+     : "0" (0), "1" (0xffffffff), "2" (__haystack), "3" (__needle),
+       "b" (__needle)
+     : "memory", "cc");
+  return __res;
+}
+# endif
+
+
+/* Bit find functions.  We define only the i686 version since for the other
+   processors gcc generates good code.  */
+# if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+#  ifdef __i686__
+#   define _HAVE_STRING_ARCH_ffs 1
+#   define ffs(word) (__builtin_constant_p (word)			      \
+		      ? __builtin_ffs (word)				      \
+		      : ({ int __cnt, __tmp;				      \
+			   __asm__ __volatile__				      \
+			     ("bsfl %2,%0\n\t"				      \
+			      "cmovel %1,%0"				      \
+			      : "=&r" (__cnt), "=r" (__tmp)		      \
+			      : "rm" (word), "1" (-1));			      \
+			   __cnt + 1; }))
+
+#   ifndef ffsl
+#    define ffsl(word) ffs(word)
+#   endif
+#  endif /* i686 */
+# endif	/* BSD || X/Open */
+
+# ifndef _FORCE_INLINES
+#  undef __STRING_INLINE
+# endif
+
+# endif	/* use string inlines && GNU CC */
+
+#endif
diff --git a/include/bits/string2.h b/include/bits/string2.h
new file mode 100644
index 0000000..b3df708
--- /dev/null
+++ b/include/bits/string2.h
@@ -0,0 +1,1329 @@
+/* Machine-independant string function optimizations.
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STRING_H
+# error "Never use <bits/string2.h> directly; include <string.h> instead."
+#endif
+
+#ifndef __NO_STRING_INLINES
+
+/* Unlike the definitions in the header <bits/string.h> the
+   definitions contained here are not optimized down to assembler
+   level.  Those optimizations are not always a good idea since this
+   means the code size increases a lot.  Instead the definitions here
+   optimize some functions in a way which do not dramatically
+   increase the code size and which do not use assembler.  The main
+   trick is to use GCC's `__builtin_constant_p' function.
+
+   Every function XXX which has a defined version in
+   <bits/string.h> must be accompanied by a symbol _HAVE_STRING_ARCH_XXX
+   to make sure we don't get redefinitions.
+
+   We must use here macros instead of inline functions since the
+   trick won't work with the latter.  */
+
+#ifndef __STRING_INLINE
+# ifdef __cplusplus
+#  define __STRING_INLINE inline
+# else
+#  define __STRING_INLINE __extern_inline
+# endif
+#endif
+
+#if _STRING_ARCH_unaligned
+/* If we can do unaligned memory accesses we must know the endianess.  */
+# include <endian.h>
+# include <bits/types.h>
+
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __STRING2_SMALL_GET16(src, idx) \
+     (((const unsigned char *) (const char *) (src))[idx + 1] << 8	      \
+      | ((const unsigned char *) (const char *) (src))[idx])
+#  define __STRING2_SMALL_GET32(src, idx) \
+     (((((const unsigned char *) (const char *) (src))[idx + 3] << 8	      \
+	| ((const unsigned char *) (const char *) (src))[idx + 2]) << 8	      \
+       | ((const unsigned char *) (const char *) (src))[idx + 1]) << 8	      \
+      | ((const unsigned char *) (const char *) (src))[idx])
+# else
+#  define __STRING2_SMALL_GET16(src, idx) \
+     (((const unsigned char *) (const char *) (src))[idx] << 8		      \
+      | ((const unsigned char *) (const char *) (src))[idx + 1])
+#  define __STRING2_SMALL_GET32(src, idx) \
+     (((((const unsigned char *) (const char *) (src))[idx] << 8	      \
+	| ((const unsigned char *) (const char *) (src))[idx + 1]) << 8	      \
+       | ((const unsigned char *) (const char *) (src))[idx + 2]) << 8	      \
+      | ((const unsigned char *) (const char *) (src))[idx + 3])
+# endif
+#else
+/* These are a few types we need for the optimizations if we cannot
+   use unaligned memory accesses.  */
+# define __STRING2_COPY_TYPE(N) \
+  typedef struct { unsigned char __arr[N]; }				      \
+    __attribute__ ((__packed__)) __STRING2_COPY_ARR##N
+__STRING2_COPY_TYPE (2);
+__STRING2_COPY_TYPE (3);
+__STRING2_COPY_TYPE (4);
+__STRING2_COPY_TYPE (5);
+__STRING2_COPY_TYPE (6);
+__STRING2_COPY_TYPE (7);
+__STRING2_COPY_TYPE (8);
+# undef __STRING2_COPY_TYPE
+#endif
+
+/* Dereferencing a pointer arg to run sizeof on it fails for the void
+   pointer case, so we use this instead.
+   Note that __x is evaluated twice. */
+#define __string2_1bptr_p(__x) \
+  ((size_t)(const void *)((__x) + 1) - (size_t)(const void *)(__x) == 1)
+
+/* Set N bytes of S to C.  */
+#if !defined _HAVE_STRING_ARCH_memset
+# if !__GNUC_PREREQ (3, 0)
+#  if _STRING_ARCH_unaligned
+#   define memset(s, c, n) \
+  (__extension__ (__builtin_constant_p (n) && (n) <= 16			      \
+		  ? ((n) == 1						      \
+		     ? __memset_1 (s, c)				      \
+		     : __memset_gc (s, c, n))				      \
+		  : (__builtin_constant_p (c) && (c) == '\0'		      \
+		     ? ({ void *__s = (s); __bzero (__s, n); __s; })	      \
+		     : memset (s, c, n))))
+
+#   define __memset_1(s, c) ({ void *__s = (s);				      \
+			    *((__uint8_t *) __s) = (__uint8_t) c; __s; })
+
+#   define __memset_gc(s, c, n) \
+  ({ void *__s = (s);							      \
+     union {								      \
+       unsigned int __ui;						      \
+       unsigned short int __usi;					      \
+       unsigned char __uc;						      \
+     } *__u = __s;							      \
+     __uint8_t __c = (__uint8_t) (c);					      \
+									      \
+     /* This `switch' statement will be removed at compile-time.  */	      \
+     switch ((unsigned int) (n))					      \
+       {								      \
+       case 15:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 11:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 7:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 3:								      \
+	 __u->__usi = (unsigned short int) __c * 0x0101;		      \
+	 __u = __extension__ ((void *) __u + 2);			      \
+	 __u->__uc = (unsigned char) __c;				      \
+	 break;								      \
+									      \
+       case 14:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 10:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 6:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 2:								      \
+	 __u->__usi = (unsigned short int) __c * 0x0101;		      \
+	 break;								      \
+									      \
+       case 13:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 9:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 5:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 1:								      \
+	 __u->__uc = (unsigned char) __c;				      \
+	 break;								      \
+									      \
+       case 16:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 12:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 8:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 4:								      \
+	 __u->__ui = __c * 0x01010101;					      \
+       case 0:								      \
+	 break;								      \
+       }								      \
+									      \
+     __s; })
+#  else
+#   define memset(s, c, n) \
+  (__extension__ (__builtin_constant_p (c) && (c) == '\0'		      \
+		  ? ({ void *__s = (s); __bzero (__s, n); __s; })	      \
+		  : memset (s, c, n)))
+#  endif
+# endif
+
+/* GCC < 3.0 optimizes memset(s, 0, n) but not bzero(s, n).
+   The optimization is broken before EGCS 1.1.
+   GCC 3.0+ has __builtin_bzero as well, but at least till GCC 3.4
+   if it decides to call the library function, it calls memset
+   and not bzero.  */
+# if __GNUC_PREREQ (2, 91)
+#  define __bzero(s, n) __builtin_memset (s, '\0', n)
+# endif
+
+#endif
+
+
+/* Copy N bytes from SRC to DEST, returning pointer to byte following the
+   last copied.  */
+#ifdef __USE_GNU
+# if !defined _HAVE_STRING_ARCH_mempcpy || defined _FORCE_INLINES
+#  ifndef _HAVE_STRING_ARCH_mempcpy
+#   if __GNUC_PREREQ (3, 4)
+#    define __mempcpy(dest, src, n) __builtin_mempcpy (dest, src, n)
+#   elif __GNUC_PREREQ (3, 0)
+#    define __mempcpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src) && __builtin_constant_p (n)      \
+		  && __string2_1bptr_p (src) && n <= 8			      \
+		  ? __builtin_memcpy (dest, src, n) + (n)		      \
+		  : __mempcpy (dest, src, n)))
+#   else
+#    define __mempcpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src) && __builtin_constant_p (n)      \
+		  && __string2_1bptr_p (src) && n <= 8			      \
+		  ? __mempcpy_small (dest, __mempcpy_args (src), n)	      \
+		  : __mempcpy (dest, src, n)))
+#   endif
+/* In glibc we use this function frequently but for namespace reasons
+   we have to use the name `__mempcpy'.  */
+#   define mempcpy(dest, src, n) __mempcpy (dest, src, n)
+#  endif
+
+#  if !__GNUC_PREREQ (3, 0) || defined _FORCE_INLINES
+#   if _STRING_ARCH_unaligned
+#    ifndef _FORCE_INLINES
+#     define __mempcpy_args(src) \
+     ((const char *) (src))[0], ((const char *) (src))[2],		      \
+     ((const char *) (src))[4], ((const char *) (src))[6],		      \
+     __extension__ __STRING2_SMALL_GET16 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET16 (src, 4),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 4)
+#    endif
+__STRING_INLINE void *__mempcpy_small (void *, char, char, char, char,
+				       __uint16_t, __uint16_t, __uint32_t,
+				       __uint32_t, size_t);
+__STRING_INLINE void *
+__mempcpy_small (void *__dest1,
+		 char __src0_1, char __src2_1, char __src4_1, char __src6_1,
+		 __uint16_t __src0_2, __uint16_t __src4_2,
+		 __uint32_t __src0_4, __uint32_t __src4_4,
+		 size_t __srclen)
+{
+  union {
+    __uint32_t __ui;
+    __uint16_t __usi;
+    unsigned char __uc;
+    unsigned char __c;
+  } *__u = __dest1;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__c = __src0_1;
+      __u = __extension__ ((void *) __u + 1);
+      break;
+    case 2:
+      __u->__usi = __src0_2;
+      __u = __extension__ ((void *) __u + 2);
+      break;
+    case 3:
+      __u->__usi = __src0_2;
+      __u = __extension__ ((void *) __u + 2);
+      __u->__c = __src2_1;
+      __u = __extension__ ((void *) __u + 1);
+      break;
+    case 4:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      break;
+    case 5:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__c = __src4_1;
+      __u = __extension__ ((void *) __u + 1);
+      break;
+    case 6:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ ((void *) __u + 2);
+      break;
+    case 7:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ ((void *) __u + 2);
+      __u->__c = __src6_1;
+      __u = __extension__ ((void *) __u + 1);
+      break;
+    case 8:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__ui = __src4_4;
+      __u = __extension__ ((void *) __u + 4);
+      break;
+    }
+  return (void *) __u;
+}
+#   else
+#    ifndef _FORCE_INLINES
+#     define __mempcpy_args(src) \
+     ((const char *) (src))[0],						      \
+     __extension__ ((__STRING2_COPY_ARR2)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1] } }),	      \
+     __extension__ ((__STRING2_COPY_ARR3)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2] } }),				      \
+     __extension__ ((__STRING2_COPY_ARR4)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3] } }),	      \
+     __extension__ ((__STRING2_COPY_ARR5)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4] } }),				      \
+     __extension__ ((__STRING2_COPY_ARR6)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4], ((const char *) (src))[5] } }),	      \
+     __extension__ ((__STRING2_COPY_ARR7)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4], ((const char *) (src))[5],		      \
+	  ((const char *) (src))[6] } }),				      \
+     __extension__ ((__STRING2_COPY_ARR8)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4], ((const char *) (src))[5],		      \
+	  ((const char *) (src))[6], ((const char *) (src))[7] } })
+#    endif
+__STRING_INLINE void *__mempcpy_small (void *, char, __STRING2_COPY_ARR2,
+				       __STRING2_COPY_ARR3,
+				       __STRING2_COPY_ARR4,
+				       __STRING2_COPY_ARR5,
+				       __STRING2_COPY_ARR6,
+				       __STRING2_COPY_ARR7,
+				       __STRING2_COPY_ARR8, size_t);
+__STRING_INLINE void *
+__mempcpy_small (void *__dest, char __src1,
+		 __STRING2_COPY_ARR2 __src2, __STRING2_COPY_ARR3 __src3,
+		 __STRING2_COPY_ARR4 __src4, __STRING2_COPY_ARR5 __src5,
+		 __STRING2_COPY_ARR6 __src6, __STRING2_COPY_ARR7 __src7,
+		 __STRING2_COPY_ARR8 __src8, size_t __srclen)
+{
+  union {
+    char __c;
+    __STRING2_COPY_ARR2 __sca2;
+    __STRING2_COPY_ARR3 __sca3;
+    __STRING2_COPY_ARR4 __sca4;
+    __STRING2_COPY_ARR5 __sca5;
+    __STRING2_COPY_ARR6 __sca6;
+    __STRING2_COPY_ARR7 __sca7;
+    __STRING2_COPY_ARR8 __sca8;
+  } *__u = __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__c = __src1;
+      break;
+    case 2:
+      __extension__ __u->__sca2 = __src2;
+      break;
+    case 3:
+      __extension__ __u->__sca3 = __src3;
+      break;
+    case 4:
+      __extension__ __u->__sca4 = __src4;
+      break;
+    case 5:
+      __extension__ __u->__sca5 = __src5;
+      break;
+    case 6:
+      __extension__ __u->__sca6 = __src6;
+      break;
+    case 7:
+      __extension__ __u->__sca7 = __src7;
+      break;
+    case 8:
+      __extension__ __u->__sca8 = __src8;
+      break;
+    }
+  return __extension__ ((void *) __u + __srclen);
+}
+#   endif
+#  endif
+# endif
+#endif
+
+
+/* Return pointer to C in S.  */
+#ifndef _HAVE_STRING_ARCH_strchr
+extern void *__rawmemchr (const void *__s, int __c);
+# if __GNUC_PREREQ (3, 2)
+#  define strchr(s, c) \
+  (__extension__ (__builtin_constant_p (c) && !__builtin_constant_p (s)	      \
+		  && (c) == '\0'					      \
+		  ? (char *) __rawmemchr (s, c)				      \
+		  : __builtin_strchr (s, c)))
+# else
+#  define strchr(s, c) \
+  (__extension__ (__builtin_constant_p (c) && (c) == '\0'		      \
+		  ? (char *) __rawmemchr (s, c)				      \
+		  : strchr (s, c)))
+# endif
+#endif
+
+
+/* Copy SRC to DEST.  */
+#if (!defined _HAVE_STRING_ARCH_strcpy && !__GNUC_PREREQ (3, 0)) \
+    || defined _FORCE_INLINES
+# if !defined _HAVE_STRING_ARCH_strcpy && !__GNUC_PREREQ (3, 0)
+#  define strcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (__string2_1bptr_p (src) && strlen (src) + 1 <= 8	      \
+		     ? __strcpy_small (dest, __strcpy_args (src),	      \
+				       strlen (src) + 1)		      \
+		     : (char *) memcpy (dest, src, strlen (src) + 1))	      \
+		  : strcpy (dest, src)))
+# endif
+
+# if _STRING_ARCH_unaligned
+#  ifndef _FORCE_INLINES
+#   define __strcpy_args(src) \
+     __extension__ __STRING2_SMALL_GET16 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET16 (src, 4),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 4)
+#  endif
+__STRING_INLINE char *__strcpy_small (char *, __uint16_t, __uint16_t,
+				      __uint32_t, __uint32_t, size_t);
+__STRING_INLINE char *
+__strcpy_small (char *__dest,
+		__uint16_t __src0_2, __uint16_t __src4_2,
+		__uint32_t __src0_4, __uint32_t __src4_4,
+		size_t __srclen)
+{
+  union {
+    __uint32_t __ui;
+    __uint16_t __usi;
+    unsigned char __uc;
+  } *__u = (void *) __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__uc = '\0';
+      break;
+    case 2:
+      __u->__usi = __src0_2;
+      break;
+    case 3:
+      __u->__usi = __src0_2;
+      __u = __extension__ ((void *) __u + 2);
+      __u->__uc = '\0';
+      break;
+    case 4:
+      __u->__ui = __src0_4;
+      break;
+    case 5:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__uc = '\0';
+      break;
+    case 6:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__usi = __src4_2;
+      break;
+    case 7:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ ((void *) __u + 2);
+      __u->__uc = '\0';
+      break;
+    case 8:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__ui = __src4_4;
+      break;
+    }
+  return __dest;
+}
+# else
+#  ifndef _FORCE_INLINES
+#   define __strcpy_args(src) \
+     __extension__ ((__STRING2_COPY_ARR2)				      \
+      { { ((const char *) (src))[0], '\0' } }),				      \
+     __extension__ ((__STRING2_COPY_ARR3)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR4)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], '\0' } }),				      \
+     __extension__ ((__STRING2_COPY_ARR5)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR6)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4], '\0' } }),				      \
+     __extension__ ((__STRING2_COPY_ARR7)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4], ((const char *) (src))[5],		      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR8)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4], ((const char *) (src))[5],		      \
+	  ((const char *) (src))[6], '\0' } })
+#  endif
+__STRING_INLINE char *__strcpy_small (char *, __STRING2_COPY_ARR2,
+				      __STRING2_COPY_ARR3,
+				      __STRING2_COPY_ARR4,
+				      __STRING2_COPY_ARR5,
+				      __STRING2_COPY_ARR6,
+				      __STRING2_COPY_ARR7,
+				      __STRING2_COPY_ARR8, size_t);
+__STRING_INLINE char *
+__strcpy_small (char *__dest,
+		__STRING2_COPY_ARR2 __src2, __STRING2_COPY_ARR3 __src3,
+		__STRING2_COPY_ARR4 __src4, __STRING2_COPY_ARR5 __src5,
+		__STRING2_COPY_ARR6 __src6, __STRING2_COPY_ARR7 __src7,
+		__STRING2_COPY_ARR8 __src8, size_t __srclen)
+{
+  union {
+    char __c;
+    __STRING2_COPY_ARR2 __sca2;
+    __STRING2_COPY_ARR3 __sca3;
+    __STRING2_COPY_ARR4 __sca4;
+    __STRING2_COPY_ARR5 __sca5;
+    __STRING2_COPY_ARR6 __sca6;
+    __STRING2_COPY_ARR7 __sca7;
+    __STRING2_COPY_ARR8 __sca8;
+  } *__u = (void *) __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__c = '\0';
+      break;
+    case 2:
+      __extension__ __u->__sca2 = __src2;
+      break;
+    case 3:
+      __extension__ __u->__sca3 = __src3;
+      break;
+    case 4:
+      __extension__ __u->__sca4 = __src4;
+      break;
+    case 5:
+      __extension__ __u->__sca5 = __src5;
+      break;
+    case 6:
+      __extension__ __u->__sca6 = __src6;
+      break;
+    case 7:
+      __extension__ __u->__sca7 = __src7;
+      break;
+    case 8:
+      __extension__ __u->__sca8 = __src8;
+      break;
+  }
+  return __dest;
+}
+# endif
+#endif
+
+
+/* Copy SRC to DEST, returning pointer to final NUL byte.  */
+#ifdef __USE_GNU
+# if !defined _HAVE_STRING_ARCH_stpcpy || defined _FORCE_INLINES
+#  ifndef _HAVE_STRING_ARCH_stpcpy
+#   if __GNUC_PREREQ (3, 4)
+#    define __stpcpy(dest, src) __builtin_stpcpy (dest, src)
+#   elif __GNUC_PREREQ (3, 0)
+#    define __stpcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (__string2_1bptr_p (src) && strlen (src) + 1 <= 8	      \
+		     ? __builtin_strcpy (dest, src) + strlen (src)	      \
+		     : ((char *) (__mempcpy) (dest, src, strlen (src) + 1)    \
+			- 1))						      \
+		  : __stpcpy (dest, src)))
+#   else
+#    define __stpcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (__string2_1bptr_p (src) && strlen (src) + 1 <= 8	      \
+		     ? __stpcpy_small (dest, __stpcpy_args (src),	      \
+				       strlen (src) + 1)		      \
+		     : ((char *) (__mempcpy) (dest, src, strlen (src) + 1)    \
+			- 1))						      \
+		  : __stpcpy (dest, src)))
+#   endif
+/* In glibc we use this function frequently but for namespace reasons
+   we have to use the name `__stpcpy'.  */
+#   define stpcpy(dest, src) __stpcpy (dest, src)
+#  endif
+
+#  if !__GNUC_PREREQ (3, 0) || defined _FORCE_INLINES
+#   if _STRING_ARCH_unaligned
+#    ifndef _FORCE_INLINES
+#     define __stpcpy_args(src) \
+     __extension__ __STRING2_SMALL_GET16 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET16 (src, 4),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 0),			      \
+     __extension__ __STRING2_SMALL_GET32 (src, 4)
+#    endif
+__STRING_INLINE char *__stpcpy_small (char *, __uint16_t, __uint16_t,
+				      __uint32_t, __uint32_t, size_t);
+__STRING_INLINE char *
+__stpcpy_small (char *__dest,
+		__uint16_t __src0_2, __uint16_t __src4_2,
+		__uint32_t __src0_4, __uint32_t __src4_4,
+		size_t __srclen)
+{
+  union {
+    unsigned int __ui;
+    unsigned short int __usi;
+    unsigned char __uc;
+    char __c;
+  } *__u = (void *) __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__uc = '\0';
+      break;
+    case 2:
+      __u->__usi = __src0_2;
+      __u = __extension__ ((void *) __u + 1);
+      break;
+    case 3:
+      __u->__usi = __src0_2;
+      __u = __extension__ ((void *) __u + 2);
+      __u->__uc = '\0';
+      break;
+    case 4:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 3);
+      break;
+    case 5:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__uc = '\0';
+      break;
+    case 6:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ ((void *) __u + 1);
+      break;
+    case 7:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__usi = __src4_2;
+      __u = __extension__ ((void *) __u + 2);
+      __u->__uc = '\0';
+      break;
+    case 8:
+      __u->__ui = __src0_4;
+      __u = __extension__ ((void *) __u + 4);
+      __u->__ui = __src4_4;
+      __u = __extension__ ((void *) __u + 3);
+      break;
+    }
+  return &__u->__c;
+}
+#   else
+#    ifndef _FORCE_INLINES
+#     define __stpcpy_args(src) \
+     __extension__ ((__STRING2_COPY_ARR2)				      \
+      { { ((const char *) (src))[0], '\0' } }),				      \
+     __extension__ ((__STRING2_COPY_ARR3)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR4)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], '\0' } }),				      \
+     __extension__ ((__STRING2_COPY_ARR5)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR6)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4], '\0' } }),				      \
+     __extension__ ((__STRING2_COPY_ARR7)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4], ((const char *) (src))[5],		      \
+	  '\0' } }),							      \
+     __extension__ ((__STRING2_COPY_ARR8)				      \
+      { { ((const char *) (src))[0], ((const char *) (src))[1],		      \
+	  ((const char *) (src))[2], ((const char *) (src))[3],		      \
+	  ((const char *) (src))[4], ((const char *) (src))[5],		      \
+	  ((const char *) (src))[6], '\0' } })
+#    endif
+__STRING_INLINE char *__stpcpy_small (char *, __STRING2_COPY_ARR2,
+				      __STRING2_COPY_ARR3,
+				      __STRING2_COPY_ARR4,
+				      __STRING2_COPY_ARR5,
+				      __STRING2_COPY_ARR6,
+				      __STRING2_COPY_ARR7,
+				      __STRING2_COPY_ARR8, size_t);
+__STRING_INLINE char *
+__stpcpy_small (char *__dest,
+		__STRING2_COPY_ARR2 __src2, __STRING2_COPY_ARR3 __src3,
+		__STRING2_COPY_ARR4 __src4, __STRING2_COPY_ARR5 __src5,
+		__STRING2_COPY_ARR6 __src6, __STRING2_COPY_ARR7 __src7,
+		__STRING2_COPY_ARR8 __src8, size_t __srclen)
+{
+  union {
+    char __c;
+    __STRING2_COPY_ARR2 __sca2;
+    __STRING2_COPY_ARR3 __sca3;
+    __STRING2_COPY_ARR4 __sca4;
+    __STRING2_COPY_ARR5 __sca5;
+    __STRING2_COPY_ARR6 __sca6;
+    __STRING2_COPY_ARR7 __sca7;
+    __STRING2_COPY_ARR8 __sca8;
+  } *__u = (void *) __dest;
+  switch ((unsigned int) __srclen)
+    {
+    case 1:
+      __u->__c = '\0';
+      break;
+    case 2:
+      __extension__ __u->__sca2 = __src2;
+      break;
+    case 3:
+      __extension__ __u->__sca3 = __src3;
+      break;
+    case 4:
+      __extension__ __u->__sca4 = __src4;
+      break;
+    case 5:
+      __extension__ __u->__sca5 = __src5;
+      break;
+    case 6:
+      __extension__ __u->__sca6 = __src6;
+      break;
+    case 7:
+      __extension__ __u->__sca7 = __src7;
+      break;
+    case 8:
+      __extension__ __u->__sca8 = __src8;
+      break;
+  }
+  return __dest + __srclen - 1;
+}
+#   endif
+#  endif
+# endif
+#endif
+
+
+/* Copy no more than N characters of SRC to DEST.  */
+#ifndef _HAVE_STRING_ARCH_strncpy
+# if __GNUC_PREREQ (3, 2)
+#  define strncpy(dest, src, n) __builtin_strncpy (dest, src, n)
+# else
+#  define strncpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src) && __builtin_constant_p (n)      \
+		  ? (strlen (src) + 1 >= ((size_t) (n))			      \
+		     ? (char *) memcpy (dest, src, n)			      \
+		     : strncpy (dest, src, n))				      \
+		  : strncpy (dest, src, n)))
+# endif
+#endif
+
+
+/* Append no more than N characters from SRC onto DEST.  */
+#ifndef _HAVE_STRING_ARCH_strncat
+# ifdef _USE_STRING_ARCH_strchr
+#  define strncat(dest, src, n) \
+  (__extension__ ({ char *__dest = (dest);				      \
+		    __builtin_constant_p (src) && __builtin_constant_p (n)    \
+		    ? (strlen (src) < ((size_t) (n))			      \
+		       ? strcat (__dest, src)				      \
+		       : (*((char *) __mempcpy (strchr (__dest, '\0'),	      \
+						src, n)) = '\0', __dest))     \
+		    : strncat (dest, src, n); }))
+# elif __GNUC_PREREQ (3, 2)
+#  define strncat(dest, src, n) __builtin_strncat (dest, src, n)
+# else
+#  define strncat(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src) && __builtin_constant_p (n)      \
+		  ? (strlen (src) < ((size_t) (n))			      \
+		     ? strcat (dest, src)				      \
+		     : strncat (dest, src, n))				      \
+		  : strncat (dest, src, n)))
+# endif
+#endif
+
+
+/* Compare characters of S1 and S2.  */
+#ifndef _HAVE_STRING_ARCH_strcmp
+# if __GNUC_PREREQ (3, 2)
+#  define strcmp(s1, s2) \
+  __extension__								      \
+  ({ size_t __s1_len, __s2_len;						      \
+     (__builtin_constant_p (s1) && __builtin_constant_p (s2)		      \
+      && (__s1_len = strlen (s1), __s2_len = strlen (s2),		      \
+	  (!__string2_1bptr_p (s1) || __s1_len >= 4)			      \
+	  && (!__string2_1bptr_p (s2) || __s2_len >= 4))		      \
+      ? __builtin_strcmp (s1, s2)					      \
+      : (__builtin_constant_p (s1) && __string2_1bptr_p (s1)		      \
+	 && (__s1_len = strlen (s1), __s1_len < 4)			      \
+	 ? (__builtin_constant_p (s2) && __string2_1bptr_p (s2)		      \
+	    ? __builtin_strcmp (s1, s2)					      \
+	    : __strcmp_cg (s1, s2, __s1_len))				      \
+	 : (__builtin_constant_p (s2) && __string2_1bptr_p (s2)		      \
+	    && (__s2_len = strlen (s2), __s2_len < 4)			      \
+	    ? (__builtin_constant_p (s1) && __string2_1bptr_p (s1)	      \
+	       ? __builtin_strcmp (s1, s2)				      \
+	       : __strcmp_gc (s1, s2, __s2_len))			      \
+	    : __builtin_strcmp (s1, s2)))); })
+# else
+#  define strcmp(s1, s2) \
+  __extension__								      \
+  ({ size_t __s1_len, __s2_len;						      \
+     (__builtin_constant_p (s1) && __builtin_constant_p (s2)		      \
+      && (__s1_len = strlen (s1), __s2_len = strlen (s2),		      \
+	  (!__string2_1bptr_p (s1) || __s1_len >= 4)			      \
+	  && (!__string2_1bptr_p (s2) || __s2_len >= 4))		      \
+      ? memcmp ((const char *) (s1), (const char *) (s2),		      \
+		(__s1_len < __s2_len ? __s1_len : __s2_len) + 1)	      \
+      : (__builtin_constant_p (s1) && __string2_1bptr_p (s1)		      \
+	 && (__s1_len = strlen (s1), __s1_len < 4)			      \
+	 ? (__builtin_constant_p (s2) && __string2_1bptr_p (s2)		      \
+	    ? __strcmp_cc (s1, s2, __s1_len)				      \
+	    : __strcmp_cg (s1, s2, __s1_len))				      \
+	 : (__builtin_constant_p (s2) && __string2_1bptr_p (s2)		      \
+	    && (__s2_len = strlen (s2), __s2_len < 4)			      \
+	    ? (__builtin_constant_p (s1) && __string2_1bptr_p (s1)	      \
+	       ? __strcmp_cc (s1, s2, __s2_len)				      \
+	       : __strcmp_gc (s1, s2, __s2_len))			      \
+	    : strcmp (s1, s2)))); })
+# endif
+
+# define __strcmp_cc(s1, s2, l) \
+  (__extension__ ({ int __result =					      \
+		      (((const unsigned char *) (const char *) (s1))[0]	      \
+		       - ((const unsigned char *) (const char *)(s2))[0]);    \
+		    if (l > 0 && __result == 0)				      \
+		      {							      \
+			__result = (((const unsigned char *)		      \
+				     (const char *) (s1))[1]		      \
+				    - ((const unsigned char *)		      \
+				       (const char *) (s2))[1]);	      \
+			if (l > 1 && __result == 0)			      \
+			  {						      \
+			    __result =					      \
+			      (((const unsigned char *)			      \
+				(const char *) (s1))[2]			      \
+			       - ((const unsigned char *)		      \
+				  (const char *) (s2))[2]);		      \
+			    if (l > 2 && __result == 0)			      \
+			      __result =				      \
+				(((const unsigned char *)		      \
+				  (const char *) (s1))[3]		      \
+				 - ((const unsigned char *)		      \
+				    (const char *) (s2))[3]);		      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+# define __strcmp_cg(s1, s2, l1) \
+  (__extension__ ({ const unsigned char *__s2 =				      \
+		      (const unsigned char *) (const char *) (s2);	      \
+		    int __result =					      \
+		      (((const unsigned char *) (const char *) (s1))[0]	      \
+		       - __s2[0]);					      \
+		    if (l1 > 0 && __result == 0)			      \
+		      {							      \
+			__result = (((const unsigned char *)		      \
+				     (const char *) (s1))[1] - __s2[1]);      \
+			if (l1 > 1 && __result == 0)			      \
+			  {						      \
+			    __result = (((const unsigned char *)	      \
+					 (const char *) (s1))[2] - __s2[2]);  \
+			    if (l1 > 2 && __result == 0)		      \
+			      __result = (((const unsigned char *)	      \
+					  (const char *)  (s1))[3]	      \
+					  - __s2[3]);			      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+# define __strcmp_gc(s1, s2, l2) (- __strcmp_cg (s2, s1, l2))
+#endif
+
+
+/* Compare N characters of S1 and S2.  */
+#ifndef _HAVE_STRING_ARCH_strncmp
+# define strncmp(s1, s2, n)						      \
+  (__extension__ (__builtin_constant_p (n)				      \
+		  && ((__builtin_constant_p (s1)			      \
+		       && strlen (s1) < ((size_t) (n)))			      \
+		      || (__builtin_constant_p (s2)			      \
+			  && strlen (s2) < ((size_t) (n))))		      \
+		  ? strcmp (s1, s2) : strncmp (s1, s2, n)))
+#endif
+
+
+/* Return the length of the initial segment of S which
+   consists entirely of characters not in REJECT.  */
+#if !defined _HAVE_STRING_ARCH_strcspn || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strcspn
+#  if __GNUC_PREREQ (3, 2)
+#   define strcspn(s, reject) \
+  __extension__								      \
+  ({ char __r0, __r1, __r2;						      \
+     (__builtin_constant_p (reject) && __string2_1bptr_p (reject)	      \
+      ? ((__builtin_constant_p (s) && __string2_1bptr_p (s))		      \
+	 ? __builtin_strcspn (s, reject)				      \
+	 : ((__r0 = ((const char *) (reject))[0], __r0 == '\0')		      \
+	    ? strlen (s)						      \
+	    : ((__r1 = ((const char *) (reject))[1], __r1 == '\0')	      \
+	       ? __strcspn_c1 (s, __r0)					      \
+	       : ((__r2 = ((const char *) (reject))[2], __r2 == '\0')	      \
+		  ? __strcspn_c2 (s, __r0, __r1)			      \
+		  : (((const char *) (reject))[3] == '\0'		      \
+		     ? __strcspn_c3 (s, __r0, __r1, __r2)		      \
+		     : __builtin_strcspn (s, reject))))))		      \
+      : __builtin_strcspn (s, reject)); })
+#  else
+#   define strcspn(s, reject) \
+  __extension__								      \
+  ({ char __r0, __r1, __r2;						      \
+     (__builtin_constant_p (reject) && __string2_1bptr_p (reject)	      \
+      ? ((__r0 = ((const char *) (reject))[0], __r0 == '\0')		      \
+	 ? strlen (s)							      \
+	 : ((__r1 = ((const char *) (reject))[1], __r1 == '\0')		      \
+	    ? __strcspn_c1 (s, __r0)					      \
+	    : ((__r2 = ((const char *) (reject))[2], __r2 == '\0')	      \
+	       ? __strcspn_c2 (s, __r0, __r1)				      \
+	       : (((const char *) (reject))[3] == '\0'			      \
+		  ? __strcspn_c3 (s, __r0, __r1, __r2)			      \
+		  : strcspn (s, reject)))))				      \
+      : strcspn (s, reject)); })
+#  endif
+# endif
+
+__STRING_INLINE size_t __strcspn_c1 (const char *__s, int __reject);
+__STRING_INLINE size_t
+__strcspn_c1 (const char *__s, int __reject)
+{
+  size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject)
+    ++__result;
+  return __result;
+}
+
+__STRING_INLINE size_t __strcspn_c2 (const char *__s, int __reject1,
+				     int __reject2);
+__STRING_INLINE size_t
+__strcspn_c2 (const char *__s, int __reject1, int __reject2)
+{
+  size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject1
+	 && __s[__result] != __reject2)
+    ++__result;
+  return __result;
+}
+
+__STRING_INLINE size_t __strcspn_c3 (const char *__s, int __reject1,
+				     int __reject2, int __reject3);
+__STRING_INLINE size_t
+__strcspn_c3 (const char *__s, int __reject1, int __reject2,
+	      int __reject3)
+{
+  size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject1
+	 && __s[__result] != __reject2 && __s[__result] != __reject3)
+    ++__result;
+  return __result;
+}
+#endif
+
+
+/* Return the length of the initial segment of S which
+   consists entirely of characters in ACCEPT.  */
+#if !defined _HAVE_STRING_ARCH_strspn || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strspn
+#  if __GNUC_PREREQ (3, 2)
+#   define strspn(s, accept) \
+  __extension__								      \
+  ({ char __a0, __a1, __a2;						      \
+     (__builtin_constant_p (accept) && __string2_1bptr_p (accept)	      \
+      ? ((__builtin_constant_p (s) && __string2_1bptr_p (s))		      \
+	 ? __builtin_strspn (s, accept)					      \
+	 : ((__a0 = ((const char *) (accept))[0], __a0 == '\0')		      \
+	    ? ((void) (s), (size_t) 0)					      \
+	    : ((__a1 = ((const char *) (accept))[1], __a1 == '\0')	      \
+	       ? __strspn_c1 (s, __a0)					      \
+	       : ((__a2 = ((const char *) (accept))[2], __a2 == '\0')	      \
+		  ? __strspn_c2 (s, __a0, __a1)				      \
+		  : (((const char *) (accept))[3] == '\0'		      \
+		     ? __strspn_c3 (s, __a0, __a1, __a2)		      \
+		     : __builtin_strspn (s, accept))))))		      \
+      : __builtin_strspn (s, accept)); })
+#  else
+#   define strspn(s, accept) \
+  __extension__								      \
+  ({ char __a0, __a1, __a2;						      \
+     (__builtin_constant_p (accept) && __string2_1bptr_p (accept)	      \
+      ? ((__a0 = ((const char *) (accept))[0], __a0 == '\0')		      \
+	 ? ((void) (s), (size_t) 0)					      \
+	 : ((__a1 = ((const char *) (accept))[1], __a1 == '\0')		      \
+	    ? __strspn_c1 (s, __a0)					      \
+	    : ((__a2 = ((const char *) (accept))[2], __a2 == '\0')	      \
+	       ? __strspn_c2 (s, __a0, __a1)				      \
+	       : (((const char *) (accept))[3] == '\0'			      \
+		  ? __strspn_c3 (s, __a0, __a1, __a2)			      \
+		  : strspn (s, accept)))))				      \
+      : strspn (s, accept)); })
+#  endif
+# endif
+
+__STRING_INLINE size_t __strspn_c1 (const char *__s, int __accept);
+__STRING_INLINE size_t
+__strspn_c1 (const char *__s, int __accept)
+{
+  size_t __result = 0;
+  /* Please note that __accept never can be '\0'.  */
+  while (__s[__result] == __accept)
+    ++__result;
+  return __result;
+}
+
+__STRING_INLINE size_t __strspn_c2 (const char *__s, int __accept1,
+				    int __accept2);
+__STRING_INLINE size_t
+__strspn_c2 (const char *__s, int __accept1, int __accept2)
+{
+  size_t __result = 0;
+  /* Please note that __accept1 and __accept2 never can be '\0'.  */
+  while (__s[__result] == __accept1 || __s[__result] == __accept2)
+    ++__result;
+  return __result;
+}
+
+__STRING_INLINE size_t __strspn_c3 (const char *__s, int __accept1,
+				    int __accept2, int __accept3);
+__STRING_INLINE size_t
+__strspn_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
+{
+  size_t __result = 0;
+  /* Please note that __accept1 to __accept3 never can be '\0'.  */
+  while (__s[__result] == __accept1 || __s[__result] == __accept2
+	 || __s[__result] == __accept3)
+    ++__result;
+  return __result;
+}
+#endif
+
+
+/* Find the first occurrence in S of any character in ACCEPT.  */
+#if !defined _HAVE_STRING_ARCH_strpbrk || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strpbrk
+#  if __GNUC_PREREQ (3, 2)
+#   define strpbrk(s, accept) \
+  __extension__								      \
+  ({ char __a0, __a1, __a2;						      \
+     (__builtin_constant_p (accept) && __string2_1bptr_p (accept)	      \
+      ? ((__builtin_constant_p (s) && __string2_1bptr_p (s))		      \
+	 ? __builtin_strpbrk (s, accept)				      \
+	 : ((__a0 = ((const char  *) (accept))[0], __a0 == '\0')	      \
+	    ? ((void) (s), (char *) NULL)				      \
+	    : ((__a1 = ((const char *) (accept))[1], __a1 == '\0')	      \
+	       ? __builtin_strchr (s, __a0)				      \
+	       : ((__a2 = ((const char *) (accept))[2], __a2 == '\0')	      \
+		  ? __strpbrk_c2 (s, __a0, __a1)			      \
+		  : (((const char *) (accept))[3] == '\0'		      \
+		     ? __strpbrk_c3 (s, __a0, __a1, __a2)		      \
+		     : __builtin_strpbrk (s, accept))))))		      \
+      : __builtin_strpbrk (s, accept)); })
+#  else
+#   define strpbrk(s, accept) \
+  __extension__								      \
+  ({ char __a0, __a1, __a2;						      \
+     (__builtin_constant_p (accept) && __string2_1bptr_p (accept)	      \
+      ? ((__a0 = ((const char  *) (accept))[0], __a0 == '\0')		      \
+	 ? ((void) (s), (char *) NULL)					      \
+	 : ((__a1 = ((const char *) (accept))[1], __a1 == '\0')		      \
+	    ? strchr (s, __a0)						      \
+	    : ((__a2 = ((const char *) (accept))[2], __a2 == '\0')	      \
+	       ? __strpbrk_c2 (s, __a0, __a1)				      \
+	       : (((const char *) (accept))[3] == '\0'			      \
+		  ? __strpbrk_c3 (s, __a0, __a1, __a2)			      \
+		  : strpbrk (s, accept)))))				      \
+      : strpbrk (s, accept)); })
+#  endif
+# endif
+
+__STRING_INLINE char *__strpbrk_c2 (const char *__s, int __accept1,
+				    int __accept2);
+__STRING_INLINE char *
+__strpbrk_c2 (const char *__s, int __accept1, int __accept2)
+{
+  /* Please note that __accept1 and __accept2 never can be '\0'.  */
+  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
+    ++__s;
+  return *__s == '\0' ? NULL : (char *) (size_t) __s;
+}
+
+__STRING_INLINE char *__strpbrk_c3 (const char *__s, int __accept1,
+				    int __accept2, int __accept3);
+__STRING_INLINE char *
+__strpbrk_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
+{
+  /* Please note that __accept1 to __accept3 never can be '\0'.  */
+  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
+	 && *__s != __accept3)
+    ++__s;
+  return *__s == '\0' ? NULL : (char *) (size_t) __s;
+}
+#endif
+
+
+/* Find the first occurrence of NEEDLE in HAYSTACK.  Newer gcc versions
+   do this itself.  */
+#if !defined _HAVE_STRING_ARCH_strstr && !__GNUC_PREREQ (2, 97)
+# define strstr(haystack, needle) \
+  (__extension__ (__builtin_constant_p (needle) && __string2_1bptr_p (needle) \
+		  ? (((const char *) (needle))[0] == '\0'		      \
+		     ? (char *) (size_t) (haystack)			      \
+		     : (((const char *) (needle))[1] == '\0'		      \
+			? strchr (haystack,				      \
+				  ((const char *) (needle))[0]) 	      \
+			: strstr (haystack, needle)))			      \
+		  : strstr (haystack, needle)))
+#endif
+
+
+#if !defined _HAVE_STRING_ARCH_strtok_r || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strtok_r
+#  define __strtok_r(s, sep, nextp) \
+  (__extension__ (__builtin_constant_p (sep) && __string2_1bptr_p (sep)	      \
+		  && ((const char *) (sep))[0] != '\0'			      \
+		  && ((const char *) (sep))[1] == '\0'			      \
+		  ? __strtok_r_1c (s, ((const char *) (sep))[0], nextp)       \
+		  : __strtok_r (s, sep, nextp)))
+# endif
+
+__STRING_INLINE char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
+__STRING_INLINE char *
+__strtok_r_1c (char *__s, char __sep, char **__nextp)
+{
+  char *__result;
+  if (__s == NULL)
+    __s = *__nextp;
+  while (*__s == __sep)
+    ++__s;
+  __result = NULL;
+  if (*__s != '\0')
+    {
+      __result = __s++;
+      while (*__s != '\0')
+	if (*__s++ == __sep)
+	  {
+	    __s[-1] = '\0';
+	    break;
+	  }
+    }
+  *__nextp = __s;
+  return __result;
+}
+# if defined __USE_POSIX || defined __USE_MISC
+#  define strtok_r(s, sep, nextp) __strtok_r (s, sep, nextp)
+# endif
+#endif
+
+
+#if !defined _HAVE_STRING_ARCH_strsep || defined _FORCE_INLINES
+# ifndef _HAVE_STRING_ARCH_strsep
+
+extern char *__strsep_g (char **__stringp, const char *__delim);
+#  define __strsep(s, reject) \
+  __extension__								      \
+  ({ char __r0, __r1, __r2;						      \
+     (__builtin_constant_p (reject) && __string2_1bptr_p (reject)	      \
+      && (__r0 = ((const char *) (reject))[0],				      \
+	  ((const char *) (reject))[0] != '\0')				      \
+      ? ((__r1 = ((const char *) (reject))[1],				      \
+	 ((const char *) (reject))[1] == '\0')				      \
+	 ? __strsep_1c (s, __r0)					      \
+	 : ((__r2 = ((const char *) (reject))[2], __r2 == '\0')		      \
+	    ? __strsep_2c (s, __r0, __r1)				      \
+	    : (((const char *) (reject))[3] == '\0'			      \
+	       ? __strsep_3c (s, __r0, __r1, __r2)			      \
+	       : __strsep_g (s, reject))))				      \
+      : __strsep_g (s, reject)); })
+# endif
+
+__STRING_INLINE char *__strsep_1c (char **__s, char __reject);
+__STRING_INLINE char *
+__strsep_1c (char **__s, char __reject)
+{
+  char *__retval = *__s;
+  if (__retval != NULL && (*__s = strchr (__retval, __reject)) != NULL)
+    *(*__s)++ = '\0';
+  return __retval;
+}
+
+__STRING_INLINE char *__strsep_2c (char **__s, char __reject1, char __reject2);
+__STRING_INLINE char *
+__strsep_2c (char **__s, char __reject1, char __reject2)
+{
+  char *__retval = *__s;
+  if (__retval != NULL)
+    {
+      char *__cp = __retval;
+      while (1)
+	{
+	  if (*__cp == '\0')
+	    {
+	      __cp = NULL;
+	  break;
+	    }
+	  if (*__cp == __reject1 || *__cp == __reject2)
+	    {
+	      *__cp++ = '\0';
+	      break;
+	    }
+	  ++__cp;
+	}
+      *__s = __cp;
+    }
+  return __retval;
+}
+
+__STRING_INLINE char *__strsep_3c (char **__s, char __reject1, char __reject2,
+				   char __reject3);
+__STRING_INLINE char *
+__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
+{
+  char *__retval = *__s;
+  if (__retval != NULL)
+    {
+      char *__cp = __retval;
+      while (1)
+	{
+	  if (*__cp == '\0')
+	    {
+	      __cp = NULL;
+	  break;
+	    }
+	  if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
+	    {
+	      *__cp++ = '\0';
+	      break;
+	    }
+	  ++__cp;
+	}
+      *__s = __cp;
+    }
+  return __retval;
+}
+# ifdef __USE_BSD
+#  define strsep(s, reject) __strsep (s, reject)
+# endif
+#endif
+
+/* We need the memory allocation functions for inline strdup().
+   Referring to stdlib.h (even minimally) is not allowed
+   in any of the tight standards compliant modes.  */
+#ifdef __USE_MISC
+
+# if !defined _HAVE_STRING_ARCH_strdup || !defined _HAVE_STRING_ARCH_strndup
+#  define __need_malloc_and_calloc
+#  include <stdlib.h>
+# endif
+
+# ifndef _HAVE_STRING_ARCH_strdup
+
+extern char *__strdup (const char *__string) __THROW __attribute_malloc__;
+#  define __strdup(s) \
+  (__extension__ (__builtin_constant_p (s) && __string2_1bptr_p (s)	      \
+		  ? (((const char *) (s))[0] == '\0'			      \
+		     ? (char *) calloc ((size_t) 1, (size_t) 1)		      \
+		     : ({ size_t __len = strlen (s) + 1;		      \
+			  char *__retval = (char *) malloc (__len);	      \
+			  if (__retval != NULL)				      \
+			    __retval = (char *) memcpy (__retval, s, __len);  \
+			  __retval; }))					      \
+		  : __strdup (s)))
+
+#  if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+#   define strdup(s) __strdup (s)
+#  endif
+# endif
+
+# ifndef _HAVE_STRING_ARCH_strndup
+
+extern char *__strndup (const char *__string, size_t __n)
+     __THROW __attribute_malloc__;
+#  define __strndup(s, n) \
+  (__extension__ (__builtin_constant_p (s) && __string2_1bptr_p (s)	      \
+		  ? (((const char *) (s))[0] == '\0'			      \
+		     ? (char *) calloc ((size_t) 1, (size_t) 1)		      \
+		     : ({ size_t __len = strlen (s) + 1;		      \
+			  size_t __n = (n);				      \
+			  char *__retval;				      \
+			  if (__n < __len)				      \
+			    __len = __n + 1;				      \
+			  __retval = (char *) malloc (__len);		      \
+			  if (__retval != NULL)				      \
+			    {						      \
+			      __retval[__len - 1] = '\0';		      \
+			      __retval = (char *) memcpy (__retval, s,	      \
+							  __len - 1);	      \
+			    }						      \
+			  __retval; }))					      \
+		  : __strndup (s, n)))
+
+#  ifdef __USE_GNU
+#   define strndup(s, n) __strndup (s, n)
+#  endif
+# endif
+
+#endif /* Use misc. or use GNU.  */
+
+#ifndef _FORCE_INLINES
+# undef __STRING_INLINE
+#endif
+
+#endif /* No string inlines.  */
diff --git a/include/bits/string3.h b/include/bits/string3.h
new file mode 100644
index 0000000..acd2577
--- /dev/null
+++ b/include/bits/string3.h
@@ -0,0 +1,151 @@
+/* Copyright (C) 2004-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STRING_H
+# error "Never use <bits/string3.h> directly; include <string.h> instead."
+#endif
+
+__warndecl (__warn_memset_zero_len,
+	    "memset used with constant zero length parameter; this could be due to transposed parameters");
+
+#ifndef __cplusplus
+/* XXX This is temporarily.  We should not redefine any of the symbols
+   and instead integrate the error checking into the original
+   definitions.  */
+# undef memcpy
+# undef memmove
+# undef memset
+# undef strcat
+# undef strcpy
+# undef strncat
+# undef strncpy
+# ifdef __USE_GNU
+#  undef mempcpy
+#  undef stpcpy
+# endif
+# ifdef __USE_BSD
+#  undef bcopy
+#  undef bzero
+# endif
+#endif
+
+
+__fortify_function void *
+__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
+	       size_t __len))
+{
+  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
+}
+
+__fortify_function void *
+__NTH (memmove (void *__dest, const void *__src, size_t __len))
+{
+  return __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
+}
+
+#ifdef __USE_GNU
+__fortify_function void *
+__NTH (mempcpy (void *__restrict __dest, const void *__restrict __src,
+		size_t __len))
+{
+  return __builtin___mempcpy_chk (__dest, __src, __len, __bos0 (__dest));
+}
+#endif
+
+
+/* The first two tests here help to catch a somewhat common problem
+   where the second and third parameter are transposed.  This is
+   especially problematic if the intended fill value is zero.  In this
+   case no work is done at all.  We detect these problems by referring
+   non-existing functions.  */
+__fortify_function void *
+__NTH (memset (void *__dest, int __ch, size_t __len))
+{
+  if (__builtin_constant_p (__len) && __len == 0
+      && (!__builtin_constant_p (__ch) || __ch != 0))
+    {
+      __warn_memset_zero_len ();
+      return __dest;
+    }
+  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
+}
+
+#ifdef __USE_BSD
+__fortify_function void
+__NTH (bcopy (const void *__src, void *__dest, size_t __len))
+{
+  (void) __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
+}
+
+__fortify_function void
+__NTH (bzero (void *__dest, size_t __len))
+{
+  (void) __builtin___memset_chk (__dest, '\0', __len, __bos0 (__dest));
+}
+#endif
+
+__fortify_function char *
+__NTH (strcpy (char *__restrict __dest, const char *__restrict __src))
+{
+  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
+}
+
+#ifdef __USE_GNU
+__fortify_function char *
+__NTH (stpcpy (char *__restrict __dest, const char *__restrict __src))
+{
+  return __builtin___stpcpy_chk (__dest, __src, __bos (__dest));
+}
+#endif
+
+
+__fortify_function char *
+__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
+		size_t __len))
+{
+  return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
+}
+
+// XXX We have no corresponding builtin yet.
+extern char *__stpncpy_chk (char *__dest, const char *__src, size_t __n,
+			    size_t __destlen) __THROW;
+extern char *__REDIRECT_NTH (__stpncpy_alias, (char *__dest, const char *__src,
+					       size_t __n), stpncpy);
+
+__fortify_function char *
+__NTH (stpncpy (char *__dest, const char *__src, size_t __n))
+{
+  if (__bos (__dest) != (size_t) -1
+      && (!__builtin_constant_p (__n) || __n <= __bos (__dest)))
+    return __stpncpy_chk (__dest, __src, __n, __bos (__dest));
+  return __stpncpy_alias (__dest, __src, __n);
+}
+
+
+__fortify_function char *
+__NTH (strcat (char *__restrict __dest, const char *__restrict __src))
+{
+  return __builtin___strcat_chk (__dest, __src, __bos (__dest));
+}
+
+
+__fortify_function char *
+__NTH (strncat (char *__restrict __dest, const char *__restrict __src,
+		size_t __len))
+{
+  return __builtin___strncat_chk (__dest, __src, __len, __bos (__dest));
+}
diff --git a/include/bits/stropts.h b/include/bits/stropts.h
new file mode 100644
index 0000000..246152c
--- /dev/null
+++ b/include/bits/stropts.h
@@ -0,0 +1,230 @@
+/* Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STROPTS_H
+# error "Never include <bits/stropts.h> directly; use <stropts.h> instead."
+#endif
+
+#ifndef _BITS_STROPTS_H
+#define _BITS_STROPTS_H	1
+
+#include <bits/types.h>
+
+/* Macros used as `request' argument to `ioctl'.  */
+#define __SID		('S' << 8)
+
+#define I_NREAD	    (__SID | 1)	/* Counts the number of data bytes in the data
+				   block in the first message.  */
+#define I_PUSH	    (__SID | 2)	/* Push STREAMS module onto top of the current
+				   STREAM, just below the STREAM head.  */
+#define I_POP	    (__SID | 3)	/* Remove STREAMS module from just below the
+				   STREAM head.  */
+#define I_LOOK	    (__SID | 4)	/* Retrieve the name of the module just below
+				   the STREAM head and place it in a character
+				   string.  */
+#define I_FLUSH	    (__SID | 5)	/* Flush all input and/or output.  */
+#define I_SRDOPT    (__SID | 6)	/* Sets the read mode.  */
+#define I_GRDOPT    (__SID | 7)	/* Returns the current read mode setting.  */
+#define I_STR	    (__SID | 8)	/* Construct an internal STREAMS `ioctl'
+				   message and send that message downstream. */
+#define I_SETSIG    (__SID | 9)	/* Inform the STREAM head that the process
+				   wants the SIGPOLL signal issued.  */
+#define I_GETSIG    (__SID |10) /* Return the events for which the calling
+				   process is currently registered to be sent
+				   a SIGPOLL signal.  */
+#define I_FIND	    (__SID |11) /* Compares the names of all modules currently
+				   present in the STREAM to the name pointed to
+				   by `arg'.  */
+#define I_LINK	    (__SID |12) /* Connect two STREAMs.  */
+#define I_UNLINK    (__SID |13) /* Disconnects the two STREAMs.  */
+#define I_PEEK	    (__SID |15) /* Allows a process to retrieve the information
+				   in the first message on the STREAM head read
+				   queue without taking the message off the
+				   queue.  */
+#define I_FDINSERT  (__SID |16) /* Create a message from the specified
+				   buffer(s), adds information about another
+				   STREAM, and send the message downstream.  */
+#define I_SENDFD    (__SID |17) /* Requests the STREAM associated with `fildes'
+				   to send a message, containing a file
+				   pointer, to the STREAM head at the other end
+				   of a STREAMS pipe.  */
+#define I_RECVFD    (__SID |14) /* Non-EFT definition.  */
+#define I_SWROPT    (__SID |19) /* Set the write mode.  */
+#define I_GWROPT    (__SID |20) /* Return the current write mode setting.  */
+#define I_LIST	    (__SID |21) /* List all the module names on the STREAM, up
+				   to and including the topmost driver name. */
+#define I_PLINK	    (__SID |22) /* Connect two STREAMs with a persistent
+				   link.  */
+#define I_PUNLINK   (__SID |23) /* Disconnect the two STREAMs that were
+				   connected with a persistent link.  */
+#define I_FLUSHBAND (__SID |28) /* Flush only band specified.  */
+#define I_CKBAND    (__SID |29) /* Check if the message of a given priority
+				   band exists on the STREAM head read
+				   queue.  */
+#define I_GETBAND   (__SID |30) /* Return the priority band of the first
+				   message on the STREAM head read queue.  */
+#define I_ATMARK    (__SID |31) /* See if the current message on the STREAM
+				   head read queue is "marked" by some module
+				   downstream.  */
+#define I_SETCLTIME (__SID |32) /* Set the time the STREAM head will delay when
+				   a STREAM is closing and there is data on
+				   the write queues.  */
+#define I_GETCLTIME (__SID |33) /* Get current value for closing timeout.  */
+#define I_CANPUT    (__SID |34) /* Check if a certain band is writable.  */
+
+
+/* Used in `I_LOOK' request.  */
+#define FMNAMESZ	8	/* compatibility w/UnixWare/Solaris.  */
+
+/* Flush options.  */
+#define FLUSHR		0x01	/* Flush read queues.  */
+#define FLUSHW		0x02	/* Flush write queues.  */
+#define FLUSHRW		0x03	/* Flush read and write queues.  */
+#ifdef __USE_GNU
+# define FLUSHBAND	0x04	/* Flush only specified band.  */
+#endif
+
+/* Possible arguments for `I_SETSIG'.  */
+#define S_INPUT		0x0001	/* A message, other than a high-priority
+				   message, has arrived.  */
+#define S_HIPRI		0x0002	/* A high-priority message is present.  */
+#define S_OUTPUT	0x0004	/* The write queue for normal data is no longer
+				   full.  */
+#define S_MSG		0x0008	/* A STREAMS signal message that contains the
+				   SIGPOLL signal reaches the front of the
+				   STREAM head read queue.  */
+#define S_ERROR		0x0010	/* Notification of an error condition.  */
+#define S_HANGUP	0x0020	/* Notification of a hangup.  */
+#define S_RDNORM	0x0040	/* A normal message has arrived.  */
+#define S_WRNORM	S_OUTPUT
+#define S_RDBAND	0x0080	/* A message with a non-zero priority has
+				   arrived.  */
+#define S_WRBAND	0x0100	/* The write queue for a non-zero priority
+				   band is no longer full.  */
+#define S_BANDURG	0x0200	/* When used in conjunction with S_RDBAND,
+				   SIGURG is generated instead of SIGPOLL when
+				   a priority message reaches the front of the
+				   STREAM head read queue.  */
+
+/* Option for `I_PEEK'.  */
+#define RS_HIPRI	0x01	/* Only look for high-priority messages.  */
+
+/* Options for `I_SRDOPT'.  */
+#define RNORM		0x0000	/* Byte-STREAM mode, the default.  */
+#define RMSGD		0x0001	/* Message-discard mode.   */
+#define RMSGN		0x0002	/* Message-nondiscard mode.   */
+#define RPROTDAT	0x0004	/* Deliver the control part of a message as
+				   data.  */
+#define RPROTDIS	0x0008	/* Discard the control part of a message,
+				   delivering any data part.  */
+#define RPROTNORM	0x0010	/* Fail `read' with EBADMSG if a message
+				   containing a control part is at the front
+				   of the STREAM head read queue.  */
+#ifdef __USE_GNU
+# define RPROTMASK	0x001C	/* The RPROT bits */
+#endif
+
+/* Possible mode for `I_SWROPT'.  */
+#define SNDZERO		0x001	/* Send a zero-length message downstream when a
+				   `write' of 0 bytes occurs.  */
+#ifdef __USE_GNU
+# define SNDPIPE	0x002	/* Send SIGPIPE on write and putmsg if
+				   sd_werror is set.  */
+#endif
+
+/* Arguments for `I_ATMARK'.  */
+#define ANYMARK		0x01	/* Check if the message is marked.  */
+#define LASTMARK	0x02	/* Check if the message is the last one marked
+				   on the queue.  */
+
+/* Argument for `I_UNLINK'.  */
+#ifdef __USE_GNU
+# define MUXID_ALL	(-1)	/* Unlink all STREAMs linked to the STREAM
+				   associated with `fildes'.  */
+#endif
+
+
+/* Macros for `getmsg', `getpmsg', `putmsg' and `putpmsg'.  */
+#define MSG_HIPRI	0x01	/* Send/receive high priority message.  */
+#define MSG_ANY		0x02	/* Receive any message.  */
+#define MSG_BAND	0x04	/* Receive message from specified band.  */
+
+/* Values returned by getmsg and getpmsg */
+#define MORECTL		1	/* More control information is left in
+				   message.  */
+#define MOREDATA	2	/* More data is left in message.  */
+
+
+/* Structure used for the I_FLUSHBAND ioctl on streams.  */
+struct bandinfo
+  {
+    unsigned char bi_pri;
+    int bi_flag;
+  };
+
+struct strbuf
+  {
+    int maxlen;		/* Maximum buffer length.  */
+    int len;		/* Length of data.  */
+    char *buf;		/* Pointer to buffer.  */
+  };
+
+struct strpeek
+  {
+    struct strbuf ctlbuf;
+    struct strbuf databuf;
+    t_uscalar_t flags;			/* UnixWare/Solaris compatibility.  */
+  };
+
+struct strfdinsert
+  {
+    struct strbuf ctlbuf;
+    struct strbuf databuf;
+    t_uscalar_t flags;			/* UnixWare/Solaris compatibility.  */
+    int fildes;
+    int offset;
+  };
+
+struct strioctl
+  {
+    int ic_cmd;
+    int ic_timout;
+    int ic_len;
+    char *ic_dp;
+  };
+
+struct strrecvfd
+  {
+    int fd;
+    uid_t uid;
+    gid_t gid;
+    char __fill[8];			/* UnixWare/Solaris compatibility */
+  };
+
+
+struct str_mlist
+  {
+    char l_name[FMNAMESZ + 1];
+  };
+
+struct str_list
+  {
+    int sl_nmods;
+    struct str_mlist *sl_modlist;
+  };
+
+#endif /* bits/stropts.h */
diff --git a/include/bits/sys_errlist.h b/include/bits/sys_errlist.h
new file mode 100644
index 0000000..6610c93
--- /dev/null
+++ b/include/bits/sys_errlist.h
@@ -0,0 +1,23 @@
+/* Declare sys_errlist and sys_nerr, or don't.  Don't version.
+   Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STDIO_H
+# error "Never include <bits/sys_errlist.h> directly; use <stdio.h> instead."
+#endif
+
+/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */
diff --git a/include/bits/syslog-ldbl.h b/include/bits/syslog-ldbl.h
new file mode 100644
index 0000000..989978d
--- /dev/null
+++ b/include/bits/syslog-ldbl.h
@@ -0,0 +1,35 @@
+/* -mlong-double-64 compatibility mode for syslog functions.
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SYSLOG_H
+# error "Never include <bits/syslog-ldbl.h> directly; use <sys/syslog.h> instead."
+#endif
+
+__LDBL_REDIR_DECL (syslog)
+
+#ifdef __USE_BSD
+__LDBL_REDIR_DECL (vsyslog)
+#endif
+
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+__LDBL_REDIR_DECL (__syslog_chk)
+
+# ifdef __USE_BSD
+__LDBL_REDIR_DECL (__vsyslog_chk)
+# endif
+#endif
diff --git a/include/bits/syslog-path.h b/include/bits/syslog-path.h
new file mode 100644
index 0000000..ae83b2b
--- /dev/null
+++ b/include/bits/syslog-path.h
@@ -0,0 +1,28 @@
+/* <bits/syslog-path.h> -- _PATH_LOG definition
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SYSLOG_H
+# error "Never include this file directly.  Use <sys/syslog.h> instead"
+#endif
+
+#ifndef _BITS_SYSLOG_PATH_H
+#define _BITS_SYSLOG_PATH_H 1
+
+#define	_PATH_LOG	"/dev/log"
+
+#endif /* bits/syslog-path.h */
diff --git a/include/bits/syslog.h b/include/bits/syslog.h
new file mode 100644
index 0000000..a5c693a
--- /dev/null
+++ b/include/bits/syslog.h
@@ -0,0 +1,49 @@
+/* Checking macros for syslog functions.
+   Copyright (C) 2005-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SYSLOG_H
+# error "Never include <bits/syslog.h> directly; use <sys/syslog.h> instead."
+#endif
+
+
+extern void __syslog_chk (int __pri, int __flag, const char *__fmt, ...)
+     __attribute__ ((__format__ (__printf__, 3, 4)));
+
+#ifdef __va_arg_pack
+__fortify_function void
+syslog (int __pri, const char *__fmt, ...)
+{
+  __syslog_chk (__pri, __USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
+}
+#elif !defined __cplusplus
+# define syslog(pri, ...) \
+  __syslog_chk (pri, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+#endif
+
+
+#ifdef __USE_BSD
+extern void __vsyslog_chk (int __pri, int __flag, const char *__fmt,
+			   __gnuc_va_list __ap)
+     __attribute__ ((__format__ (__printf__, 3, 0)));
+
+__fortify_function void
+vsyslog (int __pri, const char *__fmt, __gnuc_va_list __ap)
+{
+  __vsyslog_chk (__pri,  __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
+}
+#endif
diff --git a/include/bits/termios.h b/include/bits/termios.h
new file mode 100644
index 0000000..9fd694a
--- /dev/null
+++ b/include/bits/termios.h
@@ -0,0 +1,341 @@
+/* termios type and macro definitions.  4.4 BSD/generic GNU version.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios.h> directly; use <termios.h> instead."
+#endif
+
+/* These macros are also defined in some <bits/ioctls.h> files (with
+   numerically identical values), but this serves to shut up cpp's
+   complaining. */
+#if defined __USE_MISC || defined __USE_XOPEN
+
+# ifdef NL0
+#  undef NL0
+# endif
+# ifdef NL1
+#  undef NL1
+# endif
+# ifdef TAB0
+#  undef TAB0
+# endif
+# ifdef TAB1
+#  undef TAB1
+# endif
+# ifdef TAB2
+#  undef TAB2
+# endif
+# ifdef CR0
+#  undef CR0
+# endif
+# ifdef CR1
+#  undef CR1
+# endif
+# ifdef CR2
+#  undef CR2
+# endif
+# ifdef CR3
+#  undef CR3
+# endif
+# ifdef FF0
+#  undef FF0
+# endif
+# ifdef FF1
+#  undef FF1
+# endif
+# ifdef BS0
+#  undef BS0
+# endif
+# ifdef BS1
+#  undef BS1
+# endif
+
+#endif /* __USE_MISC || __USE_XOPEN */
+
+#ifdef __USE_BSD
+
+# ifdef MDMBUF
+#  undef MDMBUF
+# endif
+# ifdef FLUSHO
+#  undef FLUSHO
+# endif
+# ifdef PENDIN
+#  undef PENDIN
+# endif
+
+#endif /* __USE_BSD */
+
+#ifdef ECHO
+# undef ECHO
+#endif
+#ifdef TOSTOP
+# undef TOSTOP
+#endif
+#ifdef NOFLSH
+# undef NOFLSH
+#endif
+
+
+/* These definitions match those used by the 4.4 BSD kernel.
+   If the operating system has termios system calls or ioctls that
+   correctly implement the POSIX.1 behavior, there should be a
+   system-dependent version of this file that defines `struct termios',
+   `tcflag_t', `cc_t', `speed_t' and the `TC*' constants appropriately.  */
+
+/* Type of terminal control flag masks.  */
+typedef unsigned long int tcflag_t;
+
+/* Type of control characters.  */
+typedef unsigned char cc_t;
+
+/* Type of baud rate specifiers.  */
+typedef long int speed_t;
+
+/* Terminal control structure.  */
+struct termios
+{
+  /* Input modes.  */
+  tcflag_t c_iflag;
+#define	IGNBRK	(1 << 0)	/* Ignore break condition.  */
+#define	BRKINT	(1 << 1)	/* Signal interrupt on break.  */
+#define	IGNPAR	(1 << 2)	/* Ignore characters with parity errors.  */
+#define	PARMRK	(1 << 3)	/* Mark parity and framing errors.  */
+#define	INPCK	(1 << 4)	/* Enable input parity check.  */
+#define	ISTRIP	(1 << 5)	/* Strip 8th bit off characters.  */
+#define	INLCR	(1 << 6)	/* Map NL to CR on input.  */
+#define	IGNCR	(1 << 7)	/* Ignore CR.  */
+#define	ICRNL	(1 << 8)	/* Map CR to NL on input.  */
+#define	IXON	(1 << 9)	/* Enable start/stop output control.  */
+#define	IXOFF	(1 << 10)	/* Enable start/stop input control.  */
+#if defined __USE_BSD || defined __USE_UNIX98
+# define IXANY	(1 << 11)	/* Any character will restart after stop.  */
+#endif
+#ifdef	__USE_BSD
+# define IMAXBEL (1 << 13)	/* Ring bell when input queue is full.  */
+#endif
+#ifdef __USE_GNU
+# define IUCLC	(1 << 14)	/* Translate upper case input to lower case. */
+#endif
+
+  /* Output modes.  */
+  tcflag_t c_oflag;
+#define	OPOST	(1 << 0)	/* Perform output processing.  */
+#if defined __USE_BSD || defined __USE_XOPEN
+# define ONLCR	(1 << 1)	/* Map NL to CR-NL on output.  */
+#endif
+#ifdef	__USE_BSD
+# define OXTABS	TAB3		/* Expand tabs to spaces.  */
+# define ONOEOT	(1 << 3)	/* Discard EOT (^D) on output.  */
+#endif
+#if defined __USE_BSD || defined __USE_XOPEN
+# define OCRNL	(1 << 4)	/* Map CR to NL.  */
+# define ONOCR	(1 << 5)	/* Discard CR's when on column 0.  */
+# define ONLRET	(1 << 6)	/* Move to column 0 on NL.  */
+#endif
+#if defined __USE_MISC || defined __USE_XOPEN
+# define NLDLY	(3 << 8)	/* NL delay.  */
+# define NL0	(0 << 8)	/* NL type 0.  */
+# define NL1	(1 << 8)	/* NL type 1.  */
+# define TABDLY	(3 << 10)	/* TAB delay.  */
+# define TAB0	(0 << 10)	/* TAB delay type 0.  */
+# define TAB1	(1 << 10)	/* TAB delay type 1.  */
+# define TAB2	(2 << 10)	/* TAB delay type 2.  */
+# define TAB3	(1 << 2)	/* Expand tabs to spaces.  */
+# define CRDLY	(3 << 12)	/* CR delay.  */
+# define CR0	(0 << 12)	/* CR delay type 0.  */
+# define CR1	(1 << 12)	/* CR delay type 1.  */
+# define CR2	(2 << 12)	/* CR delay type 2.  */
+# define CR3	(3 << 12)	/* CR delay type 3.  */
+# define FFDLY	(1 << 14)	/* FF delay.  */
+# define FF0	(0 << 14)	/* FF delay type 0.  */
+# define FF1	(1 << 14)	/* FF delay type 1.  */
+# define BSDLY	(1 << 15)	/* BS delay.  */
+# define BS0	(0 << 15)	/* BS delay type 0.  */
+# define BS1	(1 << 15)	/* BS delay type 1.  */
+# define VTDLY	(1 << 16)	/* VT delay.  */
+# define VT0	(0 << 16)	/* VT delay type 0.  */
+# define VT1	(1 << 16)	/* VT delay type 1.  */
+#endif /* __USE_MISC || __USE_XOPEN */
+#ifdef __USE_GNU
+# define OLCUC	(1 << 17)	/* Translate lower case output to upper case */
+#endif
+#ifdef __USE_XOPEN
+# define OFILL	(1 << 18)	/* Send fill characters for delays.  */
+#endif
+
+  /* Control modes.  */
+  tcflag_t c_cflag;
+#ifdef	__USE_BSD
+# define CIGNORE	(1 << 0)	/* Ignore these control flags.  */
+#endif
+#define	CSIZE	(CS5|CS6|CS7|CS8)	/* Number of bits per byte (mask).  */
+#define	CS5	0		/* 5 bits per byte.  */
+#define	CS6	(1 << 8)	/* 6 bits per byte.  */
+#define	CS7	(1 << 9)	/* 7 bits per byte.  */
+#define	CS8	(CS6|CS7)	/* 8 bits per byte.  */
+#define	CSTOPB	(1 << 10)	/* Two stop bits instead of one.  */
+#define	CREAD	(1 << 11)	/* Enable receiver.  */
+#define	PARENB	(1 << 12)	/* Parity enable.  */
+#define	PARODD	(1 << 13)	/* Odd parity instead of even.  */
+#define	HUPCL	(1 << 14)	/* Hang up on last close.  */
+#define	CLOCAL	(1 << 15)	/* Ignore modem status lines.  */
+#ifdef	__USE_BSD
+# define CRTSCTS	(1 << 16)	/* RTS/CTS flow control.  */
+# define CRTS_IFLOW	CRTSCTS		/* Compatibility.  */
+# define CCTS_OFLOW	CRTSCTS		/* Compatibility.  */
+# define CDTRCTS	(1 << 17)	/* DTR/CTS flow control.  */
+# define MDMBUF		(1 << 20)	/* DTR/DCD flow control.  */
+# define CHWFLOW	(MDMBUF|CRTSCTS|CDTRCTS) /* All types of flow control.  */
+#endif
+
+  /* Local modes.  */
+  tcflag_t c_lflag;
+#ifdef	__USE_BSD
+# define ECHOKE	(1 << 0)	/* Visual erase for KILL.  */
+#endif
+#define	_ECHOE	(1 << 1)	/* Visual erase for ERASE.  */
+#define	ECHOE	_ECHOE
+#define	_ECHOK	(1 << 2)	/* Echo NL after KILL.  */
+#define	ECHOK	_ECHOK
+#define	_ECHO	(1 << 3)	/* Enable echo.  */
+#define	ECHO	_ECHO
+#define	_ECHONL	(1 << 4)	/* Echo NL even if ECHO is off.  */
+#define	ECHONL	_ECHONL
+#ifdef	__USE_BSD
+# define ECHOPRT	(1 << 5)	/* Hardcopy visual erase.  */
+# define ECHOCTL	(1 << 6)	/* Echo control characters as ^X.  */
+#endif
+#define	_ISIG	(1 << 7)	/* Enable signals.  */
+#define	ISIG	_ISIG
+#define	_ICANON	(1 << 8)	/* Do erase and kill processing.  */
+#define	ICANON	_ICANON
+#ifdef	__USE_BSD
+# define ALTWERASE (1 << 9)	/* Alternate WERASE algorithm.  */
+#endif
+#define	_IEXTEN	(1 << 10)	/* Enable DISCARD and LNEXT.  */
+#define	IEXTEN	_IEXTEN
+#define	EXTPROC	(1 << 11)	/* External processing.  */
+#define	_TOSTOP	(1 << 22)	/* Send SIGTTOU for background output.  */
+#define	TOSTOP	_TOSTOP
+#ifdef	__USE_BSD
+# define FLUSHO	(1 << 23)	/* Output being flushed (state).  */
+# define NOKERNINFO (1 << 25)	/* Disable VSTATUS.  */
+# define PENDIN	(1 << 29)	/* Retype pending input (state).  */
+#endif
+#define	_NOFLSH	(1 << 31)	/* Disable flush after interrupt.  */
+#define	NOFLSH	_NOFLSH
+
+  /* Control characters.  */
+#define	VEOF	0		/* End-of-file character [ICANON].  */
+#define	VEOL	1		/* End-of-line character [ICANON].  */
+#ifdef	__USE_BSD
+# define VEOL2	2		/* Second EOL character [ICANON].  */
+#endif
+#define	VERASE	3		/* Erase character [ICANON].  */
+#ifdef	__USE_BSD
+# define VWERASE	4		/* Word-erase character [ICANON].  */
+#endif
+#define	VKILL	5		/* Kill-line character [ICANON].  */
+#ifdef	__USE_BSD
+# define VREPRINT 6		/* Reprint-line character [ICANON].  */
+#endif
+#define	VINTR	8		/* Interrupt character [ISIG].  */
+#define	VQUIT	9		/* Quit character [ISIG].  */
+#define	VSUSP	10		/* Suspend character [ISIG].  */
+#ifdef	__USE_BSD
+# define VDSUSP	11		/* Delayed suspend character [ISIG].  */
+#endif
+#define	VSTART	12		/* Start (X-ON) character [IXON, IXOFF].  */
+#define	VSTOP	13		/* Stop (X-OFF) character [IXON, IXOFF].  */
+#ifdef	__USE_BSD
+# define VLNEXT	14		/* Literal-next character [IEXTEN].  */
+# define VDISCARD 15		/* Discard character [IEXTEN].  */
+#endif
+#define	VMIN	16		/* Minimum number of bytes read at once [!ICANON].  */
+#define	VTIME	17		/* Time-out value (tenths of a second) [!ICANON].  */
+#ifdef	__USE_BSD
+# define VSTATUS	18		/* Status character [ICANON].  */
+#endif
+#define	NCCS	20		/* Value duplicated in <hurd/tioctl.defs>.  */
+  cc_t c_cc[NCCS];
+
+  /* Input and output baud rates.  */
+  speed_t __ispeed, __ospeed;
+#define	B0	0		/* Hang up.  */
+#define	B50	50		/* 50 baud.  */
+#define	B75	75		/* 75 baud.  */
+#define	B110	110		/* 110 baud.  */
+#define	B134	134		/* 134.5 baud.  */
+#define	B150	150		/* 150 baud.  */
+#define	B200	200		/* 200 baud.  */
+#define	B300	300		/* 300 baud.  */
+#define	B600	600		/* 600 baud.  */
+#define	B1200	1200		/* 1200 baud.  */
+#define	B1800	1800		/* 1800 baud.  */
+#define	B2400	2400		/* 2400 baud.  */
+#define	B4800	4800		/* 4800 baud.  */
+#define	B9600	9600		/* 9600 baud.  */
+#define	B7200	7200		/* 7200 baud.  */
+#define	B14400	14400		/* 14400 baud.  */
+#define	B19200	19200		/* 19200 baud.  */
+#define	B28800	28800		/* 28800 baud.  */
+#define	B38400	38400		/* 38400 baud.  */
+#ifdef	__USE_MISC
+# define EXTA	19200
+# define EXTB	38400
+#endif
+#define	B57600	57600
+#define	B76800	76800
+#define	B115200	115200
+#define	B230400	230400
+#define	B460800	460800
+#define	B500000	500000
+#define	B576000	576000
+#define	B921600	921600
+#define	B1000000 1000000
+#define	B1152000 1152000
+#define	B1500000 1500000
+#define	B2000000 2000000
+#define	B2500000 2500000
+#define	B3000000 3000000
+#define	B3500000 3500000
+#define	B4000000 4000000
+};
+
+#define _IOT_termios /* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (tcflag_t), 4, _IOTS (cc_t), NCCS, _IOTS (speed_t), 2)
+
+/* Values for the OPTIONAL_ACTIONS argument to `tcsetattr'.  */
+#define	TCSANOW		0	/* Change immediately.  */
+#define	TCSADRAIN	1	/* Change when pending output is written.  */
+#define	TCSAFLUSH	2	/* Flush pending input before changing.  */
+#ifdef	__USE_BSD
+# define TCSASOFT	0x10	/* Flag: Don't alter hardware state.  */
+#endif
+
+/* Values for the QUEUE_SELECTOR argument to `tcflush'.  */
+#define	TCIFLUSH	1	/* Discard data received but not yet read.  */
+#define	TCOFLUSH	2	/* Discard data written but not yet sent.  */
+#define	TCIOFLUSH	3	/* Discard all pending data.  */
+
+/* Values for the ACTION argument to `tcflow'.  */
+#define	TCOOFF	1		/* Suspend output.  */
+#define	TCOON	2		/* Restart suspended output.  */
+#define	TCIOFF	3		/* Send a STOP character.  */
+#define	TCION	4		/* Send a START character.  */
diff --git a/include/bits/thread-attr.h b/include/bits/thread-attr.h
new file mode 100644
index 0000000..d9456b0
--- /dev/null
+++ b/include/bits/thread-attr.h
@@ -0,0 +1,47 @@
+/* Thread attribute type.  Generic version.
+   Copyright (C) 2000, 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_THREAD_ATTR_H
+#define _BITS_THREAD_ATTR_H	1
+
+#define __need_schedparam
+#include <bits/sched.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+enum __pthread_detachstate;
+enum __pthread_inheritsched;
+enum __pthread_contentionscope;
+
+/* This structure describes the attributes of a POSIX thread.  Note
+   that not all of them are supported on all systems.  */
+struct __pthread_attr
+{
+  struct __sched_param __schedparam;
+  void *__stackaddr;
+  size_t __stacksize;
+  size_t __guardsize;
+  enum __pthread_detachstate __detachstate;
+  enum __pthread_inheritsched __inheritsched;
+  enum __pthread_contentionscope __contentionscope;
+  int __schedpolicy;
+};
+
+#endif /* bits/thread-attr.h */
diff --git a/include/bits/thread-specific.h b/include/bits/thread-specific.h
new file mode 100644
index 0000000..b42d99e
--- /dev/null
+++ b/include/bits/thread-specific.h
@@ -0,0 +1,25 @@
+/* Thread specific data.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_THREAD_SPECIFIC_H
+#define _BITS_THREAD_SPECIFIC_H	1
+
+typedef int __pthread_key;
+
+#endif /* bits/thread-specific.h */
diff --git a/include/bits/time.h b/include/bits/time.h
new file mode 100644
index 0000000..8b3c8e2
--- /dev/null
+++ b/include/bits/time.h
@@ -0,0 +1,80 @@
+/* System-dependent timing definitions.  Generic version.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Never include this file directly; use <time.h> instead.
+ */
+
+#ifndef __need_timeval
+# ifndef _BITS_TIME_H
+#  define _BITS_TIME_H	1
+
+/* ISO/IEC 9899:1990 7.12.1: <time.h>
+   The macro `CLOCKS_PER_SEC' is the number per second of the value
+   returned by the `clock' function. */
+/* CAE XSH, Issue 4, Version 2: <time.h>
+   The value of CLOCKS_PER_SEC is required to be 1 million on all
+   XSI-conformant systems. */
+#  define CLOCKS_PER_SEC  1000000l
+
+#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
+/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
+   presents the real value for clock ticks per second for the system.  */
+#   include <bits/types.h>
+extern long int __sysconf (int);
+#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
+#  endif
+
+#  ifdef __USE_POSIX199309
+/* Identifier for system-wide realtime clock.  */
+#   define CLOCK_REALTIME		0
+/* Monotonic system-wide clock.  */
+#   define CLOCK_MONOTONIC		1
+/* High-resolution timer from the CPU.  */
+#   define CLOCK_PROCESS_CPUTIME_ID	2
+/* Thread-specific CPU-time clock.  */
+#   define CLOCK_THREAD_CPUTIME_ID	3
+/* Monotonic system-wide clock, not adjusted for frequency scaling.  */
+#   define CLOCK_MONOTONIC_RAW		4
+/* Identifier for system-wide realtime clock, updated only on ticks.  */
+#   define CLOCK_REALTIME_COARSE	5
+/* Monotonic system-wide clock, updated only on ticks.  */
+#   define CLOCK_MONOTONIC_COARSE	6
+
+/* Flag to indicate time is absolute.  */
+#   define TIMER_ABSTIME		1
+#  endif
+
+# endif	/* bits/time.h */
+#endif
+
+#ifdef __need_timeval
+# undef __need_timeval
+# ifndef _STRUCT_TIMEVAL
+#  define _STRUCT_TIMEVAL	1
+#  include <bits/types.h>
+
+/* A time value that is accurate to the nearest
+   microsecond but also has a range of years.  */
+struct timeval
+  {
+    __time_t tv_sec;		/* Seconds.  */
+    __suseconds_t tv_usec;	/* Microseconds.  */
+  };
+# endif	/* struct timeval */
+#endif	/* need timeval */
diff --git a/include/bits/types.h b/include/bits/types.h
new file mode 100644
index 0000000..02e1220
--- /dev/null
+++ b/include/bits/types.h
@@ -0,0 +1,194 @@
+/* bits/types.h -- definitions of __*_t types underlying *_t types.
+   Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Never include this file directly; use <sys/types.h> instead.
+ */
+
+#ifndef	_BITS_TYPES_H
+#define	_BITS_TYPES_H	1
+
+#include <features.h>
+#include <bits/wordsize.h>
+
+/* Convenience types.  */
+typedef unsigned char __u_char;
+typedef unsigned short int __u_short;
+typedef unsigned int __u_int;
+typedef unsigned long int __u_long;
+
+/* Fixed-size types, underlying types depend on word size and compiler.  */
+typedef signed char __int8_t;
+typedef unsigned char __uint8_t;
+typedef signed short int __int16_t;
+typedef unsigned short int __uint16_t;
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+#if __WORDSIZE == 64
+typedef signed long int __int64_t;
+typedef unsigned long int __uint64_t;
+#else
+__extension__ typedef signed long long int __int64_t;
+__extension__ typedef unsigned long long int __uint64_t;
+#endif
+
+/* quad_t is also 64 bits.  */
+#if __WORDSIZE == 64
+typedef long int __quad_t;
+typedef unsigned long int __u_quad_t;
+#else
+__extension__ typedef long long int __quad_t;
+__extension__ typedef unsigned long long int __u_quad_t;
+#endif
+
+
+/* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
+   macros for each of the OS types we define below.  The definitions
+   of those macros must use the following macros for underlying types.
+   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
+   variants of each of the following integer types on this machine.
+
+	16		-- "natural" 16-bit type (always short)
+	32		-- "natural" 32-bit type (always int)
+	64		-- "natural" 64-bit type (long or long long)
+	LONG32		-- 32-bit type, traditionally long
+	QUAD		-- 64-bit type, always long long
+	WORD		-- natural type of __WORDSIZE bits (int or long)
+	LONGWORD	-- type of __WORDSIZE bits, traditionally long
+
+   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
+   conventional uses of `long' or `long long' type modifiers match the
+   types we define, even when a less-adorned type would be the same size.
+   This matters for (somewhat) portably writing printf/scanf formats for
+   these types, where using the appropriate l or ll format modifiers can
+   make the typedefs and the formats match up across all GNU platforms.  If
+   we used `long' when it's 64 bits where `long long' is expected, then the
+   compiler would warn about the formats not matching the argument types,
+   and the programmer changing them to shut up the compiler would break the
+   program's portability.
+
+   Here we assume what is presently the case in all the GCC configurations
+   we support: long long is always 64 bits, long is always word/address size,
+   and int is always 32 bits.  */
+
+#define	__S16_TYPE		short int
+#define __U16_TYPE		unsigned short int
+#define	__S32_TYPE		int
+#define __U32_TYPE		unsigned int
+#define __SLONGWORD_TYPE	long int
+#define __ULONGWORD_TYPE	unsigned long int
+#if __WORDSIZE == 32
+# define __SQUAD_TYPE		__quad_t
+# define __UQUAD_TYPE		__u_quad_t
+# define __SWORD_TYPE		int
+# define __UWORD_TYPE		unsigned int
+# define __SLONG32_TYPE		long int
+# define __ULONG32_TYPE		unsigned long int
+# define __S64_TYPE		__quad_t
+# define __U64_TYPE		__u_quad_t
+/* We want __extension__ before typedef's that use nonstandard base types
+   such as `long long' in C89 mode.  */
+# define __STD_TYPE		__extension__ typedef
+#elif __WORDSIZE == 64
+# define __SQUAD_TYPE		long int
+# define __UQUAD_TYPE		unsigned long int
+# define __SWORD_TYPE		long int
+# define __UWORD_TYPE		unsigned long int
+# define __SLONG32_TYPE		int
+# define __ULONG32_TYPE		unsigned int
+# define __S64_TYPE		long int
+# define __U64_TYPE		unsigned long int
+/* No need to mark the typedef with __extension__.   */
+# define __STD_TYPE		typedef
+#else
+# error
+#endif
+#include <bits/typesizes.h>	/* Defines __*_T_TYPE macros.  */
+
+
+__STD_TYPE __DEV_T_TYPE __dev_t;	/* Type of device numbers.  */
+__STD_TYPE __UID_T_TYPE __uid_t;	/* Type of user identifications.  */
+__STD_TYPE __GID_T_TYPE __gid_t;	/* Type of group identifications.  */
+__STD_TYPE __INO_T_TYPE __ino_t;	/* Type of file serial numbers.  */
+__STD_TYPE __INO64_T_TYPE __ino64_t;	/* Type of file serial numbers (LFS).*/
+__STD_TYPE __MODE_T_TYPE __mode_t;	/* Type of file attribute bitmasks.  */
+__STD_TYPE __NLINK_T_TYPE __nlink_t;	/* Type of file link counts.  */
+__STD_TYPE __OFF_T_TYPE __off_t;	/* Type of file sizes and offsets.  */
+__STD_TYPE __OFF64_T_TYPE __off64_t;	/* Type of file sizes and offsets (LFS).  */
+__STD_TYPE __PID_T_TYPE __pid_t;	/* Type of process identifications.  */
+__STD_TYPE __FSID_T_TYPE __fsid_t;	/* Type of file system IDs.  */
+__STD_TYPE __CLOCK_T_TYPE __clock_t;	/* Type of CPU usage counts.  */
+__STD_TYPE __RLIM_T_TYPE __rlim_t;	/* Type for resource measurement.  */
+__STD_TYPE __RLIM64_T_TYPE __rlim64_t;	/* Type for resource measurement (LFS).  */
+__STD_TYPE __ID_T_TYPE __id_t;		/* General type for IDs.  */
+__STD_TYPE __TIME_T_TYPE __time_t;	/* Seconds since the Epoch.  */
+__STD_TYPE __USECONDS_T_TYPE __useconds_t; /* Count of microseconds.  */
+__STD_TYPE __SUSECONDS_T_TYPE __suseconds_t; /* Signed count of microseconds.  */
+
+__STD_TYPE __DADDR_T_TYPE __daddr_t;	/* The type of a disk address.  */
+__STD_TYPE __KEY_T_TYPE __key_t;	/* Type of an IPC key.  */
+
+/* Clock ID used in clock and timer functions.  */
+__STD_TYPE __CLOCKID_T_TYPE __clockid_t;
+
+/* Timer ID returned by `timer_create'.  */
+__STD_TYPE __TIMER_T_TYPE __timer_t;
+
+/* Type to represent block size.  */
+__STD_TYPE __BLKSIZE_T_TYPE __blksize_t;
+
+/* Types from the Large File Support interface.  */
+
+/* Type to count number of disk blocks.  */
+__STD_TYPE __BLKCNT_T_TYPE __blkcnt_t;
+__STD_TYPE __BLKCNT64_T_TYPE __blkcnt64_t;
+
+/* Type to count file system blocks.  */
+__STD_TYPE __FSBLKCNT_T_TYPE __fsblkcnt_t;
+__STD_TYPE __FSBLKCNT64_T_TYPE __fsblkcnt64_t;
+
+/* Type to count file system nodes.  */
+__STD_TYPE __FSFILCNT_T_TYPE __fsfilcnt_t;
+__STD_TYPE __FSFILCNT64_T_TYPE __fsfilcnt64_t;
+
+/* Type of miscellaneous file system fields.  */
+__STD_TYPE __FSWORD_T_TYPE __fsword_t;
+
+__STD_TYPE __SSIZE_T_TYPE __ssize_t; /* Type of a byte count, or error.  */
+
+/* Signed long type used in system calls.  */
+__STD_TYPE __SYSCALL_SLONG_TYPE __syscall_slong_t;
+/* Unsigned long type used in system calls.  */
+__STD_TYPE __SYSCALL_ULONG_TYPE __syscall_ulong_t;
+
+/* These few don't really vary by system, they always correspond
+   to one of the other defined types.  */
+typedef __off64_t __loff_t;	/* Type of file sizes and offsets (LFS).  */
+typedef __quad_t *__qaddr_t;
+typedef char *__caddr_t;
+
+/* Duplicates info from stdint.h but this is used in unistd.h.  */
+__STD_TYPE __SWORD_TYPE __intptr_t;
+
+/* Duplicate info from sys/socket.h.  */
+__STD_TYPE __U32_TYPE __socklen_t;
+
+
+#undef __STD_TYPE
+
+#endif /* bits/types.h */
diff --git a/include/bits/typesizes.h b/include/bits/typesizes.h
new file mode 100644
index 0000000..808c3bd
--- /dev/null
+++ b/include/bits/typesizes.h
@@ -0,0 +1,67 @@
+/* bits/typesizes.h -- underlying types for *_t.  Hurd version.
+   Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__U32_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__ULONGWORD_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U32_TYPE
+#define __NLINK_T_TYPE		__UWORD_TYPE
+#define __OFF_T_TYPE		__SLONGWORD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__ULONGWORD_TYPE
+#define __RLIM64_T_TYPE		__UQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSWORD_T_TYPE		__SWORD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		__S32_TYPE
+#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
+#define __FSID_T_TYPE		__UQUAD_TYPE
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		256
+
+
+#endif /* bits/typesizes.h */
diff --git a/include/bits/uio.h b/include/bits/uio.h
new file mode 100644
index 0000000..3d13ab3
--- /dev/null
+++ b/include/bits/uio.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_UIO_H
+# error "Never include <bits/uio.h> directly; use <sys/uio.h> instead."
+#endif
+
+
+/* `struct iovec' -- Structure describing a section of memory.  */
+
+struct iovec
+{
+  /* Starting address.  */
+  __ptr_t iov_base;
+  /* Length in bytes.  */
+  size_t iov_len;
+};
diff --git a/include/bits/unistd.h b/include/bits/unistd.h
new file mode 100644
index 0000000..336b928
--- /dev/null
+++ b/include/bits/unistd.h
@@ -0,0 +1,385 @@
+/* Checking macros for unistd functions.
+   Copyright (C) 2005-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _UNISTD_H
+# error "Never include <bits/unistd.h> directly; use <unistd.h> instead."
+#endif
+
+extern ssize_t __read_chk (int __fd, void *__buf, size_t __nbytes,
+			   size_t __buflen) __wur;
+extern ssize_t __REDIRECT (__read_alias, (int __fd, void *__buf,
+					  size_t __nbytes), read) __wur;
+extern ssize_t __REDIRECT (__read_chk_warn,
+			   (int __fd, void *__buf, size_t __nbytes,
+			    size_t __buflen), __read_chk)
+     __wur __warnattr ("read called with bigger length than size of "
+		       "the destination buffer");
+
+__fortify_function __wur ssize_t
+read (int __fd, void *__buf, size_t __nbytes)
+{
+  if (__bos0 (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__nbytes))
+	return __read_chk (__fd, __buf, __nbytes, __bos0 (__buf));
+
+      if (__nbytes > __bos0 (__buf))
+	return __read_chk_warn (__fd, __buf, __nbytes, __bos0 (__buf));
+    }
+  return __read_alias (__fd, __buf, __nbytes);
+}
+
+#ifdef __USE_UNIX98
+extern ssize_t __pread_chk (int __fd, void *__buf, size_t __nbytes,
+			    __off_t __offset, size_t __bufsize) __wur;
+extern ssize_t __pread64_chk (int __fd, void *__buf, size_t __nbytes,
+			      __off64_t __offset, size_t __bufsize) __wur;
+extern ssize_t __REDIRECT (__pread_alias,
+			   (int __fd, void *__buf, size_t __nbytes,
+			    __off_t __offset), pread) __wur;
+extern ssize_t __REDIRECT (__pread64_alias,
+			   (int __fd, void *__buf, size_t __nbytes,
+			    __off64_t __offset), pread64) __wur;
+extern ssize_t __REDIRECT (__pread_chk_warn,
+			   (int __fd, void *__buf, size_t __nbytes,
+			    __off_t __offset, size_t __bufsize), __pread_chk)
+     __wur __warnattr ("pread called with bigger length than size of "
+		       "the destination buffer");
+extern ssize_t __REDIRECT (__pread64_chk_warn,
+			   (int __fd, void *__buf, size_t __nbytes,
+			    __off64_t __offset, size_t __bufsize),
+			    __pread64_chk)
+     __wur __warnattr ("pread64 called with bigger length than size of "
+		       "the destination buffer");
+
+# ifndef __USE_FILE_OFFSET64
+__fortify_function __wur ssize_t
+pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset)
+{
+  if (__bos0 (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__nbytes))
+	return __pread_chk (__fd, __buf, __nbytes, __offset, __bos0 (__buf));
+
+      if ( __nbytes > __bos0 (__buf))
+	return __pread_chk_warn (__fd, __buf, __nbytes, __offset,
+				 __bos0 (__buf));
+    }
+  return __pread_alias (__fd, __buf, __nbytes, __offset);
+}
+# else
+__fortify_function __wur ssize_t
+pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
+{
+  if (__bos0 (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__nbytes))
+	return __pread64_chk (__fd, __buf, __nbytes, __offset, __bos0 (__buf));
+
+      if ( __nbytes > __bos0 (__buf))
+	return __pread64_chk_warn (__fd, __buf, __nbytes, __offset,
+				   __bos0 (__buf));
+    }
+
+  return __pread64_alias (__fd, __buf, __nbytes, __offset);
+}
+# endif
+
+# ifdef __USE_LARGEFILE64
+__fortify_function __wur ssize_t
+pread64 (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
+{
+  if (__bos0 (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__nbytes))
+	return __pread64_chk (__fd, __buf, __nbytes, __offset, __bos0 (__buf));
+
+      if ( __nbytes > __bos0 (__buf))
+	return __pread64_chk_warn (__fd, __buf, __nbytes, __offset,
+				   __bos0 (__buf));
+    }
+
+  return __pread64_alias (__fd, __buf, __nbytes, __offset);
+}
+# endif
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K
+extern ssize_t __readlink_chk (const char *__restrict __path,
+			       char *__restrict __buf, size_t __len,
+			       size_t __buflen)
+     __THROW __nonnull ((1, 2)) __wur;
+extern ssize_t __REDIRECT_NTH (__readlink_alias,
+			       (const char *__restrict __path,
+				char *__restrict __buf, size_t __len), readlink)
+     __nonnull ((1, 2)) __wur;
+extern ssize_t __REDIRECT_NTH (__readlink_chk_warn,
+			       (const char *__restrict __path,
+				char *__restrict __buf, size_t __len,
+				size_t __buflen), __readlink_chk)
+     __nonnull ((1, 2)) __wur __warnattr ("readlink called with bigger length "
+					  "than size of destination buffer");
+
+__fortify_function __nonnull ((1, 2)) __wur ssize_t
+__NTH (readlink (const char *__restrict __path, char *__restrict __buf,
+		 size_t __len))
+{
+  if (__bos (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+	return __readlink_chk (__path, __buf, __len, __bos (__buf));
+
+      if ( __len > __bos (__buf))
+	return __readlink_chk_warn (__path, __buf, __len, __bos (__buf));
+    }
+  return __readlink_alias (__path, __buf, __len);
+}
+#endif
+
+#ifdef __USE_ATFILE
+extern ssize_t __readlinkat_chk (int __fd, const char *__restrict __path,
+				 char *__restrict __buf, size_t __len,
+				 size_t __buflen)
+     __THROW __nonnull ((2, 3)) __wur;
+extern ssize_t __REDIRECT_NTH (__readlinkat_alias,
+			       (int __fd, const char *__restrict __path,
+				char *__restrict __buf, size_t __len),
+			       readlinkat)
+     __nonnull ((2, 3)) __wur;
+extern ssize_t __REDIRECT_NTH (__readlinkat_chk_warn,
+			       (int __fd, const char *__restrict __path,
+				char *__restrict __buf, size_t __len,
+				size_t __buflen), __readlinkat_chk)
+     __nonnull ((2, 3)) __wur __warnattr ("readlinkat called with bigger "
+					  "length than size of destination "
+					  "buffer");
+
+__fortify_function __nonnull ((2, 3)) __wur ssize_t
+__NTH (readlinkat (int __fd, const char *__restrict __path,
+		   char *__restrict __buf, size_t __len))
+{
+  if (__bos (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+	return __readlinkat_chk (__fd, __path, __buf, __len, __bos (__buf));
+
+      if (__len > __bos (__buf))
+	return __readlinkat_chk_warn (__fd, __path, __buf, __len,
+				      __bos (__buf));
+    }
+  return __readlinkat_alias (__fd, __path, __buf, __len);
+}
+#endif
+
+extern char *__getcwd_chk (char *__buf, size_t __size, size_t __buflen)
+     __THROW __wur;
+extern char *__REDIRECT_NTH (__getcwd_alias,
+			     (char *__buf, size_t __size), getcwd) __wur;
+extern char *__REDIRECT_NTH (__getcwd_chk_warn,
+			     (char *__buf, size_t __size, size_t __buflen),
+			     __getcwd_chk)
+     __wur __warnattr ("getcwd caller with bigger length than size of "
+		       "destination buffer");
+
+__fortify_function __wur char *
+__NTH (getcwd (char *__buf, size_t __size))
+{
+  if (__bos (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__size))
+	return __getcwd_chk (__buf, __size, __bos (__buf));
+
+      if (__size > __bos (__buf))
+	return __getcwd_chk_warn (__buf, __size, __bos (__buf));
+    }
+  return __getcwd_alias (__buf, __size);
+}
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+extern char *__getwd_chk (char *__buf, size_t buflen)
+     __THROW __nonnull ((1)) __wur;
+extern char *__REDIRECT_NTH (__getwd_warn, (char *__buf), getwd)
+     __nonnull ((1)) __wur __warnattr ("please use getcwd instead, as getwd "
+				       "doesn't specify buffer size");
+
+__fortify_function __nonnull ((1)) __attribute_deprecated__ __wur char *
+__NTH (getwd (char *__buf))
+{
+  if (__bos (__buf) != (size_t) -1)
+    return __getwd_chk (__buf, __bos (__buf));
+  return __getwd_warn (__buf);
+}
+#endif
+
+extern size_t __confstr_chk (int __name, char *__buf, size_t __len,
+			     size_t __buflen) __THROW;
+extern size_t __REDIRECT_NTH (__confstr_alias, (int __name, char *__buf,
+						size_t __len), confstr);
+extern size_t __REDIRECT_NTH (__confstr_chk_warn,
+			      (int __name, char *__buf, size_t __len,
+			       size_t __buflen), __confstr_chk)
+     __warnattr ("confstr called with bigger length than size of destination "
+		 "buffer");
+
+__fortify_function size_t
+__NTH (confstr (int __name, char *__buf, size_t __len))
+{
+  if (__bos (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+	return __confstr_chk (__name, __buf, __len, __bos (__buf));
+
+      if (__bos (__buf) < __len)
+	return __confstr_chk_warn (__name, __buf, __len, __bos (__buf));
+    }
+  return __confstr_alias (__name, __buf, __len);
+}
+
+
+extern int __getgroups_chk (int __size, __gid_t __list[], size_t __listlen)
+     __THROW __wur;
+extern int __REDIRECT_NTH (__getgroups_alias, (int __size, __gid_t __list[]),
+			   getgroups) __wur;
+extern int __REDIRECT_NTH (__getgroups_chk_warn,
+			   (int __size, __gid_t __list[], size_t __listlen),
+			   __getgroups_chk)
+     __wur __warnattr ("getgroups called with bigger group count than what "
+		       "can fit into destination buffer");
+
+__fortify_function int
+__NTH (getgroups (int __size, __gid_t __list[]))
+{
+  if (__bos (__list) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__size) || __size < 0)
+	return __getgroups_chk (__size, __list, __bos (__list));
+
+      if (__size * sizeof (__gid_t) > __bos (__list))
+	return __getgroups_chk_warn (__size, __list, __bos (__list));
+    }
+  return __getgroups_alias (__size, __list);
+}
+
+
+extern int __ttyname_r_chk (int __fd, char *__buf, size_t __buflen,
+			    size_t __nreal) __THROW __nonnull ((2));
+extern int __REDIRECT_NTH (__ttyname_r_alias, (int __fd, char *__buf,
+					       size_t __buflen), ttyname_r)
+     __nonnull ((2));
+extern int __REDIRECT_NTH (__ttyname_r_chk_warn,
+			   (int __fd, char *__buf, size_t __buflen,
+			    size_t __nreal), __ttyname_r_chk)
+     __nonnull ((2)) __warnattr ("ttyname_r called with bigger buflen than "
+				 "size of destination buffer");
+
+__fortify_function int
+__NTH (ttyname_r (int __fd, char *__buf, size_t __buflen))
+{
+  if (__bos (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__buflen))
+	return __ttyname_r_chk (__fd, __buf, __buflen, __bos (__buf));
+
+      if (__buflen > __bos (__buf))
+	return __ttyname_r_chk_warn (__fd, __buf, __buflen, __bos (__buf));
+    }
+  return __ttyname_r_alias (__fd, __buf, __buflen);
+}
+
+
+#if defined __USE_REENTRANT || defined __USE_POSIX199506
+extern int __getlogin_r_chk (char *__buf, size_t __buflen, size_t __nreal)
+     __nonnull ((1));
+extern int __REDIRECT (__getlogin_r_alias, (char *__buf, size_t __buflen),
+		       getlogin_r) __nonnull ((1));
+extern int __REDIRECT (__getlogin_r_chk_warn,
+		       (char *__buf, size_t __buflen, size_t __nreal),
+		       __getlogin_r_chk)
+     __nonnull ((1)) __warnattr ("getlogin_r called with bigger buflen than "
+				 "size of destination buffer");
+
+__fortify_function int
+getlogin_r (char *__buf, size_t __buflen)
+{
+  if (__bos (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__buflen))
+	return __getlogin_r_chk (__buf, __buflen, __bos (__buf));
+
+      if (__buflen > __bos (__buf))
+	return __getlogin_r_chk_warn (__buf, __buflen, __bos (__buf));
+    }
+  return __getlogin_r_alias (__buf, __buflen);
+}
+#endif
+
+
+#if defined __USE_BSD || defined __USE_UNIX98
+extern int __gethostname_chk (char *__buf, size_t __buflen, size_t __nreal)
+     __THROW __nonnull ((1));
+extern int __REDIRECT_NTH (__gethostname_alias, (char *__buf, size_t __buflen),
+			   gethostname) __nonnull ((1));
+extern int __REDIRECT_NTH (__gethostname_chk_warn,
+			   (char *__buf, size_t __buflen, size_t __nreal),
+			   __gethostname_chk)
+     __nonnull ((1)) __warnattr ("gethostname called with bigger buflen than "
+				 "size of destination buffer");
+
+__fortify_function int
+__NTH (gethostname (char *__buf, size_t __buflen))
+{
+  if (__bos (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__buflen))
+	return __gethostname_chk (__buf, __buflen, __bos (__buf));
+
+      if (__buflen > __bos (__buf))
+	return __gethostname_chk_warn (__buf, __buflen, __bos (__buf));
+    }
+  return __gethostname_alias (__buf, __buflen);
+}
+#endif
+
+
+#if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_UNIX98)
+extern int __getdomainname_chk (char *__buf, size_t __buflen, size_t __nreal)
+     __THROW __nonnull ((1)) __wur;
+extern int __REDIRECT_NTH (__getdomainname_alias, (char *__buf,
+						   size_t __buflen),
+			   getdomainname) __nonnull ((1)) __wur;
+extern int __REDIRECT_NTH (__getdomainname_chk_warn,
+			   (char *__buf, size_t __buflen, size_t __nreal),
+			   __getdomainname_chk)
+     __nonnull ((1)) __wur __warnattr ("getdomainname called with bigger "
+				       "buflen than size of destination "
+				       "buffer");
+
+__fortify_function int
+__NTH (getdomainname (char *__buf, size_t __buflen))
+{
+  if (__bos (__buf) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__buflen))
+	return __getdomainname_chk (__buf, __buflen, __bos (__buf));
+
+      if (__buflen > __bos (__buf))
+	return __getdomainname_chk_warn (__buf, __buflen, __bos (__buf));
+    }
+  return __getdomainname_alias (__buf, __buflen);
+}
+#endif
diff --git a/include/bits/ustat.h b/include/bits/ustat.h
new file mode 100644
index 0000000..48d7f07
--- /dev/null
+++ b/include/bits/ustat.h
@@ -0,0 +1,30 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_USTAT_H
+# error "Never include <bits/ustat.h> directly; use <sys/ustat.h> instead."
+#endif
+
+#include <sys/types.h>
+
+struct ustat
+  {
+    __daddr_t f_tfree;		/* Number of free blocks.  */
+    __ino_t f_tinode;		/* Number of free inodes.  */
+    char f_fname[6];
+    char f_fpack[6];
+  };
diff --git a/include/bits/utmp.h b/include/bits/utmp.h
new file mode 100644
index 0000000..891e055
--- /dev/null
+++ b/include/bits/utmp.h
@@ -0,0 +1,123 @@
+/* The `struct utmp' type, describing entries in the utmp file.  GNU version.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _UTMP_H
+# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
+#endif
+
+#include <paths.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <bits/wordsize.h>
+
+
+#define UT_LINESIZE	32
+#define UT_NAMESIZE	32
+#define UT_HOSTSIZE	256
+
+
+/* The structure describing an entry in the database of
+   previous logins.  */
+struct lastlog
+  {
+#ifdef __WORDSIZE_TIME64_COMPAT32
+    int32_t ll_time;
+#else
+    __time_t ll_time;
+#endif
+    char ll_line[UT_LINESIZE];
+    char ll_host[UT_HOSTSIZE];
+  };
+
+
+/* The structure describing the status of a terminated process.  This
+   type is used in `struct utmp' below.  */
+struct exit_status
+  {
+    short int e_termination;	/* Process termination status.  */
+    short int e_exit;		/* Process exit status.  */
+  };
+
+
+/* The structure describing an entry in the user accounting database.  */
+struct utmp
+{
+  short int ut_type;		/* Type of login.  */
+  pid_t ut_pid;			/* Process ID of login process.  */
+  char ut_line[UT_LINESIZE];	/* Devicename.  */
+  char ut_id[4];		/* Inittab ID.  */
+  char ut_user[UT_NAMESIZE];	/* Username.  */
+  char ut_host[UT_HOSTSIZE];	/* Hostname for remote login.  */
+  struct exit_status ut_exit;	/* Exit status of a process marked
+				   as DEAD_PROCESS.  */
+/* The ut_session and ut_tv fields must be the same size when compiled
+   32- and 64-bit.  This allows data files and shared memory to be
+   shared between 32- and 64-bit applications.  */
+#ifdef __WORDSIZE_TIME64_COMPAT32
+  int32_t ut_session;		/* Session ID, used for windowing.  */
+  struct
+  {
+    int32_t tv_sec;		/* Seconds.  */
+    int32_t tv_usec;		/* Microseconds.  */
+  } ut_tv;			/* Time entry was made.  */
+#else
+  long int ut_session;		/* Session ID, used for windowing.  */
+  struct timeval ut_tv;		/* Time entry was made.  */
+#endif
+
+  int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
+  char __glibc_reserved[20];		/* Reserved for future use.  */
+};
+
+/* Backwards compatibility hacks.  */
+#define ut_name		ut_user
+#ifndef _NO_UT_TIME
+/* We have a problem here: `ut_time' is also used otherwise.  Define
+   _NO_UT_TIME if the compiler complains.  */
+# define ut_time	ut_tv.tv_sec
+#endif
+#define ut_xtime	ut_tv.tv_sec
+#define ut_addr		ut_addr_v6[0]
+
+
+/* Values for the `ut_type' field of a `struct utmp'.  */
+#define EMPTY		0	/* No valid user accounting information.  */
+
+#define RUN_LVL		1	/* The system's runlevel.  */
+#define BOOT_TIME	2	/* Time of system boot.  */
+#define NEW_TIME	3	/* Time after system clock changed.  */
+#define OLD_TIME	4	/* Time when system clock changed.  */
+
+#define INIT_PROCESS	5	/* Process spawned by the init process.  */
+#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
+#define USER_PROCESS	7	/* Normal process.  */
+#define DEAD_PROCESS	8	/* Terminated process.  */
+
+#define ACCOUNTING	9
+
+/* Old Linux name for the EMPTY type.  */
+#define UT_UNKNOWN	EMPTY
+
+
+/* Tell the user that we have a modern system with UT_HOST, UT_PID,
+   UT_TYPE, UT_ID and UT_TV fields.  */
+#define _HAVE_UT_TYPE	1
+#define _HAVE_UT_PID	1
+#define _HAVE_UT_ID	1
+#define _HAVE_UT_TV	1
+#define _HAVE_UT_HOST	1
diff --git a/include/bits/utmpx.h b/include/bits/utmpx.h
new file mode 100644
index 0000000..89d43a4
--- /dev/null
+++ b/include/bits/utmpx.h
@@ -0,0 +1,102 @@
+/* Structures and definitions for the user accounting database.  GNU version.
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _UTMPX_H
+# error "Never include <bits/utmpx.h> directly; use <utmpx.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <sys/time.h>
+#include <bits/wordsize.h>
+
+
+#ifdef __USE_GNU
+# include <paths.h>
+# define _PATH_UTMPX	_PATH_UTMP
+# define _PATH_WTMPX	_PATH_WTMP
+#endif
+
+
+#define __UT_LINESIZE	32
+#define __UT_NAMESIZE	32
+#define __UT_HOSTSIZE	256
+
+
+/* The structure describing the status of a terminated process.  This
+   type is used in `struct utmpx' below.  */
+struct __exit_status
+  {
+#ifdef __USE_GNU
+    short int e_termination;	/* Process termination status.  */
+    short int e_exit;		/* Process exit status.  */
+#else
+    short int __e_termination;	/* Process termination status.  */
+    short int __e_exit;		/* Process exit status.  */
+#endif
+  };
+
+
+/* The structure describing an entry in the user accounting database.  */
+struct utmpx
+{
+  short int ut_type;		/* Type of login.  */
+  __pid_t ut_pid;		/* Process ID of login process.  */
+  char ut_line[__UT_LINESIZE];	/* Devicename.  */
+  char ut_id[4];		/* Inittab ID. */
+  char ut_user[__UT_NAMESIZE];	/* Username.  */
+  char ut_host[__UT_HOSTSIZE];	/* Hostname for remote login.  */
+  struct __exit_status ut_exit;	/* Exit status of a process marked
+				   as DEAD_PROCESS.  */
+
+/* The fields ut_session and ut_tv must be the same size when compiled
+   32- and 64-bit.  This allows files and shared memory to be shared
+   between 32- and 64-bit applications.  */
+#ifdef __WORDSIZE_TIME64_COMPAT32
+  __int32_t ut_session;		/* Session ID, used for windowing.  */
+  struct
+  {
+    __int32_t tv_sec;		/* Seconds.  */
+    __int32_t tv_usec;		/* Microseconds.  */
+  } ut_tv;			/* Time entry was made.  */
+#else
+  long int ut_session;		/* Session ID, used for windowing.  */
+  struct timeval ut_tv;		/* Time entry was made.  */
+#endif
+  __int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
+  char __glibc_reserved[20];		/* Reserved for future use.  */
+};
+
+
+/* Values for the `ut_type' field of a `struct utmpx'.  */
+#define EMPTY		0	/* No valid user accounting information.  */
+
+#ifdef __USE_GNU
+# define RUN_LVL	1	/* The system's runlevel.  */
+#endif
+#define BOOT_TIME	2	/* Time of system boot.  */
+#define NEW_TIME	3	/* Time after system clock changed.  */
+#define OLD_TIME	4	/* Time when system clock changed.  */
+
+#define INIT_PROCESS	5	/* Process spawned by the init process.  */
+#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
+#define USER_PROCESS	7	/* Normal process.  */
+#define DEAD_PROCESS	8	/* Terminated process.  */
+
+#ifdef __USE_GNU
+# define ACCOUNTING	9	/* System accounting.  */
+#endif
diff --git a/include/bits/utsname.h b/include/bits/utsname.h
new file mode 100644
index 0000000..e41c438
--- /dev/null
+++ b/include/bits/utsname.h
@@ -0,0 +1,24 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_UTSNAME_H
+# error "Never include <bits/utsname.h> directly; use <sys/utsname.h> instead."
+#endif
+
+/* The size of the character arrays used to hold the information
+   in a `struct utsname'.  Enlarge this as necessary.  */
+#define	_UTSNAME_LENGTH	1024
diff --git a/include/bits/waitflags.h b/include/bits/waitflags.h
new file mode 100644
index 0000000..b7d1351
--- /dev/null
+++ b/include/bits/waitflags.h
@@ -0,0 +1,26 @@
+/* Definitions of flag bits for `waitpid' et al.
+   Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitflags.h> directly; use <sys/wait.h> instead."
+#endif
+
+
+/* Bits in the third argument to `waitpid'.  */
+#define	WNOHANG		1	/* Don't block waiting.  */
+#define	WUNTRACED	2	/* Report status of stopped children.  */
diff --git a/include/bits/waitstatus.h b/include/bits/waitstatus.h
new file mode 100644
index 0000000..baa3962
--- /dev/null
+++ b/include/bits/waitstatus.h
@@ -0,0 +1,105 @@
+/* Definitions of status bits for `wait' et al.
+   Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitstatus.h> directly; use <sys/wait.h> instead."
+#endif
+
+
+/* Everything extant so far uses these same bits.  */
+
+
+/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
+#define	__WEXITSTATUS(status)	(((status) & 0xff00) >> 8)
+
+/* If WIFSIGNALED(STATUS), the terminating signal.  */
+#define	__WTERMSIG(status)	((status) & 0x7f)
+
+/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
+#define	__WSTOPSIG(status)	__WEXITSTATUS(status)
+
+/* Nonzero if STATUS indicates normal termination.  */
+#define	__WIFEXITED(status)	(__WTERMSIG(status) == 0)
+
+/* Nonzero if STATUS indicates termination by a signal.  */
+#define __WIFSIGNALED(status) \
+  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)
+
+/* Nonzero if STATUS indicates the child is stopped.  */
+#define	__WIFSTOPPED(status)	(((status) & 0xff) == 0x7f)
+
+/* Nonzero if STATUS indicates the child continued after a stop.  We only
+   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */
+#ifdef WCONTINUED
+# define __WIFCONTINUED(status)	((status) == __W_CONTINUED)
+#endif
+
+/* Nonzero if STATUS indicates the child dumped core.  */
+#define	__WCOREDUMP(status)	((status) & __WCOREFLAG)
+
+/* Macros for constructing status values.  */
+#define	__W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
+#define	__W_STOPCODE(sig)	((sig) << 8 | 0x7f)
+#define __W_CONTINUED		0xffff
+#define	__WCOREFLAG		0x80
+
+
+#ifdef	__USE_BSD
+
+# include <endian.h>
+
+union wait
+  {
+    int w_status;
+    struct
+      {
+# if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int __w_termsig:7; /* Terminating signal.  */
+	unsigned int __w_coredump:1; /* Set if dumped core.  */
+	unsigned int __w_retcode:8; /* Return code if exited normally.  */
+	unsigned int:16;
+# endif				/* Little endian.  */
+# if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int:16;
+	unsigned int __w_retcode:8;
+	unsigned int __w_coredump:1;
+	unsigned int __w_termsig:7;
+# endif				/* Big endian.  */
+      } __wait_terminated;
+    struct
+      {
+# if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
+	unsigned int __w_stopsig:8; /* Stopping signal.  */
+	unsigned int:16;
+# endif				/* Little endian.  */
+# if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int:16;
+	unsigned int __w_stopsig:8; /* Stopping signal.  */
+	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
+# endif				/* Big endian.  */
+      } __wait_stopped;
+  };
+
+# define w_termsig	__wait_terminated.__w_termsig
+# define w_coredump	__wait_terminated.__w_coredump
+# define w_retcode	__wait_terminated.__w_retcode
+# define w_stopsig	__wait_stopped.__w_stopsig
+# define w_stopval	__wait_stopped.__w_stopval
+
+#endif	/* Use BSD.  */
diff --git a/include/bits/wchar-ldbl.h b/include/bits/wchar-ldbl.h
new file mode 100644
index 0000000..45453be
--- /dev/null
+++ b/include/bits/wchar-ldbl.h
@@ -0,0 +1,74 @@
+/* -mlong-double-64 compatibility mode for <wchar.h> functions.
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _WCHAR_H
+# error "Never include <bits/wchar-ldbl.h> directly; use <wchar.h> instead."
+#endif
+
+#if defined __USE_ISOC95 || defined __USE_UNIX98
+__BEGIN_NAMESPACE_C99
+__LDBL_REDIR_DECL (fwprintf);
+__LDBL_REDIR_DECL (wprintf);
+__LDBL_REDIR_DECL (swprintf);
+__LDBL_REDIR_DECL (vfwprintf);
+__LDBL_REDIR_DECL (vwprintf);
+__LDBL_REDIR_DECL (vswprintf);
+# if defined __USE_ISOC99 && !defined __USE_GNU \
+     && !defined __REDIRECT \
+     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
+__LDBL_REDIR1_DECL (fwscanf, __nldbl___isoc99_fwscanf)
+__LDBL_REDIR1_DECL (wscanf, __nldbl___isoc99_wscanf)
+__LDBL_REDIR1_DECL (swscanf, __nldbl___isoc99_swscanf)
+# else
+__LDBL_REDIR_DECL (fwscanf);
+__LDBL_REDIR_DECL (wscanf);
+__LDBL_REDIR_DECL (swscanf);
+# endif
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+__LDBL_REDIR1_DECL (wcstold, wcstod);
+# if !defined __USE_GNU && !defined __REDIRECT \
+     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
+__LDBL_REDIR1_DECL (vfwscanf, __nldbl___isoc99_vfwscanf)
+__LDBL_REDIR1_DECL (vwscanf, __nldbl___isoc99_vwscanf)
+__LDBL_REDIR1_DECL (vswscanf, __nldbl___isoc99_vswscanf)
+# else
+__LDBL_REDIR_DECL (vfwscanf);
+__LDBL_REDIR_DECL (vwscanf);
+__LDBL_REDIR_DECL (vswscanf);
+# endif
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_GNU
+__LDBL_REDIR1_DECL (wcstold_l, wcstod_l);
+#endif
+
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+__LDBL_REDIR_DECL (__swprintf_chk)
+__LDBL_REDIR_DECL (__vswprintf_chk)
+# if __USE_FORTIFY_LEVEL > 1
+__LDBL_REDIR_DECL (__fwprintf_chk)
+__LDBL_REDIR_DECL (__wprintf_chk)
+__LDBL_REDIR_DECL (__vfwprintf_chk)
+__LDBL_REDIR_DECL (__vwprintf_chk)
+# endif
+#endif
diff --git a/include/bits/wchar.h b/include/bits/wchar.h
new file mode 100644
index 0000000..e4ca8db
--- /dev/null
+++ b/include/bits/wchar.h
@@ -0,0 +1,49 @@
+/* wchar_t type related definitions.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_WCHAR_H
+#define _BITS_WCHAR_H	1
+
+/* The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
+   are not defined, give the right value and type as long as both int
+   and wchar_t are 32-bit types.  Adding L'\0' to a constant value
+   ensures that the type is correct; it is necessary to use (L'\0' +
+   0) rather than just L'\0' so that the type in C++ is the promoted
+   version of wchar_t rather than the distinct wchar_t type itself.
+   Because wchar_t in preprocessor #if expressions is treated as
+   intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
+   wrong value for WCHAR_MAX in such expressions and so cannot be used
+   to define __WCHAR_MAX in the unsigned case.  */
+
+#ifdef __WCHAR_MAX__
+# define __WCHAR_MAX	__WCHAR_MAX__
+#elif L'\0' - 1 > 0
+# define __WCHAR_MAX	(0xffffffffu + L'\0')
+#else
+# define __WCHAR_MAX	(0x7fffffff + L'\0')
+#endif
+
+#ifdef __WCHAR_MIN__
+# define __WCHAR_MIN	__WCHAR_MIN__
+#elif L'\0' - 1 > 0
+# define __WCHAR_MIN	(L'\0' + 0)
+#else
+# define __WCHAR_MIN	(-__WCHAR_MAX - 1)
+#endif
+
+#endif	/* bits/wchar.h */
diff --git a/include/bits/wchar2.h b/include/bits/wchar2.h
new file mode 100644
index 0000000..29ac6b3
--- /dev/null
+++ b/include/bits/wchar2.h
@@ -0,0 +1,593 @@
+/* Checking macros for wchar functions.
+   Copyright (C) 2005-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _WCHAR_H
+# error "Never include <bits/wchar2.h> directly; use <wchar.h> instead."
+#endif
+
+
+extern wchar_t *__wmemcpy_chk (wchar_t *__restrict __s1,
+			       const wchar_t *__restrict __s2, size_t __n,
+			       size_t __ns1) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wmemcpy_alias,
+				(wchar_t *__restrict __s1,
+				 const wchar_t *__restrict __s2, size_t __n),
+				wmemcpy);
+extern wchar_t *__REDIRECT_NTH (__wmemcpy_chk_warn,
+				(wchar_t *__restrict __s1,
+				 const wchar_t *__restrict __s2, size_t __n,
+				 size_t __ns1), __wmemcpy_chk)
+     __warnattr ("wmemcpy called with length bigger than size of destination "
+		 "buffer");
+
+__fortify_function wchar_t *
+__NTH (wmemcpy (wchar_t *__restrict __s1, const wchar_t *__restrict __s2,
+		size_t __n))
+{
+  if (__bos0 (__s1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n))
+	return __wmemcpy_chk (__s1, __s2, __n,
+			      __bos0 (__s1) / sizeof (wchar_t));
+
+      if (__n > __bos0 (__s1) / sizeof (wchar_t))
+	return __wmemcpy_chk_warn (__s1, __s2, __n,
+				   __bos0 (__s1) / sizeof (wchar_t));
+    }
+  return __wmemcpy_alias (__s1, __s2, __n);
+}
+
+
+extern wchar_t *__wmemmove_chk (wchar_t *__s1, const wchar_t *__s2,
+				size_t __n, size_t __ns1) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wmemmove_alias, (wchar_t *__s1,
+						   const wchar_t *__s2,
+						   size_t __n), wmemmove);
+extern wchar_t *__REDIRECT_NTH (__wmemmove_chk_warn,
+				(wchar_t *__s1, const wchar_t *__s2,
+				 size_t __n, size_t __ns1), __wmemmove_chk)
+     __warnattr ("wmemmove called with length bigger than size of destination "
+		 "buffer");
+
+__fortify_function wchar_t *
+__NTH (wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n))
+{
+  if (__bos0 (__s1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n))
+	return __wmemmove_chk (__s1, __s2, __n,
+			       __bos0 (__s1) / sizeof (wchar_t));
+
+      if (__n > __bos0 (__s1) / sizeof (wchar_t))
+	return __wmemmove_chk_warn (__s1, __s2, __n,
+				    __bos0 (__s1) / sizeof (wchar_t));
+    }
+  return __wmemmove_alias (__s1, __s2, __n);
+}
+
+
+#ifdef __USE_GNU
+extern wchar_t *__wmempcpy_chk (wchar_t *__restrict __s1,
+				const wchar_t *__restrict __s2, size_t __n,
+				size_t __ns1) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wmempcpy_alias,
+				(wchar_t *__restrict __s1,
+				 const wchar_t *__restrict __s2,
+				 size_t __n), wmempcpy);
+extern wchar_t *__REDIRECT_NTH (__wmempcpy_chk_warn,
+				(wchar_t *__restrict __s1,
+				 const wchar_t *__restrict __s2, size_t __n,
+				 size_t __ns1), __wmempcpy_chk)
+     __warnattr ("wmempcpy called with length bigger than size of destination "
+		 "buffer");
+
+__fortify_function wchar_t *
+__NTH (wmempcpy (wchar_t *__restrict __s1, const wchar_t *__restrict __s2,
+		 size_t __n))
+{
+  if (__bos0 (__s1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n))
+	return __wmempcpy_chk (__s1, __s2, __n,
+			       __bos0 (__s1) / sizeof (wchar_t));
+
+      if (__n > __bos0 (__s1) / sizeof (wchar_t))
+	return __wmempcpy_chk_warn (__s1, __s2, __n,
+				    __bos0 (__s1) / sizeof (wchar_t));
+    }
+  return __wmempcpy_alias (__s1, __s2, __n);
+}
+#endif
+
+
+extern wchar_t *__wmemset_chk (wchar_t *__s, wchar_t __c, size_t __n,
+			       size_t __ns) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wmemset_alias, (wchar_t *__s, wchar_t __c,
+						  size_t __n), wmemset);
+extern wchar_t *__REDIRECT_NTH (__wmemset_chk_warn,
+				(wchar_t *__s, wchar_t __c, size_t __n,
+				 size_t __ns), __wmemset_chk)
+     __warnattr ("wmemset called with length bigger than size of destination "
+		 "buffer");
+
+__fortify_function wchar_t *
+__NTH (wmemset (wchar_t *__s, wchar_t __c, size_t __n))
+{
+  if (__bos0 (__s) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n))
+	return __wmemset_chk (__s, __c, __n, __bos0 (__s) / sizeof (wchar_t));
+
+      if (__n > __bos0 (__s) / sizeof (wchar_t))
+	return __wmemset_chk_warn (__s, __c, __n,
+				   __bos0 (__s) / sizeof (wchar_t));
+    }
+  return __wmemset_alias (__s, __c, __n);
+}
+
+
+extern wchar_t *__wcscpy_chk (wchar_t *__restrict __dest,
+			      const wchar_t *__restrict __src,
+			      size_t __n) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wcscpy_alias,
+				(wchar_t *__restrict __dest,
+				 const wchar_t *__restrict __src), wcscpy);
+
+__fortify_function wchar_t *
+__NTH (wcscpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src))
+{
+  if (__bos (__dest) != (size_t) -1)
+    return __wcscpy_chk (__dest, __src, __bos (__dest) / sizeof (wchar_t));
+  return __wcscpy_alias (__dest, __src);
+}
+
+
+extern wchar_t *__wcpcpy_chk (wchar_t *__restrict __dest,
+			      const wchar_t *__restrict __src,
+			      size_t __destlen) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wcpcpy_alias,
+				(wchar_t *__restrict __dest,
+				 const wchar_t *__restrict __src), wcpcpy);
+
+__fortify_function wchar_t *
+__NTH (wcpcpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src))
+{
+  if (__bos (__dest) != (size_t) -1)
+    return __wcpcpy_chk (__dest, __src, __bos (__dest) / sizeof (wchar_t));
+  return __wcpcpy_alias (__dest, __src);
+}
+
+
+extern wchar_t *__wcsncpy_chk (wchar_t *__restrict __dest,
+			       const wchar_t *__restrict __src, size_t __n,
+			       size_t __destlen) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wcsncpy_alias,
+				(wchar_t *__restrict __dest,
+				 const wchar_t *__restrict __src,
+				 size_t __n), wcsncpy);
+extern wchar_t *__REDIRECT_NTH (__wcsncpy_chk_warn,
+				(wchar_t *__restrict __dest,
+				 const wchar_t *__restrict __src,
+				 size_t __n, size_t __destlen), __wcsncpy_chk)
+     __warnattr ("wcsncpy called with length bigger than size of destination "
+		 "buffer");
+
+__fortify_function wchar_t *
+__NTH (wcsncpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src,
+		size_t __n))
+{
+  if (__bos (__dest) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n))
+	return __wcsncpy_chk (__dest, __src, __n,
+			      __bos (__dest) / sizeof (wchar_t));
+      if (__n > __bos (__dest) / sizeof (wchar_t))
+	return __wcsncpy_chk_warn (__dest, __src, __n,
+				   __bos (__dest) / sizeof (wchar_t));
+    }
+  return __wcsncpy_alias (__dest, __src, __n);
+}
+
+
+extern wchar_t *__wcpncpy_chk (wchar_t *__restrict __dest,
+			       const wchar_t *__restrict __src, size_t __n,
+			       size_t __destlen) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wcpncpy_alias,
+				(wchar_t *__restrict __dest,
+				 const wchar_t *__restrict __src,
+				 size_t __n), wcpncpy);
+extern wchar_t *__REDIRECT_NTH (__wcpncpy_chk_warn,
+				(wchar_t *__restrict __dest,
+				 const wchar_t *__restrict __src,
+				 size_t __n, size_t __destlen), __wcpncpy_chk)
+     __warnattr ("wcpncpy called with length bigger than size of destination "
+		 "buffer");
+
+__fortify_function wchar_t *
+__NTH (wcpncpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src,
+		size_t __n))
+{
+  if (__bos (__dest) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n))
+	return __wcpncpy_chk (__dest, __src, __n,
+			      __bos (__dest) / sizeof (wchar_t));
+      if (__n > __bos (__dest) / sizeof (wchar_t))
+	return __wcpncpy_chk_warn (__dest, __src, __n,
+				   __bos (__dest) / sizeof (wchar_t));
+    }
+  return __wcpncpy_alias (__dest, __src, __n);
+}
+
+
+extern wchar_t *__wcscat_chk (wchar_t *__restrict __dest,
+			      const wchar_t *__restrict __src,
+			      size_t __destlen) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wcscat_alias,
+				(wchar_t *__restrict __dest,
+				 const wchar_t *__restrict __src), wcscat);
+
+__fortify_function wchar_t *
+__NTH (wcscat (wchar_t *__restrict __dest, const wchar_t *__restrict __src))
+{
+  if (__bos (__dest) != (size_t) -1)
+    return __wcscat_chk (__dest, __src, __bos (__dest) / sizeof (wchar_t));
+  return __wcscat_alias (__dest, __src);
+}
+
+
+extern wchar_t *__wcsncat_chk (wchar_t *__restrict __dest,
+			       const wchar_t *__restrict __src,
+			       size_t __n, size_t __destlen) __THROW;
+extern wchar_t *__REDIRECT_NTH (__wcsncat_alias,
+				(wchar_t *__restrict __dest,
+				 const wchar_t *__restrict __src,
+				 size_t __n), wcsncat);
+
+__fortify_function wchar_t *
+__NTH (wcsncat (wchar_t *__restrict __dest, const wchar_t *__restrict __src,
+		size_t __n))
+{
+  if (__bos (__dest) != (size_t) -1)
+    return __wcsncat_chk (__dest, __src, __n,
+			  __bos (__dest) / sizeof (wchar_t));
+  return __wcsncat_alias (__dest, __src, __n);
+}
+
+
+extern int __swprintf_chk (wchar_t *__restrict __s, size_t __n,
+			   int __flag, size_t __s_len,
+			   const wchar_t *__restrict __format, ...)
+     __THROW /* __attribute__ ((__format__ (__wprintf__, 5, 6))) */;
+
+extern int __REDIRECT_NTH_LDBL (__swprintf_alias,
+				(wchar_t *__restrict __s, size_t __n,
+				 const wchar_t *__restrict __fmt, ...),
+				swprintf);
+
+#ifdef __va_arg_pack
+__fortify_function int
+__NTH (swprintf (wchar_t *__restrict __s, size_t __n,
+		 const wchar_t *__restrict __fmt, ...))
+{
+  if (__bos (__s) != (size_t) -1 || __USE_FORTIFY_LEVEL > 1)
+    return __swprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
+			   __bos (__s) / sizeof (wchar_t),
+			   __fmt, __va_arg_pack ());
+  return __swprintf_alias (__s, __n, __fmt, __va_arg_pack ());
+}
+#elif !defined __cplusplus
+/* XXX We might want to have support in gcc for swprintf.  */
+# define swprintf(s, n, ...) \
+  (__bos (s) != (size_t) -1 || __USE_FORTIFY_LEVEL > 1			      \
+   ? __swprintf_chk (s, n, __USE_FORTIFY_LEVEL - 1,			      \
+		     __bos (s) / sizeof (wchar_t), __VA_ARGS__)		      \
+   : swprintf (s, n, __VA_ARGS__))
+#endif
+
+extern int __vswprintf_chk (wchar_t *__restrict __s, size_t __n,
+			    int __flag, size_t __s_len,
+			    const wchar_t *__restrict __format,
+			    __gnuc_va_list __arg)
+     __THROW /* __attribute__ ((__format__ (__wprintf__, 5, 0))) */;
+
+extern int __REDIRECT_NTH_LDBL (__vswprintf_alias,
+				(wchar_t *__restrict __s, size_t __n,
+				 const wchar_t *__restrict __fmt,
+				 __gnuc_va_list __ap), vswprintf);
+
+__fortify_function int
+__NTH (vswprintf (wchar_t *__restrict __s, size_t __n,
+		  const wchar_t *__restrict __fmt, __gnuc_va_list __ap))
+{
+  if (__bos (__s) != (size_t) -1 || __USE_FORTIFY_LEVEL > 1)
+    return __vswprintf_chk (__s, __n,  __USE_FORTIFY_LEVEL - 1,
+			    __bos (__s) / sizeof (wchar_t), __fmt, __ap);
+  return __vswprintf_alias (__s, __n, __fmt, __ap);
+}
+
+
+#if __USE_FORTIFY_LEVEL > 1
+
+extern int __fwprintf_chk (__FILE *__restrict __stream, int __flag,
+			   const wchar_t *__restrict __format, ...);
+extern int __wprintf_chk (int __flag, const wchar_t *__restrict __format,
+			  ...);
+extern int __vfwprintf_chk (__FILE *__restrict __stream, int __flag,
+			    const wchar_t *__restrict __format,
+			    __gnuc_va_list __ap);
+extern int __vwprintf_chk (int __flag, const wchar_t *__restrict __format,
+			   __gnuc_va_list __ap);
+
+# ifdef __va_arg_pack
+__fortify_function int
+wprintf (const wchar_t *__restrict __fmt, ...)
+{
+  return __wprintf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
+}
+
+__fortify_function int
+fwprintf (__FILE *__restrict __stream, const wchar_t *__restrict __fmt, ...)
+{
+  return __fwprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
+			 __va_arg_pack ());
+}
+# elif !defined __cplusplus
+#  define wprintf(...) \
+  __wprintf_chk (__USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+#  define fwprintf(stream, ...) \
+  __fwprintf_chk (stream, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+# endif
+
+__fortify_function int
+vwprintf (const wchar_t *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vwprintf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __ap);
+}
+
+__fortify_function int
+vfwprintf (__FILE *__restrict __stream,
+	   const wchar_t *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vfwprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
+}
+
+#endif
+
+extern wchar_t *__fgetws_chk (wchar_t *__restrict __s, size_t __size, int __n,
+			      __FILE *__restrict __stream) __wur;
+extern wchar_t *__REDIRECT (__fgetws_alias,
+			    (wchar_t *__restrict __s, int __n,
+			     __FILE *__restrict __stream), fgetws) __wur;
+extern wchar_t *__REDIRECT (__fgetws_chk_warn,
+			    (wchar_t *__restrict __s, size_t __size, int __n,
+			     __FILE *__restrict __stream), __fgetws_chk)
+     __wur __warnattr ("fgetws called with bigger size than length "
+		       "of destination buffer");
+
+__fortify_function __wur wchar_t *
+fgetws (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
+{
+  if (__bos (__s) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n) || __n <= 0)
+	return __fgetws_chk (__s, __bos (__s) / sizeof (wchar_t),
+			     __n, __stream);
+
+      if ((size_t) __n > __bos (__s) / sizeof (wchar_t))
+	return __fgetws_chk_warn (__s, __bos (__s) / sizeof (wchar_t),
+				  __n, __stream);
+    }
+  return __fgetws_alias (__s, __n, __stream);
+}
+
+#ifdef __USE_GNU
+extern wchar_t *__fgetws_unlocked_chk (wchar_t *__restrict __s, size_t __size,
+				       int __n, __FILE *__restrict __stream)
+  __wur;
+extern wchar_t *__REDIRECT (__fgetws_unlocked_alias,
+			    (wchar_t *__restrict __s, int __n,
+			     __FILE *__restrict __stream), fgetws_unlocked)
+  __wur;
+extern wchar_t *__REDIRECT (__fgetws_unlocked_chk_warn,
+			    (wchar_t *__restrict __s, size_t __size, int __n,
+			     __FILE *__restrict __stream),
+			    __fgetws_unlocked_chk)
+     __wur __warnattr ("fgetws_unlocked called with bigger size than length "
+		       "of destination buffer");
+
+__fortify_function __wur wchar_t *
+fgetws_unlocked (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
+{
+  if (__bos (__s) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n) || __n <= 0)
+	return __fgetws_unlocked_chk (__s, __bos (__s) / sizeof (wchar_t),
+				      __n, __stream);
+
+      if ((size_t) __n > __bos (__s) / sizeof (wchar_t))
+	return __fgetws_unlocked_chk_warn (__s, __bos (__s) / sizeof (wchar_t),
+					   __n, __stream);
+    }
+  return __fgetws_unlocked_alias (__s, __n, __stream);
+}
+#endif
+
+
+extern size_t __wcrtomb_chk (char *__restrict __s, wchar_t __wchar,
+			     mbstate_t *__restrict __p,
+			     size_t __buflen) __THROW __wur;
+extern size_t __REDIRECT_NTH (__wcrtomb_alias,
+			      (char *__restrict __s, wchar_t __wchar,
+			       mbstate_t *__restrict __ps), wcrtomb) __wur;
+
+__fortify_function __wur size_t
+__NTH (wcrtomb (char *__restrict __s, wchar_t __wchar,
+		mbstate_t *__restrict __ps))
+{
+  /* We would have to include <limits.h> to get a definition of MB_LEN_MAX.
+     But this would only disturb the namespace.  So we define our own
+     version here.  */
+#define __WCHAR_MB_LEN_MAX	16
+#if defined MB_LEN_MAX && MB_LEN_MAX != __WCHAR_MB_LEN_MAX
+# error "Assumed value of MB_LEN_MAX wrong"
+#endif
+  if (__bos (__s) != (size_t) -1 && __WCHAR_MB_LEN_MAX > __bos (__s))
+    return __wcrtomb_chk (__s, __wchar, __ps, __bos (__s));
+  return __wcrtomb_alias (__s, __wchar, __ps);
+}
+
+
+extern size_t __mbsrtowcs_chk (wchar_t *__restrict __dst,
+			       const char **__restrict __src,
+			       size_t __len, mbstate_t *__restrict __ps,
+			       size_t __dstlen) __THROW;
+extern size_t __REDIRECT_NTH (__mbsrtowcs_alias,
+			      (wchar_t *__restrict __dst,
+			       const char **__restrict __src,
+			       size_t __len, mbstate_t *__restrict __ps),
+			      mbsrtowcs);
+extern size_t __REDIRECT_NTH (__mbsrtowcs_chk_warn,
+			      (wchar_t *__restrict __dst,
+			       const char **__restrict __src,
+			       size_t __len, mbstate_t *__restrict __ps,
+			       size_t __dstlen), __mbsrtowcs_chk)
+     __warnattr ("mbsrtowcs called with dst buffer smaller than len "
+		 "* sizeof (wchar_t)");
+
+__fortify_function size_t
+__NTH (mbsrtowcs (wchar_t *__restrict __dst, const char **__restrict __src,
+		  size_t __len, mbstate_t *__restrict __ps))
+{
+  if (__bos (__dst) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+	return __mbsrtowcs_chk (__dst, __src, __len, __ps,
+				__bos (__dst) / sizeof (wchar_t));
+
+      if (__len > __bos (__dst) / sizeof (wchar_t))
+	return __mbsrtowcs_chk_warn (__dst, __src, __len, __ps,
+				     __bos (__dst) / sizeof (wchar_t));
+    }
+  return __mbsrtowcs_alias (__dst, __src, __len, __ps);
+}
+
+
+extern size_t __wcsrtombs_chk (char *__restrict __dst,
+			       const wchar_t **__restrict __src,
+			       size_t __len, mbstate_t *__restrict __ps,
+			       size_t __dstlen) __THROW;
+extern size_t __REDIRECT_NTH (__wcsrtombs_alias,
+			      (char *__restrict __dst,
+			       const wchar_t **__restrict __src,
+			       size_t __len, mbstate_t *__restrict __ps),
+			      wcsrtombs);
+extern size_t __REDIRECT_NTH (__wcsrtombs_chk_warn,
+			      (char *__restrict __dst,
+			       const wchar_t **__restrict __src,
+			       size_t __len, mbstate_t *__restrict __ps,
+			       size_t __dstlen), __wcsrtombs_chk)
+    __warnattr ("wcsrtombs called with dst buffer smaller than len");
+
+__fortify_function size_t
+__NTH (wcsrtombs (char *__restrict __dst, const wchar_t **__restrict __src,
+		  size_t __len, mbstate_t *__restrict __ps))
+{
+  if (__bos (__dst) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+	return __wcsrtombs_chk (__dst, __src, __len, __ps, __bos (__dst));
+
+      if (__len > __bos (__dst))
+	return __wcsrtombs_chk_warn (__dst, __src, __len, __ps, __bos (__dst));
+    }
+  return __wcsrtombs_alias (__dst, __src, __len, __ps);
+}
+
+
+#ifdef __USE_GNU
+extern size_t __mbsnrtowcs_chk (wchar_t *__restrict __dst,
+				const char **__restrict __src, size_t __nmc,
+				size_t __len, mbstate_t *__restrict __ps,
+				size_t __dstlen) __THROW;
+extern size_t __REDIRECT_NTH (__mbsnrtowcs_alias,
+			      (wchar_t *__restrict __dst,
+			       const char **__restrict __src, size_t __nmc,
+			       size_t __len, mbstate_t *__restrict __ps),
+			      mbsnrtowcs);
+extern size_t __REDIRECT_NTH (__mbsnrtowcs_chk_warn,
+			      (wchar_t *__restrict __dst,
+			       const char **__restrict __src, size_t __nmc,
+			       size_t __len, mbstate_t *__restrict __ps,
+			       size_t __dstlen), __mbsnrtowcs_chk)
+     __warnattr ("mbsnrtowcs called with dst buffer smaller than len "
+		 "* sizeof (wchar_t)");
+
+__fortify_function size_t
+__NTH (mbsnrtowcs (wchar_t *__restrict __dst, const char **__restrict __src,
+		   size_t __nmc, size_t __len, mbstate_t *__restrict __ps))
+{
+  if (__bos (__dst) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+	return __mbsnrtowcs_chk (__dst, __src, __nmc, __len, __ps,
+				 __bos (__dst) / sizeof (wchar_t));
+
+      if (__len > __bos (__dst) / sizeof (wchar_t))
+	return __mbsnrtowcs_chk_warn (__dst, __src, __nmc, __len, __ps,
+				      __bos (__dst) / sizeof (wchar_t));
+    }
+  return __mbsnrtowcs_alias (__dst, __src, __nmc, __len, __ps);
+}
+
+
+extern size_t __wcsnrtombs_chk (char *__restrict __dst,
+				const wchar_t **__restrict __src,
+				size_t __nwc, size_t __len,
+				mbstate_t *__restrict __ps, size_t __dstlen)
+     __THROW;
+extern size_t __REDIRECT_NTH (__wcsnrtombs_alias,
+			      (char *__restrict __dst,
+			       const wchar_t **__restrict __src,
+			       size_t __nwc, size_t __len,
+			       mbstate_t *__restrict __ps), wcsnrtombs);
+extern size_t __REDIRECT_NTH (__wcsnrtombs_chk_warn,
+			      (char *__restrict __dst,
+			       const wchar_t **__restrict __src,
+			       size_t __nwc, size_t __len,
+			       mbstate_t *__restrict __ps,
+			       size_t __dstlen), __wcsnrtombs_chk)
+     __warnattr ("wcsnrtombs called with dst buffer smaller than len");
+
+__fortify_function size_t
+__NTH (wcsnrtombs (char *__restrict __dst, const wchar_t **__restrict __src,
+		   size_t __nwc, size_t __len, mbstate_t *__restrict __ps))
+{
+  if (__bos (__dst) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+	return __wcsnrtombs_chk (__dst, __src, __nwc, __len, __ps,
+				 __bos (__dst));
+
+      if (__len > __bos (__dst))
+	return __wcsnrtombs_chk_warn (__dst, __src, __nwc, __len, __ps,
+				      __bos (__dst));
+    }
+  return __wcsnrtombs_alias (__dst, __src, __nwc, __len, __ps);
+}
+#endif
diff --git a/include/bits/wordsize.h b/include/bits/wordsize.h
new file mode 100644
index 0000000..e25af28
--- /dev/null
+++ b/include/bits/wordsize.h
@@ -0,0 +1,13 @@
+/* Determine the wordsize from the preprocessor defines.  */
+
+#if defined __x86_64__ && !defined __ILP32__
+# define __WORDSIZE	64
+#else
+# define __WORDSIZE	32
+#endif
+
+#ifdef __x86_64__
+# define __WORDSIZE_TIME64_COMPAT32	1
+/* Both x86-64 and x32 use the 64-bit system call interface.  */
+# define __SYSCALL_WORDSIZE		64
+#endif
diff --git a/include/bits/xopen_lim.h b/include/bits/xopen_lim.h
new file mode 100644
index 0000000..63fd1d8
--- /dev/null
+++ b/include/bits/xopen_lim.h
@@ -0,0 +1,143 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Never include this file directly; use <limits.h> instead.
+ */
+
+/* Additional definitions from X/Open Portability Guide, Issue 4, Version 2
+   System Interfaces and Headers, 4.16 <limits.h>
+
+   Please note only the values which are not greater than the minimum
+   stated in the standard document are listed.  The `sysconf' functions
+   should be used to obtain the actual value.  */
+
+#ifndef _XOPEN_LIM_H
+#define _XOPEN_LIM_H	1
+
+#define __need_IOV_MAX
+#include <bits/stdio_lim.h>
+
+/* We do not provide fixed values for
+
+   ARG_MAX	Maximum length of argument to the `exec' function
+		including environment data.
+
+   ATEXIT_MAX	Maximum number of functions that may be registered
+		with `atexit'.
+
+   CHILD_MAX	Maximum number of simultaneous processes per real
+		user ID.
+
+   OPEN_MAX	Maximum number of files that one process can have open
+		at anyone time.
+
+   PAGESIZE
+   PAGE_SIZE	Size of bytes of a page.
+
+   PASS_MAX	Maximum number of significant bytes in a password.
+
+   We only provide a fixed limit for
+
+   IOV_MAX	Maximum number of `iovec' structures that one process has
+		available for use with `readv' or writev'.
+
+   if this is indeed fixed by the underlying system.
+*/
+
+
+/* Maximum number of `iovec' structures that one process has available
+   for use with `readv' or writev'.  */
+#define	_XOPEN_IOV_MAX	_POSIX_UIO_MAXIOV
+
+
+/* Maximum value of `digit' in calls to the `printf' and `scanf'
+   functions.  We have no limit, so return a reasonable value.  */
+#define NL_ARGMAX	_POSIX_ARG_MAX
+
+/* Maximum number of bytes in a `LANG' name.  We have no limit.  */
+#define NL_LANGMAX	_POSIX2_LINE_MAX
+
+/* Maximum message number.  We have no limit.  */
+#define NL_MSGMAX	INT_MAX
+
+/* Maximum number of bytes in N-to-1 collation mapping.  We have no
+   limit.  */
+#define NL_NMAX		INT_MAX
+
+/* Maximum set number.  We have no limit.  */
+#define NL_SETMAX	INT_MAX
+
+/* Maximum number of bytes in a message.  We have no limit.  */
+#define NL_TEXTMAX	INT_MAX
+
+/* Default process priority.  */
+#define NZERO		20
+
+
+/* Number of bits in a word of type `int'.  */
+#ifdef INT_MAX
+# if INT_MAX == 32767
+#  define WORD_BIT	16
+# else
+#  if INT_MAX == 2147483647
+#   define WORD_BIT	32
+#  else
+/* Safe assumption.  */
+#   define WORD_BIT	64
+#  endif
+# endif
+#elif defined __INT_MAX__
+# if __INT_MAX__ == 32767
+#  define WORD_BIT	16
+# else
+#  if __INT_MAX__ == 2147483647
+#   define WORD_BIT	32
+#  else
+/* Safe assumption.  */
+#   define WORD_BIT	64
+#  endif
+# endif
+#else
+# define WORD_BIT	32
+#endif
+
+/* Number of bits in a word of type `long int'.  */
+#ifdef LONG_MAX
+# if LONG_MAX == 2147483647
+#  define LONG_BIT	32
+# else
+/* Safe assumption.  */
+#  define LONG_BIT	64
+# endif
+#elif defined __LONG_MAX__
+# if __LONG_MAX__ == 2147483647
+#  define LONG_BIT	32
+# else
+/* Safe assumption.  */
+#  define LONG_BIT	64
+# endif
+#else
+# include <bits/wordsize.h>
+# if __WORDSIZE == 64
+#  define LONG_BIT	64
+# else
+#  define LONG_BIT	32
+# endif
+#endif
+
+#endif /* bits/xopen_lim.h */
diff --git a/include/bits/xtitypes.h b/include/bits/xtitypes.h
new file mode 100644
index 0000000..37aba9e
--- /dev/null
+++ b/include/bits/xtitypes.h
@@ -0,0 +1,33 @@
+/* bits/xtitypes.h -- Define some types used by <bits/stropts.h>.  x86-64.
+   Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STROPTS_H
+# error "Never include <bits/xtitypes.h> directly; use <stropts.h> instead."
+#endif
+
+#ifndef _BITS_XTITYPES_H
+#define _BITS_XTITYPES_H	1
+
+#include <bits/types.h>
+
+/* This type is used by some structs in <bits/stropts.h>.  */
+typedef __SLONG32_TYPE __t_scalar_t;
+typedef __ULONG32_TYPE __t_uscalar_t;
+
+
+#endif /* bits/xtitypes.h */
diff --git a/include/byteswap.h b/include/byteswap.h
new file mode 100644
index 0000000..cd76b44
--- /dev/null
+++ b/include/byteswap.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BYTESWAP_H
+#define _BYTESWAP_H	1
+
+#include <features.h>
+
+/* Get the machine specific, optimized definitions.  */
+#include <bits/byteswap.h>
+
+
+/* The following definitions must all be macros since otherwise some
+   of the possible optimizations are not possible.  */
+
+/* Return a value with all bytes in the 16 bit argument swapped.  */
+#define bswap_16(x) __bswap_16 (x)
+
+/* Return a value with all bytes in the 32 bit argument swapped.  */
+#define bswap_32(x) __bswap_32 (x)
+
+/* Return a value with all bytes in the 64 bit argument swapped.  */
+#define bswap_64(x) __bswap_64 (x)
+
+#endif /* byteswap.h */
diff --git a/include/complex.h b/include/complex.h
new file mode 100644
index 0000000..7ad247d
--- /dev/null
+++ b/include/complex.h
@@ -0,0 +1,112 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99:  7.3 Complex arithmetic	<complex.h>
+ */
+
+#ifndef _COMPLEX_H
+#define _COMPLEX_H	1
+
+#include <features.h>
+
+/* Get general and ISO C99 specific information.  */
+#include <bits/mathdef.h>
+
+__BEGIN_DECLS
+
+/* We might need to add support for more compilers here.  But since ISO
+   C99 is out hopefully all maintained compilers will soon provide the data
+   types `float complex' and `double complex'.  */
+#if __GNUC_PREREQ (2, 7) && !__GNUC_PREREQ (2, 97)
+# define _Complex __complex__
+#endif
+
+#define complex		_Complex
+
+/* Narrowest imaginary unit.  This depends on the floating-point
+   evaluation method.
+   XXX This probably has to go into a gcc related file.  */
+#define _Complex_I	(__extension__ 1.0iF)
+
+/* Another more descriptive name is `I'.
+   XXX Once we have the imaginary support switch this to _Imaginary_I.  */
+#undef I
+#define I _Complex_I
+
+#if defined __USE_ISOC11 && __GNUC_PREREQ (4, 7)
+/* Macros to expand into expression of specified complex type.  */
+# define CMPLX(x, y) __builtin_complex ((double) (x), (double) (y))
+# define CMPLXF(x, y) __builtin_complex ((float) (x), (float) (y))
+# define CMPLXL(x, y) __builtin_complex ((long double) (x), (long double) (y))
+#endif
+
+/* The file <bits/cmathcalls.h> contains the prototypes for all the
+   actual math functions.  These macros are used for those prototypes,
+   so we can easily declare each function as both `name' and `__name',
+   and can declare the float versions `namef' and `__namef'.  */
+
+#define __MATHCALL(function, args)	\
+  __MATHDECL (_Mdouble_complex_,function, args)
+#define __MATHDECL(type, function, args) \
+  __MATHDECL_1(type, function, args); \
+  __MATHDECL_1(type, __CONCAT(__,function), args)
+#define __MATHDECL_1(type, function, args) \
+  extern type __MATH_PRECNAME(function) args __THROW
+
+#define _Mdouble_ 		double
+#define __MATH_PRECNAME(name)	name
+#include <bits/cmathcalls.h>
+#undef	_Mdouble_
+#undef	__MATH_PRECNAME
+
+/* Now the float versions.  */
+#ifndef _Mfloat_
+# define _Mfloat_		float
+#endif
+#define _Mdouble_ 		_Mfloat_
+#define __MATH_PRECNAME(name)	name##f
+#include <bits/cmathcalls.h>
+#undef	_Mdouble_
+#undef	__MATH_PRECNAME
+
+/* And the long double versions.  It is non-critical to define them
+   here unconditionally since `long double' is required in ISO C99.  */
+#if !(defined __NO_LONG_DOUBLE_MATH && defined _LIBC)	\
+    || defined __LDBL_COMPAT
+# ifdef __LDBL_COMPAT
+#  undef __MATHDECL_1
+#  define __MATHDECL_1(type, function, args) \
+  extern type __REDIRECT_NTH(__MATH_PRECNAME(function), args, function)
+# endif
+
+# ifndef _Mlong_double_
+#  define _Mlong_double_	long double
+# endif
+# define _Mdouble_ 		_Mlong_double_
+# define __MATH_PRECNAME(name)	name##l
+# include <bits/cmathcalls.h>
+#endif
+#undef	_Mdouble_
+#undef	__MATH_PRECNAME
+#undef	__MATHDECL_1
+#undef	__MATHDECL
+#undef	__MATHCALL
+
+__END_DECLS
+
+#endif /* complex.h */
diff --git a/include/cpio.h b/include/cpio.h
new file mode 100644
index 0000000..db15a79
--- /dev/null
+++ b/include/cpio.h
@@ -0,0 +1,73 @@
+/* Extended cpio format from POSIX.1.
+   This file is part of the GNU C Library.
+   Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   NOTE: The canonical source of this file is maintained with the GNU cpio.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _CPIO_H
+#define _CPIO_H 1
+
+/* A cpio archive consists of a sequence of files.
+   Each file has a 76 byte header,
+   a variable length, NUL terminated filename,
+   and variable length file data.
+   A header for a filename "TRAILER!!!" indicates the end of the archive.  */
+
+/* All the fields in the header are ISO 646 (approximately ASCII) strings
+   of octal numbers, left padded, not NUL terminated.
+
+   Field Name	Length in Bytes	Notes
+   c_magic	6		must be "070707"
+   c_dev	6
+   c_ino	6
+   c_mode	6		see below for value
+   c_uid	6
+   c_gid	6
+   c_nlink	6
+   c_rdev	6		only valid for chr and blk special files
+   c_mtime	11
+   c_namesize	6		count includes terminating NUL in pathname
+   c_filesize	11		must be 0 for FIFOs and directories  */
+
+/* Value for the field `c_magic'.  */
+#define MAGIC	"070707"
+
+/* Values for c_mode, OR'd together: */
+
+#define C_IRUSR		000400
+#define C_IWUSR		000200
+#define C_IXUSR		000100
+#define C_IRGRP		000040
+#define C_IWGRP		000020
+#define C_IXGRP		000010
+#define C_IROTH		000004
+#define C_IWOTH		000002
+#define C_IXOTH		000001
+
+#define C_ISUID		004000
+#define C_ISGID		002000
+#define C_ISVTX		001000
+
+#define C_ISBLK		060000
+#define C_ISCHR		020000
+#define C_ISDIR		040000
+#define C_ISFIFO	010000
+#define C_ISSOCK	0140000
+#define C_ISLNK		0120000
+#define C_ISCTG		0110000
+#define C_ISREG		0100000
+
+#endif /* cpio.h */
diff --git a/include/crypt.h b/include/crypt.h
new file mode 100644
index 0000000..f95a2bd
--- /dev/null
+++ b/include/crypt.h
@@ -0,0 +1,75 @@
+/*
+ * UFC-crypt: ultra fast crypt(3) implementation
+ *
+ * Copyright (C) 1991-2014 Free Software Foundation, Inc.
+ *
+ * The GNU C Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * The GNU C Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the GNU C Library; if not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * @(#)crypt.h	1.5 12/20/96
+ *
+ */
+
+#ifndef _CRYPT_H
+#define _CRYPT_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Encrypt at most 8 characters from KEY using salt to perturb DES.  */
+extern char *crypt (const char *__key, const char *__salt)
+     __THROW __nonnull ((1, 2));
+
+/* Setup DES tables according KEY.  */
+extern void setkey (const char *__key) __THROW __nonnull ((1));
+
+/* Encrypt data in BLOCK in place if EDFLAG is zero; otherwise decrypt
+   block in place.  */
+extern void encrypt (char *__glibc_block, int __edflag)
+     __THROW __nonnull ((1));
+
+#ifdef __USE_GNU
+/* Reentrant versions of the functions above.  The additional argument
+   points to a structure where the results are placed in.  */
+struct crypt_data
+  {
+    char keysched[16 * 8];
+    char sb0[32768];
+    char sb1[32768];
+    char sb2[32768];
+    char sb3[32768];
+    /* end-of-aligment-critical-data */
+    char crypt_3_buf[14];
+    char current_salt[2];
+    long int current_saltbits;
+    int  direction, initialized;
+  };
+
+extern char *crypt_r (const char *__key, const char *__salt,
+		      struct crypt_data * __restrict __data)
+     __THROW __nonnull ((1, 2, 3));
+
+extern void setkey_r (const char *__key,
+		      struct crypt_data * __restrict __data)
+     __THROW __nonnull ((1, 2));
+
+extern void encrypt_r (char *__glibc_block, int __edflag,
+		       struct crypt_data * __restrict __data)
+     __THROW __nonnull ((1, 3));
+#endif
+
+__END_DECLS
+
+#endif	/* crypt.h */
diff --git a/include/ctype.h b/include/ctype.h
new file mode 100644
index 0000000..e15749c
--- /dev/null
+++ b/include/ctype.h
@@ -0,0 +1,349 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard 7.4: Character handling	<ctype.h>
+ */
+
+#ifndef	_CTYPE_H
+#define	_CTYPE_H	1
+
+#include <features.h>
+#include <bits/types.h>
+
+__BEGIN_DECLS
+
+#ifndef _ISbit
+/* These are all the characteristics of characters.
+   If there get to be more than 16 distinct characteristics,
+   many things must be changed that use `unsigned short int's.
+
+   The characteristics are stored always in network byte order (big
+   endian).  We define the bit value interpretations here dependent on the
+   machine's byte order.  */
+
+# include <endian.h>
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define _ISbit(bit)	(1 << (bit))
+# else /* __BYTE_ORDER == __LITTLE_ENDIAN */
+#  define _ISbit(bit)	((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))
+# endif
+
+enum
+{
+  _ISupper = _ISbit (0),	/* UPPERCASE.  */
+  _ISlower = _ISbit (1),	/* lowercase.  */
+  _ISalpha = _ISbit (2),	/* Alphabetic.  */
+  _ISdigit = _ISbit (3),	/* Numeric.  */
+  _ISxdigit = _ISbit (4),	/* Hexadecimal numeric.  */
+  _ISspace = _ISbit (5),	/* Whitespace.  */
+  _ISprint = _ISbit (6),	/* Printing.  */
+  _ISgraph = _ISbit (7),	/* Graphical.  */
+  _ISblank = _ISbit (8),	/* Blank (usually SPC and TAB).  */
+  _IScntrl = _ISbit (9),	/* Control character.  */
+  _ISpunct = _ISbit (10),	/* Punctuation.  */
+  _ISalnum = _ISbit (11)	/* Alphanumeric.  */
+};
+#endif /* ! _ISbit  */
+
+/* These are defined in ctype-info.c.
+   The declarations here must match those in localeinfo.h.
+
+   In the thread-specific locale model (see `uselocale' in <locale.h>)
+   we cannot use global variables for these as was done in the past.
+   Instead, the following accessor functions return the address of
+   each variable, which is local to the current thread if multithreaded.
+
+   These point into arrays of 384, so they can be indexed by any `unsigned
+   char' value [0,255]; by EOF (-1); or by any `signed char' value
+   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
+   char' values and for EOF; we also support negative `signed char' values
+   for broken old programs.  The case conversion arrays are of `int's
+   rather than `unsigned char's because tolower (EOF) must be EOF, which
+   doesn't fit into an `unsigned char'.  But today more important is that
+   the arrays are also used for multi-byte character sets.  */
+extern const unsigned short int **__ctype_b_loc (void)
+     __THROW __attribute__ ((__const__));
+extern const __int32_t **__ctype_tolower_loc (void)
+     __THROW __attribute__ ((__const__));
+extern const __int32_t **__ctype_toupper_loc (void)
+     __THROW __attribute__ ((__const__));
+
+
+#ifndef __cplusplus
+# define __isctype(c, type) \
+  ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)
+#elif defined __USE_EXTERN_INLINES
+# define __isctype_f(type) \
+  __extern_inline int							      \
+  is##type (int __c) __THROW						      \
+  {									      \
+    return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _IS##type; \
+  }
+#endif
+
+#define	__isascii(c)	(((c) & ~0x7f) == 0)	/* If C is a 7 bit value.  */
+#define	__toascii(c)	((c) & 0x7f)		/* Mask off high bits.  */
+
+#define	__exctype(name)	extern int name (int) __THROW
+
+__BEGIN_NAMESPACE_STD
+
+/* The following names are all functions:
+     int isCHARACTERISTIC(int c);
+   which return nonzero iff C has CHARACTERISTIC.
+   For the meaning of the characteristic names, see the `enum' above.  */
+__exctype (isalnum);
+__exctype (isalpha);
+__exctype (iscntrl);
+__exctype (isdigit);
+__exctype (islower);
+__exctype (isgraph);
+__exctype (isprint);
+__exctype (ispunct);
+__exctype (isspace);
+__exctype (isupper);
+__exctype (isxdigit);
+
+
+/* Return the lowercase version of C.  */
+extern int tolower (int __c) __THROW;
+
+/* Return the uppercase version of C.  */
+extern int toupper (int __c) __THROW;
+
+__END_NAMESPACE_STD
+
+
+/* ISO C99 introduced one new function.  */
+#ifdef	__USE_ISOC99
+__BEGIN_NAMESPACE_C99
+
+__exctype (isblank);
+
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_GNU
+/* Test C for a set of character classes according to MASK.  */
+extern int isctype (int __c, int __mask) __THROW;
+#endif
+
+#if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN
+
+/* Return nonzero iff C is in the ASCII set
+   (i.e., is no more than 7 bits wide).  */
+extern int isascii (int __c) __THROW;
+
+/* Return the part of C that is in the ASCII set
+   (i.e., the low-order 7 bits of C).  */
+extern int toascii (int __c) __THROW;
+
+/* These are the same as `toupper' and `tolower' except that they do not
+   check the argument for being in the range of a `char'.  */
+__exctype (_toupper);
+__exctype (_tolower);
+#endif /* Use SVID or use misc.  */
+
+/* This code is needed for the optimized mapping functions.  */
+#define __tobody(c, f, a, args) \
+  (__extension__							      \
+   ({ int __res;							      \
+      if (sizeof (c) > 1)						      \
+	{								      \
+	  if (__builtin_constant_p (c))					      \
+	    {								      \
+	      int __c = (c);						      \
+	      __res = __c < -128 || __c > 255 ? __c : (a)[__c];		      \
+	    }								      \
+	  else								      \
+	    __res = f args;						      \
+	}								      \
+      else								      \
+	__res = (a)[(int) (c)];						      \
+      __res; }))
+
+#if !defined __NO_CTYPE
+# ifdef __isctype_f
+__isctype_f (alnum)
+__isctype_f (alpha)
+__isctype_f (cntrl)
+__isctype_f (digit)
+__isctype_f (lower)
+__isctype_f (graph)
+__isctype_f (print)
+__isctype_f (punct)
+__isctype_f (space)
+__isctype_f (upper)
+__isctype_f (xdigit)
+#  ifdef __USE_ISOC99
+__isctype_f (blank)
+#  endif
+# elif defined __isctype
+# define isalnum(c)	__isctype((c), _ISalnum)
+# define isalpha(c)	__isctype((c), _ISalpha)
+# define iscntrl(c)	__isctype((c), _IScntrl)
+# define isdigit(c)	__isctype((c), _ISdigit)
+# define islower(c)	__isctype((c), _ISlower)
+# define isgraph(c)	__isctype((c), _ISgraph)
+# define isprint(c)	__isctype((c), _ISprint)
+# define ispunct(c)	__isctype((c), _ISpunct)
+# define isspace(c)	__isctype((c), _ISspace)
+# define isupper(c)	__isctype((c), _ISupper)
+# define isxdigit(c)	__isctype((c), _ISxdigit)
+#  ifdef __USE_ISOC99
+#   define isblank(c)	__isctype((c), _ISblank)
+#  endif
+# endif
+
+# ifdef __USE_EXTERN_INLINES
+__extern_inline int
+__NTH (tolower (int __c))
+{
+  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
+}
+
+__extern_inline int
+__NTH (toupper (int __c))
+{
+  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
+}
+# endif
+
+# if __GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus
+#  define tolower(c)	__tobody (c, tolower, *__ctype_tolower_loc (), (c))
+#  define toupper(c)	__tobody (c, toupper, *__ctype_toupper_loc (), (c))
+# endif /* Optimizing gcc */
+
+# if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN
+#  define isascii(c)	__isascii (c)
+#  define toascii(c)	__toascii (c)
+
+#  define _tolower(c)	((int) (*__ctype_tolower_loc ())[(int) (c)])
+#  define _toupper(c)	((int) (*__ctype_toupper_loc ())[(int) (c)])
+# endif
+
+#endif /* Not __NO_CTYPE.  */
+
+
+#ifdef __USE_XOPEN2K8
+/* The concept of one static locale per category is not very well
+   thought out.  Many applications will need to process its data using
+   information from several different locales.  Another application is
+   the implementation of the internationalization handling in the
+   upcoming ISO C++ standard library.  To support this another set of
+   the functions using locale data exist which have an additional
+   argument.
+
+   Attention: all these functions are *not* standardized in any form.
+   This is a proof-of-concept implementation.  */
+
+/* Structure for reentrant locale using functions.  This is an
+   (almost) opaque type for the user level programs.  */
+# include <xlocale.h>
+
+/* These definitions are similar to the ones above but all functions
+   take as an argument a handle for the locale which shall be used.  */
+#  define __isctype_l(c, type, locale) \
+  ((locale)->__ctype_b[(int) (c)] & (unsigned short int) type)
+
+# define __exctype_l(name) 						      \
+  extern int name (int, __locale_t) __THROW
+
+/* The following names are all functions:
+     int isCHARACTERISTIC(int c, locale_t *locale);
+   which return nonzero iff C has CHARACTERISTIC.
+   For the meaning of the characteristic names, see the `enum' above.  */
+__exctype_l (isalnum_l);
+__exctype_l (isalpha_l);
+__exctype_l (iscntrl_l);
+__exctype_l (isdigit_l);
+__exctype_l (islower_l);
+__exctype_l (isgraph_l);
+__exctype_l (isprint_l);
+__exctype_l (ispunct_l);
+__exctype_l (isspace_l);
+__exctype_l (isupper_l);
+__exctype_l (isxdigit_l);
+
+__exctype_l (isblank_l);
+
+
+/* Return the lowercase version of C in locale L.  */
+extern int __tolower_l (int __c, __locale_t __l) __THROW;
+extern int tolower_l (int __c, __locale_t __l) __THROW;
+
+/* Return the uppercase version of C.  */
+extern int __toupper_l (int __c, __locale_t __l) __THROW;
+extern int toupper_l (int __c, __locale_t __l) __THROW;
+
+# if __GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus
+#  define __tolower_l(c, locale) \
+  __tobody (c, __tolower_l, (locale)->__ctype_tolower, (c, locale))
+#  define __toupper_l(c, locale) \
+  __tobody (c, __toupper_l, (locale)->__ctype_toupper, (c, locale))
+#  define tolower_l(c, locale)	__tolower_l ((c), (locale))
+#  define toupper_l(c, locale)	__toupper_l ((c), (locale))
+# endif	/* Optimizing gcc */
+
+
+# ifndef __NO_CTYPE
+#  define __isalnum_l(c,l)	__isctype_l((c), _ISalnum, (l))
+#  define __isalpha_l(c,l)	__isctype_l((c), _ISalpha, (l))
+#  define __iscntrl_l(c,l)	__isctype_l((c), _IScntrl, (l))
+#  define __isdigit_l(c,l)	__isctype_l((c), _ISdigit, (l))
+#  define __islower_l(c,l)	__isctype_l((c), _ISlower, (l))
+#  define __isgraph_l(c,l)	__isctype_l((c), _ISgraph, (l))
+#  define __isprint_l(c,l)	__isctype_l((c), _ISprint, (l))
+#  define __ispunct_l(c,l)	__isctype_l((c), _ISpunct, (l))
+#  define __isspace_l(c,l)	__isctype_l((c), _ISspace, (l))
+#  define __isupper_l(c,l)	__isctype_l((c), _ISupper, (l))
+#  define __isxdigit_l(c,l)	__isctype_l((c), _ISxdigit, (l))
+
+#  define __isblank_l(c,l)	__isctype_l((c), _ISblank, (l))
+
+#  if defined __USE_SVID || defined __USE_MISC
+#   define __isascii_l(c,l)	((l), __isascii (c))
+#   define __toascii_l(c,l)	((l), __toascii (c))
+#  endif
+
+#  define isalnum_l(c,l)	__isalnum_l ((c), (l))
+#  define isalpha_l(c,l)	__isalpha_l ((c), (l))
+#  define iscntrl_l(c,l)	__iscntrl_l ((c), (l))
+#  define isdigit_l(c,l)	__isdigit_l ((c), (l))
+#  define islower_l(c,l)	__islower_l ((c), (l))
+#  define isgraph_l(c,l)	__isgraph_l ((c), (l))
+#  define isprint_l(c,l)	__isprint_l ((c), (l))
+#  define ispunct_l(c,l)	__ispunct_l ((c), (l))
+#  define isspace_l(c,l)	__isspace_l ((c), (l))
+#  define isupper_l(c,l)	__isupper_l ((c), (l))
+#  define isxdigit_l(c,l)	__isxdigit_l ((c), (l))
+
+#  define isblank_l(c,l)	__isblank_l ((c), (l))
+
+#  if defined __USE_SVID || defined __USE_MISC
+#   define isascii_l(c,l)	__isascii_l ((c), (l))
+#   define toascii_l(c,l)	__toascii_l ((c), (l))
+#  endif
+
+# endif /* Not __NO_CTYPE.  */
+
+#endif /* Use POSIX 2008.  */
+
+__END_DECLS
+
+#endif /* ctype.h  */
diff --git a/include/device/device.h b/include/device/device.h
new file mode 100644
index 0000000..98175d3
--- /dev/null
+++ b/include/device/device.h
@@ -0,0 +1,325 @@
+#ifndef	_device_user_
+#define	_device_user_
+
+/* Module device */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+
+/* Routine device_open */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_open
+(
+	mach_port_t master_port,
+	dev_mode_t mode,
+	dev_name_t name,
+	mach_port_t *device
+);
+
+/* Routine device_close */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_close
+(
+	mach_port_t device
+);
+
+/* Routine device_write */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_write
+(
+	mach_port_t device,
+	dev_mode_t mode,
+	recnum_t recnum,
+	io_buf_ptr_t data,
+	mach_msg_type_number_t dataCnt,
+	int *bytes_written
+);
+
+/* Routine device_write_inband */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_write_inband
+(
+	mach_port_t device,
+	dev_mode_t mode,
+	recnum_t recnum,
+	io_buf_ptr_inband_t data,
+	mach_msg_type_number_t dataCnt,
+	int *bytes_written
+);
+
+/* Routine device_read */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_read
+(
+	mach_port_t device,
+	dev_mode_t mode,
+	recnum_t recnum,
+	int bytes_wanted,
+	io_buf_ptr_t *data,
+	mach_msg_type_number_t *dataCnt
+);
+
+/* Routine device_read_inband */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_read_inband
+(
+	mach_port_t device,
+	dev_mode_t mode,
+	recnum_t recnum,
+	int bytes_wanted,
+	io_buf_ptr_inband_t data,
+	mach_msg_type_number_t *dataCnt
+);
+
+/* Routine device_map */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_map
+(
+	mach_port_t device,
+	vm_prot_t prot,
+	vm_offset_t offset,
+	vm_size_t size,
+	mach_port_t *pager,
+	int unmap
+);
+
+/* Routine device_set_status */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_set_status
+(
+	mach_port_t device,
+	dev_flavor_t flavor,
+	dev_status_t status,
+	mach_msg_type_number_t statusCnt
+);
+
+/* Routine device_get_status */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_get_status
+(
+	mach_port_t device,
+	dev_flavor_t flavor,
+	dev_status_t status,
+	mach_msg_type_number_t *statusCnt
+);
+
+/* Routine device_set_filter */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_set_filter
+(
+	mach_port_t device,
+	mach_port_t receive_port,
+	mach_msg_type_name_t receive_portPoly,
+	int priority,
+	filter_array_t filter,
+	mach_msg_type_number_t filterCnt
+);
+
+
+/* Module device */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+
+/* Routine device_open */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_open
+(
+	mach_port_t master_port,
+	dev_mode_t mode,
+	dev_name_t name,
+	mach_port_t *device
+);
+
+/* Routine device_close */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_close
+(
+	mach_port_t device
+);
+
+/* Routine device_write */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_write
+(
+	mach_port_t device,
+	dev_mode_t mode,
+	recnum_t recnum,
+	io_buf_ptr_t data,
+	mach_msg_type_number_t dataCnt,
+	int *bytes_written
+);
+
+/* Routine device_write_inband */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_write_inband
+(
+	mach_port_t device,
+	dev_mode_t mode,
+	recnum_t recnum,
+	io_buf_ptr_inband_t data,
+	mach_msg_type_number_t dataCnt,
+	int *bytes_written
+);
+
+/* Routine device_read */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_read
+(
+	mach_port_t device,
+	dev_mode_t mode,
+	recnum_t recnum,
+	int bytes_wanted,
+	io_buf_ptr_t *data,
+	mach_msg_type_number_t *dataCnt
+);
+
+/* Routine device_read_inband */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_read_inband
+(
+	mach_port_t device,
+	dev_mode_t mode,
+	recnum_t recnum,
+	int bytes_wanted,
+	io_buf_ptr_inband_t data,
+	mach_msg_type_number_t *dataCnt
+);
+
+/* Routine device_map */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_map
+(
+	mach_port_t device,
+	vm_prot_t prot,
+	vm_offset_t offset,
+	vm_size_t size,
+	mach_port_t *pager,
+	int unmap
+);
+
+/* Routine device_set_status */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_set_status
+(
+	mach_port_t device,
+	dev_flavor_t flavor,
+	dev_status_t status,
+	mach_msg_type_number_t statusCnt
+);
+
+/* Routine device_get_status */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_get_status
+(
+	mach_port_t device,
+	dev_flavor_t flavor,
+	dev_status_t status,
+	mach_msg_type_number_t *statusCnt
+);
+
+/* Routine device_set_filter */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_set_filter
+(
+	mach_port_t device,
+	mach_port_t receive_port,
+	mach_msg_type_name_t receive_portPoly,
+	int priority,
+	filter_array_t filter,
+	mach_msg_type_number_t filterCnt
+);
+
+#endif	/* not defined(_device_user_) */
diff --git a/include/device/device_request.h b/include/device/device_request.h
new file mode 100644
index 0000000..67f4dad
--- /dev/null
+++ b/include/device/device_request.h
@@ -0,0 +1,177 @@
+#ifndef	_device_request_user_
+#define	_device_request_user_
+
+/* Module device_request */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+
+/* SimpleRoutine device_open_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_open_request
+(
+	mach_port_t device_server_port,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	dev_name_t name
+);
+
+/* SimpleRoutine device_write_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_write_request
+(
+	mach_port_t device,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	recnum_t recnum,
+	io_buf_ptr_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* SimpleRoutine device_write_request_inband */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_write_request_inband
+(
+	mach_port_t device,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	recnum_t recnum,
+	io_buf_ptr_inband_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* SimpleRoutine device_read_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_read_request
+(
+	mach_port_t device,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	recnum_t recnum,
+	int bytes_wanted
+);
+
+/* SimpleRoutine device_read_request_inband */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __device_read_request_inband
+(
+	mach_port_t device,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	recnum_t recnum,
+	int bytes_wanted
+);
+
+
+/* Module device_request */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+
+/* SimpleRoutine device_open_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_open_request
+(
+	mach_port_t device_server_port,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	dev_name_t name
+);
+
+/* SimpleRoutine device_write_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_write_request
+(
+	mach_port_t device,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	recnum_t recnum,
+	io_buf_ptr_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* SimpleRoutine device_write_request_inband */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_write_request_inband
+(
+	mach_port_t device,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	recnum_t recnum,
+	io_buf_ptr_inband_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* SimpleRoutine device_read_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_read_request
+(
+	mach_port_t device,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	recnum_t recnum,
+	int bytes_wanted
+);
+
+/* SimpleRoutine device_read_request_inband */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t device_read_request_inband
+(
+	mach_port_t device,
+	mach_port_t reply_port,
+	dev_mode_t mode,
+	recnum_t recnum,
+	int bytes_wanted
+);
+
+#endif	/* not defined(_device_request_user_) */
diff --git a/include/dirent.h b/include/dirent.h
new file mode 100644
index 0000000..9227adc
--- /dev/null
+++ b/include/dirent.h
@@ -0,0 +1,403 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>
+ */
+
+#ifndef	_DIRENT_H
+#define	_DIRENT_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#ifdef __USE_XOPEN
+# ifndef __ino_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __ino_t ino_t;
+#  else
+typedef __ino64_t ino_t;
+#  endif
+#  define __ino_t_defined
+# endif
+# if defined __USE_LARGEFILE64 && !defined __ino64_t_defined
+typedef __ino64_t ino64_t;
+#  define __ino64_t_defined
+# endif
+#endif
+
+/* This file defines `struct dirent'.
+
+   It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'
+   member that gives the length of `d_name'.
+
+   It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'
+   member that gives the size of the entire directory entry.
+
+   It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'
+   member that gives the file offset of the next directory entry.
+
+   It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'
+   member that gives the type of the file.
+ */
+
+#include <bits/dirent.h>
+
+#if (defined __USE_BSD || defined __USE_MISC) && !defined d_fileno
+# define d_ino	d_fileno		 /* Backward compatibility.  */
+#endif
+
+/* These macros extract size information from a `struct dirent *'.
+   They may evaluate their argument multiple times, so it must not
+   have side effects.  Each of these may involve a relatively costly
+   call to `strlen' on some systems, so these values should be cached.
+
+   _D_EXACT_NAMLEN (DP)	returns the length of DP->d_name, not including
+   its terminating null character.
+
+   _D_ALLOC_NAMLEN (DP)	returns a size at least (_D_EXACT_NAMLEN (DP) + 1);
+   that is, the allocation size needed to hold the DP->d_name string.
+   Use this macro when you don't need the exact length, just an upper bound.
+   This macro is less likely to require calling `strlen' than _D_EXACT_NAMLEN.
+   */
+
+#ifdef _DIRENT_HAVE_D_NAMLEN
+# define _D_EXACT_NAMLEN(d) ((d)->d_namlen)
+# define _D_ALLOC_NAMLEN(d) (_D_EXACT_NAMLEN (d) + 1)
+#else
+# define _D_EXACT_NAMLEN(d) (strlen ((d)->d_name))
+# ifdef _DIRENT_HAVE_D_RECLEN
+#  define _D_ALLOC_NAMLEN(d) (((char *) (d) + (d)->d_reclen) - &(d)->d_name[0])
+# else
+#  define _D_ALLOC_NAMLEN(d) (sizeof (d)->d_name > 1 ? sizeof (d)->d_name : \
+			      _D_EXACT_NAMLEN (d) + 1)
+# endif
+#endif
+
+
+#ifdef __USE_BSD
+/* File types for `d_type'.  */
+enum
+  {
+    DT_UNKNOWN = 0,
+# define DT_UNKNOWN	DT_UNKNOWN
+    DT_FIFO = 1,
+# define DT_FIFO	DT_FIFO
+    DT_CHR = 2,
+# define DT_CHR		DT_CHR
+    DT_DIR = 4,
+# define DT_DIR		DT_DIR
+    DT_BLK = 6,
+# define DT_BLK		DT_BLK
+    DT_REG = 8,
+# define DT_REG		DT_REG
+    DT_LNK = 10,
+# define DT_LNK		DT_LNK
+    DT_SOCK = 12,
+# define DT_SOCK	DT_SOCK
+    DT_WHT = 14
+# define DT_WHT		DT_WHT
+  };
+
+/* Convert between stat structure types and directory types.  */
+# define IFTODT(mode)	(((mode) & 0170000) >> 12)
+# define DTTOIF(dirtype)	((dirtype) << 12)
+#endif
+
+
+/* This is the data type of directory stream objects.
+   The actual structure is opaque to users.  */
+typedef struct __dirstream DIR;
+
+/* Open a directory stream on NAME.
+   Return a DIR stream on the directory, or NULL if it could not be opened.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern DIR *opendir (const char *__name) __nonnull ((1));
+
+#ifdef __USE_XOPEN2K8
+/* Same as opendir, but open the stream on the file descriptor FD.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern DIR *fdopendir (int __fd);
+#endif
+
+/* Close the directory stream DIRP.
+   Return 0 if successful, -1 if not.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int closedir (DIR *__dirp) __nonnull ((1));
+
+/* Read a directory entry from DIRP.  Return a pointer to a `struct
+   dirent' describing the entry, or NULL for EOF or error.  The
+   storage returned may be overwritten by a later readdir call on the
+   same DIR stream.
+
+   If the Large File Support API is selected we have to use the
+   appropriate interface.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+#ifndef __USE_FILE_OFFSET64
+extern struct dirent *readdir (DIR *__dirp) __nonnull ((1));
+#else
+# ifdef __REDIRECT
+extern struct dirent *__REDIRECT (readdir, (DIR *__dirp), readdir64)
+     __nonnull ((1));
+# else
+#  define readdir readdir64
+# endif
+#endif
+
+#ifdef __USE_LARGEFILE64
+extern struct dirent64 *readdir64 (DIR *__dirp) __nonnull ((1));
+#endif
+
+#if defined __USE_POSIX || defined __USE_MISC
+/* Reentrant version of `readdir'.  Return in RESULT a pointer to the
+   next entry.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int readdir_r (DIR *__restrict __dirp,
+		      struct dirent *__restrict __entry,
+		      struct dirent **__restrict __result)
+     __nonnull ((1, 2, 3));
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (readdir_r,
+		       (DIR *__restrict __dirp,
+			struct dirent *__restrict __entry,
+			struct dirent **__restrict __result),
+		       readdir64_r) __nonnull ((1, 2, 3));
+#  else
+#   define readdir_r readdir64_r
+#  endif
+# endif
+
+# ifdef __USE_LARGEFILE64
+extern int readdir64_r (DIR *__restrict __dirp,
+			struct dirent64 *__restrict __entry,
+			struct dirent64 **__restrict __result)
+     __nonnull ((1, 2, 3));
+# endif
+#endif	/* POSIX or misc */
+
+/* Rewind DIRP to the beginning of the directory.  */
+extern void rewinddir (DIR *__dirp) __THROW __nonnull ((1));
+
+#if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
+# include <bits/types.h>
+
+/* Seek to position POS on DIRP.  */
+extern void seekdir (DIR *__dirp, long int __pos) __THROW __nonnull ((1));
+
+/* Return the current position of DIRP.  */
+extern long int telldir (DIR *__dirp) __THROW __nonnull ((1));
+#endif
+
+#if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN2K8
+
+/* Return the file descriptor used by DIRP.  */
+extern int dirfd (DIR *__dirp) __THROW __nonnull ((1));
+
+# if defined __OPTIMIZE__ && defined _DIR_dirfd
+#  define dirfd(dirp)	_DIR_dirfd (dirp)
+# endif
+
+# if defined __USE_BSD || defined __USE_MISC
+#  ifndef MAXNAMLEN
+/* Get the definitions of the POSIX.1 limits.  */
+#  include <bits/posix1_lim.h>
+
+/* `MAXNAMLEN' is the BSD name for what POSIX calls `NAME_MAX'.  */
+#   ifdef NAME_MAX
+#    define MAXNAMLEN	NAME_MAX
+#   else
+#    define MAXNAMLEN	255
+#   endif
+#  endif
+# endif
+
+# define __need_size_t
+# include <stddef.h>
+
+/* Scan the directory DIR, calling SELECTOR on each directory entry.
+   Entries for which SELECT returns nonzero are individually malloc'd,
+   sorted using qsort with CMP, and collected in a malloc'd array in
+   *NAMELIST.  Returns the number of entries selected, or -1 on error.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int scandir (const char *__restrict __dir,
+		    struct dirent ***__restrict __namelist,
+		    int (*__selector) (const struct dirent *),
+		    int (*__cmp) (const struct dirent **,
+				  const struct dirent **))
+     __nonnull ((1, 2));
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (scandir,
+		       (const char *__restrict __dir,
+			struct dirent ***__restrict __namelist,
+			int (*__selector) (const struct dirent *),
+			int (*__cmp) (const struct dirent **,
+				      const struct dirent **)),
+		       scandir64) __nonnull ((1, 2));
+#  else
+#   define scandir scandir64
+#  endif
+# endif
+
+# if defined __USE_GNU && defined __USE_LARGEFILE64
+/* This function is like `scandir' but it uses the 64bit dirent structure.
+   Please note that the CMP function must now work with struct dirent64 **.  */
+extern int scandir64 (const char *__restrict __dir,
+		      struct dirent64 ***__restrict __namelist,
+		      int (*__selector) (const struct dirent64 *),
+		      int (*__cmp) (const struct dirent64 **,
+				    const struct dirent64 **))
+     __nonnull ((1, 2));
+# endif
+
+# ifdef __USE_GNU
+/* Similar to `scandir' but a relative DIR name is interpreted relative
+   to the directory for which DFD is a descriptor.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+#  ifndef __USE_FILE_OFFSET64
+extern int scandirat (int __dfd, const char *__restrict __dir,
+		      struct dirent ***__restrict __namelist,
+		      int (*__selector) (const struct dirent *),
+		      int (*__cmp) (const struct dirent **,
+				    const struct dirent **))
+     __nonnull ((2, 3));
+#  else
+#   ifdef __REDIRECT
+extern int __REDIRECT (scandirat,
+		       (int __dfd, const char *__restrict __dir,
+			struct dirent ***__restrict __namelist,
+			int (*__selector) (const struct dirent *),
+			int (*__cmp) (const struct dirent **,
+				      const struct dirent **)),
+		       scandirat64) __nonnull ((2, 3));
+#   else
+#    define scandirat scandirat64
+#   endif
+#  endif
+
+/* This function is like `scandir' but it uses the 64bit dirent structure.
+   Please note that the CMP function must now work with struct dirent64 **.  */
+extern int scandirat64 (int __dfd, const char *__restrict __dir,
+			struct dirent64 ***__restrict __namelist,
+			int (*__selector) (const struct dirent64 *),
+			int (*__cmp) (const struct dirent64 **,
+				      const struct dirent64 **))
+     __nonnull ((2, 3));
+# endif
+
+/* Function to compare two `struct dirent's alphabetically.  */
+# ifndef __USE_FILE_OFFSET64
+extern int alphasort (const struct dirent **__e1,
+		      const struct dirent **__e2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT_NTH (alphasort,
+			   (const struct dirent **__e1,
+			    const struct dirent **__e2),
+			   alphasort64) __attribute_pure__ __nonnull ((1, 2));
+#  else
+#   define alphasort alphasort64
+#  endif
+# endif
+
+# if defined __USE_GNU && defined __USE_LARGEFILE64
+extern int alphasort64 (const struct dirent64 **__e1,
+			const struct dirent64 **__e2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+# endif
+#endif /* Use BSD or misc or XPG7.  */
+
+
+#if defined __USE_BSD || defined __USE_MISC
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Reading starts at offset *BASEP, and *BASEP is updated with the new
+   position after reading.  Returns the number of bytes read; zero when at
+   end of directory; or -1 for errors.  */
+# ifndef __USE_FILE_OFFSET64
+extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
+				size_t __nbytes,
+				__off_t *__restrict __basep)
+     __THROW __nonnull ((2, 4));
+# else
+#  ifdef __REDIRECT
+extern __ssize_t __REDIRECT_NTH (getdirentries,
+				 (int __fd, char *__restrict __buf,
+				  size_t __nbytes,
+				  __off64_t *__restrict __basep),
+				 getdirentries64) __nonnull ((2, 4));
+#  else
+#   define getdirentries getdirentries64
+#  endif
+# endif
+
+# ifdef __USE_LARGEFILE64
+extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
+				  size_t __nbytes,
+				  __off64_t *__restrict __basep)
+     __THROW __nonnull ((2, 4));
+# endif
+#endif /* Use BSD or misc.  */
+
+#ifdef __USE_GNU
+/* Function to compare two `struct dirent's by name & version.  */
+# ifndef __USE_FILE_OFFSET64
+extern int versionsort (const struct dirent **__e1,
+			const struct dirent **__e2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT_NTH (versionsort,
+			   (const struct dirent **__e1,
+			    const struct dirent **__e2),
+			   versionsort64)
+     __attribute_pure__ __nonnull ((1, 2));
+#  else
+#   define versionsort versionsort64
+#  endif
+# endif
+
+# ifdef __USE_LARGEFILE64
+extern int versionsort64 (const struct dirent64 **__e1,
+			  const struct dirent64 **__e2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+# endif
+#endif /* Use GNU.  */
+
+__END_DECLS
+
+#endif /* dirent.h  */
diff --git a/include/dlfcn.h b/include/dlfcn.h
new file mode 100644
index 0000000..461cef1
--- /dev/null
+++ b/include/dlfcn.h
@@ -0,0 +1,190 @@
+/* User functions for run-time dynamic loading.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_DLFCN_H
+#define	_DLFCN_H 1
+
+#include <features.h>
+#define __need_size_t
+#include <stddef.h>
+
+/* Collect various system dependent definitions and declarations.  */
+#include <bits/dlfcn.h>
+
+
+#ifdef __USE_GNU
+/* If the first argument of `dlsym' or `dlvsym' is set to RTLD_NEXT
+   the run-time address of the symbol called NAME in the next shared
+   object is returned.  The "next" relation is defined by the order
+   the shared objects were loaded.  */
+# define RTLD_NEXT	((void *) -1l)
+
+/* If the first argument to `dlsym' or `dlvsym' is set to RTLD_DEFAULT
+   the run-time address of the symbol called NAME in the global scope
+   is returned.  */
+# define RTLD_DEFAULT	((void *) 0)
+
+
+/* Type for namespace indeces.  */
+typedef long int Lmid_t;
+
+/* Special namespace ID values.  */
+# define LM_ID_BASE	0	/* Initial namespace.  */
+# define LM_ID_NEWLM	-1	/* For dlmopen: request new namespace.  */
+#endif
+
+
+__BEGIN_DECLS
+
+/* Open the shared object FILE and map it in; return a handle that can be
+   passed to `dlsym' to get symbol values from it.  */
+extern void *dlopen (const char *__file, int __mode) __THROWNL;
+
+/* Unmap and close a shared object opened by `dlopen'.
+   The handle cannot be used again after calling `dlclose'.  */
+extern int dlclose (void *__handle) __THROWNL __nonnull ((1));
+
+/* Find the run-time address in the shared object HANDLE refers to
+   of the symbol called NAME.  */
+extern void *dlsym (void *__restrict __handle,
+		    const char *__restrict __name) __THROW __nonnull ((2));
+
+#ifdef __USE_GNU
+/* Like `dlopen', but request object to be allocated in a new namespace.  */
+extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) __THROWNL;
+
+/* Find the run-time address in the shared object HANDLE refers to
+   of the symbol called NAME with VERSION.  */
+extern void *dlvsym (void *__restrict __handle,
+		     const char *__restrict __name,
+		     const char *__restrict __version)
+     __THROW __nonnull ((2, 3));
+#endif
+
+/* When any of the above functions fails, call this function
+   to return a string describing the error.  Each call resets
+   the error string so that a following call returns null.  */
+extern char *dlerror (void) __THROW;
+
+
+#ifdef __USE_GNU
+/* Structure containing information about object searched using
+   `dladdr'.  */
+typedef struct
+{
+  const char *dli_fname;	/* File name of defining object.  */
+  void *dli_fbase;		/* Load address of that object.  */
+  const char *dli_sname;	/* Name of nearest symbol.  */
+  void *dli_saddr;		/* Exact value of nearest symbol.  */
+} Dl_info;
+
+/* Fill in *INFO with the following information about ADDRESS.
+   Returns 0 iff no shared object's segments contain that address.  */
+extern int dladdr (const void *__address, Dl_info *__info)
+     __THROW __nonnull ((2));
+
+/* Same as `dladdr', but additionally sets *EXTRA_INFO according to FLAGS.  */
+extern int dladdr1 (const void *__address, Dl_info *__info,
+		    void **__extra_info, int __flags) __THROW __nonnull ((2));
+
+/* These are the possible values for the FLAGS argument to `dladdr1'.
+   This indicates what extra information is stored at *EXTRA_INFO.
+   It may also be zero, in which case the EXTRA_INFO argument is not used.  */
+enum
+  {
+    /* Matching symbol table entry (const ElfNN_Sym *).  */
+    RTLD_DL_SYMENT = 1,
+
+    /* The object containing the address (struct link_map *).  */
+    RTLD_DL_LINKMAP = 2
+  };
+
+
+/* Get information about the shared object HANDLE refers to.
+   REQUEST is from among the values below, and determines the use of ARG.
+
+   On success, returns zero.  On failure, returns -1 and records an error
+   message to be fetched with `dlerror'.  */
+extern int dlinfo (void *__restrict __handle,
+		   int __request, void *__restrict __arg)
+     __THROW __nonnull ((1, 3));
+
+/* These are the possible values for the REQUEST argument to `dlinfo'.  */
+enum
+  {
+    /* Treat ARG as `lmid_t *'; store namespace ID for HANDLE there.  */
+    RTLD_DI_LMID = 1,
+
+    /* Treat ARG as `struct link_map **';
+       store the `struct link_map *' for HANDLE there.  */
+    RTLD_DI_LINKMAP = 2,
+
+    RTLD_DI_CONFIGADDR = 3,	/* Unsupported, defined by Solaris.  */
+
+    /* Treat ARG as `Dl_serinfo *' (see below), and fill in to describe the
+       directories that will be searched for dependencies of this object.
+       RTLD_DI_SERINFOSIZE fills in just the `dls_cnt' and `dls_size'
+       entries to indicate the size of the buffer that must be passed to
+       RTLD_DI_SERINFO to fill in the full information.  */
+    RTLD_DI_SERINFO = 4,
+    RTLD_DI_SERINFOSIZE = 5,
+
+    /* Treat ARG as `char *', and store there the directory name used to
+       expand $ORIGIN in this shared object's dependency file names.  */
+    RTLD_DI_ORIGIN = 6,
+
+    RTLD_DI_PROFILENAME = 7,	/* Unsupported, defined by Solaris.  */
+    RTLD_DI_PROFILEOUT = 8,	/* Unsupported, defined by Solaris.  */
+
+    /* Treat ARG as `size_t *', and store there the TLS module ID
+       of this object's PT_TLS segment, as used in TLS relocations;
+       store zero if this object does not define a PT_TLS segment.  */
+    RTLD_DI_TLS_MODID = 9,
+
+    /* Treat ARG as `void **', and store there a pointer to the calling
+       thread's TLS block corresponding to this object's PT_TLS segment.
+       Store a null pointer if this object does not define a PT_TLS
+       segment, or if the calling thread has not allocated a block for it.  */
+    RTLD_DI_TLS_DATA = 10,
+
+    RTLD_DI_MAX = 10
+  };
+
+
+/* This is the type of elements in `Dl_serinfo', below.
+   The `dls_name' member points to space in the buffer passed to `dlinfo'.  */
+typedef struct
+{
+  char *dls_name;		/* Name of library search path directory.  */
+  unsigned int dls_flags;	/* Indicates where this directory came from. */
+} Dl_serpath;
+
+/* This is the structure that must be passed (by reference) to `dlinfo' for
+   the RTLD_DI_SERINFO and RTLD_DI_SERINFOSIZE requests.  */
+typedef struct
+{
+  size_t dls_size;		/* Size in bytes of the whole buffer.  */
+  unsigned int dls_cnt;		/* Number of elements in `dls_serpath'.  */
+  Dl_serpath dls_serpath[1];	/* Actually longer, dls_cnt elements.  */
+} Dl_serinfo;
+#endif /* __USE_GNU */
+
+
+__END_DECLS
+
+#endif	/* dlfcn.h */
diff --git a/include/elf.h b/include/elf.h
new file mode 100644
index 0000000..40e87b2
--- /dev/null
+++ b/include/elf.h
@@ -0,0 +1,3363 @@
+/* This file defines standard ELF types, structures, and macros.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ELF_H
+#define	_ELF_H 1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Standard ELF types.  */
+
+#include <stdint.h>
+
+/* Type for a 16-bit quantity.  */
+typedef uint16_t Elf32_Half;
+typedef uint16_t Elf64_Half;
+
+/* Types for signed and unsigned 32-bit quantities.  */
+typedef uint32_t Elf32_Word;
+typedef	int32_t  Elf32_Sword;
+typedef uint32_t Elf64_Word;
+typedef	int32_t  Elf64_Sword;
+
+/* Types for signed and unsigned 64-bit quantities.  */
+typedef uint64_t Elf32_Xword;
+typedef	int64_t  Elf32_Sxword;
+typedef uint64_t Elf64_Xword;
+typedef	int64_t  Elf64_Sxword;
+
+/* Type of addresses.  */
+typedef uint32_t Elf32_Addr;
+typedef uint64_t Elf64_Addr;
+
+/* Type of file offsets.  */
+typedef uint32_t Elf32_Off;
+typedef uint64_t Elf64_Off;
+
+/* Type for section indices, which are 16-bit quantities.  */
+typedef uint16_t Elf32_Section;
+typedef uint16_t Elf64_Section;
+
+/* Type for version symbol information.  */
+typedef Elf32_Half Elf32_Versym;
+typedef Elf64_Half Elf64_Versym;
+
+
+/* The ELF file header.  This appears at the start of every ELF file.  */
+
+#define EI_NIDENT (16)
+
+typedef struct
+{
+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
+  Elf32_Half	e_type;			/* Object file type */
+  Elf32_Half	e_machine;		/* Architecture */
+  Elf32_Word	e_version;		/* Object file version */
+  Elf32_Addr	e_entry;		/* Entry point virtual address */
+  Elf32_Off	e_phoff;		/* Program header table file offset */
+  Elf32_Off	e_shoff;		/* Section header table file offset */
+  Elf32_Word	e_flags;		/* Processor-specific flags */
+  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
+  Elf32_Half	e_phentsize;		/* Program header table entry size */
+  Elf32_Half	e_phnum;		/* Program header table entry count */
+  Elf32_Half	e_shentsize;		/* Section header table entry size */
+  Elf32_Half	e_shnum;		/* Section header table entry count */
+  Elf32_Half	e_shstrndx;		/* Section header string table index */
+} Elf32_Ehdr;
+
+typedef struct
+{
+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
+  Elf64_Half	e_type;			/* Object file type */
+  Elf64_Half	e_machine;		/* Architecture */
+  Elf64_Word	e_version;		/* Object file version */
+  Elf64_Addr	e_entry;		/* Entry point virtual address */
+  Elf64_Off	e_phoff;		/* Program header table file offset */
+  Elf64_Off	e_shoff;		/* Section header table file offset */
+  Elf64_Word	e_flags;		/* Processor-specific flags */
+  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
+  Elf64_Half	e_phentsize;		/* Program header table entry size */
+  Elf64_Half	e_phnum;		/* Program header table entry count */
+  Elf64_Half	e_shentsize;		/* Section header table entry size */
+  Elf64_Half	e_shnum;		/* Section header table entry count */
+  Elf64_Half	e_shstrndx;		/* Section header string table index */
+} Elf64_Ehdr;
+
+/* Fields in the e_ident array.  The EI_* macros are indices into the
+   array.  The macros under each EI_* macro are the values the byte
+   may have.  */
+
+#define EI_MAG0		0		/* File identification byte 0 index */
+#define ELFMAG0		0x7f		/* Magic number byte 0 */
+
+#define EI_MAG1		1		/* File identification byte 1 index */
+#define ELFMAG1		'E'		/* Magic number byte 1 */
+
+#define EI_MAG2		2		/* File identification byte 2 index */
+#define ELFMAG2		'L'		/* Magic number byte 2 */
+
+#define EI_MAG3		3		/* File identification byte 3 index */
+#define ELFMAG3		'F'		/* Magic number byte 3 */
+
+/* Conglomeration of the identification bytes, for easy testing as a word.  */
+#define	ELFMAG		"\177ELF"
+#define	SELFMAG		4
+
+#define EI_CLASS	4		/* File class byte index */
+#define ELFCLASSNONE	0		/* Invalid class */
+#define ELFCLASS32	1		/* 32-bit objects */
+#define ELFCLASS64	2		/* 64-bit objects */
+#define ELFCLASSNUM	3
+
+#define EI_DATA		5		/* Data encoding byte index */
+#define ELFDATANONE	0		/* Invalid data encoding */
+#define ELFDATA2LSB	1		/* 2's complement, little endian */
+#define ELFDATA2MSB	2		/* 2's complement, big endian */
+#define ELFDATANUM	3
+
+#define EI_VERSION	6		/* File version byte index */
+					/* Value must be EV_CURRENT */
+
+#define EI_OSABI	7		/* OS ABI identification */
+#define ELFOSABI_NONE		0	/* UNIX System V ABI */
+#define ELFOSABI_SYSV		0	/* Alias.  */
+#define ELFOSABI_HPUX		1	/* HP-UX */
+#define ELFOSABI_NETBSD		2	/* NetBSD.  */
+#define ELFOSABI_GNU		3	/* Object uses GNU ELF extensions.  */
+#define ELFOSABI_LINUX		ELFOSABI_GNU /* Compatibility alias.  */
+#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
+#define ELFOSABI_AIX		7	/* IBM AIX.  */
+#define ELFOSABI_IRIX		8	/* SGI Irix.  */
+#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
+#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
+#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
+#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
+#define ELFOSABI_ARM_AEABI	64	/* ARM EABI */
+#define ELFOSABI_ARM		97	/* ARM */
+#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
+
+#define EI_ABIVERSION	8		/* ABI version */
+
+#define EI_PAD		9		/* Byte index of padding bytes */
+
+/* Legal values for e_type (object file type).  */
+
+#define ET_NONE		0		/* No file type */
+#define ET_REL		1		/* Relocatable file */
+#define ET_EXEC		2		/* Executable file */
+#define ET_DYN		3		/* Shared object file */
+#define ET_CORE		4		/* Core file */
+#define	ET_NUM		5		/* Number of defined types */
+#define ET_LOOS		0xfe00		/* OS-specific range start */
+#define ET_HIOS		0xfeff		/* OS-specific range end */
+#define ET_LOPROC	0xff00		/* Processor-specific range start */
+#define ET_HIPROC	0xffff		/* Processor-specific range end */
+
+/* Legal values for e_machine (architecture).  */
+
+#define EM_NONE		 0		/* No machine */
+#define EM_M32		 1		/* AT&T WE 32100 */
+#define EM_SPARC	 2		/* SUN SPARC */
+#define EM_386		 3		/* Intel 80386 */
+#define EM_68K		 4		/* Motorola m68k family */
+#define EM_88K		 5		/* Motorola m88k family */
+#define EM_860		 7		/* Intel 80860 */
+#define EM_MIPS		 8		/* MIPS R3000 big-endian */
+#define EM_S370		 9		/* IBM System/370 */
+#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
+
+#define EM_PARISC	15		/* HPPA */
+#define EM_VPP500	17		/* Fujitsu VPP500 */
+#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
+#define EM_960		19		/* Intel 80960 */
+#define EM_PPC		20		/* PowerPC */
+#define EM_PPC64	21		/* PowerPC 64-bit */
+#define EM_S390		22		/* IBM S390 */
+
+#define EM_V800		36		/* NEC V800 series */
+#define EM_FR20		37		/* Fujitsu FR20 */
+#define EM_RH32		38		/* TRW RH-32 */
+#define EM_RCE		39		/* Motorola RCE */
+#define EM_ARM		40		/* ARM */
+#define EM_FAKE_ALPHA	41		/* Digital Alpha */
+#define EM_SH		42		/* Hitachi SH */
+#define EM_SPARCV9	43		/* SPARC v9 64-bit */
+#define EM_TRICORE	44		/* Siemens Tricore */
+#define EM_ARC		45		/* Argonaut RISC Core */
+#define EM_H8_300	46		/* Hitachi H8/300 */
+#define EM_H8_300H	47		/* Hitachi H8/300H */
+#define EM_H8S		48		/* Hitachi H8S */
+#define EM_H8_500	49		/* Hitachi H8/500 */
+#define EM_IA_64	50		/* Intel Merced */
+#define EM_MIPS_X	51		/* Stanford MIPS-X */
+#define EM_COLDFIRE	52		/* Motorola Coldfire */
+#define EM_68HC12	53		/* Motorola M68HC12 */
+#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
+#define EM_PCP		55		/* Siemens PCP */
+#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
+#define EM_NDR1		57		/* Denso NDR1 microprocessor */
+#define EM_STARCORE	58		/* Motorola Start*Core processor */
+#define EM_ME16		59		/* Toyota ME16 processor */
+#define EM_ST100	60		/* STMicroelectronic ST100 processor */
+#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
+#define EM_X86_64	62		/* AMD x86-64 architecture */
+#define EM_PDSP		63		/* Sony DSP Processor */
+
+#define EM_FX66		66		/* Siemens FX66 microcontroller */
+#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
+#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
+#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
+#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
+#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
+#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
+#define EM_SVX		73		/* Silicon Graphics SVx */
+#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
+#define EM_VAX		75		/* Digital VAX */
+#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
+#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
+#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
+#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
+#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
+#define EM_HUANY	81		/* Harvard University machine-independent object files */
+#define EM_PRISM	82		/* SiTera Prism */
+#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
+#define EM_FR30		84		/* Fujitsu FR30 */
+#define EM_D10V		85		/* Mitsubishi D10V */
+#define EM_D30V		86		/* Mitsubishi D30V */
+#define EM_V850		87		/* NEC v850 */
+#define EM_M32R		88		/* Mitsubishi M32R */
+#define EM_MN10300	89		/* Matsushita MN10300 */
+#define EM_MN10200	90		/* Matsushita MN10200 */
+#define EM_PJ		91		/* picoJava */
+#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
+#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
+#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
+#define EM_AARCH64	183		/* ARM AARCH64 */
+#define EM_TILEPRO	188		/* Tilera TILEPro */
+#define EM_MICROBLAZE	189		/* Xilinx MicroBlaze */
+#define EM_TILEGX	191		/* Tilera TILE-Gx */
+#define EM_NUM		192
+
+/* If it is necessary to assign new unofficial EM_* values, please
+   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
+   chances of collision with official or non-GNU unofficial values.  */
+
+#define EM_ALPHA	0x9026
+
+/* Legal values for e_version (version).  */
+
+#define EV_NONE		0		/* Invalid ELF version */
+#define EV_CURRENT	1		/* Current version */
+#define EV_NUM		2
+
+/* Section header.  */
+
+typedef struct
+{
+  Elf32_Word	sh_name;		/* Section name (string tbl index) */
+  Elf32_Word	sh_type;		/* Section type */
+  Elf32_Word	sh_flags;		/* Section flags */
+  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
+  Elf32_Off	sh_offset;		/* Section file offset */
+  Elf32_Word	sh_size;		/* Section size in bytes */
+  Elf32_Word	sh_link;		/* Link to another section */
+  Elf32_Word	sh_info;		/* Additional section information */
+  Elf32_Word	sh_addralign;		/* Section alignment */
+  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
+} Elf32_Shdr;
+
+typedef struct
+{
+  Elf64_Word	sh_name;		/* Section name (string tbl index) */
+  Elf64_Word	sh_type;		/* Section type */
+  Elf64_Xword	sh_flags;		/* Section flags */
+  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
+  Elf64_Off	sh_offset;		/* Section file offset */
+  Elf64_Xword	sh_size;		/* Section size in bytes */
+  Elf64_Word	sh_link;		/* Link to another section */
+  Elf64_Word	sh_info;		/* Additional section information */
+  Elf64_Xword	sh_addralign;		/* Section alignment */
+  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
+} Elf64_Shdr;
+
+/* Special section indices.  */
+
+#define SHN_UNDEF	0		/* Undefined section */
+#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
+#define SHN_LOPROC	0xff00		/* Start of processor-specific */
+#define SHN_BEFORE	0xff00		/* Order section before all others
+					   (Solaris).  */
+#define SHN_AFTER	0xff01		/* Order section after all others
+					   (Solaris).  */
+#define SHN_HIPROC	0xff1f		/* End of processor-specific */
+#define SHN_LOOS	0xff20		/* Start of OS-specific */
+#define SHN_HIOS	0xff3f		/* End of OS-specific */
+#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
+#define SHN_COMMON	0xfff2		/* Associated symbol is common */
+#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
+#define SHN_HIRESERVE	0xffff		/* End of reserved indices */
+
+/* Legal values for sh_type (section type).  */
+
+#define SHT_NULL	  0		/* Section header table entry unused */
+#define SHT_PROGBITS	  1		/* Program data */
+#define SHT_SYMTAB	  2		/* Symbol table */
+#define SHT_STRTAB	  3		/* String table */
+#define SHT_RELA	  4		/* Relocation entries with addends */
+#define SHT_HASH	  5		/* Symbol hash table */
+#define SHT_DYNAMIC	  6		/* Dynamic linking information */
+#define SHT_NOTE	  7		/* Notes */
+#define SHT_NOBITS	  8		/* Program space with no data (bss) */
+#define SHT_REL		  9		/* Relocation entries, no addends */
+#define SHT_SHLIB	  10		/* Reserved */
+#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
+#define SHT_INIT_ARRAY	  14		/* Array of constructors */
+#define SHT_FINI_ARRAY	  15		/* Array of destructors */
+#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
+#define SHT_GROUP	  17		/* Section group */
+#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
+#define	SHT_NUM		  19		/* Number of defined types.  */
+#define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
+#define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
+#define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
+#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
+#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
+#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
+#define SHT_SUNW_move	  0x6ffffffa
+#define SHT_SUNW_COMDAT   0x6ffffffb
+#define SHT_SUNW_syminfo  0x6ffffffc
+#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
+#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
+#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
+#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
+#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
+#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
+#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
+#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
+#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
+
+/* Legal values for sh_flags (section flags).  */
+
+#define SHF_WRITE	     (1 << 0)	/* Writable */
+#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
+#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
+#define SHF_MERGE	     (1 << 4)	/* Might be merged */
+#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
+#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
+#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
+#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
+					   required */
+#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
+#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
+#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
+#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
+#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
+					   (Solaris).  */
+#define SHF_EXCLUDE	     (1 << 31)	/* Section is excluded unless
+					   referenced or allocated (Solaris).*/
+
+/* Section group handling.  */
+#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */
+
+/* Symbol table entry.  */
+
+typedef struct
+{
+  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
+  Elf32_Addr	st_value;		/* Symbol value */
+  Elf32_Word	st_size;		/* Symbol size */
+  unsigned char	st_info;		/* Symbol type and binding */
+  unsigned char	st_other;		/* Symbol visibility */
+  Elf32_Section	st_shndx;		/* Section index */
+} Elf32_Sym;
+
+typedef struct
+{
+  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
+  unsigned char	st_info;		/* Symbol type and binding */
+  unsigned char st_other;		/* Symbol visibility */
+  Elf64_Section	st_shndx;		/* Section index */
+  Elf64_Addr	st_value;		/* Symbol value */
+  Elf64_Xword	st_size;		/* Symbol size */
+} Elf64_Sym;
+
+/* The syminfo section if available contains additional information about
+   every dynamic symbol.  */
+
+typedef struct
+{
+  Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
+  Elf32_Half si_flags;			/* Per symbol flags */
+} Elf32_Syminfo;
+
+typedef struct
+{
+  Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
+  Elf64_Half si_flags;			/* Per symbol flags */
+} Elf64_Syminfo;
+
+/* Possible values for si_boundto.  */
+#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
+#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
+#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */
+
+/* Possible bitmasks for si_flags.  */
+#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
+#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
+#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
+#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
+					   loaded */
+/* Syminfo version values.  */
+#define SYMINFO_NONE		0
+#define SYMINFO_CURRENT		1
+#define SYMINFO_NUM		2
+
+
+/* How to extract and insert information held in the st_info field.  */
+
+#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
+#define ELF32_ST_TYPE(val)		((val) & 0xf)
+#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
+
+/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
+#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
+#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
+#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
+
+/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
+
+#define STB_LOCAL	0		/* Local symbol */
+#define STB_GLOBAL	1		/* Global symbol */
+#define STB_WEAK	2		/* Weak symbol */
+#define	STB_NUM		3		/* Number of defined types.  */
+#define STB_LOOS	10		/* Start of OS-specific */
+#define STB_GNU_UNIQUE	10		/* Unique symbol.  */
+#define STB_HIOS	12		/* End of OS-specific */
+#define STB_LOPROC	13		/* Start of processor-specific */
+#define STB_HIPROC	15		/* End of processor-specific */
+
+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
+
+#define STT_NOTYPE	0		/* Symbol type is unspecified */
+#define STT_OBJECT	1		/* Symbol is a data object */
+#define STT_FUNC	2		/* Symbol is a code object */
+#define STT_SECTION	3		/* Symbol associated with a section */
+#define STT_FILE	4		/* Symbol's name is file name */
+#define STT_COMMON	5		/* Symbol is a common data object */
+#define STT_TLS		6		/* Symbol is thread-local data object*/
+#define	STT_NUM		7		/* Number of defined types.  */
+#define STT_LOOS	10		/* Start of OS-specific */
+#define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
+#define STT_HIOS	12		/* End of OS-specific */
+#define STT_LOPROC	13		/* Start of processor-specific */
+#define STT_HIPROC	15		/* End of processor-specific */
+
+
+/* Symbol table indices are found in the hash buckets and chain table
+   of a symbol hash table section.  This special index value indicates
+   the end of a chain, meaning no further symbols are found in that bucket.  */
+
+#define STN_UNDEF	0		/* End of a chain.  */
+
+
+/* How to extract and insert information held in the st_other field.  */
+
+#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
+
+/* For ELF64 the definitions are the same.  */
+#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
+
+/* Symbol visibility specification encoded in the st_other field.  */
+#define STV_DEFAULT	0		/* Default symbol visibility rules */
+#define STV_INTERNAL	1		/* Processor specific hidden class */
+#define STV_HIDDEN	2		/* Sym unavailable in other modules */
+#define STV_PROTECTED	3		/* Not preemptible, not exported */
+
+
+/* Relocation table entry without addend (in section of type SHT_REL).  */
+
+typedef struct
+{
+  Elf32_Addr	r_offset;		/* Address */
+  Elf32_Word	r_info;			/* Relocation type and symbol index */
+} Elf32_Rel;
+
+/* I have seen two different definitions of the Elf64_Rel and
+   Elf64_Rela structures, so we'll leave them out until Novell (or
+   whoever) gets their act together.  */
+/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
+
+typedef struct
+{
+  Elf64_Addr	r_offset;		/* Address */
+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
+} Elf64_Rel;
+
+/* Relocation table entry with addend (in section of type SHT_RELA).  */
+
+typedef struct
+{
+  Elf32_Addr	r_offset;		/* Address */
+  Elf32_Word	r_info;			/* Relocation type and symbol index */
+  Elf32_Sword	r_addend;		/* Addend */
+} Elf32_Rela;
+
+typedef struct
+{
+  Elf64_Addr	r_offset;		/* Address */
+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
+  Elf64_Sxword	r_addend;		/* Addend */
+} Elf64_Rela;
+
+/* How to extract and insert information held in the r_info field.  */
+
+#define ELF32_R_SYM(val)		((val) >> 8)
+#define ELF32_R_TYPE(val)		((val) & 0xff)
+#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
+
+#define ELF64_R_SYM(i)			((i) >> 32)
+#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
+#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
+
+/* Program segment header.  */
+
+typedef struct
+{
+  Elf32_Word	p_type;			/* Segment type */
+  Elf32_Off	p_offset;		/* Segment file offset */
+  Elf32_Addr	p_vaddr;		/* Segment virtual address */
+  Elf32_Addr	p_paddr;		/* Segment physical address */
+  Elf32_Word	p_filesz;		/* Segment size in file */
+  Elf32_Word	p_memsz;		/* Segment size in memory */
+  Elf32_Word	p_flags;		/* Segment flags */
+  Elf32_Word	p_align;		/* Segment alignment */
+} Elf32_Phdr;
+
+typedef struct
+{
+  Elf64_Word	p_type;			/* Segment type */
+  Elf64_Word	p_flags;		/* Segment flags */
+  Elf64_Off	p_offset;		/* Segment file offset */
+  Elf64_Addr	p_vaddr;		/* Segment virtual address */
+  Elf64_Addr	p_paddr;		/* Segment physical address */
+  Elf64_Xword	p_filesz;		/* Segment size in file */
+  Elf64_Xword	p_memsz;		/* Segment size in memory */
+  Elf64_Xword	p_align;		/* Segment alignment */
+} Elf64_Phdr;
+
+/* Special value for e_phnum.  This indicates that the real number of
+   program headers is too large to fit into e_phnum.  Instead the real
+   value is in the field sh_info of section 0.  */
+
+#define PN_XNUM		0xffff
+
+/* Legal values for p_type (segment type).  */
+
+#define	PT_NULL		0		/* Program header table entry unused */
+#define PT_LOAD		1		/* Loadable program segment */
+#define PT_DYNAMIC	2		/* Dynamic linking information */
+#define PT_INTERP	3		/* Program interpreter */
+#define PT_NOTE		4		/* Auxiliary information */
+#define PT_SHLIB	5		/* Reserved */
+#define PT_PHDR		6		/* Entry for header table itself */
+#define PT_TLS		7		/* Thread-local storage segment */
+#define	PT_NUM		8		/* Number of defined types */
+#define PT_LOOS		0x60000000	/* Start of OS-specific */
+#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
+#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
+#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
+#define PT_LOSUNW	0x6ffffffa
+#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
+#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
+#define PT_HISUNW	0x6fffffff
+#define PT_HIOS		0x6fffffff	/* End of OS-specific */
+#define PT_LOPROC	0x70000000	/* Start of processor-specific */
+#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
+
+/* Legal values for p_flags (segment flags).  */
+
+#define PF_X		(1 << 0)	/* Segment is executable */
+#define PF_W		(1 << 1)	/* Segment is writable */
+#define PF_R		(1 << 2)	/* Segment is readable */
+#define PF_MASKOS	0x0ff00000	/* OS-specific */
+#define PF_MASKPROC	0xf0000000	/* Processor-specific */
+
+/* Legal values for note segment descriptor types for core files. */
+
+#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
+#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
+#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
+#define NT_PRXREG	4		/* Contains copy of prxregset struct */
+#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
+#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
+#define NT_AUXV		6		/* Contains copy of auxv array */
+#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
+#define NT_ASRS		8		/* Contains copy of asrset struct */
+#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
+#define NT_PSINFO	13		/* Contains copy of psinfo struct */
+#define NT_PRCRED	14		/* Contains copy of prcred struct */
+#define NT_UTSNAME	15		/* Contains copy of utsname struct */
+#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
+#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
+#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct */
+#define NT_SIGINFO	0x53494749	/* Contains copy of siginfo_t,
+					   size might increase */
+#define NT_FILE		0x46494c45	/* Contains information about mapped
+					   files */
+#define NT_PRXFPREG	0x46e62b7f	/* Contains copy of user_fxsr_struct */
+#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
+#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
+#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
+#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
+#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
+#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
+#define NT_S390_HIGH_GPRS	0x300	/* s390 upper register halves */
+#define NT_S390_TIMER	0x301		/* s390 timer register */
+#define NT_S390_TODCMP	0x302		/* s390 TOD clock comparator register */
+#define NT_S390_TODPREG	0x303		/* s390 TOD programmable register */
+#define NT_S390_CTRS	0x304		/* s390 control registers */
+#define NT_S390_PREFIX	0x305		/* s390 prefix register */
+#define NT_S390_LAST_BREAK	0x306	/* s390 breaking event address */
+#define NT_S390_SYSTEM_CALL	0x307	/* s390 system call restart data */
+#define NT_S390_TDB	0x308		/* s390 transaction diagnostic block */
+#define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
+#define NT_ARM_TLS	0x401		/* ARM TLS register */
+#define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
+#define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
+
+/* Legal values for the note segment descriptor types for object files.  */
+
+#define NT_VERSION	1		/* Contains a version string.  */
+
+
+/* Dynamic section entry.  */
+
+typedef struct
+{
+  Elf32_Sword	d_tag;			/* Dynamic entry type */
+  union
+    {
+      Elf32_Word d_val;			/* Integer value */
+      Elf32_Addr d_ptr;			/* Address value */
+    } d_un;
+} Elf32_Dyn;
+
+typedef struct
+{
+  Elf64_Sxword	d_tag;			/* Dynamic entry type */
+  union
+    {
+      Elf64_Xword d_val;		/* Integer value */
+      Elf64_Addr d_ptr;			/* Address value */
+    } d_un;
+} Elf64_Dyn;
+
+/* Legal values for d_tag (dynamic entry type).  */
+
+#define DT_NULL		0		/* Marks end of dynamic section */
+#define DT_NEEDED	1		/* Name of needed library */
+#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
+#define DT_PLTGOT	3		/* Processor defined value */
+#define DT_HASH		4		/* Address of symbol hash table */
+#define DT_STRTAB	5		/* Address of string table */
+#define DT_SYMTAB	6		/* Address of symbol table */
+#define DT_RELA		7		/* Address of Rela relocs */
+#define DT_RELASZ	8		/* Total size of Rela relocs */
+#define DT_RELAENT	9		/* Size of one Rela reloc */
+#define DT_STRSZ	10		/* Size of string table */
+#define DT_SYMENT	11		/* Size of one symbol table entry */
+#define DT_INIT		12		/* Address of init function */
+#define DT_FINI		13		/* Address of termination function */
+#define DT_SONAME	14		/* Name of shared object */
+#define DT_RPATH	15		/* Library search path (deprecated) */
+#define DT_SYMBOLIC	16		/* Start symbol search here */
+#define DT_REL		17		/* Address of Rel relocs */
+#define DT_RELSZ	18		/* Total size of Rel relocs */
+#define DT_RELENT	19		/* Size of one Rel reloc */
+#define DT_PLTREL	20		/* Type of reloc in PLT */
+#define DT_DEBUG	21		/* For debugging; unspecified */
+#define DT_TEXTREL	22		/* Reloc might modify .text */
+#define DT_JMPREL	23		/* Address of PLT relocs */
+#define	DT_BIND_NOW	24		/* Process relocations of object */
+#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
+#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
+#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
+#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
+#define DT_RUNPATH	29		/* Library search path */
+#define DT_FLAGS	30		/* Flags for the object being loaded */
+#define DT_ENCODING	32		/* Start of encoded range */
+#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
+#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
+#define	DT_NUM		34		/* Number used */
+#define DT_LOOS		0x6000000d	/* Start of OS-specific */
+#define DT_HIOS		0x6ffff000	/* End of OS-specific */
+#define DT_LOPROC	0x70000000	/* Start of processor-specific */
+#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
+#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
+
+/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
+   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
+   approach.  */
+#define DT_VALRNGLO	0x6ffffd00
+#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
+#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
+#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
+#define DT_CHECKSUM	0x6ffffdf8
+#define DT_PLTPADSZ	0x6ffffdf9
+#define DT_MOVEENT	0x6ffffdfa
+#define DT_MOVESZ	0x6ffffdfb
+#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
+#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
+					   the following DT_* entry.  */
+#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
+#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
+#define DT_VALRNGHI	0x6ffffdff
+#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
+#define DT_VALNUM 12
+
+/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
+   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
+
+   If any adjustment is made to the ELF object after it has been
+   built these entries will need to be adjusted.  */
+#define DT_ADDRRNGLO	0x6ffffe00
+#define DT_GNU_HASH	0x6ffffef5	/* GNU-style hash table.  */
+#define DT_TLSDESC_PLT	0x6ffffef6
+#define DT_TLSDESC_GOT	0x6ffffef7
+#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
+#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
+#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
+#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
+#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
+#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
+#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
+#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
+#define DT_ADDRRNGHI	0x6ffffeff
+#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
+#define DT_ADDRNUM 11
+
+/* The versioning entry types.  The next are defined as part of the
+   GNU extension.  */
+#define DT_VERSYM	0x6ffffff0
+
+#define DT_RELACOUNT	0x6ffffff9
+#define DT_RELCOUNT	0x6ffffffa
+
+/* These were chosen by Sun.  */
+#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
+#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
+					   table */
+#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
+#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
+					   versions */
+#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
+#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
+#define DT_VERSIONTAGNUM 16
+
+/* Sun added these machine-independent extensions in the "processor-specific"
+   range.  Be compatible.  */
+#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
+#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
+#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
+#define DT_EXTRANUM	3
+
+/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
+#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
+#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
+#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
+#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
+#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
+
+/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
+   entry in the dynamic section.  */
+#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
+#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
+#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
+#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
+#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
+#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
+#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
+#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
+#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
+#define DF_1_TRANS	0x00000200
+#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
+#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
+#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
+#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
+#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
+#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
+#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
+#define	DF_1_NODIRECT	0x00020000	/* Object has no-direct binding. */
+#define	DF_1_IGNMULDEF	0x00040000
+#define	DF_1_NOKSYMS	0x00080000
+#define	DF_1_NOHDR	0x00100000
+#define	DF_1_EDITED	0x00200000	/* Object is modified after built.  */
+#define	DF_1_NORELOC	0x00400000
+#define	DF_1_SYMINTPOSE	0x00800000	/* Object has individual interposers.  */
+#define	DF_1_GLOBAUDIT	0x01000000	/* Global auditing required.  */
+#define	DF_1_SINGLETON	0x02000000	/* Singleton symbols are used.  */
+
+/* Flags for the feature selection in DT_FEATURE_1.  */
+#define DTF_1_PARINIT	0x00000001
+#define DTF_1_CONFEXP	0x00000002
+
+/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
+#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
+#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
+					   generally available.  */
+
+/* Version definition sections.  */
+
+typedef struct
+{
+  Elf32_Half	vd_version;		/* Version revision */
+  Elf32_Half	vd_flags;		/* Version information */
+  Elf32_Half	vd_ndx;			/* Version Index */
+  Elf32_Half	vd_cnt;			/* Number of associated aux entries */
+  Elf32_Word	vd_hash;		/* Version name hash value */
+  Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
+  Elf32_Word	vd_next;		/* Offset in bytes to next verdef
+					   entry */
+} Elf32_Verdef;
+
+typedef struct
+{
+  Elf64_Half	vd_version;		/* Version revision */
+  Elf64_Half	vd_flags;		/* Version information */
+  Elf64_Half	vd_ndx;			/* Version Index */
+  Elf64_Half	vd_cnt;			/* Number of associated aux entries */
+  Elf64_Word	vd_hash;		/* Version name hash value */
+  Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
+  Elf64_Word	vd_next;		/* Offset in bytes to next verdef
+					   entry */
+} Elf64_Verdef;
+
+
+/* Legal values for vd_version (version revision).  */
+#define VER_DEF_NONE	0		/* No version */
+#define VER_DEF_CURRENT	1		/* Current version */
+#define VER_DEF_NUM	2		/* Given version number */
+
+/* Legal values for vd_flags (version information flags).  */
+#define VER_FLG_BASE	0x1		/* Version definition of file itself */
+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
+
+/* Versym symbol index values.  */
+#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
+#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
+#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
+#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */
+
+/* Auxialiary version information.  */
+
+typedef struct
+{
+  Elf32_Word	vda_name;		/* Version or dependency names */
+  Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
+					   entry */
+} Elf32_Verdaux;
+
+typedef struct
+{
+  Elf64_Word	vda_name;		/* Version or dependency names */
+  Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
+					   entry */
+} Elf64_Verdaux;
+
+
+/* Version dependency section.  */
+
+typedef struct
+{
+  Elf32_Half	vn_version;		/* Version of structure */
+  Elf32_Half	vn_cnt;			/* Number of associated aux entries */
+  Elf32_Word	vn_file;		/* Offset of filename for this
+					   dependency */
+  Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
+  Elf32_Word	vn_next;		/* Offset in bytes to next verneed
+					   entry */
+} Elf32_Verneed;
+
+typedef struct
+{
+  Elf64_Half	vn_version;		/* Version of structure */
+  Elf64_Half	vn_cnt;			/* Number of associated aux entries */
+  Elf64_Word	vn_file;		/* Offset of filename for this
+					   dependency */
+  Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
+  Elf64_Word	vn_next;		/* Offset in bytes to next verneed
+					   entry */
+} Elf64_Verneed;
+
+
+/* Legal values for vn_version (version revision).  */
+#define VER_NEED_NONE	 0		/* No version */
+#define VER_NEED_CURRENT 1		/* Current version */
+#define VER_NEED_NUM	 2		/* Given version number */
+
+/* Auxiliary needed version information.  */
+
+typedef struct
+{
+  Elf32_Word	vna_hash;		/* Hash value of dependency name */
+  Elf32_Half	vna_flags;		/* Dependency specific information */
+  Elf32_Half	vna_other;		/* Unused */
+  Elf32_Word	vna_name;		/* Dependency name string offset */
+  Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
+					   entry */
+} Elf32_Vernaux;
+
+typedef struct
+{
+  Elf64_Word	vna_hash;		/* Hash value of dependency name */
+  Elf64_Half	vna_flags;		/* Dependency specific information */
+  Elf64_Half	vna_other;		/* Unused */
+  Elf64_Word	vna_name;		/* Dependency name string offset */
+  Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
+					   entry */
+} Elf64_Vernaux;
+
+
+/* Legal values for vna_flags.  */
+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
+
+
+/* Auxiliary vector.  */
+
+/* This vector is normally only used by the program interpreter.  The
+   usual definition in an ABI supplement uses the name auxv_t.  The
+   vector is not usually defined in a standard <elf.h> file, but it
+   can't hurt.  We rename it to avoid conflicts.  The sizes of these
+   types are an arrangement between the exec server and the program
+   interpreter, so we don't fully specify them here.  */
+
+typedef struct
+{
+  uint32_t a_type;		/* Entry type */
+  union
+    {
+      uint32_t a_val;		/* Integer value */
+      /* We use to have pointer elements added here.  We cannot do that,
+	 though, since it does not work when using 32-bit definitions
+	 on 64-bit platforms and vice versa.  */
+    } a_un;
+} Elf32_auxv_t;
+
+typedef struct
+{
+  uint64_t a_type;		/* Entry type */
+  union
+    {
+      uint64_t a_val;		/* Integer value */
+      /* We use to have pointer elements added here.  We cannot do that,
+	 though, since it does not work when using 32-bit definitions
+	 on 64-bit platforms and vice versa.  */
+    } a_un;
+} Elf64_auxv_t;
+
+/* Legal values for a_type (entry type).  */
+
+#define AT_NULL		0		/* End of vector */
+#define AT_IGNORE	1		/* Entry should be ignored */
+#define AT_EXECFD	2		/* File descriptor of program */
+#define AT_PHDR		3		/* Program headers for program */
+#define AT_PHENT	4		/* Size of program header entry */
+#define AT_PHNUM	5		/* Number of program headers */
+#define AT_PAGESZ	6		/* System page size */
+#define AT_BASE		7		/* Base address of interpreter */
+#define AT_FLAGS	8		/* Flags */
+#define AT_ENTRY	9		/* Entry point of program */
+#define AT_NOTELF	10		/* Program is not ELF */
+#define AT_UID		11		/* Real uid */
+#define AT_EUID		12		/* Effective uid */
+#define AT_GID		13		/* Real gid */
+#define AT_EGID		14		/* Effective gid */
+#define AT_CLKTCK	17		/* Frequency of times() */
+
+/* Some more special a_type values describing the hardware.  */
+#define AT_PLATFORM	15		/* String identifying platform.  */
+#define AT_HWCAP	16		/* Machine-dependent hints about
+					   processor capabilities.  */
+
+/* This entry gives some information about the FPU initialization
+   performed by the kernel.  */
+#define AT_FPUCW	18		/* Used FPU control word.  */
+
+/* Cache block sizes.  */
+#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
+#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
+#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */
+
+/* A special ignored value for PPC, used by the kernel to control the
+   interpretation of the AUXV. Must be > 16.  */
+#define AT_IGNOREPPC	22		/* Entry should be ignored.  */
+
+#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
+
+#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/
+
+#define AT_RANDOM	25		/* Address of 16 random bytes.  */
+
+#define AT_HWCAP2	26		/* More machine-dependent hints about
+					   processor capabilities.  */
+
+#define AT_EXECFN	31		/* Filename of executable.  */
+
+/* Pointer to the global system page used for system calls and other
+   nice things.  */
+#define AT_SYSINFO	32
+#define AT_SYSINFO_EHDR	33
+
+/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
+   log2 of line size; mask those to get cache size.  */
+#define AT_L1I_CACHESHAPE	34
+#define AT_L1D_CACHESHAPE	35
+#define AT_L2_CACHESHAPE	36
+#define AT_L3_CACHESHAPE	37
+
+/* Note section contents.  Each entry in the note section begins with
+   a header of a fixed form.  */
+
+typedef struct
+{
+  Elf32_Word n_namesz;			/* Length of the note's name.  */
+  Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
+  Elf32_Word n_type;			/* Type of the note.  */
+} Elf32_Nhdr;
+
+typedef struct
+{
+  Elf64_Word n_namesz;			/* Length of the note's name.  */
+  Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
+  Elf64_Word n_type;			/* Type of the note.  */
+} Elf64_Nhdr;
+
+/* Known names of notes.  */
+
+/* Solaris entries in the note section have this name.  */
+#define ELF_NOTE_SOLARIS	"SUNW Solaris"
+
+/* Note entries for GNU systems have this name.  */
+#define ELF_NOTE_GNU		"GNU"
+
+
+/* Defined types of notes for Solaris.  */
+
+/* Value of descriptor (one word) is desired pagesize for the binary.  */
+#define ELF_NOTE_PAGESIZE_HINT	1
+
+
+/* Defined note types for GNU systems.  */
+
+/* ABI information.  The descriptor consists of words:
+   word 0: OS descriptor
+   word 1: major version of the ABI
+   word 2: minor version of the ABI
+   word 3: subminor version of the ABI
+*/
+#define NT_GNU_ABI_TAG	1
+#define ELF_NOTE_ABI	NT_GNU_ABI_TAG /* Old name.  */
+
+/* Known OSes.  These values can appear in word 0 of an
+   NT_GNU_ABI_TAG note section entry.  */
+#define ELF_NOTE_OS_LINUX	0
+#define ELF_NOTE_OS_GNU		1
+#define ELF_NOTE_OS_SOLARIS2	2
+#define ELF_NOTE_OS_FREEBSD	3
+
+/* Synthetic hwcap information.  The descriptor begins with two words:
+   word 0: number of entries
+   word 1: bitmask of enabled entries
+   Then follow variable-length entries, one byte followed by a
+   '\0'-terminated hwcap name string.  The byte gives the bit
+   number to test if enabled, (1U << bit) & bitmask.  */
+#define NT_GNU_HWCAP	2
+
+/* Build ID bits as generated by ld --build-id.
+   The descriptor consists of any nonzero number of bytes.  */
+#define NT_GNU_BUILD_ID	3
+
+/* Version note generated by GNU gold containing a version string.  */
+#define NT_GNU_GOLD_VERSION	4
+
+
+/* Move records.  */
+typedef struct
+{
+  Elf32_Xword m_value;		/* Symbol value.  */
+  Elf32_Word m_info;		/* Size and index.  */
+  Elf32_Word m_poffset;		/* Symbol offset.  */
+  Elf32_Half m_repeat;		/* Repeat count.  */
+  Elf32_Half m_stride;		/* Stride info.  */
+} Elf32_Move;
+
+typedef struct
+{
+  Elf64_Xword m_value;		/* Symbol value.  */
+  Elf64_Xword m_info;		/* Size and index.  */
+  Elf64_Xword m_poffset;	/* Symbol offset.  */
+  Elf64_Half m_repeat;		/* Repeat count.  */
+  Elf64_Half m_stride;		/* Stride info.  */
+} Elf64_Move;
+
+/* Macro to construct move records.  */
+#define ELF32_M_SYM(info)	((info) >> 8)
+#define ELF32_M_SIZE(info)	((unsigned char) (info))
+#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
+
+#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
+#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
+#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
+
+
+/* Motorola 68k specific definitions.  */
+
+/* Values for Elf32_Ehdr.e_flags.  */
+#define EF_CPU32	0x00810000
+
+/* m68k relocs.  */
+
+#define R_68K_NONE	0		/* No reloc */
+#define R_68K_32	1		/* Direct 32 bit  */
+#define R_68K_16	2		/* Direct 16 bit  */
+#define R_68K_8		3		/* Direct 8 bit  */
+#define R_68K_PC32	4		/* PC relative 32 bit */
+#define R_68K_PC16	5		/* PC relative 16 bit */
+#define R_68K_PC8	6		/* PC relative 8 bit */
+#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
+#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
+#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
+#define R_68K_GOT32O	10		/* 32 bit GOT offset */
+#define R_68K_GOT16O	11		/* 16 bit GOT offset */
+#define R_68K_GOT8O	12		/* 8 bit GOT offset */
+#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
+#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
+#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
+#define R_68K_PLT32O	16		/* 32 bit PLT offset */
+#define R_68K_PLT16O	17		/* 16 bit PLT offset */
+#define R_68K_PLT8O	18		/* 8 bit PLT offset */
+#define R_68K_COPY	19		/* Copy symbol at runtime */
+#define R_68K_GLOB_DAT	20		/* Create GOT entry */
+#define R_68K_JMP_SLOT	21		/* Create PLT entry */
+#define R_68K_RELATIVE	22		/* Adjust by program base */
+#define R_68K_TLS_GD32      25          /* 32 bit GOT offset for GD */
+#define R_68K_TLS_GD16      26          /* 16 bit GOT offset for GD */
+#define R_68K_TLS_GD8       27          /* 8 bit GOT offset for GD */
+#define R_68K_TLS_LDM32     28          /* 32 bit GOT offset for LDM */
+#define R_68K_TLS_LDM16     29          /* 16 bit GOT offset for LDM */
+#define R_68K_TLS_LDM8      30          /* 8 bit GOT offset for LDM */
+#define R_68K_TLS_LDO32     31          /* 32 bit module-relative offset */
+#define R_68K_TLS_LDO16     32          /* 16 bit module-relative offset */
+#define R_68K_TLS_LDO8      33          /* 8 bit module-relative offset */
+#define R_68K_TLS_IE32      34          /* 32 bit GOT offset for IE */
+#define R_68K_TLS_IE16      35          /* 16 bit GOT offset for IE */
+#define R_68K_TLS_IE8       36          /* 8 bit GOT offset for IE */
+#define R_68K_TLS_LE32      37          /* 32 bit offset relative to
+					   static TLS block */
+#define R_68K_TLS_LE16      38          /* 16 bit offset relative to
+					   static TLS block */
+#define R_68K_TLS_LE8       39          /* 8 bit offset relative to
+					   static TLS block */
+#define R_68K_TLS_DTPMOD32  40          /* 32 bit module number */
+#define R_68K_TLS_DTPREL32  41          /* 32 bit module-relative offset */
+#define R_68K_TLS_TPREL32   42          /* 32 bit TP-relative offset */
+/* Keep this the last entry.  */
+#define R_68K_NUM	43
+
+/* Intel 80386 specific definitions.  */
+
+/* i386 relocs.  */
+
+#define R_386_NONE	   0		/* No reloc */
+#define R_386_32	   1		/* Direct 32 bit  */
+#define R_386_PC32	   2		/* PC relative 32 bit */
+#define R_386_GOT32	   3		/* 32 bit GOT entry */
+#define R_386_PLT32	   4		/* 32 bit PLT address */
+#define R_386_COPY	   5		/* Copy symbol at runtime */
+#define R_386_GLOB_DAT	   6		/* Create GOT entry */
+#define R_386_JMP_SLOT	   7		/* Create PLT entry */
+#define R_386_RELATIVE	   8		/* Adjust by program base */
+#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
+#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
+#define R_386_32PLT	   11
+#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
+#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
+					   block offset */
+#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
+					   offset */
+#define R_386_TLS_LE	   17		/* Offset relative to static TLS
+					   block */
+#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
+					   general dynamic thread local data */
+#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
+					   local dynamic thread local data
+					   in LE code */
+#define R_386_16	   20
+#define R_386_PC16	   21
+#define R_386_8		   22
+#define R_386_PC8	   23
+#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
+					   thread local data */
+#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
+#define R_386_TLS_GD_CALL  26		/* Relocation for call to
+					   __tls_get_addr() */
+#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
+#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
+					   thread local data in LE code */
+#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
+#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
+					   __tls_get_addr() in LDM code */
+#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
+#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
+#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
+					   block offset */
+#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
+					   TLS block */
+#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
+#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
+#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
+#define R_386_SIZE32	   38 		/* 32-bit symbol size */
+#define R_386_TLS_GOTDESC  39		/* GOT offset for TLS descriptor.  */
+#define R_386_TLS_DESC_CALL 40		/* Marker of call through TLS
+					   descriptor for
+					   relaxation.  */
+#define R_386_TLS_DESC     41		/* TLS descriptor containing
+					   pointer to code and to
+					   argument, returning the TLS
+					   offset for the symbol.  */
+#define R_386_IRELATIVE	   42		/* Adjust indirectly by program base */
+/* Keep this the last entry.  */
+#define R_386_NUM	   43
+
+/* SUN SPARC specific definitions.  */
+
+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
+
+#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */
+
+/* Values for Elf64_Ehdr.e_flags.  */
+
+#define EF_SPARCV9_MM		3
+#define EF_SPARCV9_TSO		0
+#define EF_SPARCV9_PSO		1
+#define EF_SPARCV9_RMO		2
+#define EF_SPARC_LEDATA		0x800000 /* little endian data */
+#define EF_SPARC_EXT_MASK	0xFFFF00
+#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
+#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
+#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
+#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */
+
+/* SPARC relocs.  */
+
+#define R_SPARC_NONE		0	/* No reloc */
+#define R_SPARC_8		1	/* Direct 8 bit */
+#define R_SPARC_16		2	/* Direct 16 bit */
+#define R_SPARC_32		3	/* Direct 32 bit */
+#define R_SPARC_DISP8		4	/* PC relative 8 bit */
+#define R_SPARC_DISP16		5	/* PC relative 16 bit */
+#define R_SPARC_DISP32		6	/* PC relative 32 bit */
+#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
+#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
+#define R_SPARC_HI22		9	/* High 22 bit */
+#define R_SPARC_22		10	/* Direct 22 bit */
+#define R_SPARC_13		11	/* Direct 13 bit */
+#define R_SPARC_LO10		12	/* Truncated 10 bit */
+#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
+#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
+#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
+#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
+#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
+#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
+#define R_SPARC_COPY		19	/* Copy symbol at runtime */
+#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
+#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
+#define R_SPARC_RELATIVE	22	/* Adjust by program base */
+#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */
+
+/* Additional Sparc64 relocs.  */
+
+#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
+#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
+#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
+#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
+#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
+#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
+#define R_SPARC_10		30	/* Direct 10 bit */
+#define R_SPARC_11		31	/* Direct 11 bit */
+#define R_SPARC_64		32	/* Direct 64 bit */
+#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
+#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
+#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
+#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
+#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
+#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
+#define R_SPARC_PC_LM22		39	/* Low miggle 22 bits of ... */
+#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
+#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
+#define R_SPARC_GLOB_JMP	42	/* was part of v9 ABI but was removed */
+#define R_SPARC_7		43	/* Direct 7 bit */
+#define R_SPARC_5		44	/* Direct 5 bit */
+#define R_SPARC_6		45	/* Direct 6 bit */
+#define R_SPARC_DISP64		46	/* PC relative 64 bit */
+#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
+#define R_SPARC_HIX22		48	/* High 22 bit complemented */
+#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
+#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
+#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
+#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
+#define R_SPARC_REGISTER	53	/* Global register usage */
+#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
+#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
+#define R_SPARC_TLS_GD_HI22	56
+#define R_SPARC_TLS_GD_LO10	57
+#define R_SPARC_TLS_GD_ADD	58
+#define R_SPARC_TLS_GD_CALL	59
+#define R_SPARC_TLS_LDM_HI22	60
+#define R_SPARC_TLS_LDM_LO10	61
+#define R_SPARC_TLS_LDM_ADD	62
+#define R_SPARC_TLS_LDM_CALL	63
+#define R_SPARC_TLS_LDO_HIX22	64
+#define R_SPARC_TLS_LDO_LOX10	65
+#define R_SPARC_TLS_LDO_ADD	66
+#define R_SPARC_TLS_IE_HI22	67
+#define R_SPARC_TLS_IE_LO10	68
+#define R_SPARC_TLS_IE_LD	69
+#define R_SPARC_TLS_IE_LDX	70
+#define R_SPARC_TLS_IE_ADD	71
+#define R_SPARC_TLS_LE_HIX22	72
+#define R_SPARC_TLS_LE_LOX10	73
+#define R_SPARC_TLS_DTPMOD32	74
+#define R_SPARC_TLS_DTPMOD64	75
+#define R_SPARC_TLS_DTPOFF32	76
+#define R_SPARC_TLS_DTPOFF64	77
+#define R_SPARC_TLS_TPOFF32	78
+#define R_SPARC_TLS_TPOFF64	79
+#define R_SPARC_GOTDATA_HIX22	80
+#define R_SPARC_GOTDATA_LOX10	81
+#define R_SPARC_GOTDATA_OP_HIX22	82
+#define R_SPARC_GOTDATA_OP_LOX10	83
+#define R_SPARC_GOTDATA_OP	84
+#define R_SPARC_H34		85
+#define R_SPARC_SIZE32		86
+#define R_SPARC_SIZE64		87
+#define R_SPARC_WDISP10		88
+#define R_SPARC_JMP_IREL	248
+#define R_SPARC_IRELATIVE	249
+#define R_SPARC_GNU_VTINHERIT	250
+#define R_SPARC_GNU_VTENTRY	251
+#define R_SPARC_REV32		252
+/* Keep this the last entry.  */
+#define R_SPARC_NUM		253
+
+/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
+
+#define DT_SPARC_REGISTER	0x70000001
+#define DT_SPARC_NUM		2
+
+/* MIPS R3000 specific definitions.  */
+
+/* Legal values for e_flags field of Elf32_Ehdr.  */
+
+#define EF_MIPS_NOREORDER	1     /* A .noreorder directive was used.  */
+#define EF_MIPS_PIC		2     /* Contains PIC code.  */
+#define EF_MIPS_CPIC		4     /* Uses PIC calling sequence.  */
+#define EF_MIPS_XGOT		8
+#define EF_MIPS_64BIT_WHIRL	16
+#define EF_MIPS_ABI2		32
+#define EF_MIPS_ABI_ON32	64
+#define EF_MIPS_NAN2008	1024  /* Uses IEEE 754-2008 NaN encoding.  */
+#define EF_MIPS_ARCH		0xf0000000 /* MIPS architecture level.  */
+
+/* Legal values for MIPS architecture level.  */
+
+#define EF_MIPS_ARCH_1		0x00000000 /* -mips1 code.  */
+#define EF_MIPS_ARCH_2		0x10000000 /* -mips2 code.  */
+#define EF_MIPS_ARCH_3		0x20000000 /* -mips3 code.  */
+#define EF_MIPS_ARCH_4		0x30000000 /* -mips4 code.  */
+#define EF_MIPS_ARCH_5		0x40000000 /* -mips5 code.  */
+#define EF_MIPS_ARCH_32		0x50000000 /* MIPS32 code.  */
+#define EF_MIPS_ARCH_64		0x60000000 /* MIPS64 code.  */
+#define EF_MIPS_ARCH_32R2	0x70000000 /* MIPS32r2 code.  */
+#define EF_MIPS_ARCH_64R2	0x80000000 /* MIPS64r2 code.  */
+
+/* The following are unofficial names and should not be used.  */
+
+#define E_MIPS_ARCH_1		EF_MIPS_ARCH_1
+#define E_MIPS_ARCH_2		EF_MIPS_ARCH_2
+#define E_MIPS_ARCH_3		EF_MIPS_ARCH_3
+#define E_MIPS_ARCH_4		EF_MIPS_ARCH_4
+#define E_MIPS_ARCH_5		EF_MIPS_ARCH_5
+#define E_MIPS_ARCH_32		EF_MIPS_ARCH_32
+#define E_MIPS_ARCH_64		EF_MIPS_ARCH_64
+
+/* Special section indices.  */
+
+#define SHN_MIPS_ACOMMON	0xff00	/* Allocated common symbols.  */
+#define SHN_MIPS_TEXT		0xff01	/* Allocated test symbols.  */
+#define SHN_MIPS_DATA		0xff02	/* Allocated data symbols.  */
+#define SHN_MIPS_SCOMMON 	0xff03	/* Small common symbols.  */
+#define SHN_MIPS_SUNDEFINED	0xff04	/* Small undefined symbols.  */
+
+/* Legal values for sh_type field of Elf32_Shdr.  */
+
+#define SHT_MIPS_LIBLIST	0x70000000 /* Shared objects used in link.  */
+#define SHT_MIPS_MSYM		0x70000001
+#define SHT_MIPS_CONFLICT	0x70000002 /* Conflicting symbols.  */
+#define SHT_MIPS_GPTAB		0x70000003 /* Global data area sizes.  */
+#define SHT_MIPS_UCODE		0x70000004 /* Reserved for SGI/MIPS compilers */
+#define SHT_MIPS_DEBUG		0x70000005 /* MIPS ECOFF debugging info.  */
+#define SHT_MIPS_REGINFO	0x70000006 /* Register usage information.  */
+#define SHT_MIPS_PACKAGE	0x70000007
+#define SHT_MIPS_PACKSYM	0x70000008
+#define SHT_MIPS_RELD		0x70000009
+#define SHT_MIPS_IFACE		0x7000000b
+#define SHT_MIPS_CONTENT	0x7000000c
+#define SHT_MIPS_OPTIONS	0x7000000d /* Miscellaneous options.  */
+#define SHT_MIPS_SHDR		0x70000010
+#define SHT_MIPS_FDESC		0x70000011
+#define SHT_MIPS_EXTSYM		0x70000012
+#define SHT_MIPS_DENSE		0x70000013
+#define SHT_MIPS_PDESC		0x70000014
+#define SHT_MIPS_LOCSYM		0x70000015
+#define SHT_MIPS_AUXSYM		0x70000016
+#define SHT_MIPS_OPTSYM		0x70000017
+#define SHT_MIPS_LOCSTR		0x70000018
+#define SHT_MIPS_LINE		0x70000019
+#define SHT_MIPS_RFDESC		0x7000001a
+#define SHT_MIPS_DELTASYM	0x7000001b
+#define SHT_MIPS_DELTAINST	0x7000001c
+#define SHT_MIPS_DELTACLASS	0x7000001d
+#define SHT_MIPS_DWARF		0x7000001e /* DWARF debugging information.  */
+#define SHT_MIPS_DELTADECL	0x7000001f
+#define SHT_MIPS_SYMBOL_LIB	0x70000020
+#define SHT_MIPS_EVENTS		0x70000021 /* Event section.  */
+#define SHT_MIPS_TRANSLATE	0x70000022
+#define SHT_MIPS_PIXIE		0x70000023
+#define SHT_MIPS_XLATE		0x70000024
+#define SHT_MIPS_XLATE_DEBUG	0x70000025
+#define SHT_MIPS_WHIRL		0x70000026
+#define SHT_MIPS_EH_REGION	0x70000027
+#define SHT_MIPS_XLATE_OLD	0x70000028
+#define SHT_MIPS_PDR_EXCEPTION	0x70000029
+
+/* Legal values for sh_flags field of Elf32_Shdr.  */
+
+#define SHF_MIPS_GPREL		0x10000000 /* Must be in global data area.  */
+#define SHF_MIPS_MERGE		0x20000000
+#define SHF_MIPS_ADDR		0x40000000
+#define SHF_MIPS_STRINGS	0x80000000
+#define SHF_MIPS_NOSTRIP	0x08000000
+#define SHF_MIPS_LOCAL		0x04000000
+#define SHF_MIPS_NAMES		0x02000000
+#define SHF_MIPS_NODUPE		0x01000000
+
+
+/* Symbol tables.  */
+
+/* MIPS specific values for `st_other'.  */
+#define STO_MIPS_DEFAULT		0x0
+#define STO_MIPS_INTERNAL		0x1
+#define STO_MIPS_HIDDEN			0x2
+#define STO_MIPS_PROTECTED		0x3
+#define STO_MIPS_PLT			0x8
+#define STO_MIPS_SC_ALIGN_UNUSED	0xff
+
+/* MIPS specific values for `st_info'.  */
+#define STB_MIPS_SPLIT_COMMON		13
+
+/* Entries found in sections of type SHT_MIPS_GPTAB.  */
+
+typedef union
+{
+  struct
+    {
+      Elf32_Word gt_current_g_value;	/* -G value used for compilation.  */
+      Elf32_Word gt_unused;		/* Not used.  */
+    } gt_header;			/* First entry in section.  */
+  struct
+    {
+      Elf32_Word gt_g_value;		/* If this value were used for -G.  */
+      Elf32_Word gt_bytes;		/* This many bytes would be used.  */
+    } gt_entry;				/* Subsequent entries in section.  */
+} Elf32_gptab;
+
+/* Entry found in sections of type SHT_MIPS_REGINFO.  */
+
+typedef struct
+{
+  Elf32_Word ri_gprmask;		/* General registers used.  */
+  Elf32_Word ri_cprmask[4];		/* Coprocessor registers used.  */
+  Elf32_Sword ri_gp_value;		/* $gp register value.  */
+} Elf32_RegInfo;
+
+/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
+
+typedef struct
+{
+  unsigned char kind;		/* Determines interpretation of the
+				   variable part of descriptor.  */
+  unsigned char size;		/* Size of descriptor, including header.  */
+  Elf32_Section section;	/* Section header index of section affected,
+				   0 for global options.  */
+  Elf32_Word info;		/* Kind-specific information.  */
+} Elf_Options;
+
+/* Values for `kind' field in Elf_Options.  */
+
+#define ODK_NULL	0	/* Undefined.  */
+#define ODK_REGINFO	1	/* Register usage information.  */
+#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
+#define ODK_PAD		3	/* Section padding options.  */
+#define ODK_HWPATCH	4	/* Hardware workarounds performed */
+#define ODK_FILL	5	/* record the fill value used by the linker. */
+#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
+#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
+#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */
+
+/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
+
+#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
+#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
+#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
+#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
+#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
+#define OEX_PRECISEFP	OEX_FPDBUG
+#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */
+
+#define OEX_FPU_INVAL	0x10
+#define OEX_FPU_DIV0	0x08
+#define OEX_FPU_OFLO	0x04
+#define OEX_FPU_UFLO	0x02
+#define OEX_FPU_INEX	0x01
+
+/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
+
+#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
+#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
+#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
+#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */
+
+#define OPAD_PREFIX	0x1
+#define OPAD_POSTFIX	0x2
+#define OPAD_SYMBOL	0x4
+
+/* Entry found in `.options' section.  */
+
+typedef struct
+{
+  Elf32_Word hwp_flags1;	/* Extra flags.  */
+  Elf32_Word hwp_flags2;	/* Extra flags.  */
+} Elf_Options_Hw;
+
+/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
+
+#define OHWA0_R4KEOP_CHECKED	0x00000001
+#define OHWA1_R4KEOP_CLEAN	0x00000002
+
+/* MIPS relocs.  */
+
+#define R_MIPS_NONE		0	/* No reloc */
+#define R_MIPS_16		1	/* Direct 16 bit */
+#define R_MIPS_32		2	/* Direct 32 bit */
+#define R_MIPS_REL32		3	/* PC relative 32 bit */
+#define R_MIPS_26		4	/* Direct 26 bit shifted */
+#define R_MIPS_HI16		5	/* High 16 bit */
+#define R_MIPS_LO16		6	/* Low 16 bit */
+#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
+#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
+#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
+#define R_MIPS_PC16		10	/* PC relative 16 bit */
+#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
+#define R_MIPS_GPREL32		12	/* GP relative 32 bit */
+
+#define R_MIPS_SHIFT5		16
+#define R_MIPS_SHIFT6		17
+#define R_MIPS_64		18
+#define R_MIPS_GOT_DISP		19
+#define R_MIPS_GOT_PAGE		20
+#define R_MIPS_GOT_OFST		21
+#define R_MIPS_GOT_HI16		22
+#define R_MIPS_GOT_LO16		23
+#define R_MIPS_SUB		24
+#define R_MIPS_INSERT_A		25
+#define R_MIPS_INSERT_B		26
+#define R_MIPS_DELETE		27
+#define R_MIPS_HIGHER		28
+#define R_MIPS_HIGHEST		29
+#define R_MIPS_CALL_HI16	30
+#define R_MIPS_CALL_LO16	31
+#define R_MIPS_SCN_DISP		32
+#define R_MIPS_REL16		33
+#define R_MIPS_ADD_IMMEDIATE	34
+#define R_MIPS_PJUMP		35
+#define R_MIPS_RELGOT		36
+#define R_MIPS_JALR		37
+#define R_MIPS_TLS_DTPMOD32	38	/* Module number 32 bit */
+#define R_MIPS_TLS_DTPREL32	39	/* Module-relative offset 32 bit */
+#define R_MIPS_TLS_DTPMOD64	40	/* Module number 64 bit */
+#define R_MIPS_TLS_DTPREL64	41	/* Module-relative offset 64 bit */
+#define R_MIPS_TLS_GD		42	/* 16 bit GOT offset for GD */
+#define R_MIPS_TLS_LDM		43	/* 16 bit GOT offset for LDM */
+#define R_MIPS_TLS_DTPREL_HI16	44	/* Module-relative offset, high 16 bits */
+#define R_MIPS_TLS_DTPREL_LO16	45	/* Module-relative offset, low 16 bits */
+#define R_MIPS_TLS_GOTTPREL	46	/* 16 bit GOT offset for IE */
+#define R_MIPS_TLS_TPREL32	47	/* TP-relative offset, 32 bit */
+#define R_MIPS_TLS_TPREL64	48	/* TP-relative offset, 64 bit */
+#define R_MIPS_TLS_TPREL_HI16	49	/* TP-relative offset, high 16 bits */
+#define R_MIPS_TLS_TPREL_LO16	50	/* TP-relative offset, low 16 bits */
+#define R_MIPS_GLOB_DAT		51
+#define R_MIPS_COPY		126
+#define R_MIPS_JUMP_SLOT        127
+/* Keep this the last entry.  */
+#define R_MIPS_NUM		128
+
+/* Legal values for p_type field of Elf32_Phdr.  */
+
+#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
+#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
+#define PT_MIPS_OPTIONS 0x70000002
+
+/* Special program header types.  */
+
+#define PF_MIPS_LOCAL	0x10000000
+
+/* Legal values for d_tag field of Elf32_Dyn.  */
+
+#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
+#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
+#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
+#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
+#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
+#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
+#define DT_MIPS_MSYM	     0x70000007
+#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
+#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
+#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
+#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
+#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
+#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
+#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
+#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
+#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
+#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
+#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
+#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
+						DT_MIPS_DELTA_CLASS.  */
+#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
+#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
+						DT_MIPS_DELTA_INSTANCE.  */
+#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
+#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
+					     DT_MIPS_DELTA_RELOC.  */
+#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
+					   relocations refer to.  */
+#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
+					   DT_MIPS_DELTA_SYM.  */
+#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
+					     class declaration.  */
+#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
+						DT_MIPS_DELTA_CLASSSYM.  */
+#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
+#define DT_MIPS_PIXIE_INIT   0x70000023
+#define DT_MIPS_SYMBOL_LIB   0x70000024
+#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
+#define DT_MIPS_LOCAL_GOTIDX 0x70000026
+#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
+#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
+#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
+#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
+#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
+#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
+#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
+						    function stored in GOT.  */
+#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
+					   by rld on dlopen() calls.  */
+#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
+#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
+#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
+/* The address of .got.plt in an executable using the new non-PIC ABI.  */
+#define DT_MIPS_PLTGOT	     0x70000032
+/* The base of the PLT in an executable using the new non-PIC ABI if that
+   PLT is writable.  For a non-writable PLT, this is omitted or has a zero
+   value.  */
+#define DT_MIPS_RWPLT        0x70000034
+#define DT_MIPS_NUM	     0x35
+
+/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
+
+#define RHF_NONE		   0		/* No flags */
+#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
+#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
+#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
+#define RHF_NO_MOVE		   (1 << 3)
+#define RHF_SGI_ONLY		   (1 << 4)
+#define RHF_GUARANTEE_INIT	   (1 << 5)
+#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
+#define RHF_GUARANTEE_START_INIT   (1 << 7)
+#define RHF_PIXIE		   (1 << 8)
+#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
+#define RHF_REQUICKSTART	   (1 << 10)
+#define RHF_REQUICKSTARTED	   (1 << 11)
+#define RHF_CORD		   (1 << 12)
+#define RHF_NO_UNRES_UNDEF	   (1 << 13)
+#define RHF_RLD_ORDER_SAFE	   (1 << 14)
+
+/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
+
+typedef struct
+{
+  Elf32_Word l_name;		/* Name (string table index) */
+  Elf32_Word l_time_stamp;	/* Timestamp */
+  Elf32_Word l_checksum;	/* Checksum */
+  Elf32_Word l_version;		/* Interface version */
+  Elf32_Word l_flags;		/* Flags */
+} Elf32_Lib;
+
+typedef struct
+{
+  Elf64_Word l_name;		/* Name (string table index) */
+  Elf64_Word l_time_stamp;	/* Timestamp */
+  Elf64_Word l_checksum;	/* Checksum */
+  Elf64_Word l_version;		/* Interface version */
+  Elf64_Word l_flags;		/* Flags */
+} Elf64_Lib;
+
+
+/* Legal values for l_flags.  */
+
+#define LL_NONE		  0
+#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
+#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
+#define LL_REQUIRE_MINOR  (1 << 2)
+#define LL_EXPORTS	  (1 << 3)
+#define LL_DELAY_LOAD	  (1 << 4)
+#define LL_DELTA	  (1 << 5)
+
+/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
+
+typedef Elf32_Addr Elf32_Conflict;
+
+
+/* HPPA specific definitions.  */
+
+/* Legal values for e_flags field of Elf32_Ehdr.  */
+
+#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
+#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
+#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
+#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
+#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
+					      prediction.  */
+#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
+#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
+
+/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
+
+#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
+#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
+#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */
+
+/* Additional section indeces.  */
+
+#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively declared
+					      symbols in ANSI C.  */
+#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */
+
+/* Legal values for sh_type field of Elf32_Shdr.  */
+
+#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
+#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
+#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */
+
+/* Legal values for sh_flags field of Elf32_Shdr.  */
+
+#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
+#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
+#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */
+
+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
+
+#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */
+
+#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
+#define STT_HP_STUB		(STT_LOOS + 0x2)
+
+/* HPPA relocs.  */
+
+#define R_PARISC_NONE		0	/* No reloc.  */
+#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
+#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
+#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
+#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
+#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
+#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
+#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
+#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
+#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
+#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
+#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
+#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
+#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
+#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
+#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
+#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
+#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
+#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
+#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
+#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
+#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
+#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
+#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
+#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
+#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
+#define R_PARISC_PLABEL21L	66	/* Left 21 bits of fdesc address.  */
+#define R_PARISC_PLABEL14R	70	/* Right 14 bits of fdesc address.  */
+#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
+#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
+#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
+#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
+#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
+#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
+#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
+#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
+#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
+#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
+#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
+#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
+#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
+#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
+#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
+#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
+#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
+#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
+#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
+#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
+#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
+#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
+#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
+#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
+#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
+#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
+#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
+#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
+#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
+#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
+#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
+#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
+#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
+#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
+#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
+#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
+#define R_PARISC_LORESERVE	128
+#define R_PARISC_COPY		128	/* Copy relocation.  */
+#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
+#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
+#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
+#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
+#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
+#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
+#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
+#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
+#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
+#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
+#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
+#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
+#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
+#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
+#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
+#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
+#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
+#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
+#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
+#define R_PARISC_GNU_VTENTRY	232
+#define R_PARISC_GNU_VTINHERIT	233
+#define R_PARISC_TLS_GD21L	234	/* GD 21-bit left.  */
+#define R_PARISC_TLS_GD14R	235	/* GD 14-bit right.  */
+#define R_PARISC_TLS_GDCALL	236	/* GD call to __t_g_a.  */
+#define R_PARISC_TLS_LDM21L	237	/* LD module 21-bit left.  */
+#define R_PARISC_TLS_LDM14R	238	/* LD module 14-bit right.  */
+#define R_PARISC_TLS_LDMCALL	239	/* LD module call to __t_g_a.  */
+#define R_PARISC_TLS_LDO21L	240	/* LD offset 21-bit left.  */
+#define R_PARISC_TLS_LDO14R	241	/* LD offset 14-bit right.  */
+#define R_PARISC_TLS_DTPMOD32	242	/* DTP module 32-bit.  */
+#define R_PARISC_TLS_DTPMOD64	243	/* DTP module 64-bit.  */
+#define R_PARISC_TLS_DTPOFF32	244	/* DTP offset 32-bit.  */
+#define R_PARISC_TLS_DTPOFF64	245	/* DTP offset 32-bit.  */
+#define R_PARISC_TLS_LE21L	R_PARISC_TPREL21L
+#define R_PARISC_TLS_LE14R	R_PARISC_TPREL14R
+#define R_PARISC_TLS_IE21L	R_PARISC_LTOFF_TP21L
+#define R_PARISC_TLS_IE14R	R_PARISC_LTOFF_TP14R
+#define R_PARISC_TLS_TPREL32	R_PARISC_TPREL32
+#define R_PARISC_TLS_TPREL64	R_PARISC_TPREL64
+#define R_PARISC_HIRESERVE	255
+
+/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
+
+#define PT_HP_TLS		(PT_LOOS + 0x0)
+#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
+#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
+#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
+#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
+#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
+#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
+#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
+#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
+#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
+#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
+#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
+#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
+#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
+#define PT_HP_STACK		(PT_LOOS + 0x14)
+
+#define PT_PARISC_ARCHEXT	0x70000000
+#define PT_PARISC_UNWIND	0x70000001
+
+/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
+
+#define PF_PARISC_SBP		0x08000000
+
+#define PF_HP_PAGE_SIZE		0x00100000
+#define PF_HP_FAR_SHARED	0x00200000
+#define PF_HP_NEAR_SHARED	0x00400000
+#define PF_HP_CODE		0x01000000
+#define PF_HP_MODIFY		0x02000000
+#define PF_HP_LAZYSWAP		0x04000000
+#define PF_HP_SBP		0x08000000
+
+
+/* Alpha specific definitions.  */
+
+/* Legal values for e_flags field of Elf64_Ehdr.  */
+
+#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
+#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */
+
+/* Legal values for sh_type field of Elf64_Shdr.  */
+
+/* These two are primerily concerned with ECOFF debugging info.  */
+#define SHT_ALPHA_DEBUG		0x70000001
+#define SHT_ALPHA_REGINFO	0x70000002
+
+/* Legal values for sh_flags field of Elf64_Shdr.  */
+
+#define SHF_ALPHA_GPREL		0x10000000
+
+/* Legal values for st_other field of Elf64_Sym.  */
+#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
+#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */
+
+/* Alpha relocs.  */
+
+#define R_ALPHA_NONE		0	/* No reloc */
+#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
+#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
+#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
+#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
+#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
+#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
+#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
+#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
+#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
+#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
+#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
+#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
+#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
+#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
+#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
+#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
+#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
+#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
+#define R_ALPHA_TLS_GD_HI	28
+#define R_ALPHA_TLSGD		29
+#define R_ALPHA_TLS_LDM		30
+#define R_ALPHA_DTPMOD64	31
+#define R_ALPHA_GOTDTPREL	32
+#define R_ALPHA_DTPREL64	33
+#define R_ALPHA_DTPRELHI	34
+#define R_ALPHA_DTPRELLO	35
+#define R_ALPHA_DTPREL16	36
+#define R_ALPHA_GOTTPREL	37
+#define R_ALPHA_TPREL64		38
+#define R_ALPHA_TPRELHI		39
+#define R_ALPHA_TPRELLO		40
+#define R_ALPHA_TPREL16		41
+/* Keep this the last entry.  */
+#define R_ALPHA_NUM		46
+
+/* Magic values of the LITUSE relocation addend.  */
+#define LITUSE_ALPHA_ADDR	0
+#define LITUSE_ALPHA_BASE	1
+#define LITUSE_ALPHA_BYTOFF	2
+#define LITUSE_ALPHA_JSR	3
+#define LITUSE_ALPHA_TLS_GD	4
+#define LITUSE_ALPHA_TLS_LDM	5
+
+/* Legal values for d_tag of Elf64_Dyn.  */
+#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
+#define DT_ALPHA_NUM		1
+
+/* PowerPC specific declarations */
+
+/* Values for Elf32/64_Ehdr.e_flags.  */
+#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */
+
+/* Cygnus local bits below */
+#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
+#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
+						   flag */
+
+/* PowerPC relocations defined by the ABIs */
+#define R_PPC_NONE		0
+#define R_PPC_ADDR32		1	/* 32bit absolute address */
+#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
+#define R_PPC_ADDR16		3	/* 16bit absolute address */
+#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
+#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
+#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
+#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
+#define R_PPC_ADDR14_BRTAKEN	8
+#define R_PPC_ADDR14_BRNTAKEN	9
+#define R_PPC_REL24		10	/* PC relative 26 bit */
+#define R_PPC_REL14		11	/* PC relative 16 bit */
+#define R_PPC_REL14_BRTAKEN	12
+#define R_PPC_REL14_BRNTAKEN	13
+#define R_PPC_GOT16		14
+#define R_PPC_GOT16_LO		15
+#define R_PPC_GOT16_HI		16
+#define R_PPC_GOT16_HA		17
+#define R_PPC_PLTREL24		18
+#define R_PPC_COPY		19
+#define R_PPC_GLOB_DAT		20
+#define R_PPC_JMP_SLOT		21
+#define R_PPC_RELATIVE		22
+#define R_PPC_LOCAL24PC		23
+#define R_PPC_UADDR32		24
+#define R_PPC_UADDR16		25
+#define R_PPC_REL32		26
+#define R_PPC_PLT32		27
+#define R_PPC_PLTREL32		28
+#define R_PPC_PLT16_LO		29
+#define R_PPC_PLT16_HI		30
+#define R_PPC_PLT16_HA		31
+#define R_PPC_SDAREL16		32
+#define R_PPC_SECTOFF		33
+#define R_PPC_SECTOFF_LO	34
+#define R_PPC_SECTOFF_HI	35
+#define R_PPC_SECTOFF_HA	36
+
+/* PowerPC relocations defined for the TLS access ABI.  */
+#define R_PPC_TLS		67 /* none	(sym+add)@tls */
+#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
+#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
+#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
+#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
+#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
+#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
+#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
+#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
+#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
+#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
+#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
+#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
+#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
+#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
+#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
+#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
+#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
+#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
+#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
+#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
+#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
+#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
+#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
+#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
+#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
+#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
+#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */
+
+/* The remaining relocs are from the Embedded ELF ABI, and are not
+   in the SVR4 ELF ABI.  */
+#define R_PPC_EMB_NADDR32	101
+#define R_PPC_EMB_NADDR16	102
+#define R_PPC_EMB_NADDR16_LO	103
+#define R_PPC_EMB_NADDR16_HI	104
+#define R_PPC_EMB_NADDR16_HA	105
+#define R_PPC_EMB_SDAI16	106
+#define R_PPC_EMB_SDA2I16	107
+#define R_PPC_EMB_SDA2REL	108
+#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
+#define R_PPC_EMB_MRKREF	110
+#define R_PPC_EMB_RELSEC16	111
+#define R_PPC_EMB_RELST_LO	112
+#define R_PPC_EMB_RELST_HI	113
+#define R_PPC_EMB_RELST_HA	114
+#define R_PPC_EMB_BIT_FLD	115
+#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */
+
+/* Diab tool relocations.  */
+#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
+#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
+#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
+#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
+#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
+#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */
+
+/* GNU extension to support local ifunc.  */
+#define R_PPC_IRELATIVE		248
+
+/* GNU relocs used in PIC code sequences.  */
+#define R_PPC_REL16		249	/* half16   (sym+add-.) */
+#define R_PPC_REL16_LO		250	/* half16   (sym+add-.)@l */
+#define R_PPC_REL16_HI		251	/* half16   (sym+add-.)@h */
+#define R_PPC_REL16_HA		252	/* half16   (sym+add-.)@ha */
+
+/* This is a phony reloc to handle any old fashioned TOC16 references
+   that may still be in object files.  */
+#define R_PPC_TOC16		255
+
+/* PowerPC specific values for the Dyn d_tag field.  */
+#define DT_PPC_GOT		(DT_LOPROC + 0)
+#define DT_PPC_NUM		1
+
+/* PowerPC64 relocations defined by the ABIs */
+#define R_PPC64_NONE		R_PPC_NONE
+#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
+#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
+#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
+#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
+#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
+#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
+#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
+#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
+#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
+#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
+#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
+#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
+#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
+#define R_PPC64_GOT16		R_PPC_GOT16
+#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
+#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
+#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
+
+#define R_PPC64_COPY		R_PPC_COPY
+#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
+#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
+#define R_PPC64_RELATIVE	R_PPC_RELATIVE
+
+#define R_PPC64_UADDR32		R_PPC_UADDR32
+#define R_PPC64_UADDR16		R_PPC_UADDR16
+#define R_PPC64_REL32		R_PPC_REL32
+#define R_PPC64_PLT32		R_PPC_PLT32
+#define R_PPC64_PLTREL32	R_PPC_PLTREL32
+#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
+#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
+#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
+
+#define R_PPC64_SECTOFF		R_PPC_SECTOFF
+#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
+#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
+#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
+#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
+#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
+#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
+#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
+#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
+#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
+#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
+#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
+#define R_PPC64_PLT64		45 /* doubleword64 L + A */
+#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
+#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
+#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
+#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
+#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
+#define R_PPC64_TOC		51 /* doubleword64 .TOC */
+#define R_PPC64_PLTGOT16	52 /* half16* M + A */
+#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
+#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
+#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */
+
+#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
+#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
+#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
+#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
+#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
+#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
+#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
+#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
+#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
+#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
+#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */
+
+/* PowerPC64 relocations defined for the TLS access ABI.  */
+#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
+#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
+#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
+#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
+#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
+#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
+#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
+#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
+#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
+#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
+#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
+#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
+#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
+#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
+#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
+#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
+#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
+#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
+#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
+#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
+#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
+#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
+#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
+#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
+#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
+#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
+#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
+#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
+#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
+#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
+#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
+#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
+#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
+#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
+#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
+#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
+#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
+#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
+#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
+#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */
+#define R_PPC64_TLSGD		107 /* none	(sym+add)@tlsgd */
+#define R_PPC64_TLSLD		108 /* none	(sym+add)@tlsld */
+#define R_PPC64_TOCSAVE		109 /* none */
+
+/* Added when HA and HI relocs were changed to report overflows.  */
+#define R_PPC64_ADDR16_HIGH	110
+#define R_PPC64_ADDR16_HIGHA	111
+#define R_PPC64_TPREL16_HIGH	112
+#define R_PPC64_TPREL16_HIGHA	113
+#define R_PPC64_DTPREL16_HIGH	114
+#define R_PPC64_DTPREL16_HIGHA	115
+
+/* GNU extension to support local ifunc.  */
+#define R_PPC64_JMP_IREL	247
+#define R_PPC64_IRELATIVE	248
+#define R_PPC64_REL16		249	/* half16   (sym+add-.) */
+#define R_PPC64_REL16_LO	250	/* half16   (sym+add-.)@l */
+#define R_PPC64_REL16_HI	251	/* half16   (sym+add-.)@h */
+#define R_PPC64_REL16_HA	252	/* half16   (sym+add-.)@ha */
+
+/* e_flags bits specifying ABI.
+   1 for original function descriptor using ABI,
+   2 for revised ABI without function descriptors,
+   0 for unspecified or not using any features affected by the differences.  */
+#define EF_PPC64_ABI	3
+
+/* PowerPC64 specific values for the Dyn d_tag field.  */
+#define DT_PPC64_GLINK  (DT_LOPROC + 0)
+#define DT_PPC64_OPD	(DT_LOPROC + 1)
+#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
+#define DT_PPC64_OPT	(DT_LOPROC + 3)
+#define DT_PPC64_NUM    3
+
+/* PowerPC64 specific values for the DT_PPC64_OPT Dyn entry.  */
+#define PPC64_OPT_TLS		1
+#define PPC64_OPT_MULTI_TOC	2
+
+/* PowerPC64 specific values for the Elf64_Sym st_other field.  */
+#define STO_PPC64_LOCAL_BIT	5
+#define STO_PPC64_LOCAL_MASK	(7 << STO_PPC64_LOCAL_BIT)
+#define PPC64_LOCAL_ENTRY_OFFSET(other)				\
+ (((1 << (((other) & STO_PPC64_LOCAL_MASK) >> STO_PPC64_LOCAL_BIT)) >> 2) << 2)
+
+
+/* ARM specific declarations */
+
+/* Processor specific flags for the ELF header e_flags field.  */
+#define EF_ARM_RELEXEC		0x01
+#define EF_ARM_HASENTRY		0x02
+#define EF_ARM_INTERWORK	0x04
+#define EF_ARM_APCS_26		0x08
+#define EF_ARM_APCS_FLOAT	0x10
+#define EF_ARM_PIC		0x20
+#define EF_ARM_ALIGN8		0x40 /* 8-bit structure alignment is in use */
+#define EF_ARM_NEW_ABI		0x80
+#define EF_ARM_OLD_ABI		0x100
+#define EF_ARM_SOFT_FLOAT	0x200
+#define EF_ARM_VFP_FLOAT	0x400
+#define EF_ARM_MAVERICK_FLOAT	0x800
+
+#define EF_ARM_ABI_FLOAT_SOFT	0x200   /* NB conflicts with EF_ARM_SOFT_FLOAT */
+#define EF_ARM_ABI_FLOAT_HARD	0x400   /* NB conflicts with EF_ARM_VFP_FLOAT */
+
+
+/* Other constants defined in the ARM ELF spec. version B-01.  */
+/* NB. These conflict with values defined above.  */
+#define EF_ARM_SYMSARESORTED	0x04
+#define EF_ARM_DYNSYMSUSESEGIDX	0x08
+#define EF_ARM_MAPSYMSFIRST	0x10
+#define EF_ARM_EABIMASK		0XFF000000
+
+/* Constants defined in AAELF.  */
+#define EF_ARM_BE8	    0x00800000
+#define EF_ARM_LE8	    0x00400000
+
+#define EF_ARM_EABI_VERSION(flags)	((flags) & EF_ARM_EABIMASK)
+#define EF_ARM_EABI_UNKNOWN	0x00000000
+#define EF_ARM_EABI_VER1	0x01000000
+#define EF_ARM_EABI_VER2	0x02000000
+#define EF_ARM_EABI_VER3	0x03000000
+#define EF_ARM_EABI_VER4	0x04000000
+#define EF_ARM_EABI_VER5	0x05000000
+
+/* Additional symbol types for Thumb.  */
+#define STT_ARM_TFUNC		STT_LOPROC /* A Thumb function.  */
+#define STT_ARM_16BIT		STT_HIPROC /* A Thumb label.  */
+
+/* ARM-specific values for sh_flags */
+#define SHF_ARM_ENTRYSECT	0x10000000 /* Section contains an entry point */
+#define SHF_ARM_COMDEF		0x80000000 /* Section may be multiply defined
+					      in the input to a link step.  */
+
+/* ARM-specific program header flags */
+#define PF_ARM_SB		0x10000000 /* Segment contains the location
+					      addressed by the static base. */
+#define PF_ARM_PI		0x20000000 /* Position-independent segment.  */
+#define PF_ARM_ABS		0x40000000 /* Absolute segment.  */
+
+/* Processor specific values for the Phdr p_type field.  */
+#define PT_ARM_EXIDX		(PT_LOPROC + 1)	/* ARM unwind segment.  */
+
+/* Processor specific values for the Shdr sh_type field.  */
+#define SHT_ARM_EXIDX		(SHT_LOPROC + 1) /* ARM unwind section.  */
+#define SHT_ARM_PREEMPTMAP	(SHT_LOPROC + 2) /* Preemption details.  */
+#define SHT_ARM_ATTRIBUTES	(SHT_LOPROC + 3) /* ARM attributes section.  */
+
+
+/* AArch64 relocs.  */
+
+#define R_AARCH64_NONE            0	/* No relocation.  */
+#define R_AARCH64_ABS64         257	/* Direct 64 bit. */
+#define R_AARCH64_ABS32         258	/* Direct 32 bit.  */
+#define R_AARCH64_ABS16		259	/* Direct 16-bit.  */
+#define R_AARCH64_PREL64	260	/* PC-relative 64-bit.	*/
+#define R_AARCH64_PREL32	261	/* PC-relative 32-bit.	*/
+#define R_AARCH64_PREL16	262	/* PC-relative 16-bit.	*/
+#define R_AARCH64_MOVW_UABS_G0	263	/* Dir. MOVZ imm. from bits 15:0.  */
+#define R_AARCH64_MOVW_UABS_G0_NC 264	/* Likewise for MOVK; no check.  */
+#define R_AARCH64_MOVW_UABS_G1	265	/* Dir. MOVZ imm. from bits 31:16.  */
+#define R_AARCH64_MOVW_UABS_G1_NC 266	/* Likewise for MOVK; no check.  */
+#define R_AARCH64_MOVW_UABS_G2	267	/* Dir. MOVZ imm. from bits 47:32.  */
+#define R_AARCH64_MOVW_UABS_G2_NC 268	/* Likewise for MOVK; no check.  */
+#define R_AARCH64_MOVW_UABS_G3	269	/* Dir. MOV{K,Z} imm. from 63:48.  */
+#define R_AARCH64_MOVW_SABS_G0	270	/* Dir. MOV{N,Z} imm. from 15:0.  */
+#define R_AARCH64_MOVW_SABS_G1	271	/* Dir. MOV{N,Z} imm. from 31:16.  */
+#define R_AARCH64_MOVW_SABS_G2	272	/* Dir. MOV{N,Z} imm. from 47:32.  */
+#define R_AARCH64_LD_PREL_LO19	273	/* PC-rel. LD imm. from bits 20:2.  */
+#define R_AARCH64_ADR_PREL_LO21	274	/* PC-rel. ADR imm. from bits 20:0.  */
+#define R_AARCH64_ADR_PREL_PG_HI21 275	/* Page-rel. ADRP imm. from 32:12.  */
+#define R_AARCH64_ADR_PREL_PG_HI21_NC 276 /* Likewise; no overflow check.  */
+#define R_AARCH64_ADD_ABS_LO12_NC 277	/* Dir. ADD imm. from bits 11:0.  */
+#define R_AARCH64_LDST8_ABS_LO12_NC 278	/* Likewise for LD/ST; no check. */
+#define R_AARCH64_TSTBR14	279	/* PC-rel. TBZ/TBNZ imm. from 15:2.  */
+#define R_AARCH64_CONDBR19	280	/* PC-rel. cond. br. imm. from 20:2. */
+#define R_AARCH64_JUMP26	282	/* PC-rel. B imm. from bits 27:2.  */
+#define R_AARCH64_CALL26	283	/* Likewise for CALL.  */
+#define R_AARCH64_LDST16_ABS_LO12_NC 284 /* Dir. ADD imm. from bits 11:1.  */
+#define R_AARCH64_LDST32_ABS_LO12_NC 285 /* Likewise for bits 11:2.  */
+#define R_AARCH64_LDST64_ABS_LO12_NC 286 /* Likewise for bits 11:3.  */
+#define R_AARCH64_MOVW_PREL_G0	287	/* PC-rel. MOV{N,Z} imm. from 15:0.  */
+#define R_AARCH64_MOVW_PREL_G0_NC 288	/* Likewise for MOVK; no check.  */
+#define R_AARCH64_MOVW_PREL_G1	289	/* PC-rel. MOV{N,Z} imm. from 31:16. */
+#define R_AARCH64_MOVW_PREL_G1_NC 290	/* Likewise for MOVK; no check.  */
+#define R_AARCH64_MOVW_PREL_G2	291	/* PC-rel. MOV{N,Z} imm. from 47:32. */
+#define R_AARCH64_MOVW_PREL_G2_NC 292	/* Likewise for MOVK; no check.  */
+#define R_AARCH64_MOVW_PREL_G3	293	/* PC-rel. MOV{N,Z} imm. from 63:48. */
+#define R_AARCH64_LDST128_ABS_LO12_NC 299 /* Dir. ADD imm. from bits 11:4.  */
+#define R_AARCH64_MOVW_GOTOFF_G0 300	/* GOT-rel. off. MOV{N,Z} imm. 15:0. */
+#define R_AARCH64_MOVW_GOTOFF_G0_NC 301	/* Likewise for MOVK; no check.  */
+#define R_AARCH64_MOVW_GOTOFF_G1 302	/* GOT-rel. o. MOV{N,Z} imm. 31:16.  */
+#define R_AARCH64_MOVW_GOTOFF_G1_NC 303	/* Likewise for MOVK; no check.  */
+#define R_AARCH64_MOVW_GOTOFF_G2 304	/* GOT-rel. o. MOV{N,Z} imm. 47:32.  */
+#define R_AARCH64_MOVW_GOTOFF_G2_NC 305	/* Likewise for MOVK; no check.  */
+#define R_AARCH64_MOVW_GOTOFF_G3 306	/* GOT-rel. o. MOV{N,Z} imm. 63:48.  */
+#define R_AARCH64_GOTREL64	307	/* GOT-relative 64-bit.  */
+#define R_AARCH64_GOTREL32	308	/* GOT-relative 32-bit.  */
+#define R_AARCH64_GOT_LD_PREL19	309	/* PC-rel. GOT off. load imm. 20:2.  */
+#define R_AARCH64_LD64_GOTOFF_LO15 310	/* GOT-rel. off. LD/ST imm. 14:3.  */
+#define R_AARCH64_ADR_GOT_PAGE	311	/* P-page-rel. GOT off. ADRP 32:12.  */
+#define R_AARCH64_LD64_GOT_LO12_NC 312	/* Dir. GOT off. LD/ST imm. 11:3.  */
+#define R_AARCH64_LD64_GOTPAGE_LO15 313	/* GOT-page-rel. GOT off. LD/ST 14:3 */
+#define R_AARCH64_TLSGD_ADR_PREL21 512	/* PC-relative ADR imm. 20:0.  */
+#define R_AARCH64_TLSGD_ADR_PAGE21 513	/* page-rel. ADRP imm. 32:12.  */
+#define R_AARCH64_TLSGD_ADD_LO12_NC 514	/* direct ADD imm. from 11:0.  */
+#define R_AARCH64_TLSGD_MOVW_G1	515	/* GOT-rel. MOV{N,Z} 31:16.  */
+#define R_AARCH64_TLSGD_MOVW_G0_NC 516	/* GOT-rel. MOVK imm. 15:0.  */
+#define R_AARCH64_TLSLD_ADR_PREL21 517	/* Like 512; local dynamic model.  */
+#define R_AARCH64_TLSLD_ADR_PAGE21 518	/* Like 513; local dynamic model.  */
+#define R_AARCH64_TLSLD_ADD_LO12_NC 519	/* Like 514; local dynamic model.  */
+#define R_AARCH64_TLSLD_MOVW_G1	520	/* Like 515; local dynamic model.  */
+#define R_AARCH64_TLSLD_MOVW_G0_NC 521	/* Like 516; local dynamic model.  */
+#define R_AARCH64_TLSLD_LD_PREL19 522	/* TLS PC-rel. load imm. 20:2.  */
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G2 523 /* TLS DTP-rel. MOV{N,Z} 47:32.  */
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G1 524 /* TLS DTP-rel. MOV{N,Z} 31:16.  */
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC 525 /* Likewise; MOVK; no check.  */
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G0 526 /* TLS DTP-rel. MOV{N,Z} 15:0.  */
+#define R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC 527 /* Likewise; MOVK; no check.  */
+#define R_AARCH64_TLSLD_ADD_DTPREL_HI12 528 /* DTP-rel. ADD imm. from 23:12. */
+#define R_AARCH64_TLSLD_ADD_DTPREL_LO12 529 /* DTP-rel. ADD imm. from 11:0.  */
+#define R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC 530 /* Likewise; no ovfl. check.  */
+#define R_AARCH64_TLSLD_LDST8_DTPREL_LO12 531 /* DTP-rel. LD/ST imm. 11:0.  */
+#define R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC 532 /* Likewise; no check.  */
+#define R_AARCH64_TLSLD_LDST16_DTPREL_LO12 533 /* DTP-rel. LD/ST imm. 11:1.  */
+#define R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC 534 /* Likewise; no check.  */
+#define R_AARCH64_TLSLD_LDST32_DTPREL_LO12 535 /* DTP-rel. LD/ST imm. 11:2.  */
+#define R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC 536 /* Likewise; no check.  */
+#define R_AARCH64_TLSLD_LDST64_DTPREL_LO12 537 /* DTP-rel. LD/ST imm. 11:3.  */
+#define R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC 538 /* Likewise; no check.  */
+#define R_AARCH64_TLSIE_MOVW_GOTTPREL_G1 539 /* GOT-rel. MOV{N,Z} 31:16.  */
+#define R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC 540 /* GOT-rel. MOVK 15:0.  */
+#define R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 541 /* Page-rel. ADRP 32:12.  */
+#define R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC 542 /* Direct LD off. 11:3.  */
+#define R_AARCH64_TLSIE_LD_GOTTPREL_PREL19 543 /* PC-rel. load imm. 20:2.  */
+#define R_AARCH64_TLSLE_MOVW_TPREL_G2 544 /* TLS TP-rel. MOV{N,Z} 47:32.  */
+#define R_AARCH64_TLSLE_MOVW_TPREL_G1 545 /* TLS TP-rel. MOV{N,Z} 31:16.  */
+#define R_AARCH64_TLSLE_MOVW_TPREL_G1_NC 546 /* Likewise; MOVK; no check.  */
+#define R_AARCH64_TLSLE_MOVW_TPREL_G0 547 /* TLS TP-rel. MOV{N,Z} 15:0.  */
+#define R_AARCH64_TLSLE_MOVW_TPREL_G0_NC 548 /* Likewise; MOVK; no check.  */
+#define R_AARCH64_TLSLE_ADD_TPREL_HI12 549 /* TP-rel. ADD imm. 23:12.  */
+#define R_AARCH64_TLSLE_ADD_TPREL_LO12 550 /* TP-rel. ADD imm. 11:0.  */
+#define R_AARCH64_TLSLE_ADD_TPREL_LO12_NC 551 /* Likewise; no ovfl. check.  */
+#define R_AARCH64_TLSLE_LDST8_TPREL_LO12 552 /* TP-rel. LD/ST off. 11:0.  */
+#define R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC 553 /* Likewise; no ovfl. check. */
+#define R_AARCH64_TLSLE_LDST16_TPREL_LO12 554 /* TP-rel. LD/ST off. 11:1.  */
+#define R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC 555 /* Likewise; no check.  */
+#define R_AARCH64_TLSLE_LDST32_TPREL_LO12 556 /* TP-rel. LD/ST off. 11:2.  */
+#define R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC 557 /* Likewise; no check.  */
+#define R_AARCH64_TLSLE_LDST64_TPREL_LO12 558 /* TP-rel. LD/ST off. 11:3.  */
+#define R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC 559 /* Likewise; no check.  */
+#define R_AARCH64_TLSDESC_LD_PREL19 560	/* PC-rel. load immediate 20:2.  */
+#define R_AARCH64_TLSDESC_ADR_PREL21 561 /* PC-rel. ADR immediate 20:0.  */
+#define R_AARCH64_TLSDESC_ADR_PAGE21 562 /* Page-rel. ADRP imm. 32:12.  */
+#define R_AARCH64_TLSDESC_LD64_LO12 563	/* Direct LD off. from 11:3.  */
+#define R_AARCH64_TLSDESC_ADD_LO12 564	/* Direct ADD imm. from 11:0.  */
+#define R_AARCH64_TLSDESC_OFF_G1 565	/* GOT-rel. MOV{N,Z} imm. 31:16.  */
+#define R_AARCH64_TLSDESC_OFF_G0_NC 566	/* GOT-rel. MOVK imm. 15:0; no ck.  */
+#define R_AARCH64_TLSDESC_LDR	567	/* Relax LDR.  */
+#define R_AARCH64_TLSDESC_ADD	568	/* Relax ADD.  */
+#define R_AARCH64_TLSDESC_CALL	569	/* Relax BLR.  */
+#define R_AARCH64_TLSLE_LDST128_TPREL_LO12 570 /* TP-rel. LD/ST off. 11:4.  */
+#define R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC 571 /* Likewise; no check.  */
+#define R_AARCH64_TLSLD_LDST128_DTPREL_LO12 572 /* DTP-rel. LD/ST imm. 11:4. */
+#define R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC 573 /* Likewise; no check.  */
+#define R_AARCH64_COPY         1024	/* Copy symbol at runtime.  */
+#define R_AARCH64_GLOB_DAT     1025	/* Create GOT entry.  */
+#define R_AARCH64_JUMP_SLOT    1026	/* Create PLT entry.  */
+#define R_AARCH64_RELATIVE     1027	/* Adjust by program base.  */
+#define R_AARCH64_TLS_DTPMOD64 1028	/* Module number, 64 bit.  */
+#define R_AARCH64_TLS_DTPREL64 1029	/* Module-relative offset, 64 bit.  */
+#define R_AARCH64_TLS_TPREL64  1030	/* TP-relative offset, 64 bit.  */
+#define R_AARCH64_TLSDESC      1031	/* TLS Descriptor.  */
+#define R_AARCH64_IRELATIVE	1032	/* STT_GNU_IFUNC relocation.  */
+
+/* ARM relocs.  */
+
+#define R_ARM_NONE		0	/* No reloc */
+#define R_ARM_PC24		1	/* Deprecated PC relative 26
+					   bit branch.  */
+#define R_ARM_ABS32		2	/* Direct 32 bit  */
+#define R_ARM_REL32		3	/* PC relative 32 bit */
+#define R_ARM_PC13		4
+#define R_ARM_ABS16		5	/* Direct 16 bit */
+#define R_ARM_ABS12		6	/* Direct 12 bit */
+#define R_ARM_THM_ABS5		7	/* Direct & 0x7C (LDR, STR).  */
+#define R_ARM_ABS8		8	/* Direct 8 bit */
+#define R_ARM_SBREL32		9
+#define R_ARM_THM_PC22		10	/* PC relative 24 bit (Thumb32 BL).  */
+#define R_ARM_THM_PC8		11	/* PC relative & 0x3FC
+					   (Thumb16 LDR, ADD, ADR).  */
+#define R_ARM_AMP_VCALL9	12
+#define R_ARM_SWI24		13	/* Obsolete static relocation.  */
+#define R_ARM_TLS_DESC		13      /* Dynamic relocation.  */
+#define R_ARM_THM_SWI8		14	/* Reserved.  */
+#define R_ARM_XPC25		15	/* Reserved.  */
+#define R_ARM_THM_XPC22		16	/* Reserved.  */
+#define R_ARM_TLS_DTPMOD32	17	/* ID of module containing symbol */
+#define R_ARM_TLS_DTPOFF32	18	/* Offset in TLS block */
+#define R_ARM_TLS_TPOFF32	19	/* Offset in static TLS block */
+#define R_ARM_COPY		20	/* Copy symbol at runtime */
+#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
+#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
+#define R_ARM_RELATIVE		23	/* Adjust by program base */
+#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
+#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
+#define R_ARM_GOT32		26	/* 32 bit GOT entry */
+#define R_ARM_PLT32		27	/* Deprecated, 32 bit PLT address.  */
+#define R_ARM_CALL		28	/* PC relative 24 bit (BL, BLX).  */
+#define R_ARM_JUMP24		29	/* PC relative 24 bit
+					   (B, BL<cond>).  */
+#define R_ARM_THM_JUMP24	30	/* PC relative 24 bit (Thumb32 B.W).  */
+#define R_ARM_BASE_ABS		31	/* Adjust by program base.  */
+#define R_ARM_ALU_PCREL_7_0	32	/* Obsolete.  */
+#define R_ARM_ALU_PCREL_15_8	33	/* Obsolete.  */
+#define R_ARM_ALU_PCREL_23_15	34	/* Obsolete.  */
+#define R_ARM_LDR_SBREL_11_0	35	/* Deprecated, prog. base relative.  */
+#define R_ARM_ALU_SBREL_19_12	36	/* Deprecated, prog. base relative.  */
+#define R_ARM_ALU_SBREL_27_20	37	/* Deprecated, prog. base relative.  */
+#define R_ARM_TARGET1		38
+#define R_ARM_SBREL31		39	/* Program base relative.  */
+#define R_ARM_V4BX		40
+#define R_ARM_TARGET2		41
+#define R_ARM_PREL31		42	/* 32 bit PC relative.  */
+#define R_ARM_MOVW_ABS_NC	43	/* Direct 16-bit (MOVW).  */
+#define R_ARM_MOVT_ABS		44	/* Direct high 16-bit (MOVT).  */
+#define R_ARM_MOVW_PREL_NC	45	/* PC relative 16-bit (MOVW).  */
+#define R_ARM_MOVT_PREL		46	/* PC relative (MOVT).  */
+#define R_ARM_THM_MOVW_ABS_NC	47	/* Direct 16 bit (Thumb32 MOVW).  */
+#define R_ARM_THM_MOVT_ABS	48	/* Direct high 16 bit
+					   (Thumb32 MOVT).  */
+#define R_ARM_THM_MOVW_PREL_NC	49	/* PC relative 16 bit
+					   (Thumb32 MOVW).  */
+#define R_ARM_THM_MOVT_PREL	50	/* PC relative high 16 bit
+					   (Thumb32 MOVT).  */
+#define R_ARM_THM_JUMP19	51	/* PC relative 20 bit
+					   (Thumb32 B<cond>.W).  */
+#define R_ARM_THM_JUMP6		52	/* PC relative X & 0x7E
+					   (Thumb16 CBZ, CBNZ).  */
+#define R_ARM_THM_ALU_PREL_11_0	53	/* PC relative 12 bit
+					   (Thumb32 ADR.W).  */
+#define R_ARM_THM_PC12		54	/* PC relative 12 bit
+					   (Thumb32 LDR{D,SB,H,SH}).  */
+#define R_ARM_ABS32_NOI		55	/* Direct 32-bit.  */
+#define R_ARM_REL32_NOI		56	/* PC relative 32-bit.  */
+#define R_ARM_ALU_PC_G0_NC	57	/* PC relative (ADD, SUB).  */
+#define R_ARM_ALU_PC_G0		58	/* PC relative (ADD, SUB).  */
+#define R_ARM_ALU_PC_G1_NC	59	/* PC relative (ADD, SUB).  */
+#define R_ARM_ALU_PC_G1		60	/* PC relative (ADD, SUB).  */
+#define R_ARM_ALU_PC_G2		61	/* PC relative (ADD, SUB).  */
+#define R_ARM_LDR_PC_G1		62	/* PC relative (LDR,STR,LDRB,STRB).  */
+#define R_ARM_LDR_PC_G2		63	/* PC relative (LDR,STR,LDRB,STRB).  */
+#define R_ARM_LDRS_PC_G0	64	/* PC relative (STR{D,H},
+					   LDR{D,SB,H,SH}).  */
+#define R_ARM_LDRS_PC_G1	65	/* PC relative (STR{D,H},
+					   LDR{D,SB,H,SH}).  */
+#define R_ARM_LDRS_PC_G2	66	/* PC relative (STR{D,H},
+					   LDR{D,SB,H,SH}).  */
+#define R_ARM_LDC_PC_G0		67	/* PC relative (LDC, STC).  */
+#define R_ARM_LDC_PC_G1		68	/* PC relative (LDC, STC).  */
+#define R_ARM_LDC_PC_G2		69	/* PC relative (LDC, STC).  */
+#define R_ARM_ALU_SB_G0_NC	70	/* Program base relative (ADD,SUB).  */
+#define R_ARM_ALU_SB_G0		71	/* Program base relative (ADD,SUB).  */
+#define R_ARM_ALU_SB_G1_NC	72	/* Program base relative (ADD,SUB).  */
+#define R_ARM_ALU_SB_G1		73	/* Program base relative (ADD,SUB).  */
+#define R_ARM_ALU_SB_G2		74	/* Program base relative (ADD,SUB).  */
+#define R_ARM_LDR_SB_G0		75	/* Program base relative (LDR,
+					   STR, LDRB, STRB).  */
+#define R_ARM_LDR_SB_G1		76	/* Program base relative
+					   (LDR, STR, LDRB, STRB).  */
+#define R_ARM_LDR_SB_G2		77	/* Program base relative
+					   (LDR, STR, LDRB, STRB).  */
+#define R_ARM_LDRS_SB_G0	78	/* Program base relative
+					   (LDR, STR, LDRB, STRB).  */
+#define R_ARM_LDRS_SB_G1	79	/* Program base relative
+					   (LDR, STR, LDRB, STRB).  */
+#define R_ARM_LDRS_SB_G2	80	/* Program base relative
+					   (LDR, STR, LDRB, STRB).  */
+#define R_ARM_LDC_SB_G0		81	/* Program base relative (LDC,STC).  */
+#define R_ARM_LDC_SB_G1		82	/* Program base relative (LDC,STC).  */
+#define R_ARM_LDC_SB_G2		83	/* Program base relative (LDC,STC).  */
+#define R_ARM_MOVW_BREL_NC	84	/* Program base relative 16
+					   bit (MOVW).  */
+#define R_ARM_MOVT_BREL		85	/* Program base relative high
+					   16 bit (MOVT).  */
+#define R_ARM_MOVW_BREL		86	/* Program base relative 16
+					   bit (MOVW).  */
+#define R_ARM_THM_MOVW_BREL_NC	87	/* Program base relative 16
+					   bit (Thumb32 MOVW).  */
+#define R_ARM_THM_MOVT_BREL	88	/* Program base relative high
+					   16 bit (Thumb32 MOVT).  */
+#define R_ARM_THM_MOVW_BREL	89	/* Program base relative 16
+					   bit (Thumb32 MOVW).  */
+#define R_ARM_TLS_GOTDESC	90
+#define R_ARM_TLS_CALL		91
+#define R_ARM_TLS_DESCSEQ	92	/* TLS relaxation.  */
+#define R_ARM_THM_TLS_CALL	93
+#define R_ARM_PLT32_ABS		94
+#define R_ARM_GOT_ABS		95	/* GOT entry.  */
+#define R_ARM_GOT_PREL		96	/* PC relative GOT entry.  */
+#define R_ARM_GOT_BREL12	97	/* GOT entry relative to GOT
+					   origin (LDR).  */
+#define R_ARM_GOTOFF12		98	/* 12 bit, GOT entry relative
+					   to GOT origin (LDR, STR).  */
+#define R_ARM_GOTRELAX		99
+#define R_ARM_GNU_VTENTRY	100
+#define R_ARM_GNU_VTINHERIT	101
+#define R_ARM_THM_PC11		102	/* PC relative & 0xFFE (Thumb16 B).  */
+#define R_ARM_THM_PC9		103	/* PC relative & 0x1FE
+					   (Thumb16 B/B<cond>).  */
+#define R_ARM_TLS_GD32		104	/* PC-rel 32 bit for global dynamic
+					   thread local data */
+#define R_ARM_TLS_LDM32		105	/* PC-rel 32 bit for local dynamic
+					   thread local data */
+#define R_ARM_TLS_LDO32		106	/* 32 bit offset relative to TLS
+					   block */
+#define R_ARM_TLS_IE32		107	/* PC-rel 32 bit for GOT entry of
+					   static TLS block offset */
+#define R_ARM_TLS_LE32		108	/* 32 bit offset relative to static
+					   TLS block */
+#define R_ARM_TLS_LDO12		109	/* 12 bit relative to TLS
+					   block (LDR, STR).  */
+#define R_ARM_TLS_LE12		110	/* 12 bit relative to static
+					   TLS block (LDR, STR).  */
+#define R_ARM_TLS_IE12GP	111	/* 12 bit GOT entry relative
+					   to GOT origin (LDR).  */
+#define R_ARM_ME_TOO		128	/* Obsolete.  */
+#define R_ARM_THM_TLS_DESCSEQ	129
+#define R_ARM_THM_TLS_DESCSEQ16	129
+#define R_ARM_THM_TLS_DESCSEQ32	130
+#define R_ARM_THM_GOT_BREL12	131	/* GOT entry relative to GOT
+					   origin, 12 bit (Thumb32 LDR).  */
+#define R_ARM_IRELATIVE		160
+#define R_ARM_RXPC25		249
+#define R_ARM_RSBREL32		250
+#define R_ARM_THM_RPC22		251
+#define R_ARM_RREL32		252
+#define R_ARM_RABS22		253
+#define R_ARM_RPC24		254
+#define R_ARM_RBASE		255
+/* Keep this the last entry.  */
+#define R_ARM_NUM		256
+
+/* IA-64 specific declarations.  */
+
+/* Processor specific flags for the Ehdr e_flags field.  */
+#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
+#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
+#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */
+
+/* Processor specific values for the Phdr p_type field.  */
+#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
+#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
+#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
+#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
+#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
+
+/* Processor specific flags for the Phdr p_flags field.  */
+#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */
+
+/* Processor specific values for the Shdr sh_type field.  */
+#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
+#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */
+
+/* Processor specific flags for the Shdr sh_flags field.  */
+#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
+#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */
+
+/* Processor specific values for the Dyn d_tag field.  */
+#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
+#define DT_IA_64_NUM		1
+
+/* IA-64 relocations.  */
+#define R_IA64_NONE		0x00	/* none */
+#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
+#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
+#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
+#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
+#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
+#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
+#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
+#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
+#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
+#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
+#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
+#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
+#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
+#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
+#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
+#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
+#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
+#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
+#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
+#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
+#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
+#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
+#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
+#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
+#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
+#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
+#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
+#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
+#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
+#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
+#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
+#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
+#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
+#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
+#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
+#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
+#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
+#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
+#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
+#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
+#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
+#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
+#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
+#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
+#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
+#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
+#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
+#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
+#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
+#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
+#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
+#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
+#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
+#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
+#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
+#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
+#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
+#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
+#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
+#define R_IA64_COPY		0x84	/* copy relocation */
+#define R_IA64_SUB		0x85	/* Addend and symbol difference */
+#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
+#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
+#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
+#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
+#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
+#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
+#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
+#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
+#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
+#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
+#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
+#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
+#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
+#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
+#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
+#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
+#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
+#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
+#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */
+
+/* SH specific declarations */
+
+/* Processor specific flags for the ELF header e_flags field.  */
+#define EF_SH_MACH_MASK		0x1f
+#define EF_SH_UNKNOWN		0x0
+#define EF_SH1			0x1
+#define EF_SH2			0x2
+#define EF_SH3			0x3
+#define EF_SH_DSP		0x4
+#define EF_SH3_DSP		0x5
+#define EF_SH4AL_DSP		0x6
+#define EF_SH3E			0x8
+#define EF_SH4			0x9
+#define EF_SH2E			0xb
+#define EF_SH4A			0xc
+#define EF_SH2A			0xd
+#define EF_SH4_NOFPU		0x10
+#define EF_SH4A_NOFPU		0x11
+#define EF_SH4_NOMMU_NOFPU	0x12
+#define EF_SH2A_NOFPU		0x13
+#define EF_SH3_NOMMU		0x14
+#define EF_SH2A_SH4_NOFPU	0x15
+#define EF_SH2A_SH3_NOFPU	0x16
+#define EF_SH2A_SH4		0x17
+#define EF_SH2A_SH3E		0x18
+
+/* SH relocs.  */
+#define	R_SH_NONE		0
+#define	R_SH_DIR32		1
+#define	R_SH_REL32		2
+#define	R_SH_DIR8WPN		3
+#define	R_SH_IND12W		4
+#define	R_SH_DIR8WPL		5
+#define	R_SH_DIR8WPZ		6
+#define	R_SH_DIR8BP		7
+#define	R_SH_DIR8W		8
+#define	R_SH_DIR8L		9
+#define	R_SH_SWITCH16		25
+#define	R_SH_SWITCH32		26
+#define	R_SH_USES		27
+#define	R_SH_COUNT		28
+#define	R_SH_ALIGN		29
+#define	R_SH_CODE		30
+#define	R_SH_DATA		31
+#define	R_SH_LABEL		32
+#define	R_SH_SWITCH8		33
+#define	R_SH_GNU_VTINHERIT	34
+#define	R_SH_GNU_VTENTRY	35
+#define	R_SH_TLS_GD_32		144
+#define	R_SH_TLS_LD_32		145
+#define	R_SH_TLS_LDO_32		146
+#define	R_SH_TLS_IE_32		147
+#define	R_SH_TLS_LE_32		148
+#define	R_SH_TLS_DTPMOD32	149
+#define	R_SH_TLS_DTPOFF32	150
+#define	R_SH_TLS_TPOFF32	151
+#define	R_SH_GOT32		160
+#define	R_SH_PLT32		161
+#define	R_SH_COPY		162
+#define	R_SH_GLOB_DAT		163
+#define	R_SH_JMP_SLOT		164
+#define	R_SH_RELATIVE		165
+#define	R_SH_GOTOFF		166
+#define	R_SH_GOTPC		167
+/* Keep this the last entry.  */
+#define	R_SH_NUM		256
+
+/* S/390 specific definitions.  */
+
+/* Valid values for the e_flags field.  */
+
+#define EF_S390_HIGH_GPRS    0x00000001  /* High GPRs kernel facility needed.  */
+
+/* Additional s390 relocs */
+
+#define R_390_NONE		0	/* No reloc.  */
+#define R_390_8			1	/* Direct 8 bit.  */
+#define R_390_12		2	/* Direct 12 bit.  */
+#define R_390_16		3	/* Direct 16 bit.  */
+#define R_390_32		4	/* Direct 32 bit.  */
+#define R_390_PC32		5	/* PC relative 32 bit.	*/
+#define R_390_GOT12		6	/* 12 bit GOT offset.  */
+#define R_390_GOT32		7	/* 32 bit GOT offset.  */
+#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
+#define R_390_COPY		9	/* Copy symbol at runtime.  */
+#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
+#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
+#define R_390_RELATIVE		12	/* Adjust by program base.  */
+#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
+#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
+#define R_390_GOT16		15	/* 16 bit GOT offset.  */
+#define R_390_PC16		16	/* PC relative 16 bit.	*/
+#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
+#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
+#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
+#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
+#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
+#define R_390_64		22	/* Direct 64 bit.  */
+#define R_390_PC64		23	/* PC relative 64 bit.	*/
+#define R_390_GOT64		24	/* 64 bit GOT offset.  */
+#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
+#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
+#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
+#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
+#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
+#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
+#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
+#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
+#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
+#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
+#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
+#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
+#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
+#define R_390_TLS_GDCALL	38	/* Tag for function call in general
+					   dynamic TLS code. */
+#define R_390_TLS_LDCALL	39	/* Tag for function call in local
+					   dynamic TLS code. */
+#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
+					   thread local data.  */
+#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
+					  thread local data.  */
+#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
+					   block offset.  */
+#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
+					   block offset.  */
+#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
+					   block offset. */
+#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
+					   thread local data in LE code.  */
+#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
+					   thread local data in LE code.  */
+#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
+					   negated static TLS block offset.  */
+#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
+					   negated static TLS block offset.  */
+#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
+					   negated static TLS block offset.  */
+#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
+					   static TLS block.  */
+#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
+					   static TLS block.  */
+#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
+					   block.  */
+#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
+					   block.  */
+#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
+#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
+#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
+					   block.  */
+#define R_390_20		57	/* Direct 20 bit.  */
+#define R_390_GOT20		58	/* 20 bit GOT offset.  */
+#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
+#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
+					   block offset.  */
+#define R_390_IRELATIVE         61      /* STT_GNU_IFUNC relocation.  */
+/* Keep this the last entry.  */
+#define R_390_NUM		62
+
+
+/* CRIS relocations.  */
+#define R_CRIS_NONE		0
+#define R_CRIS_8		1
+#define R_CRIS_16		2
+#define R_CRIS_32		3
+#define R_CRIS_8_PCREL		4
+#define R_CRIS_16_PCREL		5
+#define R_CRIS_32_PCREL		6
+#define R_CRIS_GNU_VTINHERIT	7
+#define R_CRIS_GNU_VTENTRY	8
+#define R_CRIS_COPY		9
+#define R_CRIS_GLOB_DAT		10
+#define R_CRIS_JUMP_SLOT	11
+#define R_CRIS_RELATIVE		12
+#define R_CRIS_16_GOT		13
+#define R_CRIS_32_GOT		14
+#define R_CRIS_16_GOTPLT	15
+#define R_CRIS_32_GOTPLT	16
+#define R_CRIS_32_GOTREL	17
+#define R_CRIS_32_PLT_GOTREL	18
+#define R_CRIS_32_PLT_PCREL	19
+
+#define R_CRIS_NUM		20
+
+
+/* AMD x86-64 relocations.  */
+#define R_X86_64_NONE		0	/* No reloc */
+#define R_X86_64_64		1	/* Direct 64 bit  */
+#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
+#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
+#define R_X86_64_PLT32		4	/* 32 bit PLT address */
+#define R_X86_64_COPY		5	/* Copy symbol at runtime */
+#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
+#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
+#define R_X86_64_RELATIVE	8	/* Adjust by program base */
+#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
+					   offset to GOT */
+#define R_X86_64_32		10	/* Direct 32 bit zero extended */
+#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
+#define R_X86_64_16		12	/* Direct 16 bit zero extended */
+#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
+#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
+#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
+#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
+#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
+#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
+#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
+					   to two GOT entries for GD symbol */
+#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
+					   to two GOT entries for LD symbol */
+#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
+#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
+					   to GOT entry for IE symbol */
+#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
+#define R_X86_64_PC64		24	/* PC relative 64 bit */
+#define R_X86_64_GOTOFF64	25	/* 64 bit offset to GOT */
+#define R_X86_64_GOTPC32	26	/* 32 bit signed pc relative
+					   offset to GOT */
+#define R_X86_64_GOT64		27	/* 64-bit GOT entry offset */
+#define R_X86_64_GOTPCREL64	28	/* 64-bit PC relative offset
+					   to GOT entry */
+#define R_X86_64_GOTPC64	29	/* 64-bit PC relative offset to GOT */
+#define R_X86_64_GOTPLT64	30 	/* like GOT64, says PLT entry needed */
+#define R_X86_64_PLTOFF64	31	/* 64-bit GOT relative offset
+					   to PLT entry */
+#define R_X86_64_SIZE32		32	/* Size of symbol plus 32-bit addend */
+#define R_X86_64_SIZE64		33	/* Size of symbol plus 64-bit addend */
+#define R_X86_64_GOTPC32_TLSDESC 34	/* GOT offset for TLS descriptor.  */
+#define R_X86_64_TLSDESC_CALL   35	/* Marker for call through TLS
+					   descriptor.  */
+#define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
+#define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
+#define R_X86_64_RELATIVE64	38	/* 64-bit adjust by program base */
+
+#define R_X86_64_NUM		39
+
+
+/* AM33 relocations.  */
+#define R_MN10300_NONE		0	/* No reloc.  */
+#define R_MN10300_32		1	/* Direct 32 bit.  */
+#define R_MN10300_16		2	/* Direct 16 bit.  */
+#define R_MN10300_8		3	/* Direct 8 bit.  */
+#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
+#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
+#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
+#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
+#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
+#define R_MN10300_24		9	/* Direct 24 bit.  */
+#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
+#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
+#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
+#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
+#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
+#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
+#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
+#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
+#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
+#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
+#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
+#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
+#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
+#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
+#define R_MN10300_TLS_GD	24	/* 32-bit offset for global dynamic.  */
+#define R_MN10300_TLS_LD	25	/* 32-bit offset for local dynamic.  */
+#define R_MN10300_TLS_LDO	26	/* Module-relative offset.  */
+#define R_MN10300_TLS_GOTIE	27	/* GOT offset for static TLS block
+					   offset.  */
+#define R_MN10300_TLS_IE	28	/* GOT address for static TLS block
+					   offset.  */
+#define R_MN10300_TLS_LE	29	/* Offset relative to static TLS
+					   block.  */
+#define R_MN10300_TLS_DTPMOD	30	/* ID of module containing symbol.  */
+#define R_MN10300_TLS_DTPOFF	31	/* Offset in module TLS block.  */
+#define R_MN10300_TLS_TPOFF	32	/* Offset in static TLS block.  */
+#define R_MN10300_SYM_DIFF	33	/* Adjustment for next reloc as needed
+					   by linker relaxation.  */
+#define R_MN10300_ALIGN		34	/* Alignment requirement for linker
+					   relaxation.  */
+#define R_MN10300_NUM		35
+
+
+/* M32R relocs.  */
+#define R_M32R_NONE		0	/* No reloc. */
+#define R_M32R_16		1	/* Direct 16 bit. */
+#define R_M32R_32		2	/* Direct 32 bit. */
+#define R_M32R_24		3	/* Direct 24 bit. */
+#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
+#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
+#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
+#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
+#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
+#define R_M32R_LO16		9	/* Low 16 bit. */
+#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
+#define R_M32R_GNU_VTINHERIT	11
+#define R_M32R_GNU_VTENTRY	12
+/* M32R relocs use SHT_RELA.  */
+#define R_M32R_16_RELA		33	/* Direct 16 bit. */
+#define R_M32R_32_RELA		34	/* Direct 32 bit. */
+#define R_M32R_24_RELA		35	/* Direct 24 bit. */
+#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
+#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
+#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
+#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
+#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
+#define R_M32R_LO16_RELA	41	/* Low 16 bit */
+#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
+#define R_M32R_RELA_GNU_VTINHERIT	43
+#define R_M32R_RELA_GNU_VTENTRY	44
+#define R_M32R_REL32		45	/* PC relative 32 bit.  */
+
+#define R_M32R_GOT24		48	/* 24 bit GOT entry */
+#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
+#define R_M32R_COPY		50	/* Copy symbol at runtime */
+#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
+#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
+#define R_M32R_RELATIVE		53	/* Adjust by program base */
+#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
+#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
+#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
+					   low */
+#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
+					   low */
+#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
+#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
+					   GOT with unsigned low */
+#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
+					   GOT with signed low */
+#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
+					   GOT */
+#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
+					   with unsigned low */
+#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
+					   with signed low */
+#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
+#define R_M32R_NUM		256	/* Keep this the last entry. */
+
+/* MicroBlaze relocations */
+#define R_MICROBLAZE_NONE		0	/* No reloc. */
+#define R_MICROBLAZE_32 		1	/* Direct 32 bit. */
+#define R_MICROBLAZE_32_PCREL		2	/* PC relative 32 bit. */
+#define R_MICROBLAZE_64_PCREL		3	/* PC relative 64 bit. */
+#define R_MICROBLAZE_32_PCREL_LO	4	/* Low 16 bits of PCREL32. */
+#define R_MICROBLAZE_64 		5	/* Direct 64 bit. */
+#define R_MICROBLAZE_32_LO		6	/* Low 16 bit. */
+#define R_MICROBLAZE_SRO32		7	/* Read-only small data area. */
+#define R_MICROBLAZE_SRW32		8	/* Read-write small data area. */
+#define R_MICROBLAZE_64_NONE		9	/* No reloc. */
+#define R_MICROBLAZE_32_SYM_OP_SYM	10	/* Symbol Op Symbol relocation. */
+#define R_MICROBLAZE_GNU_VTINHERIT	11	/* GNU C++ vtable hierarchy. */
+#define R_MICROBLAZE_GNU_VTENTRY	12	/* GNU C++ vtable member usage. */
+#define R_MICROBLAZE_GOTPC_64		13	/* PC-relative GOT offset.  */
+#define R_MICROBLAZE_GOT_64		14	/* GOT entry offset.  */
+#define R_MICROBLAZE_PLT_64		15	/* PLT offset (PC-relative).  */
+#define R_MICROBLAZE_REL		16	/* Adjust by program base.  */
+#define R_MICROBLAZE_JUMP_SLOT		17	/* Create PLT entry.  */
+#define R_MICROBLAZE_GLOB_DAT		18	/* Create GOT entry.  */
+#define R_MICROBLAZE_GOTOFF_64		19	/* 64 bit offset to GOT. */
+#define R_MICROBLAZE_GOTOFF_32		20	/* 32 bit offset to GOT. */
+#define R_MICROBLAZE_COPY		21	/* Runtime copy.  */
+#define R_MICROBLAZE_TLS		22	/* TLS Reloc. */
+#define R_MICROBLAZE_TLSGD		23	/* TLS General Dynamic. */
+#define R_MICROBLAZE_TLSLD		24	/* TLS Local Dynamic. */
+#define R_MICROBLAZE_TLSDTPMOD32	25	/* TLS Module ID. */
+#define R_MICROBLAZE_TLSDTPREL32	26	/* TLS Offset Within TLS Block. */
+#define R_MICROBLAZE_TLSDTPREL64	27	/* TLS Offset Within TLS Block. */
+#define R_MICROBLAZE_TLSGOTTPREL32	28	/* TLS Offset From Thread Pointer. */
+#define R_MICROBLAZE_TLSTPREL32 	29	/* TLS Offset From Thread Pointer. */
+
+/* TILEPro relocations.  */
+#define R_TILEPRO_NONE		0	/* No reloc */
+#define R_TILEPRO_32		1	/* Direct 32 bit */
+#define R_TILEPRO_16		2	/* Direct 16 bit */
+#define R_TILEPRO_8		3	/* Direct 8 bit */
+#define R_TILEPRO_32_PCREL	4	/* PC relative 32 bit */
+#define R_TILEPRO_16_PCREL	5	/* PC relative 16 bit */
+#define R_TILEPRO_8_PCREL	6	/* PC relative 8 bit */
+#define R_TILEPRO_LO16		7	/* Low 16 bit */
+#define R_TILEPRO_HI16		8	/* High 16 bit */
+#define R_TILEPRO_HA16		9	/* High 16 bit, adjusted */
+#define R_TILEPRO_COPY		10	/* Copy relocation */
+#define R_TILEPRO_GLOB_DAT	11	/* Create GOT entry */
+#define R_TILEPRO_JMP_SLOT	12	/* Create PLT entry */
+#define R_TILEPRO_RELATIVE	13	/* Adjust by program base */
+#define R_TILEPRO_BROFF_X1	14	/* X1 pipe branch offset */
+#define R_TILEPRO_JOFFLONG_X1	15	/* X1 pipe jump offset */
+#define R_TILEPRO_JOFFLONG_X1_PLT 16	/* X1 pipe jump offset to PLT */
+#define R_TILEPRO_IMM8_X0	17	/* X0 pipe 8-bit */
+#define R_TILEPRO_IMM8_Y0	18	/* Y0 pipe 8-bit */
+#define R_TILEPRO_IMM8_X1	19	/* X1 pipe 8-bit */
+#define R_TILEPRO_IMM8_Y1	20	/* Y1 pipe 8-bit */
+#define R_TILEPRO_MT_IMM15_X1	21	/* X1 pipe mtspr */
+#define R_TILEPRO_MF_IMM15_X1	22	/* X1 pipe mfspr */
+#define R_TILEPRO_IMM16_X0	23	/* X0 pipe 16-bit */
+#define R_TILEPRO_IMM16_X1	24	/* X1 pipe 16-bit */
+#define R_TILEPRO_IMM16_X0_LO	25	/* X0 pipe low 16-bit */
+#define R_TILEPRO_IMM16_X1_LO	26	/* X1 pipe low 16-bit */
+#define R_TILEPRO_IMM16_X0_HI	27	/* X0 pipe high 16-bit */
+#define R_TILEPRO_IMM16_X1_HI	28	/* X1 pipe high 16-bit */
+#define R_TILEPRO_IMM16_X0_HA	29	/* X0 pipe high 16-bit, adjusted */
+#define R_TILEPRO_IMM16_X1_HA	30	/* X1 pipe high 16-bit, adjusted */
+#define R_TILEPRO_IMM16_X0_PCREL 31	/* X0 pipe PC relative 16 bit */
+#define R_TILEPRO_IMM16_X1_PCREL 32	/* X1 pipe PC relative 16 bit */
+#define R_TILEPRO_IMM16_X0_LO_PCREL 33	/* X0 pipe PC relative low 16 bit */
+#define R_TILEPRO_IMM16_X1_LO_PCREL 34	/* X1 pipe PC relative low 16 bit */
+#define R_TILEPRO_IMM16_X0_HI_PCREL 35	/* X0 pipe PC relative high 16 bit */
+#define R_TILEPRO_IMM16_X1_HI_PCREL 36	/* X1 pipe PC relative high 16 bit */
+#define R_TILEPRO_IMM16_X0_HA_PCREL 37	/* X0 pipe PC relative ha() 16 bit */
+#define R_TILEPRO_IMM16_X1_HA_PCREL 38	/* X1 pipe PC relative ha() 16 bit */
+#define R_TILEPRO_IMM16_X0_GOT	39	/* X0 pipe 16-bit GOT offset */
+#define R_TILEPRO_IMM16_X1_GOT	40	/* X1 pipe 16-bit GOT offset */
+#define R_TILEPRO_IMM16_X0_GOT_LO 41	/* X0 pipe low 16-bit GOT offset */
+#define R_TILEPRO_IMM16_X1_GOT_LO 42	/* X1 pipe low 16-bit GOT offset */
+#define R_TILEPRO_IMM16_X0_GOT_HI 43	/* X0 pipe high 16-bit GOT offset */
+#define R_TILEPRO_IMM16_X1_GOT_HI 44	/* X1 pipe high 16-bit GOT offset */
+#define R_TILEPRO_IMM16_X0_GOT_HA 45	/* X0 pipe ha() 16-bit GOT offset */
+#define R_TILEPRO_IMM16_X1_GOT_HA 46	/* X1 pipe ha() 16-bit GOT offset */
+#define R_TILEPRO_MMSTART_X0	47	/* X0 pipe mm "start" */
+#define R_TILEPRO_MMEND_X0	48	/* X0 pipe mm "end" */
+#define R_TILEPRO_MMSTART_X1	49	/* X1 pipe mm "start" */
+#define R_TILEPRO_MMEND_X1	50	/* X1 pipe mm "end" */
+#define R_TILEPRO_SHAMT_X0	51	/* X0 pipe shift amount */
+#define R_TILEPRO_SHAMT_X1	52	/* X1 pipe shift amount */
+#define R_TILEPRO_SHAMT_Y0	53	/* Y0 pipe shift amount */
+#define R_TILEPRO_SHAMT_Y1	54	/* Y1 pipe shift amount */
+#define R_TILEPRO_DEST_IMM8_X1	55	/* X1 pipe destination 8-bit */
+/* Relocs 56-59 are currently not defined.  */
+#define R_TILEPRO_TLS_GD_CALL	60	/* "jal" for TLS GD */
+#define R_TILEPRO_IMM8_X0_TLS_GD_ADD 61	/* X0 pipe "addi" for TLS GD */
+#define R_TILEPRO_IMM8_X1_TLS_GD_ADD 62	/* X1 pipe "addi" for TLS GD */
+#define R_TILEPRO_IMM8_Y0_TLS_GD_ADD 63	/* Y0 pipe "addi" for TLS GD */
+#define R_TILEPRO_IMM8_Y1_TLS_GD_ADD 64	/* Y1 pipe "addi" for TLS GD */
+#define R_TILEPRO_TLS_IE_LOAD	65	/* "lw_tls" for TLS IE */
+#define R_TILEPRO_IMM16_X0_TLS_GD 66	/* X0 pipe 16-bit TLS GD offset */
+#define R_TILEPRO_IMM16_X1_TLS_GD 67	/* X1 pipe 16-bit TLS GD offset */
+#define R_TILEPRO_IMM16_X0_TLS_GD_LO 68	/* X0 pipe low 16-bit TLS GD offset */
+#define R_TILEPRO_IMM16_X1_TLS_GD_LO 69	/* X1 pipe low 16-bit TLS GD offset */
+#define R_TILEPRO_IMM16_X0_TLS_GD_HI 70	/* X0 pipe high 16-bit TLS GD offset */
+#define R_TILEPRO_IMM16_X1_TLS_GD_HI 71	/* X1 pipe high 16-bit TLS GD offset */
+#define R_TILEPRO_IMM16_X0_TLS_GD_HA 72	/* X0 pipe ha() 16-bit TLS GD offset */
+#define R_TILEPRO_IMM16_X1_TLS_GD_HA 73	/* X1 pipe ha() 16-bit TLS GD offset */
+#define R_TILEPRO_IMM16_X0_TLS_IE 74	/* X0 pipe 16-bit TLS IE offset */
+#define R_TILEPRO_IMM16_X1_TLS_IE 75	/* X1 pipe 16-bit TLS IE offset */
+#define R_TILEPRO_IMM16_X0_TLS_IE_LO 76	/* X0 pipe low 16-bit TLS IE offset */
+#define R_TILEPRO_IMM16_X1_TLS_IE_LO 77	/* X1 pipe low 16-bit TLS IE offset */
+#define R_TILEPRO_IMM16_X0_TLS_IE_HI 78	/* X0 pipe high 16-bit TLS IE offset */
+#define R_TILEPRO_IMM16_X1_TLS_IE_HI 79	/* X1 pipe high 16-bit TLS IE offset */
+#define R_TILEPRO_IMM16_X0_TLS_IE_HA 80	/* X0 pipe ha() 16-bit TLS IE offset */
+#define R_TILEPRO_IMM16_X1_TLS_IE_HA 81	/* X1 pipe ha() 16-bit TLS IE offset */
+#define R_TILEPRO_TLS_DTPMOD32	82	/* ID of module containing symbol */
+#define R_TILEPRO_TLS_DTPOFF32	83	/* Offset in TLS block */
+#define R_TILEPRO_TLS_TPOFF32	84	/* Offset in static TLS block */
+#define R_TILEPRO_IMM16_X0_TLS_LE 85	/* X0 pipe 16-bit TLS LE offset */
+#define R_TILEPRO_IMM16_X1_TLS_LE 86	/* X1 pipe 16-bit TLS LE offset */
+#define R_TILEPRO_IMM16_X0_TLS_LE_LO 87	/* X0 pipe low 16-bit TLS LE offset */
+#define R_TILEPRO_IMM16_X1_TLS_LE_LO 88	/* X1 pipe low 16-bit TLS LE offset */
+#define R_TILEPRO_IMM16_X0_TLS_LE_HI 89	/* X0 pipe high 16-bit TLS LE offset */
+#define R_TILEPRO_IMM16_X1_TLS_LE_HI 90	/* X1 pipe high 16-bit TLS LE offset */
+#define R_TILEPRO_IMM16_X0_TLS_LE_HA 91	/* X0 pipe ha() 16-bit TLS LE offset */
+#define R_TILEPRO_IMM16_X1_TLS_LE_HA 92	/* X1 pipe ha() 16-bit TLS LE offset */
+
+#define R_TILEPRO_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
+#define R_TILEPRO_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
+
+#define R_TILEPRO_NUM		130
+
+
+/* TILE-Gx relocations.  */
+#define R_TILEGX_NONE		0	/* No reloc */
+#define R_TILEGX_64		1	/* Direct 64 bit */
+#define R_TILEGX_32		2	/* Direct 32 bit */
+#define R_TILEGX_16		3	/* Direct 16 bit */
+#define R_TILEGX_8		4	/* Direct 8 bit */
+#define R_TILEGX_64_PCREL	5	/* PC relative 64 bit */
+#define R_TILEGX_32_PCREL	6	/* PC relative 32 bit */
+#define R_TILEGX_16_PCREL	7	/* PC relative 16 bit */
+#define R_TILEGX_8_PCREL	8	/* PC relative 8 bit */
+#define R_TILEGX_HW0		9	/* hword 0 16-bit */
+#define R_TILEGX_HW1		10	/* hword 1 16-bit */
+#define R_TILEGX_HW2		11	/* hword 2 16-bit */
+#define R_TILEGX_HW3		12	/* hword 3 16-bit */
+#define R_TILEGX_HW0_LAST	13	/* last hword 0 16-bit */
+#define R_TILEGX_HW1_LAST	14	/* last hword 1 16-bit */
+#define R_TILEGX_HW2_LAST	15	/* last hword 2 16-bit */
+#define R_TILEGX_COPY		16	/* Copy relocation */
+#define R_TILEGX_GLOB_DAT	17	/* Create GOT entry */
+#define R_TILEGX_JMP_SLOT	18	/* Create PLT entry */
+#define R_TILEGX_RELATIVE	19	/* Adjust by program base */
+#define R_TILEGX_BROFF_X1	20	/* X1 pipe branch offset */
+#define R_TILEGX_JUMPOFF_X1	21	/* X1 pipe jump offset */
+#define R_TILEGX_JUMPOFF_X1_PLT	22	/* X1 pipe jump offset to PLT */
+#define R_TILEGX_IMM8_X0	23	/* X0 pipe 8-bit */
+#define R_TILEGX_IMM8_Y0	24	/* Y0 pipe 8-bit */
+#define R_TILEGX_IMM8_X1	25	/* X1 pipe 8-bit */
+#define R_TILEGX_IMM8_Y1	26	/* Y1 pipe 8-bit */
+#define R_TILEGX_DEST_IMM8_X1	27	/* X1 pipe destination 8-bit */
+#define R_TILEGX_MT_IMM14_X1	28	/* X1 pipe mtspr */
+#define R_TILEGX_MF_IMM14_X1	29	/* X1 pipe mfspr */
+#define R_TILEGX_MMSTART_X0	30	/* X0 pipe mm "start" */
+#define R_TILEGX_MMEND_X0	31	/* X0 pipe mm "end" */
+#define R_TILEGX_SHAMT_X0	32	/* X0 pipe shift amount */
+#define R_TILEGX_SHAMT_X1	33	/* X1 pipe shift amount */
+#define R_TILEGX_SHAMT_Y0	34	/* Y0 pipe shift amount */
+#define R_TILEGX_SHAMT_Y1	35	/* Y1 pipe shift amount */
+#define R_TILEGX_IMM16_X0_HW0	36	/* X0 pipe hword 0 */
+#define R_TILEGX_IMM16_X1_HW0	37	/* X1 pipe hword 0 */
+#define R_TILEGX_IMM16_X0_HW1	38	/* X0 pipe hword 1 */
+#define R_TILEGX_IMM16_X1_HW1	39	/* X1 pipe hword 1 */
+#define R_TILEGX_IMM16_X0_HW2	40	/* X0 pipe hword 2 */
+#define R_TILEGX_IMM16_X1_HW2	41	/* X1 pipe hword 2 */
+#define R_TILEGX_IMM16_X0_HW3	42	/* X0 pipe hword 3 */
+#define R_TILEGX_IMM16_X1_HW3	43	/* X1 pipe hword 3 */
+#define R_TILEGX_IMM16_X0_HW0_LAST 44	/* X0 pipe last hword 0 */
+#define R_TILEGX_IMM16_X1_HW0_LAST 45	/* X1 pipe last hword 0 */
+#define R_TILEGX_IMM16_X0_HW1_LAST 46	/* X0 pipe last hword 1 */
+#define R_TILEGX_IMM16_X1_HW1_LAST 47	/* X1 pipe last hword 1 */
+#define R_TILEGX_IMM16_X0_HW2_LAST 48	/* X0 pipe last hword 2 */
+#define R_TILEGX_IMM16_X1_HW2_LAST 49	/* X1 pipe last hword 2 */
+#define R_TILEGX_IMM16_X0_HW0_PCREL 50	/* X0 pipe PC relative hword 0 */
+#define R_TILEGX_IMM16_X1_HW0_PCREL 51	/* X1 pipe PC relative hword 0 */
+#define R_TILEGX_IMM16_X0_HW1_PCREL 52	/* X0 pipe PC relative hword 1 */
+#define R_TILEGX_IMM16_X1_HW1_PCREL 53	/* X1 pipe PC relative hword 1 */
+#define R_TILEGX_IMM16_X0_HW2_PCREL 54	/* X0 pipe PC relative hword 2 */
+#define R_TILEGX_IMM16_X1_HW2_PCREL 55	/* X1 pipe PC relative hword 2 */
+#define R_TILEGX_IMM16_X0_HW3_PCREL 56	/* X0 pipe PC relative hword 3 */
+#define R_TILEGX_IMM16_X1_HW3_PCREL 57	/* X1 pipe PC relative hword 3 */
+#define R_TILEGX_IMM16_X0_HW0_LAST_PCREL 58 /* X0 pipe PC-rel last hword 0 */
+#define R_TILEGX_IMM16_X1_HW0_LAST_PCREL 59 /* X1 pipe PC-rel last hword 0 */
+#define R_TILEGX_IMM16_X0_HW1_LAST_PCREL 60 /* X0 pipe PC-rel last hword 1 */
+#define R_TILEGX_IMM16_X1_HW1_LAST_PCREL 61 /* X1 pipe PC-rel last hword 1 */
+#define R_TILEGX_IMM16_X0_HW2_LAST_PCREL 62 /* X0 pipe PC-rel last hword 2 */
+#define R_TILEGX_IMM16_X1_HW2_LAST_PCREL 63 /* X1 pipe PC-rel last hword 2 */
+#define R_TILEGX_IMM16_X0_HW0_GOT 64	/* X0 pipe hword 0 GOT offset */
+#define R_TILEGX_IMM16_X1_HW0_GOT 65	/* X1 pipe hword 0 GOT offset */
+#define R_TILEGX_IMM16_X0_HW0_PLT_PCREL 66 /* X0 pipe PC-rel PLT hword 0 */
+#define R_TILEGX_IMM16_X1_HW0_PLT_PCREL 67 /* X1 pipe PC-rel PLT hword 0 */
+#define R_TILEGX_IMM16_X0_HW1_PLT_PCREL 68 /* X0 pipe PC-rel PLT hword 1 */
+#define R_TILEGX_IMM16_X1_HW1_PLT_PCREL 69 /* X1 pipe PC-rel PLT hword 1 */
+#define R_TILEGX_IMM16_X0_HW2_PLT_PCREL 70 /* X0 pipe PC-rel PLT hword 2 */
+#define R_TILEGX_IMM16_X1_HW2_PLT_PCREL 71 /* X1 pipe PC-rel PLT hword 2 */
+#define R_TILEGX_IMM16_X0_HW0_LAST_GOT 72 /* X0 pipe last hword 0 GOT offset */
+#define R_TILEGX_IMM16_X1_HW0_LAST_GOT 73 /* X1 pipe last hword 0 GOT offset */
+#define R_TILEGX_IMM16_X0_HW1_LAST_GOT 74 /* X0 pipe last hword 1 GOT offset */
+#define R_TILEGX_IMM16_X1_HW1_LAST_GOT 75 /* X1 pipe last hword 1 GOT offset */
+#define R_TILEGX_IMM16_X0_HW3_PLT_PCREL 76 /* X0 pipe PC-rel PLT hword 3 */
+#define R_TILEGX_IMM16_X1_HW3_PLT_PCREL 77 /* X1 pipe PC-rel PLT hword 3 */
+#define R_TILEGX_IMM16_X0_HW0_TLS_GD 78	/* X0 pipe hword 0 TLS GD offset */
+#define R_TILEGX_IMM16_X1_HW0_TLS_GD 79	/* X1 pipe hword 0 TLS GD offset */
+#define R_TILEGX_IMM16_X0_HW0_TLS_LE 80	/* X0 pipe hword 0 TLS LE offset */
+#define R_TILEGX_IMM16_X1_HW0_TLS_LE 81	/* X1 pipe hword 0 TLS LE offset */
+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE 82 /* X0 pipe last hword 0 LE off */
+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE 83 /* X1 pipe last hword 0 LE off */
+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE 84 /* X0 pipe last hword 1 LE off */
+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE 85 /* X1 pipe last hword 1 LE off */
+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD 86 /* X0 pipe last hword 0 GD off */
+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD 87 /* X1 pipe last hword 0 GD off */
+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD 88 /* X0 pipe last hword 1 GD off */
+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD 89 /* X1 pipe last hword 1 GD off */
+/* Relocs 90-91 are currently not defined.  */
+#define R_TILEGX_IMM16_X0_HW0_TLS_IE 92	/* X0 pipe hword 0 TLS IE offset */
+#define R_TILEGX_IMM16_X1_HW0_TLS_IE 93	/* X1 pipe hword 0 TLS IE offset */
+#define R_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL 94 /* X0 pipe PC-rel PLT last hword 0 */
+#define R_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL 95 /* X1 pipe PC-rel PLT last hword 0 */
+#define R_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL 96 /* X0 pipe PC-rel PLT last hword 1 */
+#define R_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL 97 /* X1 pipe PC-rel PLT last hword 1 */
+#define R_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL 98 /* X0 pipe PC-rel PLT last hword 2 */
+#define R_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL 99 /* X1 pipe PC-rel PLT last hword 2 */
+#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE 100 /* X0 pipe last hword 0 IE off */
+#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE 101 /* X1 pipe last hword 0 IE off */
+#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE 102 /* X0 pipe last hword 1 IE off */
+#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE 103 /* X1 pipe last hword 1 IE off */
+/* Relocs 104-105 are currently not defined.  */
+#define R_TILEGX_TLS_DTPMOD64	106	/* 64-bit ID of symbol's module */
+#define R_TILEGX_TLS_DTPOFF64	107	/* 64-bit offset in TLS block */
+#define R_TILEGX_TLS_TPOFF64	108	/* 64-bit offset in static TLS block */
+#define R_TILEGX_TLS_DTPMOD32	109	/* 32-bit ID of symbol's module */
+#define R_TILEGX_TLS_DTPOFF32	110	/* 32-bit offset in TLS block */
+#define R_TILEGX_TLS_TPOFF32	111	/* 32-bit offset in static TLS block */
+#define R_TILEGX_TLS_GD_CALL	112	/* "jal" for TLS GD */
+#define R_TILEGX_IMM8_X0_TLS_GD_ADD 113	/* X0 pipe "addi" for TLS GD */
+#define R_TILEGX_IMM8_X1_TLS_GD_ADD 114	/* X1 pipe "addi" for TLS GD */
+#define R_TILEGX_IMM8_Y0_TLS_GD_ADD 115	/* Y0 pipe "addi" for TLS GD */
+#define R_TILEGX_IMM8_Y1_TLS_GD_ADD 116	/* Y1 pipe "addi" for TLS GD */
+#define R_TILEGX_TLS_IE_LOAD	117	/* "ld_tls" for TLS IE */
+#define R_TILEGX_IMM8_X0_TLS_ADD 118	/* X0 pipe "addi" for TLS GD/IE */
+#define R_TILEGX_IMM8_X1_TLS_ADD 119	/* X1 pipe "addi" for TLS GD/IE */
+#define R_TILEGX_IMM8_Y0_TLS_ADD 120	/* Y0 pipe "addi" for TLS GD/IE */
+#define R_TILEGX_IMM8_Y1_TLS_ADD 121	/* Y1 pipe "addi" for TLS GD/IE */
+
+#define R_TILEGX_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
+#define R_TILEGX_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
+
+#define R_TILEGX_NUM		130
+
+
+__END_DECLS
+
+#endif	/* elf.h */
diff --git a/include/endian.h b/include/endian.h
new file mode 100644
index 0000000..875fea3
--- /dev/null
+++ b/include/endian.h
@@ -0,0 +1,96 @@
+/* Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_ENDIAN_H
+#define	_ENDIAN_H	1
+
+#include <features.h>
+
+/* Definitions for byte order, according to significance of bytes,
+   from low addresses to high addresses.  The value is what you get by
+   putting '4' in the most significant byte, '3' in the second most
+   significant byte, '2' in the second least significant byte, and '1'
+   in the least significant byte, and then writing down one digit for
+   each byte, starting with the byte at the lowest address at the left,
+   and proceeding to the byte with the highest address at the right.  */
+
+#define	__LITTLE_ENDIAN	1234
+#define	__BIG_ENDIAN	4321
+#define	__PDP_ENDIAN	3412
+
+/* This file defines `__BYTE_ORDER' for the particular machine.  */
+#include <bits/endian.h>
+
+/* Some machines may need to use a different endianness for floating point
+   values.  */
+#ifndef __FLOAT_WORD_ORDER
+# define __FLOAT_WORD_ORDER __BYTE_ORDER
+#endif
+
+#ifdef	__USE_BSD
+# define LITTLE_ENDIAN	__LITTLE_ENDIAN
+# define BIG_ENDIAN	__BIG_ENDIAN
+# define PDP_ENDIAN	__PDP_ENDIAN
+# define BYTE_ORDER	__BYTE_ORDER
+#endif
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+# define __LONG_LONG_PAIR(HI, LO) LO, HI
+#elif __BYTE_ORDER == __BIG_ENDIAN
+# define __LONG_LONG_PAIR(HI, LO) HI, LO
+#endif
+
+
+#if defined __USE_BSD && !defined __ASSEMBLER__
+/* Conversion interfaces.  */
+# include <bits/byteswap.h>
+
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define htobe16(x) __bswap_16 (x)
+#  define htole16(x) (x)
+#  define be16toh(x) __bswap_16 (x)
+#  define le16toh(x) (x)
+
+#  define htobe32(x) __bswap_32 (x)
+#  define htole32(x) (x)
+#  define be32toh(x) __bswap_32 (x)
+#  define le32toh(x) (x)
+
+#  define htobe64(x) __bswap_64 (x)
+#  define htole64(x) (x)
+#  define be64toh(x) __bswap_64 (x)
+#  define le64toh(x) (x)
+
+# else
+#  define htobe16(x) (x)
+#  define htole16(x) __bswap_16 (x)
+#  define be16toh(x) (x)
+#  define le16toh(x) __bswap_16 (x)
+
+#  define htobe32(x) (x)
+#  define htole32(x) __bswap_32 (x)
+#  define be32toh(x) (x)
+#  define le32toh(x) __bswap_32 (x)
+
+#  define htobe64(x) (x)
+#  define htole64(x) __bswap_64 (x)
+#  define be64toh(x) (x)
+#  define le64toh(x) __bswap_64 (x)
+# endif
+#endif
+
+#endif	/* endian.h */
diff --git a/include/envz.h b/include/envz.h
new file mode 100644
index 0000000..f51931c
--- /dev/null
+++ b/include/envz.h
@@ -0,0 +1,73 @@
+/* Routines for dealing with '\0' separated environment vectors
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ENVZ_H
+#define _ENVZ_H	1
+
+#include <features.h>
+
+#include <errno.h>
+
+/* Envz's are argz's too, and should be created etc., using the same
+   routines.  */
+#include <argz.h>
+
+__BEGIN_DECLS
+
+/* Returns a pointer to the entry in ENVZ for NAME, or 0 if there is none.  */
+extern char *envz_entry (const char *__restrict __envz, size_t __envz_len,
+			 const char *__restrict __name)
+     __THROW __attribute_pure__;
+
+/* Returns a pointer to the value portion of the entry in ENVZ for NAME, or 0
+   if there is none.  */
+extern char *envz_get (const char *__restrict __envz, size_t __envz_len,
+		       const char *__restrict __name)
+     __THROW __attribute_pure__;
+
+/* Adds an entry for NAME with value VALUE to ENVZ & ENVZ_LEN.  If an entry
+   with the same name already exists in ENVZ, it is removed.  If VALUE is
+   NULL, then the new entry will a special null one, for which envz_get will
+   return NULL, although envz_entry will still return an entry; this is handy
+   because when merging with another envz, the null entry can override an
+   entry in the other one.  Null entries can be removed with envz_strip ().  */
+extern error_t envz_add (char **__restrict __envz,
+			 size_t *__restrict __envz_len,
+			 const char *__restrict __name,
+			 const char *__restrict __value) __THROW;
+
+/* Adds each entry in ENVZ2 to ENVZ & ENVZ_LEN, as if with envz_add().  If
+   OVERRIDE is true, then values in ENVZ2 will supersede those with the same
+   name in ENV, otherwise not.  */
+extern error_t envz_merge (char **__restrict __envz,
+			   size_t *__restrict __envz_len,
+			   const char *__restrict __envz2,
+			   size_t __envz2_len, int __override) __THROW;
+
+/* Remove the entry for NAME from ENVZ & ENVZ_LEN, if any.  */
+extern void envz_remove (char **__restrict __envz,
+			 size_t *__restrict __envz_len,
+			 const char *__restrict __name) __THROW;
+
+/* Remove null entries.  */
+extern void envz_strip (char **__restrict __envz,
+			size_t *__restrict __envz_len) __THROW;
+
+__END_DECLS
+
+#endif /* envz.h */
diff --git a/include/err.h b/include/err.h
new file mode 100644
index 0000000..fabd836
--- /dev/null
+++ b/include/err.h
@@ -0,0 +1,57 @@
+/* 4.4BSD utility functions for error messages.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_ERR_H
+#define	_ERR_H	1
+
+#include <features.h>
+
+#define	__need___va_list
+#include <stdarg.h>
+#ifndef	__GNUC_VA_LIST
+# define __gnuc_va_list	__ptr_t
+#endif
+
+__BEGIN_DECLS
+
+/* Print "program: ", FORMAT, ": ", the standard error string for errno,
+   and a newline, on stderr.  */
+extern void warn (const char *__format, ...)
+     __attribute__ ((__format__ (__printf__, 1, 2)));
+extern void vwarn (const char *__format, __gnuc_va_list)
+     __attribute__ ((__format__ (__printf__, 1, 0)));
+
+/* Likewise, but without ": " and the standard error string.  */
+extern void warnx (const char *__format, ...)
+     __attribute__ ((__format__ (__printf__, 1, 2)));
+extern void vwarnx (const char *__format, __gnuc_va_list)
+     __attribute__ ((__format__ (__printf__, 1, 0)));
+
+/* Likewise, and then exit with STATUS.  */
+extern void err (int __status, const char *__format, ...)
+     __attribute__ ((__noreturn__, __format__ (__printf__, 2, 3)));
+extern void verr (int __status, const char *__format, __gnuc_va_list)
+     __attribute__ ((__noreturn__, __format__ (__printf__, 2, 0)));
+extern void errx (int __status, const char *__format, ...)
+     __attribute__ ((__noreturn__, __format__ (__printf__, 2, 3)));
+extern void verrx (int __status, const char *, __gnuc_va_list)
+     __attribute__ ((__noreturn__, __format__ (__printf__, 2, 0)));
+
+__END_DECLS
+
+#endif	/* err.h */
diff --git a/include/errno.h b/include/errno.h
new file mode 100644
index 0000000..9360221
--- /dev/null
+++ b/include/errno.h
@@ -0,0 +1,72 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.5 Errors	<errno.h>
+ */
+
+#ifndef	_ERRNO_H
+
+/* The includer defined __need_Emath if he wants only the definitions
+   of EDOM and ERANGE, and not everything else.  */
+#ifndef	__need_Emath
+# define _ERRNO_H	1
+# include <features.h>
+#endif
+
+__BEGIN_DECLS
+
+/* Get the error number constants from the system-specific file.
+   This file will test __need_Emath and _ERRNO_H.  */
+#include <bits/errno.h>
+#undef	__need_Emath
+
+#ifdef	_ERRNO_H
+
+/* Declare the `errno' variable, unless it's defined as a macro by
+   bits/errno.h.  This is the case in GNU, where it is a per-thread
+   variable.  This redeclaration using the macro still works, but it
+   will be a function declaration without a prototype and may trigger
+   a -Wstrict-prototypes warning.  */
+#ifndef	errno
+extern int errno;
+#endif
+
+#ifdef __USE_GNU
+
+/* The full and simple forms of the name with which the program was
+   invoked.  These variables are set up automatically at startup based on
+   the value of ARGV[0] (this works only if you use GNU ld).  */
+extern char *program_invocation_name, *program_invocation_short_name;
+#endif /* __USE_GNU */
+#endif /* _ERRNO_H */
+
+__END_DECLS
+
+#endif /* _ERRNO_H */
+
+/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
+   that printing `error_t' values in the debugger shows the names.  We
+   might need this definition sometimes even if this file was included
+   before.  */
+#if defined __USE_GNU || defined __need_error_t
+# ifndef __error_t_defined
+typedef int error_t;
+#  define __error_t_defined	1
+# endif
+# undef __need_error_t
+#endif
diff --git a/include/error.h b/include/error.h
new file mode 100644
index 0000000..a3c7ef0
--- /dev/null
+++ b/include/error.h
@@ -0,0 +1,57 @@
+/* Declaration for error-reporting function
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ERROR_H
+#define _ERROR_H 1
+
+#include <features.h>
+
+
+__BEGIN_DECLS
+
+/* Print a message with `fprintf (stderr, FORMAT, ...)';
+   if ERRNUM is nonzero, follow it with ": " and strerror (ERRNUM).
+   If STATUS is nonzero, terminate the program with `exit (STATUS)'.  */
+
+extern void error (int __status, int __errnum, const char *__format, ...)
+     __attribute__ ((__format__ (__printf__, 3, 4)));
+
+extern void error_at_line (int __status, int __errnum, const char *__fname,
+			   unsigned int __lineno, const char *__format, ...)
+     __attribute__ ((__format__ (__printf__, 5, 6)));
+
+/* If NULL, error will flush stdout, then print on stderr the program
+   name, a colon and a space.  Otherwise, error will call this
+   function without parameters instead.  */
+extern void (*error_print_progname) (void);
+
+/* This variable is incremented each time `error' is called.  */
+extern unsigned int error_message_count;
+
+/* Sometimes we want to have at most one error per line.  This
+   variable controls whether this mode is selected or not.  */
+extern int error_one_per_line;
+
+
+#if defined __extern_always_inline && defined __va_arg_pack
+# include <bits/error.h>
+#endif
+
+__END_DECLS
+
+#endif /* error.h */
diff --git a/include/execinfo.h b/include/execinfo.h
new file mode 100644
index 0000000..b7d874d
--- /dev/null
+++ b/include/execinfo.h
@@ -0,0 +1,43 @@
+/* Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _EXECINFO_H
+#define _EXECINFO_H 1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Store up to SIZE return address of the current program state in
+   ARRAY and return the exact number of values stored.  */
+extern int backtrace (void **__array, int __size) __nonnull ((1));
+
+
+/* Return names of functions from the backtrace list in ARRAY in a newly
+   malloc()ed memory block.  */
+extern char **backtrace_symbols (void *const *__array, int __size)
+     __THROW __nonnull ((1));
+
+
+/* This function is similar to backtrace_symbols() but it writes the result
+   immediately to a file.  */
+extern void backtrace_symbols_fd (void *const *__array, int __size, int __fd)
+     __THROW __nonnull ((1));
+
+__END_DECLS
+
+#endif /* execinfo.h  */
diff --git a/include/faultexc_server.h b/include/faultexc_server.h
new file mode 100644
index 0000000..e2ccfcc
--- /dev/null
+++ b/include/faultexc_server.h
@@ -0,0 +1,43 @@
+#ifndef	_exc_server_
+#define	_exc_server_
+
+/* Module exc */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/mig_errors.h>
+#include <mach/std_types.h>
+
+/* Routine exception_raise */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _hurdsig_fault_catch_exception_raise
+(
+	mach_port_t exception_port,
+	mach_port_t thread,
+	mach_port_t task,
+	integer_t exception,
+	integer_t code,
+	integer_t subcode
+);
+
+extern mig_routine_t _hurdsig_fault_exc_server_routines[];
+static inline mig_routine_t _hurdsig_fault_exc_server_routine
+	(const mach_msg_header_t *InHeadP)
+{
+	int msgh_id;
+
+	msgh_id = InHeadP->msgh_id - 2400;
+
+	if ((msgh_id > 0) || (msgh_id < 0))
+		return 0;
+
+	return _hurdsig_fault_exc_server_routines[msgh_id];
+}
+
+#endif	/* not defined(_exc_server_) */
diff --git a/include/fcntl.h b/include/fcntl.h
new file mode 100644
index 0000000..28d83ae
--- /dev/null
+++ b/include/fcntl.h
@@ -0,0 +1,307 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 6.5 File Control Operations	<fcntl.h>
+ */
+
+#ifndef	_FCNTL_H
+#define	_FCNTL_H	1
+
+#include <features.h>
+
+/* This must be early so <bits/fcntl.h> can define types winningly.  */
+__BEGIN_DECLS
+
+/* Get __mode_t, __dev_t and __off_t  .*/
+#include <bits/types.h>
+
+/* Get the definitions of O_*, F_*, FD_*: all the
+   numbers and flag bits for `open', `fcntl', et al.  */
+#include <bits/fcntl.h>
+
+/* POSIX.1-2001 specifies that these types are defined by <fcntl.h>.
+   Earlier POSIX standards permitted any type ending in `_t' to be defined
+   by any POSIX header, so we don't conditionalize the definitions here.  */
+#ifndef __mode_t_defined
+typedef __mode_t mode_t;
+# define __mode_t_defined
+#endif
+
+#ifndef __off_t_defined
+# ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+# else
+typedef __off64_t off_t;
+# endif
+# define __off_t_defined
+#endif
+
+#if defined __USE_LARGEFILE64 && !defined __off64_t_defined
+typedef __off64_t off64_t;
+# define __off64_t_defined
+#endif
+
+#ifndef __pid_t_defined
+typedef __pid_t pid_t;
+# define __pid_t_defined
+#endif
+
+/* For XPG all symbols from <sys/stat.h> should also be available.  */
+#if defined __USE_XOPEN || defined __USE_XOPEN2K8
+# define __need_timespec
+# include <time.h>
+# include <bits/stat.h>
+
+# define S_IFMT		__S_IFMT
+# define S_IFDIR	__S_IFDIR
+# define S_IFCHR	__S_IFCHR
+# define S_IFBLK	__S_IFBLK
+# define S_IFREG	__S_IFREG
+# ifdef __S_IFIFO
+#  define S_IFIFO	__S_IFIFO
+# endif
+# ifdef __S_IFLNK
+#  define S_IFLNK	__S_IFLNK
+# endif
+# if (defined __USE_UNIX98 || defined __USE_XOPEN2K8) && defined __S_IFSOCK
+#  define S_IFSOCK	__S_IFSOCK
+# endif
+
+/* Protection bits.  */
+
+# define S_ISUID	__S_ISUID       /* Set user ID on execution.  */
+# define S_ISGID	__S_ISGID       /* Set group ID on execution.  */
+
+# if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
+/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */
+#  define S_ISVTX	__S_ISVTX
+# endif
+
+# define S_IRUSR	__S_IREAD       /* Read by owner.  */
+# define S_IWUSR	__S_IWRITE      /* Write by owner.  */
+# define S_IXUSR	__S_IEXEC       /* Execute by owner.  */
+/* Read, write, and execute by owner.  */
+# define S_IRWXU	(__S_IREAD|__S_IWRITE|__S_IEXEC)
+
+# define S_IRGRP	(S_IRUSR >> 3)  /* Read by group.  */
+# define S_IWGRP	(S_IWUSR >> 3)  /* Write by group.  */
+# define S_IXGRP	(S_IXUSR >> 3)  /* Execute by group.  */
+/* Read, write, and execute by group.  */
+# define S_IRWXG	(S_IRWXU >> 3)
+
+# define S_IROTH	(S_IRGRP >> 3)  /* Read by others.  */
+# define S_IWOTH	(S_IWGRP >> 3)  /* Write by others.  */
+# define S_IXOTH	(S_IXGRP >> 3)  /* Execute by others.  */
+/* Read, write, and execute by others.  */
+# define S_IRWXO	(S_IRWXG >> 3)
+#endif
+
+#ifdef	__USE_MISC
+# ifndef R_OK			/* Verbatim from <unistd.h>.  Ugh.  */
+/* Values for the second argument to access.
+   These may be OR'd together.  */
+#  define R_OK	4		/* Test for read permission.  */
+#  define W_OK	2		/* Test for write permission.  */
+#  define X_OK	1		/* Test for execute permission.  */
+#  define F_OK	0		/* Test for existence.  */
+# endif
+#endif /* Use misc.  */
+
+/* XPG wants the following symbols.   <stdio.h> has the same definitions.  */
+#if defined __USE_XOPEN || defined __USE_XOPEN2K8
+# define SEEK_SET	0	/* Seek from beginning of file.  */
+# define SEEK_CUR	1	/* Seek from current position.  */
+# define SEEK_END	2	/* Seek from end of file.  */
+#endif	/* XPG */
+
+/* The constants AT_REMOVEDIR and AT_EACCESS have the same value.  AT_EASSESS
+   is meaningful only to faccessat, while AT_REMOVEDIR is meaningful only to
+   unlinkat.  The two functions do completely different things and therefore,
+   the flags can be allowed to overlap.  For example, passing AT_REMOVEDIR to
+   faccessat would be undefined behavior and thus treating it equivalent to
+   AT_EACCESS is valid undefined behavior.  */
+#ifdef __USE_ATFILE
+# define AT_FDCWD		-100	/* Special value used to indicate
+					   the *at functions should use the
+					   current working directory. */
+# define AT_SYMLINK_NOFOLLOW	0x100	/* Do not follow symbolic links.  */
+# define AT_REMOVEDIR		0x200	/* Remove directory instead of
+					   unlinking file.  */
+# define AT_SYMLINK_FOLLOW	0x400	/* Follow symbolic links.  */
+# ifdef __USE_GNU
+#  define AT_NO_AUTOMOUNT	0x800	/* Suppress terminal automount
+					   traversal.  */
+#  define AT_EMPTY_PATH		0x1000	/* Allow empty relative pathname.  */
+# endif
+# define AT_EACCESS		0x200	/* Test access permitted for
+					   effective IDs, not real IDs.  */
+#endif
+
+/* Do the file control operation described by CMD on FD.
+   The remaining arguments are interpreted depending on CMD.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int fcntl (int __fd, int __cmd, ...);
+
+/* Open FILE and return a new file descriptor for it, or -1 on error.
+   OFLAG determines the type of access used.  If O_CREAT is on OFLAG,
+   the third argument is taken as a `mode_t', the mode of the created file.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+#ifndef __USE_FILE_OFFSET64
+extern int open (const char *__file, int __oflag, ...) __nonnull ((1));
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (open, (const char *__file, int __oflag, ...), open64)
+     __nonnull ((1));
+# else
+#  define open open64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int open64 (const char *__file, int __oflag, ...) __nonnull ((1));
+#endif
+
+#ifdef __USE_ATFILE
+/* Similar to `open' but a relative path name is interpreted relative to
+   the directory for which FD is a descriptor.
+
+   NOTE: some other `openat' implementation support additional functionality
+   through this interface, especially using the O_XATTR flag.  This is not
+   yet supported here.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int openat (int __fd, const char *__file, int __oflag, ...)
+     __nonnull ((2));
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (openat, (int __fd, const char *__file, int __oflag,
+				...), openat64) __nonnull ((2));
+#  else
+#   define openat openat64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int openat64 (int __fd, const char *__file, int __oflag, ...)
+     __nonnull ((2));
+# endif
+#endif
+
+/* Create and open FILE, with mode MODE.  This takes an `int' MODE
+   argument because that is what `mode_t' will be widened to.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+#ifndef __USE_FILE_OFFSET64
+extern int creat (const char *__file, mode_t __mode) __nonnull ((1));
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (creat, (const char *__file, mode_t __mode),
+		       creat64) __nonnull ((1));
+# else
+#  define creat creat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int creat64 (const char *__file, mode_t __mode) __nonnull ((1));
+#endif
+
+#if !defined F_LOCK && (defined __USE_MISC || (defined __USE_XOPEN_EXTENDED \
+					       && !defined __USE_POSIX))
+/* NOTE: These declarations also appear in <unistd.h>; be sure to keep both
+   files consistent.  Some systems have them there and some here, and some
+   software depends on the macros being defined without including both.  */
+
+/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
+   LEN is always relative to the current file position.
+   The CMD argument is one of the following.  */
+
+# define F_ULOCK 0	/* Unlock a previously locked region.  */
+# define F_LOCK  1	/* Lock a region for exclusive use.  */
+# define F_TLOCK 2	/* Test and lock a region for exclusive use.  */
+# define F_TEST  3	/* Test a region for other processes locks.  */
+
+# ifndef __USE_FILE_OFFSET64
+extern int lockf (int __fd, int __cmd, off_t __len);
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (lockf, (int __fd, int __cmd, __off64_t __len), lockf64);
+#  else
+#   define lockf lockf64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int lockf64 (int __fd, int __cmd, off64_t __len);
+# endif
+#endif
+
+#ifdef __USE_XOPEN2K
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+# ifndef __USE_FILE_OFFSET64
+extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
+			  int __advise) __THROW;
+# else
+ # ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (posix_fadvise, (int __fd, __off64_t __offset,
+					   __off64_t __len, int __advise),
+			   posix_fadvise64);
+#  else
+#   define posix_fadvise posix_fadvise64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
+			    int __advise) __THROW;
+# endif
+
+
+/* Reserve storage for the data of the file associated with FD.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
+# else
+ # ifdef __REDIRECT
+extern int __REDIRECT (posix_fallocate, (int __fd, __off64_t __offset,
+					 __off64_t __len),
+		       posix_fallocate64);
+#  else
+#   define posix_fallocate posix_fallocate64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
+# endif
+#endif
+
+
+/* Define some inlines helping to catch common problems.  */
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function \
+    && defined __va_arg_pack_len
+# include <bits/fcntl2.h>
+#endif
+
+__END_DECLS
+
+#endif /* fcntl.h  */
diff --git a/include/features.h b/include/features.h
new file mode 100644
index 0000000..21173a2
--- /dev/null
+++ b/include/features.h
@@ -0,0 +1,405 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_FEATURES_H
+#define	_FEATURES_H	1
+
+/* These are defined by the user (or the compiler)
+   to specify the desired environment:
+
+   __STRICT_ANSI__	ISO Standard C.
+   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
+   _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
+   _POSIX_SOURCE	IEEE Std 1003.1.
+   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
+			if >=199309L, add IEEE Std 1003.1b-1993;
+			if >=199506L, add IEEE Std 1003.1c-1995;
+			if >=200112L, all of IEEE 1003.1-2004
+			if >=200809L, all of IEEE 1003.1-2008
+   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
+			Single Unix conformance is wanted, to 600 for the
+			sixth revision, to 700 for the seventh revision.
+   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
+   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
+   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
+   _FILE_OFFSET_BITS=N	Select default filesystem interface.
+   _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.
+   _SVID_SOURCE		ISO C, POSIX, and SVID things.
+   _ATFILE_SOURCE	Additional *at interfaces.
+   _GNU_SOURCE		All of the above, plus GNU extensions.
+   _DEFAULT_SOURCE	The default set of features (taking precedence over
+			__STRICT_ANSI__).
+   _REENTRANT		Select additionally reentrant object.
+   _THREAD_SAFE		Same as _REENTRANT, often used by other systems.
+   _FORTIFY_SOURCE	If set to numeric value > 0 additional security
+			measures are defined, according to level.
+
+   The `-ansi' switch to the GNU C compiler, and standards conformance
+   options such as `-std=c99', define __STRICT_ANSI__.  If none of
+   these are defined, or if _DEFAULT_SOURCE is defined, the default is
+   to have _SVID_SOURCE, _BSD_SOURCE, and _POSIX_SOURCE set to one and
+   _POSIX_C_SOURCE set to 200809L.  If more than one of these are
+   defined, they accumulate.  For example __STRICT_ANSI__,
+   _POSIX_SOURCE and _POSIX_C_SOURCE together give you ISO C, 1003.1,
+   and 1003.2, but nothing else.
+
+   These are defined by this file and are used by the
+   header files to decide what to declare or define:
+
+   __USE_ISOC11		Define ISO C11 things.
+   __USE_ISOC99		Define ISO C99 things.
+   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
+   __USE_POSIX		Define IEEE Std 1003.1 things.
+   __USE_POSIX2		Define IEEE Std 1003.2 things.
+   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
+   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
+   __USE_XOPEN		Define XPG things.
+   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
+   __USE_UNIX98		Define Single Unix V2 things.
+   __USE_XOPEN2K        Define XPG6 things.
+   __USE_XOPEN2KXSI     Define XPG6 XSI things.
+   __USE_XOPEN2K8       Define XPG7 things.
+   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
+   __USE_LARGEFILE	Define correct standard I/O things.
+   __USE_LARGEFILE64	Define LFS things with separate names.
+   __USE_FILE_OFFSET64	Define 64bit interface as default.
+   __USE_BSD		Define 4.3BSD things.
+   __USE_SVID		Define SVID things.
+   __USE_MISC		Define things common to BSD and System V Unix.
+   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
+   __USE_GNU		Define GNU extensions.
+   __USE_REENTRANT	Define reentrant/thread-safe *_r functions.
+   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
+
+   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
+   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
+   only for compatibility.  All new code should use the other symbols
+   to test for features.
+
+   All macros listed above as possibly being defined by this file are
+   explicitly undefined if they are not explicitly defined.
+   Feature-test macros that are not defined by the user or compiler
+   but are implied by the other feature-test macros defined (or by the
+   lack of any definitions) are defined by the file.  */
+
+
+/* Undefine everything, so we get a clean slate.  */
+#undef	__USE_ISOC11
+#undef	__USE_ISOC99
+#undef	__USE_ISOC95
+#undef	__USE_ISOCXX11
+#undef	__USE_POSIX
+#undef	__USE_POSIX2
+#undef	__USE_POSIX199309
+#undef	__USE_POSIX199506
+#undef	__USE_XOPEN
+#undef	__USE_XOPEN_EXTENDED
+#undef	__USE_UNIX98
+#undef	__USE_XOPEN2K
+#undef	__USE_XOPEN2KXSI
+#undef	__USE_XOPEN2K8
+#undef	__USE_XOPEN2K8XSI
+#undef	__USE_LARGEFILE
+#undef	__USE_LARGEFILE64
+#undef	__USE_FILE_OFFSET64
+#undef	__USE_BSD
+#undef	__USE_SVID
+#undef	__USE_MISC
+#undef	__USE_ATFILE
+#undef	__USE_GNU
+#undef	__USE_REENTRANT
+#undef	__USE_FORTIFY_LEVEL
+#undef	__KERNEL_STRICT_NAMES
+
+/* Suppress kernel-name space pollution unless user expressedly asks
+   for it.  */
+#ifndef _LOOSE_KERNEL_NAMES
+# define __KERNEL_STRICT_NAMES
+#endif
+
+/* Convenience macros to test the versions of glibc and gcc.
+   Use them like this:
+   #if __GNUC_PREREQ (2,8)
+   ... code requiring gcc 2.8 or later ...
+   #endif
+   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
+   were not defined then.  */
+#if defined __GNUC__ && defined __GNUC_MINOR__
+# define __GNUC_PREREQ(maj, min) \
+	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+#else
+# define __GNUC_PREREQ(maj, min) 0
+#endif
+
+
+/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
+#ifdef _GNU_SOURCE
+# undef  _ISOC95_SOURCE
+# define _ISOC95_SOURCE	1
+# undef  _ISOC99_SOURCE
+# define _ISOC99_SOURCE	1
+# undef  _ISOC11_SOURCE
+# define _ISOC11_SOURCE	1
+# undef  _POSIX_SOURCE
+# define _POSIX_SOURCE	1
+# undef  _POSIX_C_SOURCE
+# define _POSIX_C_SOURCE	200809L
+# undef  _XOPEN_SOURCE
+# define _XOPEN_SOURCE	700
+# undef  _XOPEN_SOURCE_EXTENDED
+# define _XOPEN_SOURCE_EXTENDED	1
+# undef	 _LARGEFILE64_SOURCE
+# define _LARGEFILE64_SOURCE	1
+# undef  _DEFAULT_SOURCE
+# define _DEFAULT_SOURCE	1
+# undef  _BSD_SOURCE
+# define _BSD_SOURCE	1
+# undef  _SVID_SOURCE
+# define _SVID_SOURCE	1
+# undef  _ATFILE_SOURCE
+# define _ATFILE_SOURCE	1
+#endif
+
+/* If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
+   define _DEFAULT_SOURCE, _BSD_SOURCE and _SVID_SOURCE.  */
+#if (defined _DEFAULT_SOURCE					\
+     || (!defined __STRICT_ANSI__				\
+	 && !defined _ISOC99_SOURCE				\
+	 && !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE	\
+	 && !defined _XOPEN_SOURCE				\
+	 && !defined _BSD_SOURCE && !defined _SVID_SOURCE))
+# undef  _DEFAULT_SOURCE
+# define _DEFAULT_SOURCE	1
+# undef  _BSD_SOURCE
+# define _BSD_SOURCE	1
+# undef  _SVID_SOURCE
+# define _SVID_SOURCE	1
+#endif
+
+/* This is to enable the ISO C11 extension.  */
+#if (defined _ISOC11_SOURCE \
+     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L))
+# define __USE_ISOC11	1
+#endif
+
+/* This is to enable the ISO C99 extension.  */
+#if (defined _ISOC99_SOURCE || defined _ISOC11_SOURCE \
+     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))
+# define __USE_ISOC99	1
+#endif
+
+/* This is to enable the ISO C90 Amendment 1:1995 extension.  */
+#if (defined _ISOC99_SOURCE || defined _ISOC11_SOURCE \
+     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199409L))
+# define __USE_ISOC95	1
+#endif
+
+/* This is to enable compatibility for ISO C++11.
+
+   So far g++ does not provide a macro.  Check the temporary macro for
+   now, too.  */
+#if ((defined __cplusplus && __cplusplus >= 201103L)			      \
+     || defined __GXX_EXPERIMENTAL_CXX0X__)
+# define __USE_ISOCXX11	1
+#endif
+
+/* If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
+   is defined, use POSIX.1-2008 (or another version depending on
+   _XOPEN_SOURCE).  */
+#ifdef _DEFAULT_SOURCE
+# if !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE
+#  define __USE_POSIX_IMPLICITLY	1
+# endif
+# undef  _POSIX_SOURCE
+# define _POSIX_SOURCE	1
+# undef  _POSIX_C_SOURCE
+# define _POSIX_C_SOURCE	200809L
+#endif
+#if ((!defined __STRICT_ANSI__ || (_XOPEN_SOURCE - 0) >= 500) && \
+     !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE)
+# define _POSIX_SOURCE	1
+# if defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 500
+#  define _POSIX_C_SOURCE	2
+# elif defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 600
+#  define _POSIX_C_SOURCE	199506L
+# elif defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 700
+#  define _POSIX_C_SOURCE	200112L
+# else
+#  define _POSIX_C_SOURCE	200809L
+# endif
+# define __USE_POSIX_IMPLICITLY	1
+#endif
+
+#if defined _POSIX_SOURCE || _POSIX_C_SOURCE >= 1 || defined _XOPEN_SOURCE
+# define __USE_POSIX	1
+#endif
+
+#if defined _POSIX_C_SOURCE && _POSIX_C_SOURCE >= 2 || defined _XOPEN_SOURCE
+# define __USE_POSIX2	1
+#endif
+
+#if (_POSIX_C_SOURCE - 0) >= 199309L
+# define __USE_POSIX199309	1
+#endif
+
+#if (_POSIX_C_SOURCE - 0) >= 199506L
+# define __USE_POSIX199506	1
+#endif
+
+#if (_POSIX_C_SOURCE - 0) >= 200112L
+# define __USE_XOPEN2K		1
+# undef __USE_ISOC95
+# define __USE_ISOC95		1
+# undef __USE_ISOC99
+# define __USE_ISOC99		1
+#endif
+
+#if (_POSIX_C_SOURCE - 0) >= 200809L
+# define __USE_XOPEN2K8		1
+# undef  _ATFILE_SOURCE
+# define _ATFILE_SOURCE	1
+#endif
+
+#ifdef	_XOPEN_SOURCE
+# define __USE_XOPEN	1
+# if (_XOPEN_SOURCE - 0) >= 500
+#  define __USE_XOPEN_EXTENDED	1
+#  define __USE_UNIX98	1
+#  undef _LARGEFILE_SOURCE
+#  define _LARGEFILE_SOURCE	1
+#  if (_XOPEN_SOURCE - 0) >= 600
+#   if (_XOPEN_SOURCE - 0) >= 700
+#    define __USE_XOPEN2K8	1
+#    define __USE_XOPEN2K8XSI	1
+#   endif
+#   define __USE_XOPEN2K	1
+#   define __USE_XOPEN2KXSI	1
+#   undef __USE_ISOC95
+#   define __USE_ISOC95		1
+#   undef __USE_ISOC99
+#   define __USE_ISOC99		1
+#  endif
+# else
+#  ifdef _XOPEN_SOURCE_EXTENDED
+#   define __USE_XOPEN_EXTENDED	1
+#  endif
+# endif
+#endif
+
+#ifdef _LARGEFILE_SOURCE
+# define __USE_LARGEFILE	1
+#endif
+
+#ifdef _LARGEFILE64_SOURCE
+# define __USE_LARGEFILE64	1
+#endif
+
+#if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
+# define __USE_FILE_OFFSET64	1
+#endif
+
+#if defined _BSD_SOURCE || defined _SVID_SOURCE
+# define __USE_MISC	1
+#endif
+
+#ifdef	_BSD_SOURCE
+# define __USE_BSD	1
+#endif
+
+#ifdef	_SVID_SOURCE
+# define __USE_SVID	1
+#endif
+
+#ifdef	_ATFILE_SOURCE
+# define __USE_ATFILE	1
+#endif
+
+#ifdef	_GNU_SOURCE
+# define __USE_GNU	1
+#endif
+
+#if defined _REENTRANT || defined _THREAD_SAFE
+# define __USE_REENTRANT	1
+#endif
+
+#if defined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0
+# if !defined __OPTIMIZE__ || __OPTIMIZE__ <= 0
+#  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+# elif !__GNUC_PREREQ (4, 1)
+#  warning _FORTIFY_SOURCE requires GCC 4.1 or later
+# elif _FORTIFY_SOURCE > 1
+#  define __USE_FORTIFY_LEVEL 2
+# else
+#  define __USE_FORTIFY_LEVEL 1
+# endif
+#endif
+#ifndef __USE_FORTIFY_LEVEL
+# define __USE_FORTIFY_LEVEL 0
+#endif
+
+/* Get definitions of __STDC_* predefined macros, if the compiler has
+   not preincluded this header automatically.  */
+#include <stdc-predef.h>
+
+/* This macro indicates that the installed library is the GNU C Library.
+   For historic reasons the value now is 6 and this will stay from now
+   on.  The use of this variable is deprecated.  Use __GLIBC__ and
+   __GLIBC_MINOR__ now (see below) when you want to test for a specific
+   GNU C library version and use the values in <gnu/lib-names.h> to get
+   the sonames of the shared libraries.  */
+#undef  __GNU_LIBRARY__
+#define __GNU_LIBRARY__ 6
+
+/* Major and minor version number of the GNU C library package.  Use
+   these macros to test for features in specific releases.  */
+#define	__GLIBC__	2
+#define	__GLIBC_MINOR__	19
+
+#define __GLIBC_PREREQ(maj, min) \
+	((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))
+
+/* This is here only because every header file already includes this one.  */
+#ifndef __ASSEMBLER__
+# ifndef _SYS_CDEFS_H
+#  include <sys/cdefs.h>
+# endif
+
+/* If we don't have __REDIRECT, prototypes will be missing if
+   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */
+# if defined __USE_FILE_OFFSET64 && !defined __REDIRECT
+#  define __USE_LARGEFILE	1
+#  define __USE_LARGEFILE64	1
+# endif
+
+#endif	/* !ASSEMBLER */
+
+/* Decide whether we can define 'extern inline' functions in headers.  */
+#if __GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ \
+    && !defined __OPTIMIZE_SIZE__ && !defined __NO_INLINE__ \
+    && defined __extern_inline
+# define __USE_EXTERN_INLINES	1
+#endif
+
+
+/* This is here only because every header file already includes this one.
+   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
+   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
+   that will always return failure (and set errno to ENOSYS).  */
+#include <gnu/stubs.h>
+
+
+#endif	/* features.h  */
diff --git a/include/fenv.h b/include/fenv.h
new file mode 100644
index 0000000..1171199
--- /dev/null
+++ b/include/fenv.h
@@ -0,0 +1,135 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * ISO C99 7.6: Floating-point environment	<fenv.h>
+ */
+
+#ifndef _FENV_H
+#define _FENV_H	1
+
+#include <features.h>
+
+/* Get the architecture dependend definitions.  The following definitions
+   are expected to be done:
+
+   fenv_t	type for object representing an entire floating-point
+		environment
+
+   FE_DFL_ENV	macro of type pointer to fenv_t to be used as the argument
+		to functions taking an argument of type fenv_t; in this
+		case the default environment will be used
+
+   fexcept_t	type for object representing the floating-point exception
+		flags including status associated with the flags
+
+   The following macros are defined iff the implementation supports this
+   kind of exception.
+   FE_INEXACT		inexact result
+   FE_DIVBYZERO		division by zero
+   FE_UNDERFLOW		result not representable due to underflow
+   FE_OVERFLOW		result not representable due to overflow
+   FE_INVALID		invalid operation
+
+   FE_ALL_EXCEPT	bitwise OR of all supported exceptions
+
+   The next macros are defined iff the appropriate rounding mode is
+   supported by the implementation.
+   FE_TONEAREST		round to nearest
+   FE_UPWARD		round toward +Inf
+   FE_DOWNWARD		round toward -Inf
+   FE_TOWARDZERO	round toward 0
+*/
+#include <bits/fenv.h>
+
+__BEGIN_DECLS
+
+/* Floating-point exception handling.  */
+
+/* Clear the supported exceptions represented by EXCEPTS.  */
+extern int feclearexcept (int __excepts) __THROW;
+
+/* Store implementation-defined representation of the exception flags
+   indicated by EXCEPTS in the object pointed to by FLAGP.  */
+extern int fegetexceptflag (fexcept_t *__flagp, int __excepts) __THROW;
+
+/* Raise the supported exceptions represented by EXCEPTS.  */
+extern int feraiseexcept (int __excepts) __THROW;
+
+/* Set complete status for exceptions indicated by EXCEPTS according to
+   the representation in the object pointed to by FLAGP.  */
+extern int fesetexceptflag (const fexcept_t *__flagp, int __excepts) __THROW;
+
+/* Determine which of subset of the exceptions specified by EXCEPTS are
+   currently set.  */
+extern int fetestexcept (int __excepts) __THROW;
+
+
+/* Rounding control.  */
+
+/* Get current rounding direction.  */
+extern int fegetround (void) __THROW;
+
+/* Establish the rounding direction represented by ROUND.  */
+extern int fesetround (int __rounding_direction) __THROW;
+
+
+/* Floating-point environment.  */
+
+/* Store the current floating-point environment in the object pointed
+   to by ENVP.  */
+extern int fegetenv (fenv_t *__envp) __THROW;
+
+/* Save the current environment in the object pointed to by ENVP, clear
+   exception flags and install a non-stop mode (if available) for all
+   exceptions.  */
+extern int feholdexcept (fenv_t *__envp) __THROW;
+
+/* Establish the floating-point environment represented by the object
+   pointed to by ENVP.  */
+extern int fesetenv (const fenv_t *__envp) __THROW;
+
+/* Save current exceptions in temporary storage, install environment
+   represented by object pointed to by ENVP and raise exceptions
+   according to saved exceptions.  */
+extern int feupdateenv (const fenv_t *__envp) __THROW;
+
+
+/* Include optimization.  */
+#ifdef __OPTIMIZE__
+# include <bits/fenvinline.h>
+#endif
+
+#ifdef __USE_GNU
+
+/* Enable individual exceptions.  Will not enable more exceptions than
+   EXCEPTS specifies.  Returns the previous enabled exceptions if all
+   exceptions are successfully set, otherwise returns -1.  */
+extern int feenableexcept (int __excepts) __THROW;
+
+/* Disable individual exceptions.  Will not disable more exceptions than
+   EXCEPTS specifies.  Returns the previous enabled exceptions if all
+   exceptions are successfully disabled, otherwise returns -1.  */
+extern int fedisableexcept (int __excepts) __THROW;
+
+/* Return enabled exceptions.  */
+extern int fegetexcept (void) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* fenv.h */
diff --git a/include/fmtmsg.h b/include/fmtmsg.h
new file mode 100644
index 0000000..ec4c5e0
--- /dev/null
+++ b/include/fmtmsg.h
@@ -0,0 +1,105 @@
+/* Message display handling.
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef __FMTMSG_H
+#define __FMTMSG_H	1
+
+#include <features.h>
+
+
+__BEGIN_DECLS
+
+/* Values to control `fmtmsg' function.  */
+enum
+{
+  MM_HARD = 0x001,	/* Source of the condition is hardware.  */
+#define MM_HARD MM_HARD
+  MM_SOFT = 0x002,	/* Source of the condition is software.  */
+#define MM_SOFT MM_SOFT
+  MM_FIRM = 0x004,	/* Source of the condition is firmware.  */
+#define MM_FIRM MM_FIRM
+  MM_APPL = 0x008,	/* Condition detected by application.  */
+#define MM_APPL MM_APPL
+  MM_UTIL = 0x010,	/* Condition detected by utility.  */
+#define MM_UTIL MM_UTIL
+  MM_OPSYS = 0x020,	/* Condition detected by operating system.  */
+#define MM_OPSYS MM_OPSYS
+  MM_RECOVER = 0x040,	/* Recoverable error.  */
+#define MM_RECOVER MM_RECOVER
+  MM_NRECOV = 0x080,	/* Non-recoverable error.  */
+#define MM_NRECOV MM_NRECOV
+  MM_PRINT = 0x100,	/* Display message in standard error.  */
+#define MM_PRINT MM_PRINT
+  MM_CONSOLE = 0x200	/* Display message on system console.  */
+#define MM_CONSOLE MM_CONSOLE
+};
+
+/* Values to be for SEVERITY parameter of `fmtmsg'.  */
+enum
+{
+  MM_NOSEV = 0,		/* No severity level provided for the message.  */
+#define MM_NOSEV MM_NOSEV
+  MM_HALT,		/* Error causing application to halt.  */
+#define MM_HALT MM_HALT
+  MM_ERROR,		/* Application has encountered a non-fatal fault.  */
+#define MM_ERROR MM_ERROR
+  MM_WARNING,		/* Application has detected unusual non-error
+			   condition.  */
+#define MM_WARNING MM_WARNING
+  MM_INFO		/* Informative message.  */
+#define MM_INFO MM_INFO
+};
+
+
+/* Macros which can be used as null values for the arguments of `fmtmsg'.  */
+#define MM_NULLLBL	((char *) 0)
+#define MM_NULLSEV	0
+#define MM_NULLMC	((long int) 0)
+#define MM_NULLTXT	((char *) 0)
+#define MM_NULLACT	((char *) 0)
+#define MM_NULLTAG	((char *) 0)
+
+
+/* Possible return values of `fmtmsg'.  */
+enum
+{
+  MM_NOTOK = -1,
+#define MM_NOTOK MM_NOTOK
+  MM_OK = 0,
+#define MM_OK MM_OK
+  MM_NOMSG = 1,
+#define MM_NOMSG MM_NOMSG
+  MM_NOCON = 4
+#define MM_NOCON MM_NOCON
+};
+
+
+/* Print message with given CLASSIFICATION, LABEL, SEVERITY, TEXT, ACTION
+   and TAG to console or standard error.  */
+extern int fmtmsg (long int __classification, const char *__label,
+		   int __severity, const char *__text,
+		   const char *__action, const char *__tag);
+
+#ifdef __USE_SVID
+/* Add or remove severity level.  */
+extern int addseverity (int __severity, const char *__string) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* fmtmsg.h */
diff --git a/include/fnmatch.h b/include/fnmatch.h
new file mode 100644
index 0000000..ac96fb8
--- /dev/null
+++ b/include/fnmatch.h
@@ -0,0 +1,62 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_FNMATCH_H
+#define	_FNMATCH_H	1
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* We #undef these before defining them because some losing systems
+   (HP-UX A.08.07 for example) define these in <unistd.h>.  */
+#undef	FNM_PATHNAME
+#undef	FNM_NOESCAPE
+#undef	FNM_PERIOD
+
+/* Bits set in the FLAGS argument to `fnmatch'.  */
+#define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
+#define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
+#define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
+
+#if !defined _POSIX_C_SOURCE || _POSIX_C_SOURCE < 2 || defined _GNU_SOURCE
+# define FNM_FILE_NAME	 FNM_PATHNAME	/* Preferred GNU name.  */
+# define FNM_LEADING_DIR (1 << 3)	/* Ignore `/...' after a match.  */
+# define FNM_CASEFOLD	 (1 << 4)	/* Compare without regard to case.  */
+# define FNM_EXTMATCH	 (1 << 5)	/* Use ksh-like extended matching. */
+#endif
+
+/* Value returned by `fnmatch' if STRING does not match PATTERN.  */
+#define	FNM_NOMATCH	1
+
+/* This value is returned if the implementation does not support
+   `fnmatch'.  Since this is not the case here it will never be
+   returned but the conformance test suites still require the symbol
+   to be defined.  */
+#ifdef _XOPEN_SOURCE
+# define FNM_NOSYS	(-1)
+#endif
+
+/* Match NAME against the filename pattern PATTERN,
+   returning zero if it matches, FNM_NOMATCH if not.  */
+extern int fnmatch (const char *__pattern, const char *__name, int __flags);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* fnmatch.h */
diff --git a/include/fpu_control.h b/include/fpu_control.h
new file mode 100644
index 0000000..2295f46
--- /dev/null
+++ b/include/fpu_control.h
@@ -0,0 +1,109 @@
+/* FPU control word bits.  x86 version.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Olaf Flebbe.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H	1
+
+/* Note that this file sets on x86-64 only the x87 FPU, it does not
+   touch the SSE unit.  */
+
+/* Here is the dirty part. Set up your 387 through the control word
+ * (cw) register.
+ *
+ *     15-13    12  11-10  9-8     7-6     5    4    3    2    1    0
+ * | reserved | IC | RC  | PC | reserved | PM | UM | OM | ZM | DM | IM
+ *
+ * IM: Invalid operation mask
+ * DM: Denormalized operand mask
+ * ZM: Zero-divide mask
+ * OM: Overflow mask
+ * UM: Underflow mask
+ * PM: Precision (inexact result) mask
+ *
+ * Mask bit is 1 means no interrupt.
+ *
+ * PC: Precision control
+ * 11 - round to extended precision
+ * 10 - round to double precision
+ * 00 - round to single precision
+ *
+ * RC: Rounding control
+ * 00 - rounding to nearest
+ * 01 - rounding down (toward - infinity)
+ * 10 - rounding up (toward + infinity)
+ * 11 - rounding toward zero
+ *
+ * IC: Infinity control
+ * That is for 8087 and 80287 only.
+ *
+ * The hardware default is 0x037f which we use.
+ */
+
+#include <features.h>
+
+/* masking of interrupts */
+#define _FPU_MASK_IM  0x01
+#define _FPU_MASK_DM  0x02
+#define _FPU_MASK_ZM  0x04
+#define _FPU_MASK_OM  0x08
+#define _FPU_MASK_UM  0x10
+#define _FPU_MASK_PM  0x20
+
+/* precision control */
+#define _FPU_EXTENDED 0x300	/* libm requires double extended precision.  */
+#define _FPU_DOUBLE   0x200
+#define _FPU_SINGLE   0x0
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x0    /* RECOMMENDED */
+#define _FPU_RC_DOWN    0x400
+#define _FPU_RC_UP      0x800
+#define _FPU_RC_ZERO    0xC00
+
+#define _FPU_RESERVED 0xF0C0  /* Reserved bits in cw */
+
+
+/* The fdlibm code requires strict IEEE double precision arithmetic,
+   and no interrupts for exceptions, rounding to nearest.  */
+
+#define _FPU_DEFAULT  0x037f
+
+/* IEEE:  same as above.  */
+#define _FPU_IEEE     0x037f
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__HI__)));
+
+/* Macros for accessing the hardware control word.  "*&" is used to
+   work around a bug in older versions of GCC.  __volatile__ is used
+   to support combination of writing the control register and reading
+   it back.  Without __volatile__, the old value may be used for reading
+   back under compiler optimization.
+
+   Note that the use of these macros is not sufficient anymore with
+   recent hardware nor on x86-64.  Some floating point operations are
+   executed in the SSE/SSE2 engines which have their own control and
+   status register.  */
+#define _FPU_GETCW(cw) __asm__ __volatile__ ("fnstcw %0" : "=m" (*&cw))
+#define _FPU_SETCW(cw) __asm__ __volatile__ ("fldcw %0" : : "m" (*&cw))
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#endif	/* fpu_control.h */
diff --git a/include/fstab.h b/include/fstab.h
new file mode 100644
index 0000000..9f17e1b
--- /dev/null
+++ b/include/fstab.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 1980, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)fstab.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _FSTAB_H
+#define _FSTAB_H	1
+
+#include <features.h>
+
+/*
+ * File system table, see fstab(5).
+ *
+ * Used by dump, mount, umount, swapon, fsck, df, ...
+ *
+ * For ufs fs_spec field is the block special name.  Programs that want to
+ * use the character special name must create that name by prepending a 'r'
+ * after the right most slash.  Quota files are always named "quotas", so
+ * if type is "rq", then use concatenation of fs_file and "quotas" to locate
+ * quota file.
+ */
+#define	_PATH_FSTAB	"/etc/fstab"
+#define	FSTAB		"/etc/fstab"	/* deprecated */
+
+#define	FSTAB_RW	"rw"		/* read/write device */
+#define	FSTAB_RQ	"rq"		/* read/write with quotas */
+#define	FSTAB_RO	"ro"		/* read-only device */
+#define	FSTAB_SW	"sw"		/* swap device */
+#define	FSTAB_XX	"xx"		/* ignore totally */
+
+struct fstab
+  {
+    char *fs_spec;			/* block special device name */
+    char *fs_file;			/* file system path prefix */
+    char *fs_vfstype;			/* File system type, ufs, nfs */
+    char *fs_mntops;			/* Mount options ala -o */
+    const char *fs_type;		/* FSTAB_* from fs_mntops */
+    int	fs_freq;			/* dump frequency, in days */
+    int	fs_passno;			/* pass number on parallel dump */
+  };
+
+
+__BEGIN_DECLS
+
+extern struct fstab *getfsent (void) __THROW;
+extern struct fstab *getfsspec (const char *__name) __THROW;
+extern struct fstab *getfsfile (const char *__name) __THROW;
+extern int setfsent (void) __THROW;
+extern void endfsent (void) __THROW;
+
+__END_DECLS
+
+#endif /* fstab.h */
diff --git a/include/fts.h b/include/fts.h
new file mode 100644
index 0000000..0a070ba
--- /dev/null
+++ b/include/fts.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)fts.h	8.3 (Berkeley) 8/14/94
+ */
+
+#ifndef	_FTS_H
+#define	_FTS_H 1
+
+#include <features.h>
+#include <sys/types.h>
+
+/* The fts interface is incompatible with the LFS interface which
+   transparently uses the 64-bit file access functions.  */
+#ifdef __USE_FILE_OFFSET64
+# error "<fts.h> cannot be used with -D_FILE_OFFSET_BITS==64"
+#endif
+
+
+typedef struct {
+	struct _ftsent *fts_cur;	/* current node */
+	struct _ftsent *fts_child;	/* linked list of children */
+	struct _ftsent **fts_array;	/* sort array */
+	dev_t fts_dev;			/* starting device # */
+	char *fts_path;			/* path for this descent */
+	int fts_rfd;			/* fd for root */
+	int fts_pathlen;		/* sizeof(path) */
+	int fts_nitems;			/* elements in the sort array */
+	int (*fts_compar) (const void *, const void *); /* compare fn */
+
+#define	FTS_COMFOLLOW	0x0001		/* follow command line symlinks */
+#define	FTS_LOGICAL	0x0002		/* logical walk */
+#define	FTS_NOCHDIR	0x0004		/* don't change directories */
+#define	FTS_NOSTAT	0x0008		/* don't get stat info */
+#define	FTS_PHYSICAL	0x0010		/* physical walk */
+#define	FTS_SEEDOT	0x0020		/* return dot and dot-dot */
+#define	FTS_XDEV	0x0040		/* don't cross devices */
+#define FTS_WHITEOUT	0x0080		/* return whiteout information */
+#define	FTS_OPTIONMASK	0x00ff		/* valid user option mask */
+
+#define	FTS_NAMEONLY	0x0100		/* (private) child names only */
+#define	FTS_STOP	0x0200		/* (private) unrecoverable error */
+	int fts_options;		/* fts_open options, global flags */
+} FTS;
+
+typedef struct _ftsent {
+	struct _ftsent *fts_cycle;	/* cycle node */
+	struct _ftsent *fts_parent;	/* parent directory */
+	struct _ftsent *fts_link;	/* next file in directory */
+	long fts_number;	        /* local numeric value */
+	void *fts_pointer;	        /* local address value */
+	char *fts_accpath;		/* access path */
+	char *fts_path;			/* root path */
+	int fts_errno;			/* errno for this node */
+	int fts_symfd;			/* fd for symlink */
+	u_short fts_pathlen;		/* strlen(fts_path) */
+	u_short fts_namelen;		/* strlen(fts_name) */
+
+	ino_t fts_ino;			/* inode */
+	dev_t fts_dev;			/* device */
+	nlink_t fts_nlink;		/* link count */
+
+#define	FTS_ROOTPARENTLEVEL	-1
+#define	FTS_ROOTLEVEL		 0
+	short fts_level;		/* depth (-1 to N) */
+
+#define	FTS_D		 1		/* preorder directory */
+#define	FTS_DC		 2		/* directory that causes cycles */
+#define	FTS_DEFAULT	 3		/* none of the above */
+#define	FTS_DNR		 4		/* unreadable directory */
+#define	FTS_DOT		 5		/* dot or dot-dot */
+#define	FTS_DP		 6		/* postorder directory */
+#define	FTS_ERR		 7		/* error; errno is set */
+#define	FTS_F		 8		/* regular file */
+#define	FTS_INIT	 9		/* initialized only */
+#define	FTS_NS		10		/* stat(2) failed */
+#define	FTS_NSOK	11		/* no stat(2) requested */
+#define	FTS_SL		12		/* symbolic link */
+#define	FTS_SLNONE	13		/* symbolic link without target */
+#define FTS_W		14		/* whiteout object */
+	u_short fts_info;		/* user flags for FTSENT structure */
+
+#define	FTS_DONTCHDIR	 0x01		/* don't chdir .. to the parent */
+#define	FTS_SYMFOLLOW	 0x02		/* followed a symlink to get here */
+	u_short fts_flags;		/* private flags for FTSENT structure */
+
+#define	FTS_AGAIN	 1		/* read node again */
+#define	FTS_FOLLOW	 2		/* follow symbolic link */
+#define	FTS_NOINSTR	 3		/* no instructions */
+#define	FTS_SKIP	 4		/* discard node */
+	u_short fts_instr;		/* fts_set() instructions */
+
+	struct stat *fts_statp;		/* stat(2) information */
+	char fts_name[1];		/* file name */
+} FTSENT;
+
+__BEGIN_DECLS
+FTSENT	*fts_children (FTS *, int);
+int	 fts_close (FTS *);
+FTS	*fts_open (char * const *, int,
+		   int (*)(const FTSENT **, const FTSENT **));
+FTSENT	*fts_read (FTS *);
+int	 fts_set (FTS *, FTSENT *, int) __THROW;
+__END_DECLS
+
+#endif /* fts.h */
diff --git a/include/ftw.h b/include/ftw.h
new file mode 100644
index 0000000..e5e3dd0
--- /dev/null
+++ b/include/ftw.h
@@ -0,0 +1,177 @@
+/* Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	X/Open Portability Guide 4.2: ftw.h
+ */
+
+#ifndef _FTW_H
+#define	_FTW_H	1
+
+#include <features.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+
+__BEGIN_DECLS
+
+/* Values for the FLAG argument to the user function passed to `ftw'
+   and 'nftw'.  */
+enum
+{
+  FTW_F,		/* Regular file.  */
+#define FTW_F	 FTW_F
+  FTW_D,		/* Directory.  */
+#define FTW_D	 FTW_D
+  FTW_DNR,		/* Unreadable directory.  */
+#define FTW_DNR	 FTW_DNR
+  FTW_NS,		/* Unstatable file.  */
+#define FTW_NS	 FTW_NS
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+
+  FTW_SL,		/* Symbolic link.  */
+# define FTW_SL	 FTW_SL
+#endif
+
+#ifdef __USE_XOPEN_EXTENDED
+/* These flags are only passed from the `nftw' function.  */
+  FTW_DP,		/* Directory, all subdirs have been visited. */
+# define FTW_DP	 FTW_DP
+  FTW_SLN		/* Symbolic link naming non-existing file.  */
+# define FTW_SLN FTW_SLN
+
+#endif	/* extended X/Open */
+};
+
+
+#ifdef __USE_XOPEN_EXTENDED
+/* Flags for fourth argument of `nftw'.  */
+enum
+{
+  FTW_PHYS = 1,		/* Perform physical walk, ignore symlinks.  */
+# define FTW_PHYS	FTW_PHYS
+  FTW_MOUNT = 2,	/* Report only files on same file system as the
+			   argument.  */
+# define FTW_MOUNT	FTW_MOUNT
+  FTW_CHDIR = 4,	/* Change to current directory while processing it.  */
+# define FTW_CHDIR	FTW_CHDIR
+  FTW_DEPTH = 8		/* Report files in directory before directory itself.*/
+# define FTW_DEPTH	FTW_DEPTH
+# ifdef __USE_GNU
+  ,
+  FTW_ACTIONRETVAL = 16	/* Assume callback to return FTW_* values instead of
+			   zero to continue and non-zero to terminate.  */
+#  define FTW_ACTIONRETVAL FTW_ACTIONRETVAL
+# endif
+};
+
+#ifdef __USE_GNU
+/* Return values from callback functions.  */
+enum
+{
+  FTW_CONTINUE = 0,	/* Continue with next sibling or for FTW_D with the
+			   first child.  */
+# define FTW_CONTINUE	FTW_CONTINUE
+  FTW_STOP = 1,		/* Return from `ftw' or `nftw' with FTW_STOP as return
+			   value.  */
+# define FTW_STOP	FTW_STOP
+  FTW_SKIP_SUBTREE = 2,	/* Only meaningful for FTW_D: Don't walk through the
+			   subtree, instead just continue with its next
+			   sibling. */
+# define FTW_SKIP_SUBTREE FTW_SKIP_SUBTREE
+  FTW_SKIP_SIBLINGS = 3,/* Continue with FTW_DP callback for current directory
+			    (if FTW_DEPTH) and then its siblings.  */
+# define FTW_SKIP_SIBLINGS FTW_SKIP_SIBLINGS
+};
+#endif
+
+/* Structure used for fourth argument to callback function for `nftw'.  */
+struct FTW
+  {
+    int base;
+    int level;
+  };
+#endif	/* extended X/Open */
+
+
+/* Convenient types for callback functions.  */
+typedef int (*__ftw_func_t) (const char *__filename,
+			     const struct stat *__status, int __flag);
+#ifdef __USE_LARGEFILE64
+typedef int (*__ftw64_func_t) (const char *__filename,
+			       const struct stat64 *__status, int __flag);
+#endif
+#ifdef __USE_XOPEN_EXTENDED
+typedef int (*__nftw_func_t) (const char *__filename,
+			      const struct stat *__status, int __flag,
+			      struct FTW *__info);
+# ifdef __USE_LARGEFILE64
+typedef int (*__nftw64_func_t) (const char *__filename,
+				const struct stat64 *__status,
+				int __flag, struct FTW *__info);
+# endif
+#endif
+
+/* Call a function on every element in a directory tree.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+#ifndef __USE_FILE_OFFSET64
+extern int ftw (const char *__dir, __ftw_func_t __func, int __descriptors)
+     __nonnull ((1, 2));
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (ftw, (const char *__dir, __ftw_func_t __func,
+			     int __descriptors), ftw64) __nonnull ((1, 2));
+# else
+#  define ftw ftw64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int ftw64 (const char *__dir, __ftw64_func_t __func,
+		  int __descriptors) __nonnull ((1, 2));
+#endif
+
+#ifdef __USE_XOPEN_EXTENDED
+/* Call a function on every element in a directory tree.  FLAG allows
+   to specify the behaviour more detailed.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int nftw (const char *__dir, __nftw_func_t __func, int __descriptors,
+		 int __flag) __nonnull ((1, 2));
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (nftw, (const char *__dir, __nftw_func_t __func,
+			      int __descriptors, int __flag), nftw64)
+     __nonnull ((1, 2));
+#  else
+#   define nftw nftw64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int nftw64 (const char *__dir, __nftw64_func_t __func,
+		   int __descriptors, int __flag) __nonnull ((1, 2));
+# endif
+#endif
+
+__END_DECLS
+
+#endif	/* ftw.h */
diff --git a/include/gconv.h b/include/gconv.h
new file mode 100644
index 0000000..108dccb
--- /dev/null
+++ b/include/gconv.h
@@ -0,0 +1,180 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This header provides no interface for a user to the internals of
+   the gconv implementation in the libc.  Therefore there is no use
+   for these definitions beside for writing additional gconv modules.  */
+
+#ifndef _GCONV_H
+#define _GCONV_H	1
+
+#include <features.h>
+#define __need_mbstate_t
+#define __need_wint_t
+#include <wchar.h>
+#define __need_size_t
+#define __need_wchar_t
+#include <stddef.h>
+
+/* ISO 10646 value used to signal invalid value.  */
+#define __UNKNOWN_10646_CHAR	((wchar_t) 0xfffd)
+
+/* Error codes for gconv functions.  */
+enum
+{
+  __GCONV_OK = 0,
+  __GCONV_NOCONV,
+  __GCONV_NODB,
+  __GCONV_NOMEM,
+
+  __GCONV_EMPTY_INPUT,
+  __GCONV_FULL_OUTPUT,
+  __GCONV_ILLEGAL_INPUT,
+  __GCONV_INCOMPLETE_INPUT,
+
+  __GCONV_ILLEGAL_DESCRIPTOR,
+  __GCONV_INTERNAL_ERROR
+};
+
+
+/* Flags the `__gconv_open' function can set.  */
+enum
+{
+  __GCONV_IS_LAST = 0x0001,
+  __GCONV_IGNORE_ERRORS = 0x0002,
+  __GCONV_SWAP = 0x0004
+};
+
+
+/* Forward declarations.  */
+struct __gconv_step;
+struct __gconv_step_data;
+struct __gconv_loaded_object;
+struct __gconv_trans_data;
+
+
+/* Type of a conversion function.  */
+typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
+			    const unsigned char **, const unsigned char *,
+			    unsigned char **, size_t *, int, int);
+
+/* Type of a specialized conversion function for a single byte to INTERNAL.  */
+typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);
+
+/* Constructor and destructor for local data for conversion step.  */
+typedef int (*__gconv_init_fct) (struct __gconv_step *);
+typedef void (*__gconv_end_fct) (struct __gconv_step *);
+
+
+/* Type of a transliteration/transscription function.  */
+typedef int (*__gconv_trans_fct) (struct __gconv_step *,
+				  struct __gconv_step_data *, void *,
+				  const unsigned char *,
+				  const unsigned char **,
+				  const unsigned char *, unsigned char **,
+				  size_t *);
+
+/* Function to call to provide transliteration module with context.  */
+typedef int (*__gconv_trans_context_fct) (void *, const unsigned char *,
+					  const unsigned char *,
+					  unsigned char *, unsigned char *);
+
+/* Function to query module about supported encoded character sets.  */
+typedef int (*__gconv_trans_query_fct) (const char *, const char ***,
+					size_t *);
+
+/* Constructor and destructor for local data for transliteration.  */
+typedef int (*__gconv_trans_init_fct) (void **, const char *);
+typedef void (*__gconv_trans_end_fct) (void *);
+
+struct __gconv_trans_data
+{
+  /* Transliteration/Transscription function.  */
+  __gconv_trans_fct __trans_fct;
+  __gconv_trans_context_fct __trans_context_fct;
+  __gconv_trans_end_fct __trans_end_fct;
+  void *__data;
+  struct __gconv_trans_data *__next;
+};
+
+
+/* Description of a conversion step.  */
+struct __gconv_step
+{
+  struct __gconv_loaded_object *__shlib_handle;
+  const char *__modname;
+
+  int __counter;
+
+  char *__from_name;
+  char *__to_name;
+
+  __gconv_fct __fct;
+  __gconv_btowc_fct __btowc_fct;
+  __gconv_init_fct __init_fct;
+  __gconv_end_fct __end_fct;
+
+  /* Information about the number of bytes needed or produced in this
+     step.  This helps optimizing the buffer sizes.  */
+  int __min_needed_from;
+  int __max_needed_from;
+  int __min_needed_to;
+  int __max_needed_to;
+
+  /* Flag whether this is a stateful encoding or not.  */
+  int __stateful;
+
+  void *__data;		/* Pointer to step-local data.  */
+};
+
+/* Additional data for steps in use of conversion descriptor.  This is
+   allocated by the `init' function.  */
+struct __gconv_step_data
+{
+  unsigned char *__outbuf;    /* Output buffer for this step.  */
+  unsigned char *__outbufend; /* Address of first byte after the output
+				 buffer.  */
+
+  /* Is this the last module in the chain.  */
+  int __flags;
+
+  /* Counter for number of invocations of the module function for this
+     descriptor.  */
+  int __invocation_counter;
+
+  /* Flag whether this is an internal use of the module (in the mb*towc*
+     and wc*tomb* functions) or regular with iconv(3).  */
+  int __internal_use;
+
+  __mbstate_t *__statep;
+  __mbstate_t __state;	/* This element must not be used directly by
+			   any module; always use STATEP!  */
+
+  /* Transliteration information.  */
+  struct __gconv_trans_data *__trans;
+};
+
+
+/* Combine conversion step description with data.  */
+typedef struct __gconv_info
+{
+  size_t __nsteps;
+  struct __gconv_step *__steps;
+  __extension__ struct __gconv_step_data __data __flexarr;
+} *__gconv_t;
+
+#endif /* gconv.h */
diff --git a/include/getopt.h b/include/getopt.h
new file mode 100644
index 0000000..da1a01f
--- /dev/null
+++ b/include/getopt.h
@@ -0,0 +1,191 @@
+/* Declarations for getopt.
+   Copyright (C) 1989-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _GETOPT_H
+
+#ifndef __need_getopt
+# define _GETOPT_H 1
+#endif
+
+/* If __GNU_LIBRARY__ is not already defined, either we are being used
+   standalone, or this is the first header included in the source file.
+   If we are being used with glibc, we need to include <features.h>, but
+   that does not exist if we are standalone.  So: if __GNU_LIBRARY__ is
+   not defined, include <ctype.h>, which will pull in <features.h> for us
+   if it's from glibc.  (Why ctype.h?  It's guaranteed to exist and it
+   doesn't flood the namespace with stuff the way some other headers do.)  */
+#if !defined __GNU_LIBRARY__
+# include <ctype.h>
+#endif
+
+#ifndef __THROW
+# ifndef __GNUC_PREREQ
+#  define __GNUC_PREREQ(maj, min) (0)
+# endif
+# if defined __cplusplus && __GNUC_PREREQ (2,8)
+#  define __THROW	throw ()
+# else
+#  define __THROW
+# endif
+#endif
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* For communication from `getopt' to the caller.
+   When `getopt' finds an option that takes an argument,
+   the argument value is returned here.
+   Also, when `ordering' is RETURN_IN_ORDER,
+   each non-option ARGV-element is returned here.  */
+
+extern char *optarg;
+
+/* Index in ARGV of the next element to be scanned.
+   This is used for communication to and from the caller
+   and for communication between successive calls to `getopt'.
+
+   On entry to `getopt', zero means this is the first call; initialize.
+
+   When `getopt' returns -1, this is the index of the first of the
+   non-option elements that the caller should itself scan.
+
+   Otherwise, `optind' communicates from one call to the next
+   how much of ARGV has been scanned so far.  */
+
+extern int optind;
+
+/* Callers store zero here to inhibit the error message `getopt' prints
+   for unrecognized options.  */
+
+extern int opterr;
+
+/* Set to an option character which was unrecognized.  */
+
+extern int optopt;
+
+#ifndef __need_getopt
+/* Describe the long-named options requested by the application.
+   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
+   of `struct option' terminated by an element containing a name which is
+   zero.
+
+   The field `has_arg' is:
+   no_argument		(or 0) if the option does not take an argument,
+   required_argument	(or 1) if the option requires an argument,
+   optional_argument 	(or 2) if the option takes an optional argument.
+
+   If the field `flag' is not NULL, it points to a variable that is set
+   to the value given in the field `val' when the option is found, but
+   left unchanged if the option is not found.
+
+   To have a long-named option do something other than set an `int' to
+   a compiled-in constant, such as set a value from `optarg', set the
+   option's `flag' field to zero and its `val' field to a nonzero
+   value (the equivalent single-letter option character, if there is
+   one).  For long options that have a zero `flag' field, `getopt'
+   returns the contents of the `val' field.  */
+
+struct option
+{
+  const char *name;
+  /* has_arg can't be an enum because some compilers complain about
+     type mismatches in all the code that assumes it is an int.  */
+  int has_arg;
+  int *flag;
+  int val;
+};
+
+/* Names for the values of the `has_arg' field of `struct option'.  */
+
+# define no_argument		0
+# define required_argument	1
+# define optional_argument	2
+#endif	/* need getopt */
+
+
+/* Get definitions and prototypes for functions to process the
+   arguments in ARGV (ARGC of them, minus the program name) for
+   options given in OPTS.
+
+   Return the option character from OPTS just read.  Return -1 when
+   there are no more options.  For unrecognized options, or options
+   missing arguments, `optopt' is set to the option letter, and '?' is
+   returned.
+
+   The OPTS string is a list of characters which are recognized option
+   letters, optionally followed by colons, specifying that that letter
+   takes an argument, to be placed in `optarg'.
+
+   If a letter in OPTS is followed by two colons, its argument is
+   optional.  This behavior is specific to the GNU `getopt'.
+
+   The argument `--' causes premature termination of argument
+   scanning, explicitly telling `getopt' that there are no more
+   options.
+
+   If OPTS begins with `--', then non-option arguments are treated as
+   arguments to the option '\0'.  This behavior is specific to the GNU
+   `getopt'.  */
+
+#ifdef __GNU_LIBRARY__
+/* Many other libraries have conflicting prototypes for getopt, with
+   differences in the consts, in stdlib.h.  To avoid compilation
+   errors, only prototype getopt for the GNU C library.  */
+extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
+       __THROW;
+
+# if defined __need_getopt && defined __USE_POSIX2 \
+  && !defined __USE_POSIX_IMPLICITLY && !defined __USE_GNU
+/* The GNU getopt has more functionality than the standard version.  The
+   additional functionality can be disable at runtime.  This redirection
+   helps to also do this at runtime.  */
+#  ifdef __REDIRECT
+  extern int __REDIRECT_NTH (getopt, (int ___argc, char *const *___argv,
+				      const char *__shortopts),
+			     __posix_getopt);
+#  else
+extern int __posix_getopt (int ___argc, char *const *___argv,
+			   const char *__shortopts) __THROW;
+#   define getopt __posix_getopt
+#  endif
+# endif
+#else /* not __GNU_LIBRARY__ */
+extern int getopt ();
+#endif /* __GNU_LIBRARY__ */
+
+#ifndef __need_getopt
+extern int getopt_long (int ___argc, char *const *___argv,
+			const char *__shortopts,
+		        const struct option *__longopts, int *__longind)
+       __THROW;
+extern int getopt_long_only (int ___argc, char *const *___argv,
+			     const char *__shortopts,
+		             const struct option *__longopts, int *__longind)
+       __THROW;
+
+#endif
+
+#ifdef	__cplusplus
+}
+#endif
+
+/* Make sure we later can get all the definitions and declarations.  */
+#undef __need_getopt
+
+#endif /* getopt.h */
diff --git a/include/glob.h b/include/glob.h
new file mode 100644
index 0000000..9c5f37f
--- /dev/null
+++ b/include/glob.h
@@ -0,0 +1,181 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_GLOB_H
+#define	_GLOB_H	1
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+
+/* We need `size_t' for the following definitions.  */
+#ifndef __size_t
+typedef __SIZE_TYPE__ __size_t;
+# if defined __USE_XOPEN || __USE_XOPEN2K8
+typedef __SIZE_TYPE__ size_t;
+# endif
+#else
+/* The GNU CC stddef.h version defines __size_t as empty.  We need a real
+   definition.  */
+# undef __size_t
+# define __size_t size_t
+#endif
+
+/* Bits set in the FLAGS argument to `glob'.  */
+#define	GLOB_ERR	(1 << 0)/* Return on read errors.  */
+#define	GLOB_MARK	(1 << 1)/* Append a slash to each name.  */
+#define	GLOB_NOSORT	(1 << 2)/* Don't sort the names.  */
+#define	GLOB_DOOFFS	(1 << 3)/* Insert PGLOB->gl_offs NULLs.  */
+#define	GLOB_NOCHECK	(1 << 4)/* If nothing matches, return the pattern.  */
+#define	GLOB_APPEND	(1 << 5)/* Append to results of a previous call.  */
+#define	GLOB_NOESCAPE	(1 << 6)/* Backslashes don't quote metacharacters.  */
+#define	GLOB_PERIOD	(1 << 7)/* Leading `.' can be matched by metachars.  */
+
+#if !defined __USE_POSIX2 || defined __USE_BSD || defined __USE_GNU
+# define GLOB_MAGCHAR	 (1 << 8)/* Set in gl_flags if any metachars seen.  */
+# define GLOB_ALTDIRFUNC (1 << 9)/* Use gl_opendir et al functions.  */
+# define GLOB_BRACE	 (1 << 10)/* Expand "{a,b}" to "a" "b".  */
+# define GLOB_NOMAGIC	 (1 << 11)/* If no magic chars, return the pattern.  */
+# define GLOB_TILDE	 (1 << 12)/* Expand ~user and ~ to home directories. */
+# define GLOB_ONLYDIR	 (1 << 13)/* Match only directories.  */
+# define GLOB_TILDE_CHECK (1 << 14)/* Like GLOB_TILDE but return an error
+				      if the user name is not available.  */
+# define __GLOB_FLAGS	(GLOB_ERR|GLOB_MARK|GLOB_NOSORT|GLOB_DOOFFS| \
+			 GLOB_NOESCAPE|GLOB_NOCHECK|GLOB_APPEND|     \
+			 GLOB_PERIOD|GLOB_ALTDIRFUNC|GLOB_BRACE|     \
+			 GLOB_NOMAGIC|GLOB_TILDE|GLOB_ONLYDIR|GLOB_TILDE_CHECK)
+#else
+# define __GLOB_FLAGS	(GLOB_ERR|GLOB_MARK|GLOB_NOSORT|GLOB_DOOFFS| \
+			 GLOB_NOESCAPE|GLOB_NOCHECK|GLOB_APPEND|     \
+			 GLOB_PERIOD)
+#endif
+
+/* Error returns from `glob'.  */
+#define	GLOB_NOSPACE	1	/* Ran out of memory.  */
+#define	GLOB_ABORTED	2	/* Read error.  */
+#define	GLOB_NOMATCH	3	/* No matches found.  */
+#define GLOB_NOSYS	4	/* Not implemented.  */
+#ifdef __USE_GNU
+/* Previous versions of this file defined GLOB_ABEND instead of
+   GLOB_ABORTED.  Provide a compatibility definition here.  */
+# define GLOB_ABEND GLOB_ABORTED
+#endif
+
+/* Structure describing a globbing run.  */
+#ifdef __USE_GNU
+struct stat;
+#endif
+typedef struct
+  {
+    __size_t gl_pathc;		/* Count of paths matched by the pattern.  */
+    char **gl_pathv;		/* List of matched pathnames.  */
+    __size_t gl_offs;		/* Slots to reserve in `gl_pathv'.  */
+    int gl_flags;		/* Set to FLAGS, maybe | GLOB_MAGCHAR.  */
+
+    /* If the GLOB_ALTDIRFUNC flag is set, the following functions
+       are used instead of the normal file access functions.  */
+    void (*gl_closedir) (void *);
+#ifdef __USE_GNU
+    struct dirent *(*gl_readdir) (void *);
+#else
+    void *(*gl_readdir) (void *);
+#endif
+    void *(*gl_opendir) (const char *);
+#ifdef __USE_GNU
+    int (*gl_lstat) (const char *__restrict, struct stat *__restrict);
+    int (*gl_stat) (const char *__restrict, struct stat *__restrict);
+#else
+    int (*gl_lstat) (const char *__restrict, void *__restrict);
+    int (*gl_stat) (const char *__restrict, void *__restrict);
+#endif
+  } glob_t;
+
+#ifdef __USE_LARGEFILE64
+# ifdef __USE_GNU
+struct stat64;
+# endif
+typedef struct
+  {
+    __size_t gl_pathc;
+    char **gl_pathv;
+    __size_t gl_offs;
+    int gl_flags;
+
+    /* If the GLOB_ALTDIRFUNC flag is set, the following functions
+       are used instead of the normal file access functions.  */
+    void (*gl_closedir) (void *);
+# ifdef __USE_GNU
+    struct dirent64 *(*gl_readdir) (void *);
+# else
+    void *(*gl_readdir) (void *);
+# endif
+    void *(*gl_opendir) (const char *);
+# ifdef __USE_GNU
+    int (*gl_lstat) (const char *__restrict, struct stat64 *__restrict);
+    int (*gl_stat) (const char *__restrict, struct stat64 *__restrict);
+# else
+    int (*gl_lstat) (const char *__restrict, void *__restrict);
+    int (*gl_stat) (const char *__restrict, void *__restrict);
+# endif
+  } glob64_t;
+#endif
+
+/* Do glob searching for PATTERN, placing results in PGLOB.
+   The bits defined above may be set in FLAGS.
+   If a directory cannot be opened or read and ERRFUNC is not nil,
+   it is called with the pathname that caused the error, and the
+   `errno' value from the failing call; if it returns non-zero
+   `glob' returns GLOB_ABEND; if it returns zero, the error is ignored.
+   If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
+   Otherwise, `glob' returns zero.  */
+#if !defined __USE_FILE_OFFSET64
+extern int glob (const char *__restrict __pattern, int __flags,
+		 int (*__errfunc) (const char *, int),
+		 glob_t *__restrict __pglob) __THROW;
+
+/* Free storage allocated in PGLOB by a previous `glob' call.  */
+extern void globfree (glob_t *__pglob) __THROW;
+#else
+extern int __REDIRECT_NTH (glob, (const char *__restrict __pattern,
+				  int __flags,
+				  int (*__errfunc) (const char *, int),
+				  glob_t *__restrict __pglob), glob64);
+
+extern void __REDIRECT_NTH (globfree, (glob_t *__pglob), globfree64);
+#endif
+
+#ifdef __USE_LARGEFILE64
+extern int glob64 (const char *__restrict __pattern, int __flags,
+		   int (*__errfunc) (const char *, int),
+		   glob64_t *__restrict __pglob) __THROW;
+
+extern void globfree64 (glob64_t *__pglob) __THROW;
+#endif
+
+
+#ifdef __USE_GNU
+/* Return nonzero if PATTERN contains any metacharacters.
+   Metacharacters can be quoted with backslashes if QUOTE is nonzero.
+
+   This function is not part of the interface specified by POSIX.2
+   but several programs want to use it.  */
+extern int glob_pattern_p (const char *__pattern, int __quote) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* glob.h  */
diff --git a/include/gnu-versions.h b/include/gnu-versions.h
new file mode 100644
index 0000000..6ffbd47
--- /dev/null
+++ b/include/gnu-versions.h
@@ -0,0 +1,52 @@
+/* Header with interface version macros for library pieces copied elsewhere.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _GNU_VERSIONS_H
+#define	_GNU_VERSIONS_H	1
+
+/* This file exists to define these few macros.  Each specifies a version
+   number associated with the library interface of a piece of the C library
+   which is also distributed with other GNU packages.  These pieces are
+   both part of the GNU C library and also distributed with other GNU
+   packages so those packages may use their facilities on systems lacking
+   the GNU C library.  The source files for each piece surround all their
+   code with `#ifndef ELIDE_CODE' after defining it with this:
+
+   #define OBSTACK_INTERFACE_VERSION 1
+   #if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
+   #include <gnu-versions.h>
+   #if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
+   #define ELIDE_CODE
+   #endif
+   #endif
+
+   This allows those one to avoid compiling those files when part of a GNU
+   package not libc, on a system using a GNU C library that supports the
+   same interface.
+
+   Please preserve the format of the comments after each macro.  And
+   remember, if any of these versions change, the libc.so major version
+   number must change too (so avoid it)!  */
+
+#define _GNU_OBSTACK_INTERFACE_VERSION	1 /* vs malloc/obstack.c */
+#define _GNU_REGEX_INTERFACE_VERSION	1 /* vs posix/regex.c */
+#define _GNU_GLOB_INTERFACE_VERSION	1 /* vs posix/glob.c */
+#define _GNU_GETOPT_INTERFACE_VERSION	2 /* vs posix/getopt.c and
+					     posix/getopt1.c */
+
+#endif	/* gnu-versions.h */
diff --git a/include/gnu/lib-names.h b/include/gnu/lib-names.h
new file mode 100644
index 0000000..b92830f
--- /dev/null
+++ b/include/gnu/lib-names.h
@@ -0,0 +1,35 @@
+/* This file is automatically generated.
+   It defines macros to allow user program to find the shared
+   library files which come as part of GNU libc.  */
+#ifndef __GNU_LIB_NAMES_H
+#define __GNU_LIB_NAMES_H	1
+
+#include <bits/wordsize.h>
+
+#define LD_SO                           "ld.so.1"
+#define LIBANL_SO                       "libanl.so.1"
+#define LIBBROKENLOCALE_SO              "libBrokenLocale.so.1"
+#define LIBCIDN_SO                      "libcidn.so.1"
+#define LIBCRYPT_SO                     "libcrypt.so.1"
+#define LIBC_SO                         "libc.so.0.3"
+#define LIBDL_SO                        "libdl.so.2"
+#define LIBGCC_S_SO                     "libgcc_s.so.1"
+#define LIBHURDUSER_SO                  "libhurduser.so.0.3"
+#define LIBMACHUSER_SO                  "libmachuser.so.1"
+#define LIBM_SO                         "libm.so.6"
+#define LIBNSL_SO                       "libnsl.so.1"
+#define LIBNSS_COMPAT_SO                "libnss_compat.so.2"
+#define LIBNSS_DB_SO                    "libnss_db.so.2"
+#define LIBNSS_DNS_SO                   "libnss_dns.so.2"
+#define LIBNSS_FILES_SO                 "libnss_files.so.2"
+#define LIBNSS_HESIOD_SO                "libnss_hesiod.so.2"
+#define LIBNSS_LDAP_SO                  "libnss_ldap.so.2"
+#define LIBNSS_NISPLUS_SO               "libnss_nisplus.so.2"
+#define LIBNSS_NIS_SO                   "libnss_nis.so.2"
+#define LIBNSS_TEST1_SO                 "libnss_test1.so.2"
+#define LIBPTHREAD_SO                   "libpthread.so.0.3"
+#define LIBRESOLV_SO                    "libresolv.so.2"
+#define LIBRT_SO                        "librt.so.1"
+#define LIBUTIL_SO                      "libutil.so.1"
+
+#endif	/* gnu/lib-names.h */
diff --git a/include/gnu/libc-version.h b/include/gnu/libc-version.h
new file mode 100644
index 0000000..b2d32e1
--- /dev/null
+++ b/include/gnu/libc-version.h
@@ -0,0 +1,34 @@
+/* Interface to GNU libc specific functions for version information.
+   Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _GNU_LIBC_VERSION_H
+#define	_GNU_LIBC_VERSION_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Return string describing release status of currently running GNU libc.  */
+extern const char *gnu_get_libc_release (void) __THROW;
+
+/* Return string describing version of currently running GNU libc.  */
+extern const char *gnu_get_libc_version (void) __THROW;
+
+__END_DECLS
+
+#endif	/* gnu/libc-version.h */
diff --git a/include/gnu/stubs.h b/include/gnu/stubs.h
new file mode 100644
index 0000000..e69de29
diff --git a/include/grp.h b/include/grp.h
new file mode 100644
index 0000000..13b00ec
--- /dev/null
+++ b/include/grp.h
@@ -0,0 +1,207 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 9.2.1 Group Database Access	<grp.h>
+ */
+
+#ifndef	_GRP_H
+#define	_GRP_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+
+/* For the Single Unix specification we must define this type here.  */
+#if (defined __USE_XOPEN || defined __USE_XOPEN2K) && !defined __gid_t_defined
+typedef __gid_t gid_t;
+# define __gid_t_defined
+#endif
+
+/* The group structure.	 */
+struct group
+  {
+    char *gr_name;		/* Group name.	*/
+    char *gr_passwd;		/* Password.	*/
+    __gid_t gr_gid;		/* Group ID.	*/
+    char **gr_mem;		/* Member list.	*/
+  };
+
+
+#if defined __USE_SVID || defined __USE_GNU
+# define __need_FILE
+# include <stdio.h>
+#endif
+
+
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Rewind the group-file stream.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void setgrent (void);
+#endif
+
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED \
+    || defined __USE_XOPEN2K8
+/* Close the group-file stream.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void endgrent (void);
+
+/* Read an entry from the group-file stream, opening it if necessary.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct group *getgrent (void);
+#endif
+
+#ifdef	__USE_SVID
+/* Read a group entry from STREAM.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct group *fgetgrent (FILE *__stream);
+#endif
+
+#ifdef __USE_GNU
+/* Write the given entry onto the given stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int putgrent (const struct group *__restrict __p,
+		     FILE *__restrict __f);
+#endif
+
+/* Search for an entry with a matching group ID.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct group *getgrgid (__gid_t __gid);
+
+/* Search for an entry with a matching group name.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct group *getgrnam (const char *__name);
+
+#if defined __USE_POSIX || defined __USE_MISC
+
+# ifdef __USE_MISC
+/* Reasonable value for the buffer sized used in the reentrant
+   functions below.  But better use `sysconf'.  */
+#  define NSS_BUFLEN_GROUP	1024
+# endif
+
+/* Reentrant versions of some of the functions above.
+
+   PLEASE NOTE: the `getgrent_r' function is not (yet) standardized.
+   The interface may change in later versions of this library.  But
+   the interface is designed following the principals used for the
+   other reentrant functions so the chances are good this is what the
+   POSIX people would choose.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+
+# ifdef __USE_GNU
+extern int getgrent_r (struct group *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct group **__restrict __result);
+# endif
+
+/* Search for an entry with a matching group ID.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int getgrgid_r (__gid_t __gid, struct group *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct group **__restrict __result);
+
+/* Search for an entry with a matching group name.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int getgrnam_r (const char *__restrict __name,
+		       struct group *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct group **__restrict __result);
+
+# ifdef	__USE_SVID
+/* Read a group entry from STREAM.  This function is not standardized
+   an probably never will.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fgetgrent_r (FILE *__restrict __stream,
+			struct group *__restrict __resultbuf,
+			char *__restrict __buffer, size_t __buflen,
+			struct group **__restrict __result);
+# endif
+
+#endif	/* POSIX or reentrant */
+
+
+#ifdef	__USE_BSD
+
+# define __need_size_t
+# include <stddef.h>
+
+/* Set the group set for the current user to GROUPS (N of them).  */
+extern int setgroups (size_t __n, const __gid_t *__groups) __THROW;
+
+/* Store at most *NGROUPS members of the group set for USER into
+   *GROUPS.  Also include GROUP.  The actual number of groups found is
+   returned in *NGROUPS.  Return -1 if the if *NGROUPS is too small.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int getgrouplist (const char *__user, __gid_t __group,
+			 __gid_t *__groups, int *__ngroups);
+
+/* Initialize the group set for the current user
+   by reading the group database and using all groups
+   of which USER is a member.  Also include GROUP.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int initgroups (const char *__user, __gid_t __group);
+
+#endif /* Use BSD.  */
+
+__END_DECLS
+
+#endif /* grp.h  */
diff --git a/include/gshadow.h b/include/gshadow.h
new file mode 100644
index 0000000..fc21c42
--- /dev/null
+++ b/include/gshadow.h
@@ -0,0 +1,130 @@
+/* Copyright (C) 2009-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Declaration of types and functions for shadow group suite.  */
+
+#ifndef _GSHADOW_H
+#define _GSHADOW_H	1
+
+#include <features.h>
+
+#include <paths.h>
+
+#define	__need_FILE
+#include <stdio.h>
+#define __need_size_t
+#include <stddef.h>
+
+/* Path to the user database files.  */
+#define	GSHADOW _PATH_GSHADOW
+
+
+__BEGIN_DECLS
+
+/* Structure of the group file.  */
+struct sgrp
+  {
+    char *sg_namp;		/* Group name.  */
+    char *sg_passwd;		/* Encrypted password.  */
+    char **sg_adm;		/* Group administrator list.  */
+    char **sg_mem;		/* Group member list.  */
+  };
+
+
+/* Open database for reading.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern void setsgent (void);
+
+/* Close database.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern void endsgent (void);
+
+/* Get next entry from database, perhaps after opening the file.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct sgrp *getsgent (void);
+
+/* Get shadow entry matching NAME.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct sgrp *getsgnam (const char *__name);
+
+/* Read shadow entry from STRING.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct sgrp *sgetsgent (const char *__string);
+
+/* Read next shadow entry from STREAM.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct sgrp *fgetsgent (FILE *__stream);
+
+/* Write line containing shadow password entry to stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int putsgent (const struct sgrp *__g, FILE *__stream);
+
+
+#ifdef __USE_MISC
+/* Reentrant versions of some of the functions above.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern int getsgent_r (struct sgrp *__result_buf, char *__buffer,
+		       size_t __buflen, struct sgrp **__result);
+
+extern int getsgnam_r (const char *__name, struct sgrp *__result_buf,
+		       char *__buffer, size_t __buflen,
+		       struct sgrp **__result);
+
+extern int sgetsgent_r (const char *__string, struct sgrp *__result_buf,
+			char *__buffer, size_t __buflen,
+			struct sgrp **__result);
+
+extern int fgetsgent_r (FILE *__stream, struct sgrp *__result_buf,
+			char *__buffer, size_t __buflen,
+			struct sgrp **__result);
+#endif	/* misc */
+
+__END_DECLS
+
+#endif /* gshadow.h */
diff --git a/include/hurd.h b/include/hurd.h
new file mode 100644
index 0000000..b9799ac
--- /dev/null
+++ b/include/hurd.h
@@ -0,0 +1,350 @@
+/* Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_HURD_H
+
+#define	_HURD_H	1
+#include <features.h>
+
+
+/* Get types, macros, constants and function declarations
+   for all Mach microkernel interaction.  */
+#include <mach.h>
+#include <mach/mig_errors.h>
+
+/* Get types and constants necessary for Hurd interfaces.  */
+#include <hurd/hurd_types.h>
+
+/* Get MiG stub declarations for commonly used Hurd interfaces.  */
+#include <hurd/auth.h>
+#include <hurd/process.h>
+#include <hurd/fs.h>
+#include <hurd/io.h>
+
+/* Get `struct hurd_port' and related definitions implementing lightweight
+   user references for ports.  These are used pervasively throughout the C
+   library; this is here to avoid putting it in nearly every source file.  */
+#include <hurd/port.h>
+
+#include <errno.h>
+
+#ifndef _HURD_H_EXTERN_INLINE
+#define _HURD_H_EXTERN_INLINE __extern_inline
+#endif
+
+int __hurd_fail (error_t err);
+
+#ifdef __USE_EXTERN_INLINES
+_HURD_H_EXTERN_INLINE int
+__hurd_fail (error_t err)
+{
+  switch (err)
+    {
+    case EMACH_SEND_INVALID_DEST:
+    case EMIG_SERVER_DIED:
+      /* The server has disappeared!  */
+      err = EIEIO;
+      break;
+
+    case KERN_NO_SPACE:
+      err = ENOMEM;
+      break;
+
+    case KERN_INVALID_ARGUMENT:
+      err = EINVAL;
+      break;
+
+    case 0:
+      return 0;
+
+    default:
+      break;
+    }
+
+  errno = err;
+  return -1;
+}
+#endif
+
+/* Basic ports and info, initialized by startup.  */
+
+extern int _hurd_exec_flags;	/* Flags word passed in exec_startup.  */
+extern struct hurd_port *_hurd_ports;
+extern unsigned int _hurd_nports;
+extern mode_t _hurd_umask;
+extern sigset_t _hurdsig_traced;
+
+/* Shorthand macro for internal library code referencing _hurd_ports (see
+   <hurd/port.h>).  */
+
+#define	__USEPORT(which, expr) \
+  HURD_PORT_USE (&_hurd_ports[INIT_PORT_##which], (expr))
+
+/* Function version of __USEPORT: calls OPERATE with a send right.  */
+
+extern error_t _hurd_ports_use (int which, error_t (*operate) (mach_port_t));
+
+
+/* Base address and size of the initial stack set up by the exec server.
+   If using cthreads, this stack is deallocated in startup.
+   Not locked.  */
+
+extern vm_address_t _hurd_stack_base;
+extern vm_size_t _hurd_stack_size;
+
+/* Initial file descriptor table we were passed at startup.  If we are
+   using a real dtable, these are turned into that and then cleared at
+   startup.  If not, these are never changed after startup.  Not locked.  */
+
+extern mach_port_t *_hurd_init_dtable;
+extern mach_msg_type_number_t _hurd_init_dtablesize;
+
+/* Current process IDs.  */
+
+extern pid_t _hurd_pid, _hurd_ppid, _hurd_pgrp;
+extern int _hurd_orphaned;
+
+/* This variable is incremented every time the process IDs change.  */
+extern unsigned int _hurd_pids_changed_stamp;
+
+/* This condition is broadcast every time the process IDs change.  */
+extern struct condition _hurd_pids_changed_sync;
+
+/* Unix `data break', for brk and sbrk.
+   If brk and sbrk are not used, this info will not be initialized or used.  */
+
+
+/* Data break.  This is what `sbrk (0)' returns.  */
+
+extern vm_address_t _hurd_brk;
+
+/* End of allocated space.  This is generally `round_page (_hurd_brk)'.  */
+
+extern vm_address_t _hurd_data_end;
+
+/* This mutex locks _hurd_brk and _hurd_data_end.  */
+
+extern struct mutex _hurd_brk_lock;
+
+/* Set the data break to NEWBRK; _hurd_brk_lock must
+   be held, and is released on return.  */
+
+extern int _hurd_set_brk (vm_address_t newbrk);
+
+#define __need_FILE
+#include <stdio.h>
+
+/* Calls to get and set basic ports.  */
+
+extern error_t _hurd_ports_get (unsigned int which, mach_port_t *result);
+extern error_t _hurd_ports_set (unsigned int which, mach_port_t newport);
+
+extern process_t getproc (void);
+extern file_t getcwdir (void), getcrdir (void);
+extern auth_t getauth (void);
+extern mach_port_t getcttyid (void);
+extern int setproc (process_t);
+extern int setcwdir (file_t), setcrdir (file_t);
+extern int setcttyid (mach_port_t);
+
+/* Does reauth with the proc server and fd io servers.  */
+extern int __setauth (auth_t), setauth (auth_t);
+
+
+/* Modify a port cell by looking up a directory name.
+   This verifies that it is a directory and that we have search permission.  */
+extern int _hurd_change_directory_port_from_name (struct hurd_port *portcell,
+						  const char *name);
+/* Same thing, but using an open file descriptor.
+   Also verifies that it is a directory and that we have search permission.  */
+extern int _hurd_change_directory_port_from_fd (struct hurd_port *portcell,
+						int fd);
+
+
+
+/* Get and set the effective UID set.  */
+extern int geteuids (int __n, uid_t *__uidset);
+extern int seteuids (int __n, const uid_t *__uidset);
+
+
+/* Split FILE into a directory and a name within the directory.  The
+   directory lookup uses the current root and working directory.  If
+   successful, stores in *NAME a pointer into FILE where the name
+   within directory begins and returns a port to the directory;
+   otherwise sets `errno' and returns MACH_PORT_NULL.  */
+
+extern file_t __file_name_split (const char *file, char **name);
+extern file_t file_name_split (const char *file, char **name);
+
+/* Split DIRECTORY into a parent directory and a name within the directory.
+   This is the same as file_name_split, but ignores trailing slashes.  */
+
+extern file_t __directory_name_split (const char *file, char **name);
+extern file_t directory_name_split (const char *file, char **name);
+
+/* Open a port to FILE with the given FLAGS and MODE (see <fcntl.h>).
+   The file lookup uses the current root and working directory.
+   Returns a port to the file if successful; otherwise sets `errno'
+   and returns MACH_PORT_NULL.  */
+
+extern file_t __file_name_lookup (const char *file, int flags, mode_t mode);
+extern file_t file_name_lookup (const char *file, int flags, mode_t mode);
+
+/* Open a port to FILE with the given FLAGS and MODE (see <fcntl.h>).  The
+   file lookup uses the current root directory, but uses STARTDIR as the
+   "working directory" for file relative names.  Returns a port to the file
+   if successful; otherwise sets `errno' and returns MACH_PORT_NULL.  */
+
+extern file_t __file_name_lookup_under (file_t startdir, const char *file,
+					int flags, mode_t mode);
+extern file_t file_name_lookup_under (file_t startdir, const char *file,
+				      int flags, mode_t mode);
+
+
+/* Lookup FILE_NAME and return the node opened with FLAGS & MODE
+   (see hurd_file_name_lookup for details), but a simple file name (without
+   any directory prefixes) will be consecutively prefixed with the pathnames
+   in the `:' separated list PATH until one succeeds in a successful lookup.
+   If none succeed, then the first error that wasn't ENOENT is returned, or
+   ENOENT if no other errors were returned.  If PREFIXED_NAME is non-NULL,
+   then if the result is looked up directly, *PREFIXED_NAME is set to NULL, and
+   if it is looked up using a prefix from PATH, *PREFIXED_NAME is set to
+   malloc'd storage containing the prefixed name.  */
+extern file_t file_name_path_lookup (const char *file_name, const char *path,
+				     int flags, mode_t mode,
+				     char **prefixed_name);
+
+
+
+/* Open a file descriptor on a port.  FLAGS are as for `open'; flags
+   affected by io_set_openmodes are not changed by this.  If successful,
+   this consumes a user reference for PORT (which will be deallocated on
+   close).  */
+
+extern int openport (io_t port, int flags);
+
+/* Open a stream on a port.  MODE is as for `fopen'.
+   If successful, this consumes a user reference for PORT
+   (which will be deallocated on fclose).  */
+
+extern FILE *fopenport (io_t port, const char *mode);
+extern FILE *__fopenport (io_t port, const char *mode);
+
+
+/* Execute a file, replacing TASK's current program image.  */
+
+extern error_t _hurd_exec (task_t task,
+			   file_t file,
+			   char *const argv[],
+			   char *const envp[]);
+
+
+/* Inform the proc server we have exited with STATUS, and kill the
+   task thoroughly.  This function never returns, no matter what.  */
+
+extern void _hurd_exit (int status) __attribute__ ((noreturn));
+
+
+/* Initialize the library data structures from the
+   ints and ports passed to us by the exec server.
+   Then vm_deallocate PORTARRAY and INTARRAY.  */
+
+extern void _hurd_init (int flags, char **argv,
+			mach_port_t *portarray, size_t portarraysize,
+			int *intarray, size_t intarraysize);
+
+/* Do startup handshaking with the proc server, and initialize library data
+   structures that require proc server interaction.  This includes
+   initializing signals; see _hurdsig_init in <hurd/signal.h>.  */
+
+extern void _hurd_proc_init (char **argv,
+			     const int *intarray, size_t intarraysize);
+
+
+/* Return the socket server for sockaddr domain DOMAIN.  If DEAD is
+   nonzero, remove the old cached port and always do a fresh lookup.
+
+   It is assumed that a socket server will stay alive during a complex socket
+   operation involving several RPCs.  But a socket server may die during
+   long idle periods between socket operations.  Callers should first pass
+   zero for DEAD; if the first socket RPC tried on the returned port fails
+   with MACH_SEND_INVALID_DEST or MIG_SERVER_DIED (indicating the server
+   went away), the caller should call _hurd_socket_server again with DEAD
+   nonzero and retry the RPC on the new socket server port.  */
+
+extern socket_t _hurd_socket_server (int domain, int dead);
+
+/* Send a `sig_post' RPC to process number PID.  If PID is zero,
+   send the message to all processes in the current process's process group.
+   If PID is < -1, send SIG to all processes in process group - PID.
+   SIG and REFPORT are passed along in the request message.  */
+
+extern error_t _hurd_sig_post (pid_t pid, int sig, mach_port_t refport);
+extern error_t hurd_sig_post (pid_t pid, int sig, mach_port_t refport);
+
+/* Fetch the host privileged port and device master port from the proc
+   server.  They are fetched only once and then cached in the
+   variables below.  A special program that gets them from somewhere
+   other than the proc server (such as a bootstrap filesystem) can set
+   these variables to install the ports.  */
+
+extern kern_return_t __get_privileged_ports (mach_port_t *host_priv_ptr,
+					     device_t *device_master_ptr);
+extern kern_return_t get_privileged_ports (mach_port_t *host_priv_ptr,
+					   device_t *device_master_ptr);
+extern mach_port_t _hurd_host_priv, _hurd_device_master;
+
+/* Return the PID of the task whose control port is TASK.
+   On error, sets `errno' and returns -1.  */
+
+extern pid_t __task2pid (task_t task), task2pid (task_t task);
+
+/* Return the task control port of process PID.
+   On error, sets `errno' and returns MACH_PORT_NULL.  */
+
+extern task_t __pid2task (pid_t pid), pid2task (pid_t pid);
+
+/* Return the current thread's thread port.  This is a cheap operation (no
+   system call), but it relies on Hurd signal state being set up.  */
+extern thread_t hurd_thread_self (void);
+
+
+/* Cancel pending operations on THREAD.  If it is doing an interruptible RPC,
+   that RPC will now return EINTR; otherwise, the "cancelled" flag will be
+   set, causing the next `hurd_check_cancel' call to return nonzero or the
+   next interruptible RPC to return EINTR (whichever is called first).  */
+extern error_t hurd_thread_cancel (thread_t thread);
+
+/* Test and clear the calling thread's "cancelled" flag.  */
+extern int hurd_check_cancel (void);
+
+
+/* Return the io server port for file descriptor FD.
+   This adds a Mach user reference to the returned port.
+   On error, sets `errno' and returns MACH_PORT_NULL.  */
+
+extern io_t __getdport (int fd), getdport (int fd);
+
+
+#include <stdarg.h>
+
+/* Write formatted output to PORT, a Mach port supporting the i/o protocol,
+   according to the format string FORMAT, using the argument list in ARG.  */
+int vpprintf (io_t port, const char *format, va_list arg);
+
+
+#endif	/* hurd.h */
diff --git a/include/hurd/auth.h b/include/hurd/auth.h
new file mode 100644
index 0000000..200cd8d
--- /dev/null
+++ b/include/hurd/auth.h
@@ -0,0 +1,197 @@
+#ifndef	_auth_user_
+#define	_auth_user_
+
+/* Module auth */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine auth_getids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __auth_getids
+(
+	auth_t handle,
+	idarray_t *euids,
+	mach_msg_type_number_t *euidsCnt,
+	idarray_t *auids,
+	mach_msg_type_number_t *auidsCnt,
+	idarray_t *egids,
+	mach_msg_type_number_t *egidsCnt,
+	idarray_t *agids,
+	mach_msg_type_number_t *agidsCnt
+);
+
+/* Routine auth_makeauth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __auth_makeauth
+(
+	auth_t handle,
+	portarray_t other_handles,
+	mach_msg_type_name_t other_handlesPoly,
+	mach_msg_type_number_t other_handlesCnt,
+	idarray_t euids,
+	mach_msg_type_number_t euidsCnt,
+	idarray_t auids,
+	mach_msg_type_number_t auidsCnt,
+	idarray_t egids,
+	mach_msg_type_number_t egidsCnt,
+	idarray_t agids,
+	mach_msg_type_number_t agidsCnt,
+	mach_port_t *newhandle
+);
+
+/* Routine auth_user_authenticate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __auth_user_authenticate
+(
+	auth_t handle,
+	mach_port_t rendezvous,
+	mach_msg_type_name_t rendezvousPoly,
+	mach_port_t *newport
+);
+
+/* Routine auth_server_authenticate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __auth_server_authenticate
+(
+	auth_t handle,
+	mach_port_t rendezvous,
+	mach_msg_type_name_t rendezvousPoly,
+	mach_port_t newport,
+	mach_msg_type_name_t newportPoly,
+	idarray_t *euids,
+	mach_msg_type_number_t *euidsCnt,
+	idarray_t *auids,
+	mach_msg_type_number_t *auidsCnt,
+	idarray_t *egids,
+	mach_msg_type_number_t *egidsCnt,
+	idarray_t *agids,
+	mach_msg_type_number_t *agidsCnt
+);
+
+
+/* Module auth */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine auth_getids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t auth_getids
+(
+	auth_t handle,
+	idarray_t *euids,
+	mach_msg_type_number_t *euidsCnt,
+	idarray_t *auids,
+	mach_msg_type_number_t *auidsCnt,
+	idarray_t *egids,
+	mach_msg_type_number_t *egidsCnt,
+	idarray_t *agids,
+	mach_msg_type_number_t *agidsCnt
+);
+
+/* Routine auth_makeauth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t auth_makeauth
+(
+	auth_t handle,
+	portarray_t other_handles,
+	mach_msg_type_name_t other_handlesPoly,
+	mach_msg_type_number_t other_handlesCnt,
+	idarray_t euids,
+	mach_msg_type_number_t euidsCnt,
+	idarray_t auids,
+	mach_msg_type_number_t auidsCnt,
+	idarray_t egids,
+	mach_msg_type_number_t egidsCnt,
+	idarray_t agids,
+	mach_msg_type_number_t agidsCnt,
+	mach_port_t *newhandle
+);
+
+/* Routine auth_user_authenticate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t auth_user_authenticate
+(
+	auth_t handle,
+	mach_port_t rendezvous,
+	mach_msg_type_name_t rendezvousPoly,
+	mach_port_t *newport
+);
+
+/* Routine auth_server_authenticate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t auth_server_authenticate
+(
+	auth_t handle,
+	mach_port_t rendezvous,
+	mach_msg_type_name_t rendezvousPoly,
+	mach_port_t newport,
+	mach_msg_type_name_t newportPoly,
+	idarray_t *euids,
+	mach_msg_type_number_t *euidsCnt,
+	idarray_t *auids,
+	mach_msg_type_number_t *auidsCnt,
+	idarray_t *egids,
+	mach_msg_type_number_t *egidsCnt,
+	idarray_t *agids,
+	mach_msg_type_number_t *agidsCnt
+);
+
+#endif	/* not defined(_auth_user_) */
diff --git a/include/hurd/auth_reply.h b/include/hurd/auth_reply.h
new file mode 100644
index 0000000..6a82c4b
--- /dev/null
+++ b/include/hurd/auth_reply.h
@@ -0,0 +1,111 @@
+#ifndef	_auth_reply_user_
+#define	_auth_reply_user_
+
+/* Module auth_reply */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine auth_user_authenticate_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __auth_user_authenticate_reply
+(
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	kern_return_t return_code,
+	mach_port_t newhandle,
+	mach_msg_type_name_t newhandlePoly
+);
+
+/* SimpleRoutine auth_server_authenticate_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __auth_server_authenticate_reply
+(
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	kern_return_t return_code,
+	idarray_t gen_uids,
+	mach_msg_type_number_t gen_uidsCnt,
+	idarray_t aux_uids,
+	mach_msg_type_number_t aux_uidsCnt,
+	idarray_t gen_gids,
+	mach_msg_type_number_t gen_gidsCnt,
+	idarray_t aux_gids,
+	mach_msg_type_number_t aux_gidsCnt
+);
+
+
+/* Module auth_reply */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine auth_user_authenticate_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t auth_user_authenticate_reply
+(
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	kern_return_t return_code,
+	mach_port_t newhandle,
+	mach_msg_type_name_t newhandlePoly
+);
+
+/* SimpleRoutine auth_server_authenticate_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t auth_server_authenticate_reply
+(
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	kern_return_t return_code,
+	idarray_t gen_uids,
+	mach_msg_type_number_t gen_uidsCnt,
+	idarray_t aux_uids,
+	mach_msg_type_number_t aux_uidsCnt,
+	idarray_t gen_gids,
+	mach_msg_type_number_t gen_gidsCnt,
+	idarray_t aux_gids,
+	mach_msg_type_number_t aux_gidsCnt
+);
+
+#endif	/* not defined(_auth_reply_user_) */
diff --git a/include/hurd/auth_request.h b/include/hurd/auth_request.h
new file mode 100644
index 0000000..456a9e1
--- /dev/null
+++ b/include/hurd/auth_request.h
@@ -0,0 +1,103 @@
+#ifndef	_auth_reply_user_
+#define	_auth_reply_user_
+
+/* Module auth_reply */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine auth_user_authenticate_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __auth_user_authenticate_request
+(
+	auth_t handle,
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	mach_port_t rendezvous,
+	mach_msg_type_name_t rendezvousPoly
+);
+
+/* SimpleRoutine auth_server_authenticate_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __auth_server_authenticate_request
+(
+	auth_t handle,
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	mach_port_t rendezvous,
+	mach_msg_type_name_t rendezvousPoly,
+	mach_port_t newport,
+	mach_msg_type_name_t newportPoly
+);
+
+
+/* Module auth_reply */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine auth_user_authenticate_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t auth_user_authenticate_request
+(
+	auth_t handle,
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	mach_port_t rendezvous,
+	mach_msg_type_name_t rendezvousPoly
+);
+
+/* SimpleRoutine auth_server_authenticate_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t auth_server_authenticate_request
+(
+	auth_t handle,
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	mach_port_t rendezvous,
+	mach_msg_type_name_t rendezvousPoly,
+	mach_port_t newport,
+	mach_msg_type_name_t newportPoly
+);
+
+#endif	/* not defined(_auth_reply_user_) */
diff --git a/include/hurd/crash.h b/include/hurd/crash.h
new file mode 100644
index 0000000..00d602a
--- /dev/null
+++ b/include/hurd/crash.h
@@ -0,0 +1,81 @@
+#ifndef	_crash_user_
+#define	_crash_user_
+
+/* Module crash */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine crash_dump_task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __crash_dump_task
+(
+	mach_port_t crashserver,
+	mach_port_t task,
+	file_t file,
+	int signo,
+	integer_t sigcode,
+	int sigerror,
+	natural_t exc,
+	natural_t code,
+	natural_t subcode,
+	mach_port_t cttyid_port,
+	mach_msg_type_name_t cttyid_portPoly
+);
+
+
+/* Module crash */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine crash_dump_task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t crash_dump_task
+(
+	mach_port_t crashserver,
+	mach_port_t task,
+	file_t file,
+	int signo,
+	integer_t sigcode,
+	int sigerror,
+	natural_t exc,
+	natural_t code,
+	natural_t subcode,
+	mach_port_t cttyid_port,
+	mach_msg_type_name_t cttyid_portPoly
+);
+
+#endif	/* not defined(_crash_user_) */
diff --git a/include/hurd/exec.h b/include/hurd/exec.h
new file mode 100644
index 0000000..c0c1dd7
--- /dev/null
+++ b/include/hurd/exec.h
@@ -0,0 +1,161 @@
+#ifndef	_exec_user_
+#define	_exec_user_
+
+/* Module exec */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine exec_exec */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __exec_exec
+(
+	file_t execserver,
+	mach_port_t file,
+	mach_msg_type_name_t filePoly,
+	mach_port_t oldtask,
+	int flags,
+	data_t argv,
+	mach_msg_type_number_t argvCnt,
+	data_t envp,
+	mach_msg_type_number_t envpCnt,
+	portarray_t dtable,
+	mach_msg_type_name_t dtablePoly,
+	mach_msg_type_number_t dtableCnt,
+	portarray_t portarray,
+	mach_msg_type_name_t portarrayPoly,
+	mach_msg_type_number_t portarrayCnt,
+	intarray_t intarray,
+	mach_msg_type_number_t intarrayCnt,
+	mach_port_array_t deallocnames,
+	mach_msg_type_number_t deallocnamesCnt,
+	mach_port_array_t destroynames,
+	mach_msg_type_number_t destroynamesCnt
+);
+
+/* Routine exec_init */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __exec_init
+(
+	file_t execserver,
+	auth_t auth_handle,
+	mach_port_t proc_server,
+	mach_msg_type_name_t proc_serverPoly
+);
+
+/* SimpleRoutine exec_setexecdata */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __exec_setexecdata
+(
+	file_t execserver,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt,
+	intarray_t ints,
+	mach_msg_type_number_t intsCnt
+);
+
+
+/* Module exec */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine exec_exec */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t exec_exec
+(
+	file_t execserver,
+	mach_port_t file,
+	mach_msg_type_name_t filePoly,
+	mach_port_t oldtask,
+	int flags,
+	data_t argv,
+	mach_msg_type_number_t argvCnt,
+	data_t envp,
+	mach_msg_type_number_t envpCnt,
+	portarray_t dtable,
+	mach_msg_type_name_t dtablePoly,
+	mach_msg_type_number_t dtableCnt,
+	portarray_t portarray,
+	mach_msg_type_name_t portarrayPoly,
+	mach_msg_type_number_t portarrayCnt,
+	intarray_t intarray,
+	mach_msg_type_number_t intarrayCnt,
+	mach_port_array_t deallocnames,
+	mach_msg_type_number_t deallocnamesCnt,
+	mach_port_array_t destroynames,
+	mach_msg_type_number_t destroynamesCnt
+);
+
+/* Routine exec_init */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t exec_init
+(
+	file_t execserver,
+	auth_t auth_handle,
+	mach_port_t proc_server,
+	mach_msg_type_name_t proc_serverPoly
+);
+
+/* SimpleRoutine exec_setexecdata */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t exec_setexecdata
+(
+	file_t execserver,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt,
+	intarray_t ints,
+	mach_msg_type_number_t intsCnt
+);
+
+#endif	/* not defined(_exec_user_) */
diff --git a/include/hurd/exec_startup.h b/include/hurd/exec_startup.h
new file mode 100644
index 0000000..712bc8a
--- /dev/null
+++ b/include/hurd/exec_startup.h
@@ -0,0 +1,93 @@
+#ifndef	_exec_startup_user_
+#define	_exec_startup_user_
+
+/* Module exec_startup */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine exec_startup_get_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __exec_startup_get_info
+(
+	exec_startup_t bootstrap,
+	vm_address_t *user_entry,
+	vm_address_t *phdr_data,
+	vm_size_t *phdr_size,
+	vm_address_t *stack_base,
+	vm_size_t *stack_size,
+	int *flags,
+	data_t *argv,
+	mach_msg_type_number_t *argvCnt,
+	data_t *envp,
+	mach_msg_type_number_t *envpCnt,
+	portarray_t *dtable,
+	mach_msg_type_number_t *dtableCnt,
+	portarray_t *portarray,
+	mach_msg_type_number_t *portarrayCnt,
+	intarray_t *intarray,
+	mach_msg_type_number_t *intarrayCnt
+);
+
+
+/* Module exec_startup */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine exec_startup_get_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t exec_startup_get_info
+(
+	exec_startup_t bootstrap,
+	vm_address_t *user_entry,
+	vm_address_t *phdr_data,
+	vm_size_t *phdr_size,
+	vm_address_t *stack_base,
+	vm_size_t *stack_size,
+	int *flags,
+	data_t *argv,
+	mach_msg_type_number_t *argvCnt,
+	data_t *envp,
+	mach_msg_type_number_t *envpCnt,
+	portarray_t *dtable,
+	mach_msg_type_number_t *dtableCnt,
+	portarray_t *portarray,
+	mach_msg_type_number_t *portarrayCnt,
+	intarray_t *intarray,
+	mach_msg_type_number_t *intarrayCnt
+);
+
+#endif	/* not defined(_exec_startup_user_) */
diff --git a/include/hurd/fd.h b/include/hurd/fd.h
new file mode 100644
index 0000000..6d4b637
--- /dev/null
+++ b/include/hurd/fd.h
@@ -0,0 +1,295 @@
+/* File descriptors.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_HURD_FD_H
+
+#define	_HURD_FD_H	1
+#include <features.h>
+
+#include <cthreads.h>
+
+#include <hurd/hurd_types.h>
+#include <hurd/port.h>
+#include <sys/socket.h>
+
+
+/* Structure representing a file descriptor.  */
+
+struct hurd_fd
+  {
+    struct hurd_port port;	/* io server port.  */
+    int flags;			/* fcntl flags; locked by port.lock.  */
+
+    /* Normal port to the ctty.  When `port' is our ctty, this is a port to
+       the same io object but which never returns EBACKGROUND; when not,
+       this is nil.  */
+    struct hurd_port ctty;
+  };
+
+
+/* Current file descriptor table.  */
+
+extern int _hurd_dtablesize;
+extern struct hurd_fd **_hurd_dtable;
+extern struct mutex _hurd_dtable_lock; /* Locks those two variables.  */
+
+#include <hurd/signal.h>
+
+#ifndef _HURD_FD_H_EXTERN_INLINE
+#define _HURD_FD_H_EXTERN_INLINE __extern_inline
+#endif
+
+/* Returns the descriptor cell for FD.  If FD is invalid or unused, return
+   NULL.  The cell is unlocked; when ready to use it, lock it and check for
+   it being unused.  */
+
+struct hurd_fd *_hurd_fd_get (int fd);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_FD_H_EXTERN_INLINE struct hurd_fd *
+_hurd_fd_get (int fd)
+{
+  struct hurd_fd *descriptor;
+
+  HURD_CRITICAL_BEGIN;
+  __mutex_lock (&_hurd_dtable_lock);
+  if (fd < 0 || fd >= _hurd_dtablesize)
+    descriptor = NULL;
+  else
+    {
+      struct hurd_fd *cell = _hurd_dtable[fd];
+      if (cell == NULL)
+	/* No descriptor allocated at this index.  */
+	descriptor = NULL;
+      else
+	{
+	  __spin_lock (&cell->port.lock);
+	  if (cell->port.port == MACH_PORT_NULL)
+	    /* The descriptor at this index has no port in it.
+	       This happens if it existed before but was closed.  */
+	    descriptor = NULL;
+	  else
+	    descriptor = cell;
+	  __spin_unlock (&cell->port.lock);
+	}
+    }
+  __mutex_unlock (&_hurd_dtable_lock);
+  HURD_CRITICAL_END;
+
+  return descriptor;
+}
+#endif
+
+
+/* Evaluate EXPR with the variable `descriptor' bound to a pointer to the
+   file descriptor structure for FD.   */
+
+#define	HURD_FD_USE(fd, expr)						      \
+  ({ struct hurd_fd *descriptor = _hurd_fd_get (fd);			      \
+     descriptor == NULL ? EBADF : (expr); })
+
+/* Evaluate EXPR with the variable `port' bound to the port to FD, and
+   `ctty' bound to the ctty port.  */
+
+#define HURD_DPORT_USE(fd, expr) \
+  HURD_FD_USE ((fd), HURD_FD_PORT_USE (descriptor, (expr)))
+
+/* Likewise, but FD is a pointer to the file descriptor structure.  */
+
+#define	HURD_FD_PORT_USE(fd, expr)					      \
+  ({ error_t __result;							      \
+     struct hurd_fd *const __d = (fd);					      \
+     struct hurd_userlink __ulink, __ctty_ulink;			      \
+     io_t port, ctty;							      \
+     void *crit = _hurd_critical_section_lock ();			      \
+     __spin_lock (&__d->port.lock);					      \
+     if (__d->port.port == MACH_PORT_NULL)				      \
+       {								      \
+	 __spin_unlock (&__d->port.lock);				      \
+	 _hurd_critical_section_unlock (crit);				      \
+	 __result = EBADF;						      \
+       }								      \
+     else								      \
+       {								      \
+	 ctty = _hurd_port_get (&__d->ctty, &__ctty_ulink);		      \
+	 port = _hurd_port_locked_get (&__d->port, &__ulink);		      \
+	 _hurd_critical_section_unlock (crit);				      \
+	 __result = (expr);						      \
+	 _hurd_port_free (&__d->port, &__ulink, port);			      \
+	 if (ctty != MACH_PORT_NULL)					      \
+	   _hurd_port_free (&__d->ctty, &__ctty_ulink, ctty);		      \
+       }								      \
+     __result; })
+
+#include <errno.h>
+
+/* Check if ERR should generate a signal.
+   Returns the signal to take, or zero if none.  */
+
+int _hurd_fd_error_signal (error_t err);
+
+#ifdef __USE_EXTERN_INLINES
+_HURD_FD_H_EXTERN_INLINE int
+_hurd_fd_error_signal (error_t err)
+{
+  switch (err)
+    {
+    case EMACH_SEND_INVALID_DEST:
+    case EMIG_SERVER_DIED:
+      /* The server has disappeared!  */
+      return SIGLOST;
+    case EPIPE:
+      return SIGPIPE;
+    default:
+      /* Having a default case avoids -Wenum-switch warnings.  */
+      return 0;
+    }
+}
+#endif
+
+/* Handle an error from an RPC on a file descriptor's port.  You should
+   always use this function to handle errors from RPCs made on file
+   descriptor ports.  Some errors are translated into signals.  */
+
+error_t _hurd_fd_error (int fd, error_t err);
+
+#ifdef __USE_EXTERN_INLINES
+_HURD_FD_H_EXTERN_INLINE error_t
+_hurd_fd_error (int fd, error_t err)
+{
+  int signo = _hurd_fd_error_signal (err);
+  if (signo)
+    {
+      const struct hurd_signal_detail detail
+	= { code: fd, error: err, exc: 0 };
+      _hurd_raise_signal (NULL, signo, &detail);
+    }
+  return err;
+}
+#endif
+
+/* Handle error code ERR from an RPC on file descriptor FD's port.
+   Set `errno' to the appropriate error code, and always return -1.  */
+
+int __hurd_dfail (int fd, error_t err);
+
+#ifdef __USE_EXTERN_INLINES
+_HURD_FD_H_EXTERN_INLINE int
+__hurd_dfail (int fd, error_t err)
+{
+  errno = _hurd_fd_error (fd, err);
+  return -1;
+}
+#endif
+
+/* Likewise, but do not raise SIGPIPE on EPIPE if flags contain
+   MSG_NOSIGNAL.  */
+
+int __hurd_sockfail (int fd, int flags, error_t err);
+
+#ifdef __USE_EXTERN_INLINES
+_HURD_FD_H_EXTERN_INLINE int
+__hurd_sockfail (int fd, int flags, error_t err)
+{
+  if (!(flags & MSG_NOSIGNAL) || err != EPIPE)
+    err = _hurd_fd_error (fd, err);
+  errno = err;
+  return -1;
+}
+#endif
+
+/* Set up *FD to have PORT its server port, doing appropriate ctty magic.
+   Does no locking or unlocking.  */
+
+extern void _hurd_port2fd (struct hurd_fd *fd, io_t port, int flags);
+
+/* Allocate a new file descriptor and install PORT in it (doing any
+   appropriate ctty magic); consumes a user reference on PORT.  FLAGS are
+   as for `open'; only O_IGNORE_CTTY and O_CLOEXEC are meaningful, but all are
+   saved.
+
+   If the descriptor table is full, set errno, and return -1.
+   If DEALLOC is nonzero, deallocate PORT first.  */
+
+extern int _hurd_intern_fd (io_t port, int flags, int dealloc);
+
+/* Allocate a new file descriptor in the table and return it, locked.  The
+   new descriptor number will be no less than FIRST_FD.  If the table is
+   full, set errno to EMFILE and return NULL.  If FIRST_FD is negative or
+   bigger than the size of the table, set errno to EINVAL and return NULL.  */
+
+extern struct hurd_fd *_hurd_alloc_fd (int *fd_ptr, int first_fd);
+
+/* Allocate a new file descriptor structure and initialize its port cells
+   with PORT and CTTY.  (This does not affect the descriptor table.)  */
+
+extern struct hurd_fd *_hurd_new_fd (io_t port, io_t ctty);
+
+/* Close a file descriptor, making it available for future reallocation.  */
+
+extern error_t _hurd_fd_close (struct hurd_fd *fd);
+
+/* Read and write data from a file descriptor; just like `read' and `write'
+   if OFFSET is -1, or like `pread' and `pwrite' if OFFSET is not -1.
+   If successful, stores the amount actually read or written in *NBYTES.  */
+
+extern error_t _hurd_fd_read (struct hurd_fd *fd,
+			      void *buf, size_t *nbytes, loff_t offset);
+extern error_t _hurd_fd_write (struct hurd_fd *fd,
+			       const void *buf, size_t *nbytes, loff_t offset);
+
+
+/* Call *RPC on PORT and/or CTTY; if a call on CTTY returns EBACKGROUND,
+   generate SIGTTIN/SIGTTOU or EIO as appropriate.  */
+
+extern error_t _hurd_ctty_input (io_t port, io_t ctty, error_t (*rpc) (io_t));
+extern error_t _hurd_ctty_output (io_t port, io_t ctty, error_t (*rpc) (io_t));
+
+
+/* The guts of `select' and `poll'.  Check the first NFDS descriptors
+   either in POLLFDS (if nonnull) or in each of READFDS, WRITEFDS,
+   EXCEPTFDS that is nonnull.  If TIMEOUT is not NULL, time out after
+   waiting the interval specified therein.  If SIGMASK is nonnull,
+   the set of blocked signals is temporarily set to that during this call.
+   Returns the number of ready descriptors, or -1 for errors.  */
+struct pollfd;
+struct timespec;
+extern int _hurd_select (int nfds, struct pollfd *pollfds,
+			 fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+			 const struct timespec *timeout,
+			 const sigset_t *sigmask);
+
+/* Variant of file_name_lookup used in *at function implementations.
+   AT_FLAGS may only contain AT_SYMLINK_FOLLOW or AT_SYMLINK_NOFOLLOW,
+   which will remove and add O_NOLINK from FLAGS respectively.
+   Other bits cause EINVAL.  */
+extern file_t __file_name_lookup_at (int fd, int at_flags,
+				     const char *file_name,
+				     int flags, mode_t mode);
+
+/* Variant of file_name_split used in *at function implementations.  */
+extern file_t __file_name_split_at (int fd, const char *file_name,
+				    char **name);
+
+/* Variant of directory_name_split used in *at function implementations.  */
+extern file_t __directory_name_split_at (int fd, const char *directory_name,
+					 char **name);
+
+
+
+#endif	/* hurd/fd.h */
diff --git a/include/hurd/fs.h b/include/hurd/fs.h
new file mode 100644
index 0000000..68ad126
--- /dev/null
+++ b/include/hurd/fs.h
@@ -0,0 +1,975 @@
+#ifndef	_fs_user_
+#define	_fs_user_
+
+/* Module fs */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine file_exec */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_exec
+(
+	file_t exec_file,
+	mach_port_t exec_task,
+	int flags,
+	data_t argv,
+	mach_msg_type_number_t argvCnt,
+	data_t envp,
+	mach_msg_type_number_t envpCnt,
+	portarray_t fdarray,
+	mach_msg_type_name_t fdarrayPoly,
+	mach_msg_type_number_t fdarrayCnt,
+	portarray_t portarray,
+	mach_msg_type_name_t portarrayPoly,
+	mach_msg_type_number_t portarrayCnt,
+	intarray_t intarray,
+	mach_msg_type_number_t intarrayCnt,
+	mach_port_array_t deallocnames,
+	mach_msg_type_number_t deallocnamesCnt,
+	mach_port_array_t destroynames,
+	mach_msg_type_number_t destroynamesCnt
+);
+
+/* Routine file_chown */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_chown
+(
+	file_t chown_file,
+	uid_t new_owner,
+	gid_t new_group
+);
+
+/* Routine file_chauthor */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_chauthor
+(
+	file_t chauth_file,
+	uid_t new_author
+);
+
+/* Routine file_chmod */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_chmod
+(
+	file_t chmod_file,
+	mode_t new_mode
+);
+
+/* Routine file_chflags */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_chflags
+(
+	file_t chflags_file,
+	int new_flags
+);
+
+/* Routine file_utimes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_utimes
+(
+	file_t utimes_file,
+	time_value_t new_atime,
+	time_value_t new_mtime
+);
+
+/* Routine file_set_size */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_set_size
+(
+	file_t trunc_file,
+	loff_t new_size
+);
+
+/* Routine file_lock */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_lock
+(
+	file_t lock_file,
+	int flags
+);
+
+/* Routine file_lock_stat */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_lock_stat
+(
+	file_t lock_file,
+	int *mystatus,
+	int *otherstatus
+);
+
+/* Routine file_check_access */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_check_access
+(
+	file_t file,
+	int *allowed
+);
+
+/* Routine file_notice_changes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_notice_changes
+(
+	file_t file,
+	mach_port_t port,
+	mach_msg_type_name_t portPoly
+);
+
+/* Routine file_getcontrol */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_getcontrol
+(
+	file_t file,
+	mach_port_t *control
+);
+
+/* Routine file_statfs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_statfs
+(
+	file_t file,
+	fsys_statfsbuf_t *info
+);
+
+/* Routine file_sync */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_sync
+(
+	file_t file,
+	int wait,
+	int omit_metadata
+);
+
+/* Routine file_syncfs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_syncfs
+(
+	file_t file,
+	int wait,
+	int do_children
+);
+
+/* Routine file_get_storage_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_get_storage_info
+(
+	file_t file,
+	portarray_t *ports,
+	mach_msg_type_number_t *portsCnt,
+	intarray_t *ints,
+	mach_msg_type_number_t *intsCnt,
+	off_array_t *offsets,
+	mach_msg_type_number_t *offsetsCnt,
+	data_t *data,
+	mach_msg_type_number_t *dataCnt
+);
+
+/* Routine file_getlinknode */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_getlinknode
+(
+	file_t file,
+	mach_port_t *linknode
+);
+
+/* Routine file_getfh */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_getfh
+(
+	file_t file,
+	data_t *filehandle,
+	mach_msg_type_number_t *filehandleCnt
+);
+
+/* Routine dir_lookup */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __dir_lookup
+(
+	file_t start_dir,
+	string_t file_name,
+	int flags,
+	mode_t mode,
+	retry_type *do_retry,
+	string_t retry_name,
+	mach_port_t *result
+);
+
+/* Routine dir_readdir */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __dir_readdir
+(
+	file_t dir,
+	data_t *data,
+	mach_msg_type_number_t *dataCnt,
+	int entry,
+	int nentries,
+	vm_size_t bufsiz,
+	int *amount
+);
+
+/* Routine dir_mkdir */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __dir_mkdir
+(
+	file_t directory,
+	string_t name,
+	mode_t mode
+);
+
+/* Routine dir_rmdir */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __dir_rmdir
+(
+	file_t directory,
+	string_t name
+);
+
+/* Routine dir_unlink */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __dir_unlink
+(
+	file_t directory,
+	string_t name
+);
+
+/* Routine dir_link */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __dir_link
+(
+	file_t dir,
+	file_t file,
+	string_t name,
+	int excl
+);
+
+/* Routine dir_rename */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __dir_rename
+(
+	file_t olddirectory,
+	string_t oldname,
+	file_t newdirectory,
+	string_t newname,
+	int excl
+);
+
+/* Routine dir_mkfile */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __dir_mkfile
+(
+	file_t directory,
+	int flags,
+	mode_t mode,
+	mach_port_t *newnode
+);
+
+/* Routine dir_notice_changes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __dir_notice_changes
+(
+	file_t directory,
+	mach_port_t port,
+	mach_msg_type_name_t portPoly
+);
+
+/* Routine file_set_translator */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_set_translator
+(
+	file_t file,
+	int passive_flags,
+	int active_flags,
+	int oldtrans_flags,
+	data_t passive,
+	mach_msg_type_number_t passiveCnt,
+	mach_port_t active,
+	mach_msg_type_name_t activePoly
+);
+
+/* Routine file_get_translator */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_get_translator
+(
+	file_t file,
+	data_t *translator,
+	mach_msg_type_number_t *translatorCnt
+);
+
+/* Routine file_get_translator_cntl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_get_translator_cntl
+(
+	file_t file,
+	mach_port_t *translator_cntl
+);
+
+/* Routine file_get_fs_options */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_get_fs_options
+(
+	file_t file,
+	data_t *options,
+	mach_msg_type_number_t *optionsCnt
+);
+
+/* Routine file_reparent */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_reparent
+(
+	file_t file,
+	mach_port_t parent,
+	mach_port_t *new_file
+);
+
+/* Routine file_get_children */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_get_children
+(
+	file_t file,
+	data_t *children,
+	mach_msg_type_number_t *childrenCnt
+);
+
+/* Routine file_get_source */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __file_get_source
+(
+	file_t file,
+	string_t source
+);
+
+
+/* Module fs */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine file_exec */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_exec
+(
+	file_t exec_file,
+	mach_port_t exec_task,
+	int flags,
+	data_t argv,
+	mach_msg_type_number_t argvCnt,
+	data_t envp,
+	mach_msg_type_number_t envpCnt,
+	portarray_t fdarray,
+	mach_msg_type_name_t fdarrayPoly,
+	mach_msg_type_number_t fdarrayCnt,
+	portarray_t portarray,
+	mach_msg_type_name_t portarrayPoly,
+	mach_msg_type_number_t portarrayCnt,
+	intarray_t intarray,
+	mach_msg_type_number_t intarrayCnt,
+	mach_port_array_t deallocnames,
+	mach_msg_type_number_t deallocnamesCnt,
+	mach_port_array_t destroynames,
+	mach_msg_type_number_t destroynamesCnt
+);
+
+/* Routine file_chown */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_chown
+(
+	file_t chown_file,
+	uid_t new_owner,
+	gid_t new_group
+);
+
+/* Routine file_chauthor */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_chauthor
+(
+	file_t chauth_file,
+	uid_t new_author
+);
+
+/* Routine file_chmod */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_chmod
+(
+	file_t chmod_file,
+	mode_t new_mode
+);
+
+/* Routine file_chflags */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_chflags
+(
+	file_t chflags_file,
+	int new_flags
+);
+
+/* Routine file_utimes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_utimes
+(
+	file_t utimes_file,
+	time_value_t new_atime,
+	time_value_t new_mtime
+);
+
+/* Routine file_set_size */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_set_size
+(
+	file_t trunc_file,
+	loff_t new_size
+);
+
+/* Routine file_lock */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_lock
+(
+	file_t lock_file,
+	int flags
+);
+
+/* Routine file_lock_stat */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_lock_stat
+(
+	file_t lock_file,
+	int *mystatus,
+	int *otherstatus
+);
+
+/* Routine file_check_access */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_check_access
+(
+	file_t file,
+	int *allowed
+);
+
+/* Routine file_notice_changes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_notice_changes
+(
+	file_t file,
+	mach_port_t port,
+	mach_msg_type_name_t portPoly
+);
+
+/* Routine file_getcontrol */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_getcontrol
+(
+	file_t file,
+	mach_port_t *control
+);
+
+/* Routine file_statfs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_statfs
+(
+	file_t file,
+	fsys_statfsbuf_t *info
+);
+
+/* Routine file_sync */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_sync
+(
+	file_t file,
+	int wait,
+	int omit_metadata
+);
+
+/* Routine file_syncfs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_syncfs
+(
+	file_t file,
+	int wait,
+	int do_children
+);
+
+/* Routine file_get_storage_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_get_storage_info
+(
+	file_t file,
+	portarray_t *ports,
+	mach_msg_type_number_t *portsCnt,
+	intarray_t *ints,
+	mach_msg_type_number_t *intsCnt,
+	off_array_t *offsets,
+	mach_msg_type_number_t *offsetsCnt,
+	data_t *data,
+	mach_msg_type_number_t *dataCnt
+);
+
+/* Routine file_getlinknode */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_getlinknode
+(
+	file_t file,
+	mach_port_t *linknode
+);
+
+/* Routine file_getfh */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_getfh
+(
+	file_t file,
+	data_t *filehandle,
+	mach_msg_type_number_t *filehandleCnt
+);
+
+/* Routine dir_lookup */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t dir_lookup
+(
+	file_t start_dir,
+	string_t file_name,
+	int flags,
+	mode_t mode,
+	retry_type *do_retry,
+	string_t retry_name,
+	mach_port_t *result
+);
+
+/* Routine dir_readdir */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t dir_readdir
+(
+	file_t dir,
+	data_t *data,
+	mach_msg_type_number_t *dataCnt,
+	int entry,
+	int nentries,
+	vm_size_t bufsiz,
+	int *amount
+);
+
+/* Routine dir_mkdir */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t dir_mkdir
+(
+	file_t directory,
+	string_t name,
+	mode_t mode
+);
+
+/* Routine dir_rmdir */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t dir_rmdir
+(
+	file_t directory,
+	string_t name
+);
+
+/* Routine dir_unlink */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t dir_unlink
+(
+	file_t directory,
+	string_t name
+);
+
+/* Routine dir_link */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t dir_link
+(
+	file_t dir,
+	file_t file,
+	string_t name,
+	int excl
+);
+
+/* Routine dir_rename */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t dir_rename
+(
+	file_t olddirectory,
+	string_t oldname,
+	file_t newdirectory,
+	string_t newname,
+	int excl
+);
+
+/* Routine dir_mkfile */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t dir_mkfile
+(
+	file_t directory,
+	int flags,
+	mode_t mode,
+	mach_port_t *newnode
+);
+
+/* Routine dir_notice_changes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t dir_notice_changes
+(
+	file_t directory,
+	mach_port_t port,
+	mach_msg_type_name_t portPoly
+);
+
+/* Routine file_set_translator */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_set_translator
+(
+	file_t file,
+	int passive_flags,
+	int active_flags,
+	int oldtrans_flags,
+	data_t passive,
+	mach_msg_type_number_t passiveCnt,
+	mach_port_t active,
+	mach_msg_type_name_t activePoly
+);
+
+/* Routine file_get_translator */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_get_translator
+(
+	file_t file,
+	data_t *translator,
+	mach_msg_type_number_t *translatorCnt
+);
+
+/* Routine file_get_translator_cntl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_get_translator_cntl
+(
+	file_t file,
+	mach_port_t *translator_cntl
+);
+
+/* Routine file_get_fs_options */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_get_fs_options
+(
+	file_t file,
+	data_t *options,
+	mach_msg_type_number_t *optionsCnt
+);
+
+/* Routine file_reparent */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_reparent
+(
+	file_t file,
+	mach_port_t parent,
+	mach_port_t *new_file
+);
+
+/* Routine file_get_children */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_get_children
+(
+	file_t file,
+	data_t *children,
+	mach_msg_type_number_t *childrenCnt
+);
+
+/* Routine file_get_source */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t file_get_source
+(
+	file_t file,
+	string_t source
+);
+
+#endif	/* not defined(_fs_user_) */
diff --git a/include/hurd/fsys.h b/include/hurd/fsys.h
new file mode 100644
index 0000000..b20747f
--- /dev/null
+++ b/include/hurd/fsys.h
@@ -0,0 +1,337 @@
+#ifndef	_fsys_user_
+#define	_fsys_user_
+
+/* Module fsys */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine fsys_startup */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_startup
+(
+	mach_port_t bootstrap,
+	int openflags,
+	mach_port_t control_port,
+	mach_msg_type_name_t control_portPoly,
+	mach_port_t *realnode
+);
+
+/* Routine fsys_goaway */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_goaway
+(
+	fsys_t fsys,
+	int flags
+);
+
+/* Routine fsys_getroot */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_getroot
+(
+	fsys_t fsys,
+	mach_port_t dotdot_node,
+	mach_msg_type_name_t dotdot_nodePoly,
+	idarray_t gen_uids,
+	mach_msg_type_number_t gen_uidsCnt,
+	idarray_t gen_gids,
+	mach_msg_type_number_t gen_gidsCnt,
+	int flags,
+	retry_type *do_retry,
+	string_t retry_name,
+	mach_port_t *file
+);
+
+/* Routine fsys_getfile */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_getfile
+(
+	fsys_t fsys,
+	idarray_t gen_uids,
+	mach_msg_type_number_t gen_uidsCnt,
+	idarray_t gen_gids,
+	mach_msg_type_number_t gen_gidsCnt,
+	data_t filehandle,
+	mach_msg_type_number_t filehandleCnt,
+	mach_port_t *file
+);
+
+/* Routine fsys_syncfs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_syncfs
+(
+	fsys_t fsys,
+	int wait,
+	int do_children
+);
+
+/* Routine fsys_set_options */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_set_options
+(
+	fsys_t fsys,
+	data_t options,
+	mach_msg_type_number_t optionsCnt,
+	int do_children
+);
+
+/* Routine fsys_getpriv */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_getpriv
+(
+	fsys_t fsys,
+	mach_port_t *host_priv,
+	mach_port_t *device_master,
+	mach_port_t *fstask
+);
+
+/* Routine fsys_init */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_init
+(
+	fsys_t fsys,
+	mach_port_t proc_server,
+	mach_msg_type_name_t proc_serverPoly,
+	auth_t auth_handle
+);
+
+/* Routine fsys_forward */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_forward
+(
+	mach_port_t server,
+	mach_port_t requestor,
+	mach_msg_type_name_t requestorPoly,
+	data_t argv,
+	mach_msg_type_number_t argvCnt
+);
+
+/* Routine fsys_get_options */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __fsys_get_options
+(
+	fsys_t server,
+	data_t *options,
+	mach_msg_type_number_t *optionsCnt
+);
+
+
+/* Module fsys */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine fsys_startup */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_startup
+(
+	mach_port_t bootstrap,
+	int openflags,
+	mach_port_t control_port,
+	mach_msg_type_name_t control_portPoly,
+	mach_port_t *realnode
+);
+
+/* Routine fsys_goaway */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_goaway
+(
+	fsys_t fsys,
+	int flags
+);
+
+/* Routine fsys_getroot */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_getroot
+(
+	fsys_t fsys,
+	mach_port_t dotdot_node,
+	mach_msg_type_name_t dotdot_nodePoly,
+	idarray_t gen_uids,
+	mach_msg_type_number_t gen_uidsCnt,
+	idarray_t gen_gids,
+	mach_msg_type_number_t gen_gidsCnt,
+	int flags,
+	retry_type *do_retry,
+	string_t retry_name,
+	mach_port_t *file
+);
+
+/* Routine fsys_getfile */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_getfile
+(
+	fsys_t fsys,
+	idarray_t gen_uids,
+	mach_msg_type_number_t gen_uidsCnt,
+	idarray_t gen_gids,
+	mach_msg_type_number_t gen_gidsCnt,
+	data_t filehandle,
+	mach_msg_type_number_t filehandleCnt,
+	mach_port_t *file
+);
+
+/* Routine fsys_syncfs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_syncfs
+(
+	fsys_t fsys,
+	int wait,
+	int do_children
+);
+
+/* Routine fsys_set_options */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_set_options
+(
+	fsys_t fsys,
+	data_t options,
+	mach_msg_type_number_t optionsCnt,
+	int do_children
+);
+
+/* Routine fsys_getpriv */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_getpriv
+(
+	fsys_t fsys,
+	mach_port_t *host_priv,
+	mach_port_t *device_master,
+	mach_port_t *fstask
+);
+
+/* Routine fsys_init */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_init
+(
+	fsys_t fsys,
+	mach_port_t proc_server,
+	mach_msg_type_name_t proc_serverPoly,
+	auth_t auth_handle
+);
+
+/* Routine fsys_forward */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_forward
+(
+	mach_port_t server,
+	mach_port_t requestor,
+	mach_msg_type_name_t requestorPoly,
+	data_t argv,
+	mach_msg_type_number_t argvCnt
+);
+
+/* Routine fsys_get_options */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t fsys_get_options
+(
+	fsys_t server,
+	data_t *options,
+	mach_msg_type_number_t *optionsCnt
+);
+
+#endif	/* not defined(_fsys_user_) */
diff --git a/include/hurd/id.h b/include/hurd/id.h
new file mode 100644
index 0000000..37431e3
--- /dev/null
+++ b/include/hurd/id.h
@@ -0,0 +1,54 @@
+/* User and group IDs.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_HURD_ID_H
+
+#define	_HURD_ID_H	1
+#include <features.h>
+
+#include <cthreads.h>		/* For `struct mutex'.  */
+
+/* Structure describing authorization data for the process.  */
+
+struct hurd_id_data
+  {
+    struct mutex lock;
+
+    int valid;			/* If following data are up to date.  */
+
+    struct
+      {
+	uid_t *uids;
+	gid_t *gids;
+	mach_msg_type_number_t nuids, ngids;
+      } gen, aux;
+
+    auth_t rid_auth;		/* Cache used by access.  */
+  };
+
+/* Current data.  */
+
+extern struct hurd_id_data _hurd_id;
+
+
+/* Update _hurd_id (caller should be holding the lock).  */
+
+extern error_t _hurd_check_ids (void);
+
+
+#endif	/* hurd/id.h */
diff --git a/include/hurd/ifsock.h b/include/hurd/ifsock.h
new file mode 100644
index 0000000..23b2c51
--- /dev/null
+++ b/include/hurd/ifsock.h
@@ -0,0 +1,63 @@
+#ifndef	_ifsock_user_
+#define	_ifsock_user_
+
+/* Module ifsock */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine ifsock_getsockaddr */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __ifsock_getsockaddr
+(
+	file_t file,
+	mach_port_t *sockaddr
+);
+
+
+/* Module ifsock */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine ifsock_getsockaddr */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t ifsock_getsockaddr
+(
+	file_t file,
+	mach_port_t *sockaddr
+);
+
+#endif	/* not defined(_ifsock_user_) */
diff --git a/include/hurd/interrupt.h b/include/hurd/interrupt.h
new file mode 100644
index 0000000..4553db7
--- /dev/null
+++ b/include/hurd/interrupt.h
@@ -0,0 +1,63 @@
+#ifndef	_interrupt_user_
+#define	_interrupt_user_
+
+/* Module interrupt */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine interrupt_operation */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __interrupt_operation
+(
+	interrupt_t object,
+	natural_t timeout
+);
+
+
+/* Module interrupt */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine interrupt_operation */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t interrupt_operation
+(
+	interrupt_t object,
+	natural_t timeout
+);
+
+#endif	/* not defined(_interrupt_user_) */
diff --git a/include/hurd/io.h b/include/hurd/io.h
new file mode 100644
index 0000000..7289b47
--- /dev/null
+++ b/include/hurd/io.h
@@ -0,0 +1,849 @@
+#ifndef	_io_user_
+#define	_io_user_
+
+/* Module io */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine io_write */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_write
+(
+	io_t io_object,
+	data_t data,
+	mach_msg_type_number_t dataCnt,
+	loff_t offset,
+	vm_size_t *amount
+);
+
+/* Routine io_read */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_read
+(
+	io_t io_object,
+	data_t *data,
+	mach_msg_type_number_t *dataCnt,
+	loff_t offset,
+	vm_size_t amount
+);
+
+/* Routine io_seek */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_seek
+(
+	io_t io_object,
+	loff_t offset,
+	int whence,
+	loff_t *newp
+);
+
+/* Routine io_readable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_readable
+(
+	io_t io_object,
+	vm_size_t *amount
+);
+
+/* Routine io_set_all_openmodes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_set_all_openmodes
+(
+	io_t io_object,
+	int newbits
+);
+
+/* Routine io_get_openmodes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_openmodes
+(
+	io_t io_object,
+	int *bits
+);
+
+/* Routine io_set_some_openmodes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_set_some_openmodes
+(
+	io_t io_object,
+	int bits_to_set
+);
+
+/* Routine io_clear_some_openmodes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_clear_some_openmodes
+(
+	io_t io_object,
+	int bits_to_clear
+);
+
+/* Routine io_async */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_async
+(
+	io_t io_object,
+	mach_port_t notify_port,
+	mach_msg_type_name_t notify_portPoly,
+	mach_port_t *async_id_port
+);
+
+/* Routine io_mod_owner */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_mod_owner
+(
+	io_t io_object,
+	pid_t owner
+);
+
+/* Routine io_get_owner */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_owner
+(
+	io_t io_object,
+	pid_t *owner
+);
+
+/* Routine io_get_icky_async_id */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_icky_async_id
+(
+	io_t io_object,
+	mach_port_t *icky_async_id_port
+);
+
+/* Routine io_select */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_select
+(
+	io_t io_object,
+	mach_port_t reply,
+	natural_t timeout,
+	int *select_type
+);
+
+/* Routine io_stat */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_stat
+(
+	io_t stat_object,
+	io_statbuf_t *stat_info
+);
+
+/* SimpleRoutine io_reauthenticate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_reauthenticate
+(
+	io_t auth_object,
+	mach_port_t rendezvous2,
+	mach_msg_type_name_t rendezvous2Poly
+);
+
+/* Routine io_restrict_auth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_restrict_auth
+(
+	io_t io_object,
+	mach_port_t *new_object,
+	idarray_t uids,
+	mach_msg_type_number_t uidsCnt,
+	idarray_t gids,
+	mach_msg_type_number_t gidsCnt
+);
+
+/* Routine io_duplicate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_duplicate
+(
+	io_t io_object,
+	mach_port_t *newport
+);
+
+/* Routine io_server_version */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_server_version
+(
+	io_t vers_object,
+	string_t server_name,
+	int *server_major_version,
+	int *server_minor_version,
+	int *server_edit_level
+);
+
+/* Routine io_map */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_map
+(
+	io_t io_object,
+	mach_port_t *memobjrd,
+	mach_port_t *memobjwt
+);
+
+/* Routine io_map_cntl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_map_cntl
+(
+	io_t io_object,
+	mach_port_t *memobj
+);
+
+/* Routine io_get_conch */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_conch
+(
+	io_t io_object
+);
+
+/* Routine io_release_conch */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_release_conch
+(
+	io_t io_object
+);
+
+/* Routine io_eofnotify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_eofnotify
+(
+	io_t io_object
+);
+
+/* Routine io_prenotify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_prenotify
+(
+	io_t io_object,
+	vm_offset_t write_start,
+	vm_offset_t write_end
+);
+
+/* Routine io_postnotify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_postnotify
+(
+	io_t io_object,
+	vm_offset_t write_start,
+	vm_offset_t write_end
+);
+
+/* Routine io_readnotify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_readnotify
+(
+	io_t io_object
+);
+
+/* Routine io_readsleep */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_readsleep
+(
+	io_t io_object
+);
+
+/* Routine io_sigio */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_sigio
+(
+	io_t io_object
+);
+
+/* Routine io_pathconf */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_pathconf
+(
+	io_t io_object,
+	int name,
+	int *value
+);
+
+/* Routine io_identity */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_identity
+(
+	io_t io_object,
+	mach_port_t *idport,
+	mach_port_t *fsidport,
+	ino64_t *fileno
+);
+
+/* Routine io_revoke */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_revoke
+(
+	io_t io_object
+);
+
+/* Routine io_select_timeout */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_select_timeout
+(
+	io_t io_object,
+	mach_port_t reply,
+	timespec_t timeout,
+	int *select_type
+);
+
+
+/* Module io */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine io_write */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_write
+(
+	io_t io_object,
+	data_t data,
+	mach_msg_type_number_t dataCnt,
+	loff_t offset,
+	vm_size_t *amount
+);
+
+/* Routine io_read */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_read
+(
+	io_t io_object,
+	data_t *data,
+	mach_msg_type_number_t *dataCnt,
+	loff_t offset,
+	vm_size_t amount
+);
+
+/* Routine io_seek */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_seek
+(
+	io_t io_object,
+	loff_t offset,
+	int whence,
+	loff_t *newp
+);
+
+/* Routine io_readable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_readable
+(
+	io_t io_object,
+	vm_size_t *amount
+);
+
+/* Routine io_set_all_openmodes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_set_all_openmodes
+(
+	io_t io_object,
+	int newbits
+);
+
+/* Routine io_get_openmodes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_openmodes
+(
+	io_t io_object,
+	int *bits
+);
+
+/* Routine io_set_some_openmodes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_set_some_openmodes
+(
+	io_t io_object,
+	int bits_to_set
+);
+
+/* Routine io_clear_some_openmodes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_clear_some_openmodes
+(
+	io_t io_object,
+	int bits_to_clear
+);
+
+/* Routine io_async */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_async
+(
+	io_t io_object,
+	mach_port_t notify_port,
+	mach_msg_type_name_t notify_portPoly,
+	mach_port_t *async_id_port
+);
+
+/* Routine io_mod_owner */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_mod_owner
+(
+	io_t io_object,
+	pid_t owner
+);
+
+/* Routine io_get_owner */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_owner
+(
+	io_t io_object,
+	pid_t *owner
+);
+
+/* Routine io_get_icky_async_id */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_icky_async_id
+(
+	io_t io_object,
+	mach_port_t *icky_async_id_port
+);
+
+/* Routine io_select */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_select
+(
+	io_t io_object,
+	mach_port_t reply,
+	natural_t timeout,
+	int *select_type
+);
+
+/* Routine io_stat */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_stat
+(
+	io_t stat_object,
+	io_statbuf_t *stat_info
+);
+
+/* SimpleRoutine io_reauthenticate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_reauthenticate
+(
+	io_t auth_object,
+	mach_port_t rendezvous2,
+	mach_msg_type_name_t rendezvous2Poly
+);
+
+/* Routine io_restrict_auth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_restrict_auth
+(
+	io_t io_object,
+	mach_port_t *new_object,
+	idarray_t uids,
+	mach_msg_type_number_t uidsCnt,
+	idarray_t gids,
+	mach_msg_type_number_t gidsCnt
+);
+
+/* Routine io_duplicate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_duplicate
+(
+	io_t io_object,
+	mach_port_t *newport
+);
+
+/* Routine io_server_version */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_server_version
+(
+	io_t vers_object,
+	string_t server_name,
+	int *server_major_version,
+	int *server_minor_version,
+	int *server_edit_level
+);
+
+/* Routine io_map */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_map
+(
+	io_t io_object,
+	mach_port_t *memobjrd,
+	mach_port_t *memobjwt
+);
+
+/* Routine io_map_cntl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_map_cntl
+(
+	io_t io_object,
+	mach_port_t *memobj
+);
+
+/* Routine io_get_conch */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_conch
+(
+	io_t io_object
+);
+
+/* Routine io_release_conch */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_release_conch
+(
+	io_t io_object
+);
+
+/* Routine io_eofnotify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_eofnotify
+(
+	io_t io_object
+);
+
+/* Routine io_prenotify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_prenotify
+(
+	io_t io_object,
+	vm_offset_t write_start,
+	vm_offset_t write_end
+);
+
+/* Routine io_postnotify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_postnotify
+(
+	io_t io_object,
+	vm_offset_t write_start,
+	vm_offset_t write_end
+);
+
+/* Routine io_readnotify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_readnotify
+(
+	io_t io_object
+);
+
+/* Routine io_readsleep */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_readsleep
+(
+	io_t io_object
+);
+
+/* Routine io_sigio */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_sigio
+(
+	io_t io_object
+);
+
+/* Routine io_pathconf */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_pathconf
+(
+	io_t io_object,
+	int name,
+	int *value
+);
+
+/* Routine io_identity */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_identity
+(
+	io_t io_object,
+	mach_port_t *idport,
+	mach_port_t *fsidport,
+	ino64_t *fileno
+);
+
+/* Routine io_revoke */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_revoke
+(
+	io_t io_object
+);
+
+/* Routine io_select_timeout */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_select_timeout
+(
+	io_t io_object,
+	mach_port_t reply,
+	timespec_t timeout,
+	int *select_type
+);
+
+#endif	/* not defined(_io_user_) */
diff --git a/include/hurd/io_reply.h b/include/hurd/io_reply.h
new file mode 100644
index 0000000..a0c3307
--- /dev/null
+++ b/include/hurd/io_reply.h
@@ -0,0 +1,913 @@
+#ifndef	_io_reply_user_
+#define	_io_reply_user_
+
+/* Module io_reply */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine io_write_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_write_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	vm_size_t amount
+);
+
+/* SimpleRoutine io_read_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_read_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	data_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* SimpleRoutine io_seek_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_seek_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	loff_t newp
+);
+
+/* SimpleRoutine io_readable_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_readable_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	vm_size_t amount
+);
+
+/* SimpleRoutine io_set_all_openmodes_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_set_all_openmodes_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_get_openmodes_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_openmodes_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	int bits
+);
+
+/* SimpleRoutine io_set_some_openmodes_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_set_some_openmodes_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_clear_some_openmodes_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_clear_some_openmodes_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_async_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_async_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t async_id_port,
+	mach_msg_type_name_t async_id_portPoly
+);
+
+/* SimpleRoutine io_mod_owner_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_mod_owner_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_get_owner_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_owner_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	pid_t owner
+);
+
+/* SimpleRoutine io_get_icky_async_id_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_icky_async_id_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t id_port,
+	mach_msg_type_name_t id_portPoly
+);
+
+/* SimpleRoutine io_select_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_select_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	int select_result
+);
+
+/* SimpleRoutine io_stat_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_stat_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	io_statbuf_t stat_info
+);
+
+/* SimpleRoutine io_restrict_auth_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_restrict_auth_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t new_object,
+	mach_msg_type_name_t new_objectPoly
+);
+
+/* SimpleRoutine io_duplicate_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_duplicate_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t newport,
+	mach_msg_type_name_t newportPoly
+);
+
+/* SimpleRoutine io_server_version_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_server_version_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	string_t server_name,
+	int server_major_version,
+	int server_minor_version,
+	int server_edit_level
+);
+
+/* SimpleRoutine io_map_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_map_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t rdobject,
+	mach_msg_type_name_t rdobjectPoly,
+	mach_port_t wrobject,
+	mach_msg_type_name_t wrobjectPoly
+);
+
+/* SimpleRoutine io_map_cntl_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_map_cntl_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t memobj,
+	mach_msg_type_name_t memobjPoly
+);
+
+/* SimpleRoutine io_get_conch_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_conch_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_release_conch_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_release_conch_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_eofnotify_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_eofnotify_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_prenotify_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_prenotify_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_postnotify_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_postnotify_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_readnotify_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_readnotify_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_readsleep_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_readsleep_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_sigio_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_sigio_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_pathconf_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_pathconf_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	int value
+);
+
+/* SimpleRoutine io_identity_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_identity_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t idport,
+	mach_msg_type_name_t idportPoly,
+	mach_port_t fsidport,
+	mach_msg_type_name_t fsidportPoly,
+	ino64_t fileno
+);
+
+/* SimpleRoutine io_revoke_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_revoke_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_select_timeout_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_select_timeout_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	int select_result
+);
+
+
+/* Module io_reply */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine io_write_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_write_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	vm_size_t amount
+);
+
+/* SimpleRoutine io_read_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_read_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	data_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* SimpleRoutine io_seek_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_seek_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	loff_t newp
+);
+
+/* SimpleRoutine io_readable_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_readable_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	vm_size_t amount
+);
+
+/* SimpleRoutine io_set_all_openmodes_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_set_all_openmodes_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_get_openmodes_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_openmodes_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	int bits
+);
+
+/* SimpleRoutine io_set_some_openmodes_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_set_some_openmodes_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_clear_some_openmodes_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_clear_some_openmodes_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_async_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_async_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t async_id_port,
+	mach_msg_type_name_t async_id_portPoly
+);
+
+/* SimpleRoutine io_mod_owner_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_mod_owner_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_get_owner_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_owner_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	pid_t owner
+);
+
+/* SimpleRoutine io_get_icky_async_id_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_icky_async_id_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t id_port,
+	mach_msg_type_name_t id_portPoly
+);
+
+/* SimpleRoutine io_select_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_select_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	int select_result
+);
+
+/* SimpleRoutine io_stat_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_stat_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	io_statbuf_t stat_info
+);
+
+/* SimpleRoutine io_restrict_auth_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_restrict_auth_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t new_object,
+	mach_msg_type_name_t new_objectPoly
+);
+
+/* SimpleRoutine io_duplicate_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_duplicate_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t newport,
+	mach_msg_type_name_t newportPoly
+);
+
+/* SimpleRoutine io_server_version_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_server_version_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	string_t server_name,
+	int server_major_version,
+	int server_minor_version,
+	int server_edit_level
+);
+
+/* SimpleRoutine io_map_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_map_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t rdobject,
+	mach_msg_type_name_t rdobjectPoly,
+	mach_port_t wrobject,
+	mach_msg_type_name_t wrobjectPoly
+);
+
+/* SimpleRoutine io_map_cntl_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_map_cntl_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t memobj,
+	mach_msg_type_name_t memobjPoly
+);
+
+/* SimpleRoutine io_get_conch_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_conch_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_release_conch_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_release_conch_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_eofnotify_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_eofnotify_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_prenotify_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_prenotify_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_postnotify_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_postnotify_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_readnotify_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_readnotify_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_readsleep_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_readsleep_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_sigio_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_sigio_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_pathconf_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_pathconf_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	int value
+);
+
+/* SimpleRoutine io_identity_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_identity_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	mach_port_t idport,
+	mach_msg_type_name_t idportPoly,
+	mach_port_t fsidport,
+	mach_msg_type_name_t fsidportPoly,
+	ino64_t fileno
+);
+
+/* SimpleRoutine io_revoke_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_revoke_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine io_select_timeout_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_select_timeout_reply
+(
+	mach_port_t reply,
+	mach_msg_type_name_t replyPoly,
+	kern_return_t return_code,
+	int select_result
+);
+
+#endif	/* not defined(_io_reply_user_) */
diff --git a/include/hurd/io_request.h b/include/hurd/io_request.h
new file mode 100644
index 0000000..7403d20
--- /dev/null
+++ b/include/hurd/io_request.h
@@ -0,0 +1,833 @@
+#ifndef	_io_user_
+#define	_io_user_
+
+/* Module io */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine io_write_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_write_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	data_t data,
+	mach_msg_type_number_t dataCnt,
+	loff_t offset
+);
+
+/* SimpleRoutine io_read_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_read_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	loff_t offset,
+	vm_size_t amount
+);
+
+/* SimpleRoutine io_seek_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_seek_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	loff_t offset,
+	int whence
+);
+
+/* SimpleRoutine io_readable_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_readable_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_set_all_openmodes_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_set_all_openmodes_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int newbits
+);
+
+/* SimpleRoutine io_get_openmodes_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_openmodes_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_set_some_openmodes_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_set_some_openmodes_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int bits_to_set
+);
+
+/* SimpleRoutine io_clear_some_openmodes_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_clear_some_openmodes_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int bits_to_clear
+);
+
+/* SimpleRoutine io_async_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_async_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	mach_port_t notify_port,
+	mach_msg_type_name_t notify_portPoly
+);
+
+/* SimpleRoutine io_mod_owner_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_mod_owner_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	pid_t owner
+);
+
+/* SimpleRoutine io_get_owner_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_owner_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_get_icky_async_id_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_icky_async_id_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_select_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_select_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int select_type
+);
+
+/* SimpleRoutine io_stat_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_stat_request
+(
+	io_t stat_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_restrict_auth_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_restrict_auth_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	idarray_t uids,
+	mach_msg_type_number_t uidsCnt,
+	idarray_t gids,
+	mach_msg_type_number_t gidsCnt
+);
+
+/* SimpleRoutine io_duplicate_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_duplicate_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_server_version_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_server_version_request
+(
+	io_t vers_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_map_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_map_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_map_cntl_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_map_cntl_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_get_conch_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_get_conch_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_release_conch_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_release_conch_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_eofnotify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_eofnotify_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_prenotify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_prenotify_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	vm_offset_t write_start,
+	vm_offset_t write_end
+);
+
+/* SimpleRoutine io_postnotify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_postnotify_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	vm_offset_t write_start,
+	vm_offset_t write_end
+);
+
+/* SimpleRoutine io_readnotify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_readnotify_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_readsleep_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_readsleep_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_sigio_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_sigio_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_pathconf_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_pathconf_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int name
+);
+
+/* SimpleRoutine io_identity_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_identity_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_revoke_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_revoke_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_select_timeout_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __io_select_timeout_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	timespec_t timeout,
+	int select_type
+);
+
+
+/* Module io */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine io_write_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_write_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	data_t data,
+	mach_msg_type_number_t dataCnt,
+	loff_t offset
+);
+
+/* SimpleRoutine io_read_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_read_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	loff_t offset,
+	vm_size_t amount
+);
+
+/* SimpleRoutine io_seek_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_seek_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	loff_t offset,
+	int whence
+);
+
+/* SimpleRoutine io_readable_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_readable_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_set_all_openmodes_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_set_all_openmodes_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int newbits
+);
+
+/* SimpleRoutine io_get_openmodes_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_openmodes_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_set_some_openmodes_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_set_some_openmodes_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int bits_to_set
+);
+
+/* SimpleRoutine io_clear_some_openmodes_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_clear_some_openmodes_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int bits_to_clear
+);
+
+/* SimpleRoutine io_async_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_async_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	mach_port_t notify_port,
+	mach_msg_type_name_t notify_portPoly
+);
+
+/* SimpleRoutine io_mod_owner_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_mod_owner_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	pid_t owner
+);
+
+/* SimpleRoutine io_get_owner_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_owner_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_get_icky_async_id_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_icky_async_id_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_select_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_select_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int select_type
+);
+
+/* SimpleRoutine io_stat_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_stat_request
+(
+	io_t stat_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_restrict_auth_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_restrict_auth_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	idarray_t uids,
+	mach_msg_type_number_t uidsCnt,
+	idarray_t gids,
+	mach_msg_type_number_t gidsCnt
+);
+
+/* SimpleRoutine io_duplicate_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_duplicate_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_server_version_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_server_version_request
+(
+	io_t vers_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_map_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_map_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_map_cntl_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_map_cntl_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_get_conch_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_get_conch_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_release_conch_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_release_conch_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_eofnotify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_eofnotify_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_prenotify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_prenotify_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	vm_offset_t write_start,
+	vm_offset_t write_end
+);
+
+/* SimpleRoutine io_postnotify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_postnotify_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	vm_offset_t write_start,
+	vm_offset_t write_end
+);
+
+/* SimpleRoutine io_readnotify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_readnotify_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_readsleep_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_readsleep_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_sigio_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_sigio_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_pathconf_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_pathconf_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	int name
+);
+
+/* SimpleRoutine io_identity_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_identity_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_revoke_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_revoke_request
+(
+	io_t io_object,
+	mach_port_t reply
+);
+
+/* SimpleRoutine io_select_timeout_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t io_select_timeout_request
+(
+	io_t io_object,
+	mach_port_t reply,
+	timespec_t timeout,
+	int select_type
+);
+
+#endif	/* not defined(_io_user_) */
diff --git a/include/hurd/ioctl.h b/include/hurd/ioctl.h
new file mode 100644
index 0000000..3af3f9f
--- /dev/null
+++ b/include/hurd/ioctl.h
@@ -0,0 +1,76 @@
+/* User-registered handlers for specific `ioctl' requests.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_HURD_IOCTL_H
+#define	_HURD_IOCTL_H	1
+
+#define	__need___va_list
+#include <stdarg.h>
+#include <bits/ioctls.h>
+
+
+/* Type of handler function, called like ioctl to do its entire job.  */
+typedef int (*ioctl_handler_t) (int fd, int request, void *arg);
+
+/* Structure that records an ioctl handler.  */
+struct ioctl_handler
+  {
+    /* Range of handled _IOC_NOTYPE (REQUEST) values.  */
+    int first_request, last_request;
+
+    /* Handler function, called like ioctl to do its entire job.  */
+    ioctl_handler_t handler;
+
+    struct ioctl_handler *next;	/* Next handler.  */
+  };
+
+
+/* Register HANDLER to handle ioctls with REQUEST values between
+   FIRST_REQUEST and LAST_REQUEST inclusive.  Returns zero if successful.
+   Return nonzero and sets `errno' for an error.  */
+
+extern int hurd_register_ioctl_handler (int first_request, int last_request,
+					ioctl_handler_t handler);
+
+
+/* Define a library-internal handler for ioctl commands between FIRST and
+   LAST inclusive.  The last element gratuitously references HANDLER to
+   avoid `defined but not used' warnings.  */
+
+#define	_HURD_HANDLE_IOCTLS_1(handler, first, last, moniker)		      \
+  static const struct ioctl_handler handler##_ioctl_handler##moniker	      \
+	__attribute__ ((__unused__)) =					      \
+    { _IOC_NOTYPE (first), _IOC_NOTYPE (last),				      \
+	(ioctl_handler_t) (handler), NULL };				      \
+  text_set_element (_hurd_ioctl_handler_lists,				      \
+                    handler##_ioctl_handler##moniker)
+#define	_HURD_HANDLE_IOCTLS(handler, first, last)			      \
+  _HURD_HANDLE_IOCTLS_1 (handler, first, last, first##_to_##last)
+
+/* Define a library-internal handler for a single ioctl command.  */
+
+#define _HURD_HANDLE_IOCTL(handler, ioctl) \
+  _HURD_HANDLE_IOCTLS_1 (handler, ioctl, ioctl, ioctl##_only)
+
+
+/* Lookup the handler for the given ioctl request.  */
+
+ioctl_handler_t _hurd_lookup_ioctl_handler (int request);
+
+
+#endif	/* hurd/ioctl.h */
diff --git a/include/hurd/login.h b/include/hurd/login.h
new file mode 100644
index 0000000..a9cf841
--- /dev/null
+++ b/include/hurd/login.h
@@ -0,0 +1,165 @@
+#ifndef	_login_user_
+#define	_login_user_
+
+/* Module login */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine login_message_user */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __login_message_user
+(
+	file_t login,
+	data_t message,
+	mach_msg_type_number_t messageCnt
+);
+
+/* Routine login_get_location */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __login_get_location
+(
+	file_t login,
+	data_t *location,
+	mach_msg_type_number_t *locationCnt
+);
+
+/* Routine login_get_idle_time */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __login_get_idle_time
+(
+	file_t login,
+	time_value_t *idletime
+);
+
+/* Routine login_get_input_devices */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __login_get_input_devices
+(
+	file_t login,
+	data_t *devices,
+	mach_msg_type_number_t *devicesCnt
+);
+
+/* Routine login_get_login_collection */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __login_get_login_collection
+(
+	file_t login,
+	pid_t *id
+);
+
+
+/* Module login */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine login_message_user */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t login_message_user
+(
+	file_t login,
+	data_t message,
+	mach_msg_type_number_t messageCnt
+);
+
+/* Routine login_get_location */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t login_get_location
+(
+	file_t login,
+	data_t *location,
+	mach_msg_type_number_t *locationCnt
+);
+
+/* Routine login_get_idle_time */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t login_get_idle_time
+(
+	file_t login,
+	time_value_t *idletime
+);
+
+/* Routine login_get_input_devices */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t login_get_input_devices
+(
+	file_t login,
+	data_t *devices,
+	mach_msg_type_number_t *devicesCnt
+);
+
+/* Routine login_get_login_collection */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t login_get_login_collection
+(
+	file_t login,
+	pid_t *id
+);
+
+#endif	/* not defined(_login_user_) */
diff --git a/include/hurd/lookup.h b/include/hurd/lookup.h
new file mode 100644
index 0000000..0abe581
--- /dev/null
+++ b/include/hurd/lookup.h
@@ -0,0 +1,190 @@
+/* Declarations of file name translation functions for the GNU Hurd.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _HURD_LOOKUP_H
+#define _HURD_LOOKUP_H	1
+
+/* These functions all take two callback functions as the first two arguments.
+   The first callback function USE_INIT_PORT is called as follows:
+
+   error_t use_init_port (int which, error_t (*operate) (mach_port_t));
+
+   WHICH is nonnegative value less than INIT_PORT_MAX, indicating which
+   init port is required.  The callback function should call *OPERATE
+   with a send right to the appropriate init port.  No user reference
+   is consumed; the right will only be used after *OPERATE returns if
+   *OPERATE has added its own user reference.
+
+   LOOKUP is a function to do the actual filesystem lookup.  It is passed the
+   same arguments that the dir_lookup rpc accepts, and if 0, __dir_lookup is
+   used.
+
+   The second callback function GET_DTABLE_PORT should behave like `getdport'.
+
+   All these functions return zero on success or an error code on failure.  */
+
+
+/* Open a port to FILE with the given FLAGS and MODE (see <fcntl.h>).  If
+   successful, returns zero and store the port to FILE in *PORT; otherwise
+   returns an error code. */
+
+error_t __hurd_file_name_lookup (error_t (*use_init_port)
+				   (int which,
+				    error_t (*operate) (mach_port_t)),
+				 file_t (*get_dtable_port) (int fd),
+				 error_t (*lookup)
+				   (file_t dir, char *name, int flags, mode_t mode,
+				    retry_type *do_retry, string_t retry_name,
+				    mach_port_t *result),
+				 const char *file_name,
+				 int flags, mode_t mode,
+				 file_t *result);
+error_t hurd_file_name_lookup (error_t (*use_init_port)
+			         (int which,
+				  error_t (*operate) (mach_port_t)),
+			       file_t (*get_dtable_port) (int fd),
+			       error_t (*lookup)
+				 (file_t dir, char *name, int flags, mode_t mode,
+				  retry_type *do_retry, string_t retry_name,
+				  mach_port_t *result),
+			       const char *file_name,
+			       int flags, mode_t mode,
+			       file_t *result);
+
+
+/* Split FILE into a directory and a name within the directory.  Look up a
+   port for the directory and store it in *DIR; store in *NAME a pointer
+   into FILE where the name within directory begins.  */
+
+error_t __hurd_file_name_split (error_t (*use_init_port)
+				  (int which,
+				   error_t (*operate) (mach_port_t)),
+				file_t (*get_dtable_port) (int fd),
+				error_t (*lookup) (file_t dir, char *name,
+						   int flags, mode_t mode,
+				   retry_type *do_retry, string_t retry_name,
+				   mach_port_t *result),
+				const char *file_name,
+				file_t *dir, char **name);
+error_t hurd_file_name_split (error_t (*use_init_port)
+			        (int which,
+				 error_t (*operate) (mach_port_t)),
+			      file_t (*get_dtable_port) (int fd),
+			      error_t (*lookup) (file_t dir, char *name,
+						 int flags, mode_t mode,
+				 retry_type *do_retry, string_t retry_name,
+				 mach_port_t *result),
+			      const char *file_name,
+			      file_t *dir, char **name);
+
+/* Split DIRECTORY into a parent directory and a name within the directory.
+   This is the same as hurd_file_name_split, but ignores trailing slashes.  */
+
+error_t __hurd_directory_name_split (error_t (*use_init_port)
+				  (int which,
+				   error_t (*operate) (mach_port_t)),
+				file_t (*get_dtable_port) (int fd),
+				error_t (*lookup) (file_t dir, char *name,
+						   int flags, mode_t mode,
+				   retry_type *do_retry, string_t retry_name,
+				   mach_port_t *result),
+				const char *directory_name,
+				file_t *dir, char **name);
+error_t hurd_directory_name_split (error_t (*use_init_port)
+				   (int which,
+				    error_t (*operate) (mach_port_t)),
+				   file_t (*get_dtable_port) (int fd),
+				   error_t (*lookup) (file_t dir, char *name,
+						      int flags, mode_t mode,
+				    retry_type *do_retry, string_t retry_name,
+				    mach_port_t *result),
+				   const char *directory_name,
+				   file_t *dir, char **name);
+
+
+/* Process the values returned by `dir_lookup' et al, and loop doing
+   `dir_lookup' calls until one returns FS_RETRY_NONE.  The arguments
+   should be those just passed to and/or returned from `dir_lookup',
+   `fsys_getroot', or `file_invoke_translator'.  This function consumes the
+   reference in *RESULT even if it returns an error.  */
+
+error_t __hurd_file_name_lookup_retry (error_t (*use_init_port)
+				         (int which,
+					  error_t (*operate) (mach_port_t)),
+				       file_t (*get_dtable_port) (int fd),
+				       error_t (*lookup)
+				         (file_t dir, char *name,
+					  int flags, mode_t mode,
+					  retry_type *do_retry,
+					  string_t retry_name,
+					  mach_port_t *result),
+				       enum retry_type doretry,
+				       char retryname[1024],
+				       int flags, mode_t mode,
+				       file_t *result);
+error_t hurd_file_name_lookup_retry (error_t (*use_init_port)
+				       (int which,
+					error_t (*operate) (mach_port_t)),
+				     file_t (*get_dtable_port) (int fd),
+				     error_t (*lookup)
+				       (file_t dir, char *name,
+					int flags, mode_t mode,
+					retry_type *do_retry,
+					string_t retry_name,
+					mach_port_t *result),
+				     enum retry_type doretry,
+				     char retryname[1024],
+				     int flags, mode_t mode,
+				     file_t *result);
+
+
+/* If FILE_NAME contains a '/', or PATH is NULL, call FUN with FILE_NAME, and
+   return the result (if PREFIXED_NAME is non-NULL, setting *PREFIXED_NAME to
+   NULL).  Otherwise, call FUN repeatedly with FILE_NAME prefixed with each
+   successive `:' separated element of PATH, returning whenever FUN returns
+   0 (if PREFIXED_NAME is non-NULL, setting *PREFIXED_NAME to the resulting
+   prefixed path).  If FUN never returns 0, return the first non-ENOENT
+   return value, or ENOENT if there is none.  */
+error_t file_name_path_scan (const char *file_name, const char *path,
+			     error_t (*fun)(const char *name),
+			     char **prefixed_name);
+
+/* Lookup FILE_NAME and return the node opened with FLAGS & MODE in result
+   (see hurd_file_name_lookup for details), but a simple filename (without
+   any directory prefixes) will be consecutively prefixed with the pathnames
+   in the `:' separated list PATH until one succeeds in a successful lookup.
+   If none succeed, then the first error that wasn't ENOENT is returned, or
+   ENOENT if no other errors were returned.  If PREFIXED_NAME is non-NULL,
+   then if RESULT is looked up directly, *PREFIXED_NAME is set to NULL, and
+   if it is looked up using a prefix from PATH, *PREFIXED_NAME is set to
+   malloced storage containing the prefixed name.  */
+error_t hurd_file_name_path_lookup (error_t (*use_init_port)
+				    (int which,
+				     error_t (*operate) (mach_port_t)),
+				    file_t (*get_dtable_port) (int fd),
+				    error_t (*lookup)
+				      (file_t dir, char *name,
+				       int flags, mode_t mode,
+				       retry_type *do_retry,
+				       string_t retry_name,
+				       mach_port_t *result),
+				    const char *file_name, const char *path,
+				    int flags, mode_t mode,
+				    file_t *result, char **prefixed_name);
+
+#endif	/* hurd/lookup.h */
diff --git a/include/hurd/msg.h b/include/hurd/msg.h
new file mode 100644
index 0000000..6dc5e94
--- /dev/null
+++ b/include/hurd/msg.h
@@ -0,0 +1,697 @@
+#ifndef	_msg_user_
+#define	_msg_user_
+
+/* Module msg */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine msg_sig_post */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_sig_post
+(
+	mach_port_t process,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+/* Routine msg_proc_newids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_proc_newids
+(
+	mach_port_t process,
+	mach_port_t task,
+	pid_t ppid,
+	pid_t pgrp,
+	int orphaned
+);
+
+/* Routine msg_add_auth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_add_auth
+(
+	mach_port_t process,
+	auth_t auth
+);
+
+/* Routine msg_del_auth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_del_auth
+(
+	mach_port_t process,
+	mach_port_t task,
+	intarray_t uids,
+	mach_msg_type_number_t uidsCnt,
+	intarray_t gids,
+	mach_msg_type_number_t gidsCnt
+);
+
+/* Routine msg_get_init_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_get_init_port
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	mach_port_t *port
+);
+
+/* Routine msg_set_init_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_set_init_port
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	mach_port_t port,
+	mach_msg_type_name_t portPoly
+);
+
+/* Routine msg_get_init_ports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_get_init_ports
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t *ports,
+	mach_msg_type_number_t *portsCnt
+);
+
+/* Routine msg_set_init_ports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_set_init_ports
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt
+);
+
+/* Routine msg_get_init_int */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_get_init_int
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	int *value
+);
+
+/* Routine msg_set_init_int */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_set_init_int
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	int value
+);
+
+/* Routine msg_get_init_ints */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_get_init_ints
+(
+	mach_port_t process,
+	mach_port_t refport,
+	intarray_t *values,
+	mach_msg_type_number_t *valuesCnt
+);
+
+/* Routine msg_set_init_ints */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_set_init_ints
+(
+	mach_port_t process,
+	mach_port_t refport,
+	intarray_t values,
+	mach_msg_type_number_t valuesCnt
+);
+
+/* Routine msg_get_dtable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_get_dtable
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t *dtable,
+	mach_msg_type_number_t *dtableCnt
+);
+
+/* Routine msg_set_dtable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_set_dtable
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t dtable,
+	mach_msg_type_name_t dtablePoly,
+	mach_msg_type_number_t dtableCnt
+);
+
+/* Routine msg_get_fd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_get_fd
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int fd,
+	mach_port_t *port
+);
+
+/* Routine msg_set_fd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_set_fd
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int fd,
+	mach_port_t port,
+	mach_msg_type_name_t portPoly
+);
+
+/* Routine msg_get_environment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_get_environment
+(
+	mach_port_t process,
+	data_t *value,
+	mach_msg_type_number_t *valueCnt
+);
+
+/* Routine msg_set_environment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_set_environment
+(
+	mach_port_t process,
+	mach_port_t refport,
+	data_t value,
+	mach_msg_type_number_t valueCnt
+);
+
+/* Routine msg_get_env_variable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_get_env_variable
+(
+	mach_port_t process,
+	string_t variable,
+	data_t *value,
+	mach_msg_type_number_t *valueCnt
+);
+
+/* Routine msg_set_env_variable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_set_env_variable
+(
+	mach_port_t process,
+	mach_port_t refport,
+	string_t variable,
+	string_t value,
+	boolean_t replace
+);
+
+/* Routine msg_sig_post_untraced */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_sig_post_untraced
+(
+	mach_port_t process,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+/* Routine msg_report_wait */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_report_wait
+(
+	mach_port_t process,
+	mach_port_t thread,
+	string_t wait_desc,
+	mach_msg_id_t *wait_rpc
+);
+
+/* Routine msg_describe_ports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_describe_ports
+(
+	mach_port_t process,
+	mach_port_t refport,
+	mach_port_array_t names,
+	mach_msg_type_number_t namesCnt,
+	data_t *descriptions,
+	mach_msg_type_number_t *descriptionsCnt
+);
+
+
+/* Module msg */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine msg_sig_post */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_sig_post
+(
+	mach_port_t process,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+/* Routine msg_proc_newids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_proc_newids
+(
+	mach_port_t process,
+	mach_port_t task,
+	pid_t ppid,
+	pid_t pgrp,
+	int orphaned
+);
+
+/* Routine msg_add_auth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_add_auth
+(
+	mach_port_t process,
+	auth_t auth
+);
+
+/* Routine msg_del_auth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_del_auth
+(
+	mach_port_t process,
+	mach_port_t task,
+	intarray_t uids,
+	mach_msg_type_number_t uidsCnt,
+	intarray_t gids,
+	mach_msg_type_number_t gidsCnt
+);
+
+/* Routine msg_get_init_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_get_init_port
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	mach_port_t *port
+);
+
+/* Routine msg_set_init_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_set_init_port
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	mach_port_t port,
+	mach_msg_type_name_t portPoly
+);
+
+/* Routine msg_get_init_ports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_get_init_ports
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t *ports,
+	mach_msg_type_number_t *portsCnt
+);
+
+/* Routine msg_set_init_ports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_set_init_ports
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt
+);
+
+/* Routine msg_get_init_int */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_get_init_int
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	int *value
+);
+
+/* Routine msg_set_init_int */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_set_init_int
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	int value
+);
+
+/* Routine msg_get_init_ints */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_get_init_ints
+(
+	mach_port_t process,
+	mach_port_t refport,
+	intarray_t *values,
+	mach_msg_type_number_t *valuesCnt
+);
+
+/* Routine msg_set_init_ints */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_set_init_ints
+(
+	mach_port_t process,
+	mach_port_t refport,
+	intarray_t values,
+	mach_msg_type_number_t valuesCnt
+);
+
+/* Routine msg_get_dtable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_get_dtable
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t *dtable,
+	mach_msg_type_number_t *dtableCnt
+);
+
+/* Routine msg_set_dtable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_set_dtable
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t dtable,
+	mach_msg_type_name_t dtablePoly,
+	mach_msg_type_number_t dtableCnt
+);
+
+/* Routine msg_get_fd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_get_fd
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int fd,
+	mach_port_t *port
+);
+
+/* Routine msg_set_fd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_set_fd
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int fd,
+	mach_port_t port,
+	mach_msg_type_name_t portPoly
+);
+
+/* Routine msg_get_environment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_get_environment
+(
+	mach_port_t process,
+	data_t *value,
+	mach_msg_type_number_t *valueCnt
+);
+
+/* Routine msg_set_environment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_set_environment
+(
+	mach_port_t process,
+	mach_port_t refport,
+	data_t value,
+	mach_msg_type_number_t valueCnt
+);
+
+/* Routine msg_get_env_variable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_get_env_variable
+(
+	mach_port_t process,
+	string_t variable,
+	data_t *value,
+	mach_msg_type_number_t *valueCnt
+);
+
+/* Routine msg_set_env_variable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_set_env_variable
+(
+	mach_port_t process,
+	mach_port_t refport,
+	string_t variable,
+	string_t value,
+	boolean_t replace
+);
+
+/* Routine msg_sig_post_untraced */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_sig_post_untraced
+(
+	mach_port_t process,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+/* Routine msg_report_wait */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_report_wait
+(
+	mach_port_t process,
+	mach_port_t thread,
+	string_t wait_desc,
+	mach_msg_id_t *wait_rpc
+);
+
+/* Routine msg_describe_ports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_describe_ports
+(
+	mach_port_t process,
+	mach_port_t refport,
+	mach_port_array_t names,
+	mach_msg_type_number_t namesCnt,
+	data_t *descriptions,
+	mach_msg_type_number_t *descriptionsCnt
+);
+
+#endif	/* not defined(_msg_user_) */
diff --git a/include/hurd/msg_reply.h b/include/hurd/msg_reply.h
new file mode 100644
index 0000000..60d6a51
--- /dev/null
+++ b/include/hurd/msg_reply.h
@@ -0,0 +1,91 @@
+#ifndef	_msg_reply_user_
+#define	_msg_reply_user_
+
+/* Module msg_reply */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine msg_sig_post_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_sig_post_reply
+(
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine msg_sig_post_untraced_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_sig_post_untraced_reply
+(
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	kern_return_t return_code
+);
+
+
+/* Module msg_reply */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine msg_sig_post_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_sig_post_reply
+(
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	kern_return_t return_code
+);
+
+/* SimpleRoutine msg_sig_post_untraced_reply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_sig_post_untraced_reply
+(
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	kern_return_t return_code
+);
+
+#endif	/* not defined(_msg_reply_user_) */
diff --git a/include/hurd/msg_request.h b/include/hurd/msg_request.h
new file mode 100644
index 0000000..6cde0c6
--- /dev/null
+++ b/include/hurd/msg_request.h
@@ -0,0 +1,103 @@
+#ifndef	_msg_request_user_
+#define	_msg_request_user_
+
+/* Module msg_request */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine msg_sig_post_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_sig_post_request
+(
+	mach_port_t process,
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+/* SimpleRoutine msg_sig_post_untraced_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __msg_sig_post_untraced_request
+(
+	mach_port_t process,
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+
+/* Module msg_request */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine msg_sig_post_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_sig_post_request
+(
+	mach_port_t process,
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+/* SimpleRoutine msg_sig_post_untraced_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t msg_sig_post_untraced_request
+(
+	mach_port_t process,
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+#endif	/* not defined(_msg_request_user_) */
diff --git a/include/hurd/msg_server.h b/include/hurd/msg_server.h
new file mode 100644
index 0000000..58d0c3b
--- /dev/null
+++ b/include/hurd/msg_server.h
@@ -0,0 +1,369 @@
+#ifndef	_msg_server_
+#define	_msg_server_
+
+/* Module msg */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/mig_errors.h>
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine msg_sig_post */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_sig_post
+(
+	mach_port_t process,
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+/* Routine msg_proc_newids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_proc_newids
+(
+	mach_port_t process,
+	mach_port_t task,
+	pid_t ppid,
+	pid_t pgrp,
+	int orphaned
+);
+
+/* Routine msg_add_auth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_add_auth
+(
+	mach_port_t process,
+	auth_t auth
+);
+
+/* Routine msg_del_auth */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_del_auth
+(
+	mach_port_t process,
+	mach_port_t task,
+	intarray_t uids,
+	mach_msg_type_number_t uidsCnt,
+	intarray_t gids,
+	mach_msg_type_number_t gidsCnt
+);
+
+/* Routine msg_get_init_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_get_init_port
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	mach_port_t *port,
+	mach_msg_type_name_t *portPoly
+);
+
+/* Routine msg_set_init_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_set_init_port
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	mach_port_t port
+);
+
+/* Routine msg_get_init_ports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_get_init_ports
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t *ports,
+	mach_msg_type_name_t *portsPoly,
+	mach_msg_type_number_t *portsCnt
+);
+
+/* Routine msg_set_init_ports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_set_init_ports
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t ports,
+	mach_msg_type_number_t portsCnt
+);
+
+/* Routine msg_get_init_int */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_get_init_int
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	int *value
+);
+
+/* Routine msg_set_init_int */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_set_init_int
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int which,
+	int value
+);
+
+/* Routine msg_get_init_ints */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_get_init_ints
+(
+	mach_port_t process,
+	mach_port_t refport,
+	intarray_t *values,
+	mach_msg_type_number_t *valuesCnt
+);
+
+/* Routine msg_set_init_ints */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_set_init_ints
+(
+	mach_port_t process,
+	mach_port_t refport,
+	intarray_t values,
+	mach_msg_type_number_t valuesCnt
+);
+
+/* Routine msg_get_dtable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_get_dtable
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t *dtable,
+	mach_msg_type_name_t *dtablePoly,
+	mach_msg_type_number_t *dtableCnt
+);
+
+/* Routine msg_set_dtable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_set_dtable
+(
+	mach_port_t process,
+	mach_port_t refport,
+	portarray_t dtable,
+	mach_msg_type_number_t dtableCnt
+);
+
+/* Routine msg_get_fd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_get_fd
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int fd,
+	mach_port_t *port,
+	mach_msg_type_name_t *portPoly
+);
+
+/* Routine msg_set_fd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_set_fd
+(
+	mach_port_t process,
+	mach_port_t refport,
+	int fd,
+	mach_port_t port
+);
+
+/* Routine msg_get_environment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_get_environment
+(
+	mach_port_t process,
+	data_t *value,
+	mach_msg_type_number_t *valueCnt
+);
+
+/* Routine msg_set_environment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_set_environment
+(
+	mach_port_t process,
+	mach_port_t refport,
+	data_t value,
+	mach_msg_type_number_t valueCnt
+);
+
+/* Routine msg_get_env_variable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_get_env_variable
+(
+	mach_port_t process,
+	string_t variable,
+	data_t *value,
+	mach_msg_type_number_t *valueCnt
+);
+
+/* Routine msg_set_env_variable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_set_env_variable
+(
+	mach_port_t process,
+	mach_port_t refport,
+	string_t variable,
+	string_t value,
+	boolean_t replace
+);
+
+/* Routine msg_sig_post_untraced */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_sig_post_untraced
+(
+	mach_port_t process,
+	mach_port_t reply_port,
+	mach_msg_type_name_t reply_portPoly,
+	int signal,
+	natural_t sigcode,
+	mach_port_t refport
+);
+
+/* Routine msg_report_wait */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_report_wait
+(
+	mach_port_t process,
+	mach_port_t thread,
+	string_t wait_desc,
+	mach_msg_id_t *wait_rpc
+);
+
+/* Routine msg_describe_ports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_msg_describe_ports
+(
+	mach_port_t process,
+	mach_port_t refport,
+	mach_port_array_t names,
+	mach_msg_type_number_t namesCnt,
+	data_t *descriptions,
+	mach_msg_type_number_t *descriptionsCnt
+);
+
+extern mig_routine_t _S_msg_server_routines[];
+static inline mig_routine_t _S_msg_server_routine
+	(const mach_msg_header_t *InHeadP)
+{
+	int msgh_id;
+
+	msgh_id = InHeadP->msgh_id - 23000;
+
+	if ((msgh_id > 24) || (msgh_id < 0))
+		return 0;
+
+	return _S_msg_server_routines[msgh_id];
+}
+
+#endif	/* not defined(_msg_server_) */
diff --git a/include/hurd/password.h b/include/hurd/password.h
new file mode 100644
index 0000000..1838756
--- /dev/null
+++ b/include/hurd/password.h
@@ -0,0 +1,95 @@
+#ifndef	_password_user_
+#define	_password_user_
+
+/* Module password */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine password_check_user */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __password_check_user
+(
+	io_t server,
+	uid_t user,
+	string_t pw,
+	mach_port_t *auth
+);
+
+/* Routine password_check_group */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __password_check_group
+(
+	io_t server,
+	uid_t group,
+	string_t pw,
+	mach_port_t *auth
+);
+
+
+/* Module password */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine password_check_user */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t password_check_user
+(
+	io_t server,
+	uid_t user,
+	string_t pw,
+	mach_port_t *auth
+);
+
+/* Routine password_check_group */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t password_check_group
+(
+	io_t server,
+	uid_t group,
+	string_t pw,
+	mach_port_t *auth
+);
+
+#endif	/* not defined(_password_user_) */
diff --git a/include/hurd/pfinet.h b/include/hurd/pfinet.h
new file mode 100644
index 0000000..4b6e1b4
--- /dev/null
+++ b/include/hurd/pfinet.h
@@ -0,0 +1,67 @@
+#ifndef	_pfinet_user_
+#define	_pfinet_user_
+
+/* Module pfinet */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine pfinet_siocgifconf */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __pfinet_siocgifconf
+(
+	io_t port,
+	vm_size_t amount,
+	data_t *buf,
+	mach_msg_type_number_t *bufCnt
+);
+
+
+/* Module pfinet */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine pfinet_siocgifconf */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t pfinet_siocgifconf
+(
+	io_t port,
+	vm_size_t amount,
+	data_t *buf,
+	mach_msg_type_number_t *bufCnt
+);
+
+#endif	/* not defined(_pfinet_user_) */
diff --git a/include/hurd/port.h b/include/hurd/port.h
new file mode 100644
index 0000000..ee7caa0
--- /dev/null
+++ b/include/hurd/port.h
@@ -0,0 +1,189 @@
+/* Lightweight user references for ports.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_HURD_PORT_H
+
+#define	_HURD_PORT_H	1
+#include <features.h>
+
+#include <mach.h>
+#include <hurd/userlink.h>
+#include <spin-lock.h>
+#include <hurd/signal.h>
+
+
+/* Structure describing a cell containing a port.  With the lock held, a
+   user extracts PORT, and attaches his own link (in local storage) to the
+   USERS chain.  PORT can then safely be used.  When PORT is no longer
+   needed, with the lock held, the user removes his link from the chain.
+   If his link is the last, and PORT has changed since he fetched it, the
+   user deallocates the port he used.  See <hurd/userlink.h>.  */
+
+struct hurd_port
+  {
+    spin_lock_t lock;		/* Locks rest.  */
+    struct hurd_userlink *users; /* Chain of users; see below.  */
+    mach_port_t port;		/* Port. */
+  };
+
+
+/* Evaluate EXPR with the variable `port' bound to the port in PORTCELL.  */
+
+#define	HURD_PORT_USE(portcell, expr)					      \
+  ({ struct hurd_port *const __p = (portcell);				      \
+     struct hurd_userlink __link;					      \
+     const mach_port_t port = _hurd_port_get (__p, &__link);		      \
+     __typeof(expr) __result = (expr);					      \
+     _hurd_port_free (__p, &__link, port);				      \
+     __result; })
+
+
+#ifndef _HURD_PORT_H_EXTERN_INLINE
+#define _HURD_PORT_H_EXTERN_INLINE __extern_inline
+#endif
+
+
+/* Initialize *PORT to INIT.  */
+
+void _hurd_port_init (struct hurd_port *port, mach_port_t init);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_PORT_H_EXTERN_INLINE void
+_hurd_port_init (struct hurd_port *port, mach_port_t init)
+{
+  __spin_lock_init (&port->lock);
+  port->users = NULL;
+  port->port = init;
+}
+#endif
+
+
+/* Cleanup function for non-local exits.  */
+extern void _hurd_port_cleanup (void *, jmp_buf, int);
+
+/* Get a reference to *PORT, which is locked.
+   Pass return value and LINK to _hurd_port_free when done.  */
+
+mach_port_t
+_hurd_port_locked_get (struct hurd_port *port,
+		       struct hurd_userlink *link);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_PORT_H_EXTERN_INLINE mach_port_t
+_hurd_port_locked_get (struct hurd_port *port,
+		       struct hurd_userlink *link)
+{
+  mach_port_t result;
+  result = port->port;
+  if (result != MACH_PORT_NULL)
+    {
+      link->cleanup = &_hurd_port_cleanup;
+      link->cleanup_data = (void *) result;
+      _hurd_userlink_link (&port->users, link);
+    }
+  __spin_unlock (&port->lock);
+  return result;
+}
+#endif
+
+/* Same, but locks PORT first.  */
+
+mach_port_t
+_hurd_port_get (struct hurd_port *port,
+		struct hurd_userlink *link);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_PORT_H_EXTERN_INLINE mach_port_t
+_hurd_port_get (struct hurd_port *port,
+		struct hurd_userlink *link)
+{
+  mach_port_t result;
+  HURD_CRITICAL_BEGIN;
+  __spin_lock (&port->lock);
+  result = _hurd_port_locked_get (port, link);
+  HURD_CRITICAL_END;
+  return result;
+}
+#endif
+
+
+/* Free a reference gotten with `USED_PORT = _hurd_port_get (PORT, LINK);' */
+
+void
+_hurd_port_free (struct hurd_port *port,
+		 struct hurd_userlink *link,
+		 mach_port_t used_port);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_PORT_H_EXTERN_INLINE void
+_hurd_port_free (struct hurd_port *port,
+		 struct hurd_userlink *link,
+		 mach_port_t used_port)
+{
+  int dealloc;
+  if (used_port == MACH_PORT_NULL)
+    /* When we fetch an empty port cell with _hurd_port_get,
+       it does not link us on the users chain, since there is
+       no shared resource.  */
+    return;
+  HURD_CRITICAL_BEGIN;
+  __spin_lock (&port->lock);
+  dealloc = _hurd_userlink_unlink (link);
+  __spin_unlock (&port->lock);
+  HURD_CRITICAL_END;
+  if (dealloc)
+    __mach_port_deallocate (__mach_task_self (), used_port);
+}
+#endif
+
+
+/* Set *PORT's port to NEWPORT.  NEWPORT's reference is consumed by PORT->port.
+   PORT->lock is locked.  */
+
+void _hurd_port_locked_set (struct hurd_port *port, mach_port_t newport);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_PORT_H_EXTERN_INLINE void
+_hurd_port_locked_set (struct hurd_port *port, mach_port_t newport)
+{
+  mach_port_t old;
+  old = _hurd_userlink_clear (&port->users) ? port->port : MACH_PORT_NULL;
+  port->port = newport;
+  __spin_unlock (&port->lock);
+  if (old != MACH_PORT_NULL)
+    __mach_port_deallocate (__mach_task_self (), old);
+}
+#endif
+
+/* Same, but locks PORT first.  */
+
+void _hurd_port_set (struct hurd_port *port, mach_port_t newport);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_PORT_H_EXTERN_INLINE void
+_hurd_port_set (struct hurd_port *port, mach_port_t newport)
+{
+  HURD_CRITICAL_BEGIN;
+  __spin_lock (&port->lock);
+  _hurd_port_locked_set (port, newport);
+  HURD_CRITICAL_END;
+}
+#endif
+
+
+#endif	/* hurd/port.h */
diff --git a/include/hurd/process.h b/include/hurd/process.h
new file mode 100644
index 0000000..a7d22c7
--- /dev/null
+++ b/include/hurd/process.h
@@ -0,0 +1,1449 @@
+#ifndef	_process_user_
+#define	_process_user_
+
+/* Module process */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine proc_getprivports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getprivports
+(
+	process_t process,
+	mach_port_t *host_priv,
+	mach_port_t *device_master
+);
+
+/* Routine proc_getallpids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getallpids
+(
+	process_t process,
+	pidarray_t *pidarray,
+	mach_msg_type_number_t *pidarrayCnt
+);
+
+/* Routine proc_setexecdata */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setexecdata
+(
+	process_t process,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt,
+	intarray_t ints,
+	mach_msg_type_number_t intsCnt
+);
+
+/* Routine proc_getexecdata */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getexecdata
+(
+	process_t process,
+	portarray_t *ports,
+	mach_msg_type_number_t *portsCnt,
+	intarray_t *ints,
+	mach_msg_type_number_t *intsCnt
+);
+
+/* Routine proc_execdata_notify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_execdata_notify
+(
+	process_t process,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly
+);
+
+/* Routine proc_uname */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_uname
+(
+	process_t process,
+	utsname_t *uname
+);
+
+/* Routine proc_register_version */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_register_version
+(
+	process_t process,
+	mach_port_t credential,
+	string_t name,
+	string_t release,
+	string_t version
+);
+
+/* SimpleRoutine proc_reauthenticate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_reauthenticate
+(
+	process_t process,
+	mach_port_t rendezvous2,
+	mach_msg_type_name_t rendezvous2Poly
+);
+
+/* Routine proc_child */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_child
+(
+	process_t process,
+	mach_port_t child
+);
+
+/* Routine proc_setmsgport */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setmsgport
+(
+	process_t process,
+	mach_port_t newmsgport,
+	mach_port_t *oldmsgport
+);
+
+/* Routine proc_reassign */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_reassign
+(
+	process_t process,
+	mach_port_t newtask
+);
+
+/* Routine proc_setowner */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setowner
+(
+	process_t process,
+	uid_t owner,
+	int clear
+);
+
+/* Routine proc_getpids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getpids
+(
+	process_t process,
+	pid_t *pid,
+	pid_t *ppid,
+	int *orphaned
+);
+
+/* Routine proc_set_arg_locations */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_set_arg_locations
+(
+	process_t process,
+	vm_address_t argv,
+	vm_address_t envp
+);
+
+/* Routine proc_get_arg_locations */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_get_arg_locations
+(
+	process_t process,
+	vm_address_t *argv,
+	vm_address_t *envp
+);
+
+/* Routine proc_getmsgport */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getmsgport
+(
+	process_t process,
+	pid_t pid,
+	mach_port_t *msgport
+);
+
+/* Routine proc_wait */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_wait
+(
+	process_t process,
+	pid_t pid,
+	int options,
+	int *status,
+	int *sigcode,
+	rusage_t *rusage,
+	pid_t *pid_status
+);
+
+/* Routine proc_dostop */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_dostop
+(
+	process_t process,
+	mach_port_t contthread
+);
+
+/* Routine proc_handle_exceptions */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_handle_exceptions
+(
+	process_t process,
+	mach_port_t msgport,
+	mach_port_t forwardport,
+	mach_msg_type_name_t forwardportPoly,
+	int flavor,
+	thread_state_t new_state,
+	mach_msg_type_number_t new_stateCnt
+);
+
+/* Routine proc_mark_stop */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_stop
+(
+	process_t process,
+	int signo,
+	int sigcode
+);
+
+/* Routine proc_mark_cont */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_cont
+(
+	process_t process
+);
+
+/* Routine proc_mark_exit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_exit
+(
+	process_t process,
+	int status,
+	int sigcode
+);
+
+/* Routine proc_mark_exec */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_exec
+(
+	process_t process
+);
+
+/* Routine proc_mark_traced */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_traced
+(
+	process_t process
+);
+
+/* Routine proc_mod_stopchild */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mod_stopchild
+(
+	process_t process,
+	int doit
+);
+
+/* Routine proc_pid2task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_pid2task
+(
+	process_t process,
+	pid_t pid,
+	mach_port_t *task
+);
+
+/* Routine proc_task2pid */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_task2pid
+(
+	process_t process,
+	mach_port_t task,
+	pid_t *pid
+);
+
+/* Routine proc_task2proc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_task2proc
+(
+	process_t process,
+	mach_port_t task,
+	mach_port_t *proc
+);
+
+/* Routine proc_proc2task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_proc2task
+(
+	process_t process,
+	mach_port_t *task
+);
+
+/* Routine proc_pid2proc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_pid2proc
+(
+	process_t process,
+	pid_t pid,
+	mach_port_t *proc
+);
+
+/* Routine proc_getprocinfo */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getprocinfo
+(
+	process_t process,
+	pid_t which,
+	int *flags,
+	procinfo_t *procinfo,
+	mach_msg_type_number_t *procinfoCnt,
+	data_t *threadwaits,
+	mach_msg_type_number_t *threadwaitsCnt
+);
+
+/* Routine proc_getprocargs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getprocargs
+(
+	process_t process,
+	pid_t which,
+	data_t *procargs,
+	mach_msg_type_number_t *procargsCnt
+);
+
+/* Routine proc_getprocenv */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getprocenv
+(
+	process_t process,
+	pid_t which,
+	data_t *procenv,
+	mach_msg_type_number_t *procenvCnt
+);
+
+/* Routine proc_make_login_coll */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_make_login_coll
+(
+	process_t process
+);
+
+/* Routine proc_getloginid */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getloginid
+(
+	process_t process,
+	pid_t pid,
+	pid_t *login_id
+);
+
+/* Routine proc_getloginpids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getloginpids
+(
+	process_t process,
+	pid_t id,
+	pidarray_t *pids,
+	mach_msg_type_number_t *pidsCnt
+);
+
+/* Routine proc_setlogin */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setlogin
+(
+	process_t process,
+	string_t logname
+);
+
+/* Routine proc_getlogin */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getlogin
+(
+	process_t process,
+	string_t logname
+);
+
+/* Routine proc_setsid */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setsid
+(
+	process_t process
+);
+
+/* Routine proc_getsid */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getsid
+(
+	process_t process,
+	pid_t pid,
+	pid_t *sid
+);
+
+/* Routine proc_getsessionpgids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getsessionpgids
+(
+	process_t process,
+	pid_t sid,
+	pidarray_t *pgidset,
+	mach_msg_type_number_t *pgidsetCnt
+);
+
+/* Routine proc_getsessionpids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getsessionpids
+(
+	process_t process,
+	pid_t sid,
+	pidarray_t *pidset,
+	mach_msg_type_number_t *pidsetCnt
+);
+
+/* Routine proc_getsidport */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getsidport
+(
+	process_t process,
+	mach_port_t *sessport
+);
+
+/* Routine proc_setpgrp */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setpgrp
+(
+	process_t process,
+	pid_t pid,
+	pid_t pgrp
+);
+
+/* Routine proc_getpgrp */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getpgrp
+(
+	process_t process,
+	pid_t pid,
+	pid_t *pgrp
+);
+
+/* Routine proc_getpgrppids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getpgrppids
+(
+	process_t process,
+	pid_t pgrp,
+	pidarray_t *pidset,
+	mach_msg_type_number_t *pidsetCnt
+);
+
+/* Routine proc_get_tty */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_get_tty
+(
+	process_t calling_process,
+	pid_t target_process,
+	mach_port_t *tty
+);
+
+/* Routine proc_getnports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getnports
+(
+	process_t process,
+	pid_t which,
+	mach_msg_type_number_t *nports
+);
+
+/* Routine proc_set_init_task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_set_init_task
+(
+	process_t process,
+	mach_port_t task
+);
+
+/* Routine proc_mark_important */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_important
+(
+	process_t process
+);
+
+/* Routine proc_is_important */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_is_important
+(
+	process_t process,
+	boolean_t *essential
+);
+
+/* Routine proc_set_code */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_set_code
+(
+	process_t process,
+	vm_address_t start_code,
+	vm_address_t end_code
+);
+
+/* Routine proc_get_code */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_get_code
+(
+	process_t process,
+	vm_address_t *start_code,
+	vm_address_t *end_code
+);
+
+/* Routine proc_make_task_namespace */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_make_task_namespace
+(
+	process_t process,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly
+);
+
+
+/* Module process */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine proc_getprivports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getprivports
+(
+	process_t process,
+	mach_port_t *host_priv,
+	mach_port_t *device_master
+);
+
+/* Routine proc_getallpids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getallpids
+(
+	process_t process,
+	pidarray_t *pidarray,
+	mach_msg_type_number_t *pidarrayCnt
+);
+
+/* Routine proc_setexecdata */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setexecdata
+(
+	process_t process,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt,
+	intarray_t ints,
+	mach_msg_type_number_t intsCnt
+);
+
+/* Routine proc_getexecdata */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getexecdata
+(
+	process_t process,
+	portarray_t *ports,
+	mach_msg_type_number_t *portsCnt,
+	intarray_t *ints,
+	mach_msg_type_number_t *intsCnt
+);
+
+/* Routine proc_execdata_notify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_execdata_notify
+(
+	process_t process,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly
+);
+
+/* Routine proc_uname */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_uname
+(
+	process_t process,
+	utsname_t *uname
+);
+
+/* Routine proc_register_version */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_register_version
+(
+	process_t process,
+	mach_port_t credential,
+	string_t name,
+	string_t release,
+	string_t version
+);
+
+/* SimpleRoutine proc_reauthenticate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_reauthenticate
+(
+	process_t process,
+	mach_port_t rendezvous2,
+	mach_msg_type_name_t rendezvous2Poly
+);
+
+/* Routine proc_child */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_child
+(
+	process_t process,
+	mach_port_t child
+);
+
+/* Routine proc_setmsgport */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setmsgport
+(
+	process_t process,
+	mach_port_t newmsgport,
+	mach_port_t *oldmsgport
+);
+
+/* Routine proc_reassign */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_reassign
+(
+	process_t process,
+	mach_port_t newtask
+);
+
+/* Routine proc_setowner */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setowner
+(
+	process_t process,
+	uid_t owner,
+	int clear
+);
+
+/* Routine proc_getpids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getpids
+(
+	process_t process,
+	pid_t *pid,
+	pid_t *ppid,
+	int *orphaned
+);
+
+/* Routine proc_set_arg_locations */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_set_arg_locations
+(
+	process_t process,
+	vm_address_t argv,
+	vm_address_t envp
+);
+
+/* Routine proc_get_arg_locations */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_get_arg_locations
+(
+	process_t process,
+	vm_address_t *argv,
+	vm_address_t *envp
+);
+
+/* Routine proc_getmsgport */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getmsgport
+(
+	process_t process,
+	pid_t pid,
+	mach_port_t *msgport
+);
+
+/* Routine proc_wait */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_wait
+(
+	process_t process,
+	pid_t pid,
+	int options,
+	int *status,
+	int *sigcode,
+	rusage_t *rusage,
+	pid_t *pid_status
+);
+
+/* Routine proc_dostop */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_dostop
+(
+	process_t process,
+	mach_port_t contthread
+);
+
+/* Routine proc_handle_exceptions */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_handle_exceptions
+(
+	process_t process,
+	mach_port_t msgport,
+	mach_port_t forwardport,
+	mach_msg_type_name_t forwardportPoly,
+	int flavor,
+	thread_state_t new_state,
+	mach_msg_type_number_t new_stateCnt
+);
+
+/* Routine proc_mark_stop */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_stop
+(
+	process_t process,
+	int signo,
+	int sigcode
+);
+
+/* Routine proc_mark_cont */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_cont
+(
+	process_t process
+);
+
+/* Routine proc_mark_exit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_exit
+(
+	process_t process,
+	int status,
+	int sigcode
+);
+
+/* Routine proc_mark_exec */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_exec
+(
+	process_t process
+);
+
+/* Routine proc_mark_traced */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_traced
+(
+	process_t process
+);
+
+/* Routine proc_mod_stopchild */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mod_stopchild
+(
+	process_t process,
+	int doit
+);
+
+/* Routine proc_pid2task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_pid2task
+(
+	process_t process,
+	pid_t pid,
+	mach_port_t *task
+);
+
+/* Routine proc_task2pid */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_task2pid
+(
+	process_t process,
+	mach_port_t task,
+	pid_t *pid
+);
+
+/* Routine proc_task2proc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_task2proc
+(
+	process_t process,
+	mach_port_t task,
+	mach_port_t *proc
+);
+
+/* Routine proc_proc2task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_proc2task
+(
+	process_t process,
+	mach_port_t *task
+);
+
+/* Routine proc_pid2proc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_pid2proc
+(
+	process_t process,
+	pid_t pid,
+	mach_port_t *proc
+);
+
+/* Routine proc_getprocinfo */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getprocinfo
+(
+	process_t process,
+	pid_t which,
+	int *flags,
+	procinfo_t *procinfo,
+	mach_msg_type_number_t *procinfoCnt,
+	data_t *threadwaits,
+	mach_msg_type_number_t *threadwaitsCnt
+);
+
+/* Routine proc_getprocargs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getprocargs
+(
+	process_t process,
+	pid_t which,
+	data_t *procargs,
+	mach_msg_type_number_t *procargsCnt
+);
+
+/* Routine proc_getprocenv */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getprocenv
+(
+	process_t process,
+	pid_t which,
+	data_t *procenv,
+	mach_msg_type_number_t *procenvCnt
+);
+
+/* Routine proc_make_login_coll */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_make_login_coll
+(
+	process_t process
+);
+
+/* Routine proc_getloginid */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getloginid
+(
+	process_t process,
+	pid_t pid,
+	pid_t *login_id
+);
+
+/* Routine proc_getloginpids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getloginpids
+(
+	process_t process,
+	pid_t id,
+	pidarray_t *pids,
+	mach_msg_type_number_t *pidsCnt
+);
+
+/* Routine proc_setlogin */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setlogin
+(
+	process_t process,
+	string_t logname
+);
+
+/* Routine proc_getlogin */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getlogin
+(
+	process_t process,
+	string_t logname
+);
+
+/* Routine proc_setsid */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setsid
+(
+	process_t process
+);
+
+/* Routine proc_getsid */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getsid
+(
+	process_t process,
+	pid_t pid,
+	pid_t *sid
+);
+
+/* Routine proc_getsessionpgids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getsessionpgids
+(
+	process_t process,
+	pid_t sid,
+	pidarray_t *pgidset,
+	mach_msg_type_number_t *pgidsetCnt
+);
+
+/* Routine proc_getsessionpids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getsessionpids
+(
+	process_t process,
+	pid_t sid,
+	pidarray_t *pidset,
+	mach_msg_type_number_t *pidsetCnt
+);
+
+/* Routine proc_getsidport */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getsidport
+(
+	process_t process,
+	mach_port_t *sessport
+);
+
+/* Routine proc_setpgrp */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setpgrp
+(
+	process_t process,
+	pid_t pid,
+	pid_t pgrp
+);
+
+/* Routine proc_getpgrp */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getpgrp
+(
+	process_t process,
+	pid_t pid,
+	pid_t *pgrp
+);
+
+/* Routine proc_getpgrppids */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getpgrppids
+(
+	process_t process,
+	pid_t pgrp,
+	pidarray_t *pidset,
+	mach_msg_type_number_t *pidsetCnt
+);
+
+/* Routine proc_get_tty */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_get_tty
+(
+	process_t calling_process,
+	pid_t target_process,
+	mach_port_t *tty
+);
+
+/* Routine proc_getnports */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getnports
+(
+	process_t process,
+	pid_t which,
+	mach_msg_type_number_t *nports
+);
+
+/* Routine proc_set_init_task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_set_init_task
+(
+	process_t process,
+	mach_port_t task
+);
+
+/* Routine proc_mark_important */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_important
+(
+	process_t process
+);
+
+/* Routine proc_is_important */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_is_important
+(
+	process_t process,
+	boolean_t *essential
+);
+
+/* Routine proc_set_code */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_set_code
+(
+	process_t process,
+	vm_address_t start_code,
+	vm_address_t end_code
+);
+
+/* Routine proc_get_code */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_get_code
+(
+	process_t process,
+	vm_address_t *start_code,
+	vm_address_t *end_code
+);
+
+/* Routine proc_make_task_namespace */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_make_task_namespace
+(
+	process_t process,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly
+);
+
+#endif	/* not defined(_process_user_) */
diff --git a/include/hurd/process_request.h b/include/hurd/process_request.h
new file mode 100644
index 0000000..71174a6
--- /dev/null
+++ b/include/hurd/process_request.h
@@ -0,0 +1,1455 @@
+#ifndef	_process_user_
+#define	_process_user_
+
+/* Module process */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine proc_getprivports_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getprivports_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_getallpids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getallpids_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_setexecdata_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setexecdata_request
+(
+	process_t process,
+	mach_port_t reply,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt,
+	intarray_t ints,
+	mach_msg_type_number_t intsCnt
+);
+
+/* SimpleRoutine proc_getexecdata_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getexecdata_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_execdata_notify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_execdata_notify_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly
+);
+
+/* SimpleRoutine proc_uname_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_uname_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_register_version_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_register_version_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t credential,
+	string_t name,
+	string_t release,
+	string_t version
+);
+
+/* SimpleRoutine proc_reauthenticate_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_reauthenticate_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t rendezvous2,
+	mach_msg_type_name_t rendezvous2Poly
+);
+
+/* SimpleRoutine proc_child_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_child_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t child
+);
+
+/* SimpleRoutine proc_setmsgport_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setmsgport_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t newmsgport
+);
+
+/* SimpleRoutine proc_reassign_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_reassign_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t newtask
+);
+
+/* SimpleRoutine proc_setowner_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setowner_request
+(
+	process_t process,
+	mach_port_t reply,
+	uid_t owner,
+	int clear
+);
+
+/* SimpleRoutine proc_getpids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getpids_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_set_arg_locations_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_set_arg_locations_request
+(
+	process_t process,
+	mach_port_t reply,
+	vm_address_t argv,
+	vm_address_t envp
+);
+
+/* SimpleRoutine proc_get_arg_locations_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_get_arg_locations_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_getmsgport_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getmsgport_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_wait_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_wait_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid,
+	int options
+);
+
+/* SimpleRoutine proc_dostop_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_dostop_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t contthread
+);
+
+/* SimpleRoutine proc_handle_exceptions_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_handle_exceptions_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t msgport,
+	mach_port_t forwardport,
+	mach_msg_type_name_t forwardportPoly,
+	int flavor,
+	thread_state_t new_state,
+	mach_msg_type_number_t new_stateCnt
+);
+
+/* SimpleRoutine proc_mark_stop_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_stop_request
+(
+	process_t process,
+	mach_port_t reply,
+	int signo,
+	int sigcode
+);
+
+/* SimpleRoutine proc_mark_cont_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_cont_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_mark_exit_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_exit_request
+(
+	process_t process,
+	mach_port_t reply,
+	int status,
+	int sigcode
+);
+
+/* SimpleRoutine proc_mark_exec_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_exec_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_mark_traced_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_traced_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_mod_stopchild_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mod_stopchild_request
+(
+	process_t process,
+	mach_port_t reply,
+	int doit
+);
+
+/* SimpleRoutine proc_pid2task_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_pid2task_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_task2pid_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_task2pid_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t task
+);
+
+/* SimpleRoutine proc_task2proc_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_task2proc_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t task
+);
+
+/* SimpleRoutine proc_proc2task_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_proc2task_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_pid2proc_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_pid2proc_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getprocinfo_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getprocinfo_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t which,
+	int flags
+);
+
+/* SimpleRoutine proc_getprocargs_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getprocargs_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t which
+);
+
+/* SimpleRoutine proc_getprocenv_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getprocenv_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t which
+);
+
+/* SimpleRoutine proc_make_login_coll_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_make_login_coll_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_getloginid_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getloginid_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getloginpids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getloginpids_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t id
+);
+
+/* SimpleRoutine proc_setlogin_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setlogin_request
+(
+	process_t process,
+	mach_port_t reply,
+	string_t logname
+);
+
+/* SimpleRoutine proc_getlogin_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getlogin_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_setsid_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setsid_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_getsid_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getsid_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getsessionpgids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getsessionpgids_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t sid
+);
+
+/* SimpleRoutine proc_getsessionpids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getsessionpids_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t sid
+);
+
+/* SimpleRoutine proc_getsidport_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getsidport_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_setpgrp_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_setpgrp_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid,
+	pid_t pgrp
+);
+
+/* SimpleRoutine proc_getpgrp_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getpgrp_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getpgrppids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getpgrppids_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pgrp
+);
+
+/* SimpleRoutine proc_get_tty_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_get_tty_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getnports_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_getnports_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t which
+);
+
+/* SimpleRoutine proc_set_init_task_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_set_init_task_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t task
+);
+
+/* SimpleRoutine proc_mark_important_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_mark_important_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_is_important_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_is_important_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_set_code_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_set_code_request
+(
+	process_t process,
+	mach_port_t reply,
+	vm_address_t start_code,
+	vm_address_t end_code
+);
+
+/* SimpleRoutine proc_get_code_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_get_code_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_make_task_namespace_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __proc_make_task_namespace_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly
+);
+
+
+/* Module process */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* SimpleRoutine proc_getprivports_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getprivports_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_getallpids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getallpids_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_setexecdata_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setexecdata_request
+(
+	process_t process,
+	mach_port_t reply,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt,
+	intarray_t ints,
+	mach_msg_type_number_t intsCnt
+);
+
+/* SimpleRoutine proc_getexecdata_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getexecdata_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_execdata_notify_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_execdata_notify_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly
+);
+
+/* SimpleRoutine proc_uname_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_uname_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_register_version_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_register_version_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t credential,
+	string_t name,
+	string_t release,
+	string_t version
+);
+
+/* SimpleRoutine proc_reauthenticate_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_reauthenticate_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t rendezvous2,
+	mach_msg_type_name_t rendezvous2Poly
+);
+
+/* SimpleRoutine proc_child_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_child_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t child
+);
+
+/* SimpleRoutine proc_setmsgport_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setmsgport_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t newmsgport
+);
+
+/* SimpleRoutine proc_reassign_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_reassign_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t newtask
+);
+
+/* SimpleRoutine proc_setowner_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setowner_request
+(
+	process_t process,
+	mach_port_t reply,
+	uid_t owner,
+	int clear
+);
+
+/* SimpleRoutine proc_getpids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getpids_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_set_arg_locations_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_set_arg_locations_request
+(
+	process_t process,
+	mach_port_t reply,
+	vm_address_t argv,
+	vm_address_t envp
+);
+
+/* SimpleRoutine proc_get_arg_locations_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_get_arg_locations_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_getmsgport_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getmsgport_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_wait_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_wait_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid,
+	int options
+);
+
+/* SimpleRoutine proc_dostop_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_dostop_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t contthread
+);
+
+/* SimpleRoutine proc_handle_exceptions_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_handle_exceptions_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t msgport,
+	mach_port_t forwardport,
+	mach_msg_type_name_t forwardportPoly,
+	int flavor,
+	thread_state_t new_state,
+	mach_msg_type_number_t new_stateCnt
+);
+
+/* SimpleRoutine proc_mark_stop_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_stop_request
+(
+	process_t process,
+	mach_port_t reply,
+	int signo,
+	int sigcode
+);
+
+/* SimpleRoutine proc_mark_cont_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_cont_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_mark_exit_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_exit_request
+(
+	process_t process,
+	mach_port_t reply,
+	int status,
+	int sigcode
+);
+
+/* SimpleRoutine proc_mark_exec_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_exec_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_mark_traced_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_traced_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_mod_stopchild_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mod_stopchild_request
+(
+	process_t process,
+	mach_port_t reply,
+	int doit
+);
+
+/* SimpleRoutine proc_pid2task_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_pid2task_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_task2pid_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_task2pid_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t task
+);
+
+/* SimpleRoutine proc_task2proc_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_task2proc_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t task
+);
+
+/* SimpleRoutine proc_proc2task_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_proc2task_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_pid2proc_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_pid2proc_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getprocinfo_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getprocinfo_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t which,
+	int flags
+);
+
+/* SimpleRoutine proc_getprocargs_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getprocargs_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t which
+);
+
+/* SimpleRoutine proc_getprocenv_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getprocenv_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t which
+);
+
+/* SimpleRoutine proc_make_login_coll_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_make_login_coll_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_getloginid_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getloginid_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getloginpids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getloginpids_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t id
+);
+
+/* SimpleRoutine proc_setlogin_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setlogin_request
+(
+	process_t process,
+	mach_port_t reply,
+	string_t logname
+);
+
+/* SimpleRoutine proc_getlogin_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getlogin_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_setsid_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setsid_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_getsid_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getsid_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getsessionpgids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getsessionpgids_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t sid
+);
+
+/* SimpleRoutine proc_getsessionpids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getsessionpids_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t sid
+);
+
+/* SimpleRoutine proc_getsidport_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getsidport_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_setpgrp_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_setpgrp_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid,
+	pid_t pgrp
+);
+
+/* SimpleRoutine proc_getpgrp_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getpgrp_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getpgrppids_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getpgrppids_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pgrp
+);
+
+/* SimpleRoutine proc_get_tty_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_get_tty_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t pid
+);
+
+/* SimpleRoutine proc_getnports_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_getnports_request
+(
+	process_t process,
+	mach_port_t reply,
+	pid_t which
+);
+
+/* SimpleRoutine proc_set_init_task_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_set_init_task_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t task
+);
+
+/* SimpleRoutine proc_mark_important_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_mark_important_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_is_important_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_is_important_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_set_code_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_set_code_request
+(
+	process_t process,
+	mach_port_t reply,
+	vm_address_t start_code,
+	vm_address_t end_code
+);
+
+/* SimpleRoutine proc_get_code_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_get_code_request
+(
+	process_t process,
+	mach_port_t reply
+);
+
+/* SimpleRoutine proc_make_task_namespace_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t proc_make_task_namespace_request
+(
+	process_t process,
+	mach_port_t reply,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly
+);
+
+#endif	/* not defined(_process_user_) */
diff --git a/include/hurd/resource.h b/include/hurd/resource.h
new file mode 100644
index 0000000..af9da09
--- /dev/null
+++ b/include/hurd/resource.h
@@ -0,0 +1,51 @@
+/* Resource limits for the Hurd.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _HURD_RESOURCE_H
+#define _HURD_RESOURCE_H
+
+#include <sys/types.h>
+#include <sys/resource.h>
+#include <errno.h>
+#include <hurd/process.h>
+
+/* This array contains the current resource limits for the process.  */
+extern struct rlimit _hurd_rlimits[RLIM_NLIMITS];
+extern struct mutex _hurd_rlimit_lock; /* Locks _hurd_rlimits.  */
+
+
+/* Helper function for getpriority and setpriority.  Maps FN over all the
+   processes specified by WHICH and WHO.  PI is non-null if a
+   proc_getprocinfo was already done; FN may use *PI arbitrarily, it is
+   reset on the next call; PI_FLAGS is passed to proc_getprocinfo.  Returns
+   FN's result the first time it returns nonzero.  If FN never returns
+   nonzero, this returns zero.  */
+extern error_t _hurd_priority_which_map (enum __priority_which which, int who,
+					 error_t (*fn) (pid_t pid,
+							struct procinfo *pi),
+					 int pi_flags);
+
+/* Convert between Mach priority values and the priority
+   values used by getpriority, setpriority, and nice.  */
+#define MACH_PRIORITY_TO_NICE(prio) ((prio) - 25)
+#define NICE_TO_MACH_PRIORITY(nice) ((nice) + 25)
+
+
+
+
+#endif
diff --git a/include/hurd/signal.h b/include/hurd/signal.h
new file mode 100644
index 0000000..73bf976
--- /dev/null
+++ b/include/hurd/signal.h
@@ -0,0 +1,416 @@
+/* Implementing POSIX.1 signals under the Hurd.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_HURD_SIGNAL_H
+
+#define	_HURD_SIGNAL_H	1
+#include <features.h>
+/* Make sure <signal.h> is going to define NSIG.  */
+#ifndef __USE_GNU
+#error "Must have `_GNU_SOURCE' feature test macro to use this file"
+#endif
+
+#define __need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+#include <mach/mach_types.h>
+#include <mach/port.h>
+#include <mach/message.h>
+#include <hurd/hurd_types.h>
+#include <signal.h>
+#include <errno.h>
+#include <hurd/msg.h>
+
+#include <cthreads.h>		/* For `struct mutex'.  */
+#include <setjmp.h>		/* For `jmp_buf'.  */
+#include <spin-lock.h>
+struct hurd_signal_preemptor;	/* <hurd/sigpreempt.h> */
+
+
+/* Full details of a signal.  */
+struct hurd_signal_detail
+  {
+    /* Codes from origination Mach exception_raise message.  */
+    integer_t exc, exc_code, exc_subcode;
+    /* Sigcode as passed or computed from exception codes.  */
+    integer_t code;
+    /* Error code as passed or extracted from exception codes.  */
+    error_t error;
+  };
+
+
+/* Per-thread signal state.  */
+
+struct hurd_sigstate
+  {
+    spin_lock_t critical_section_lock; /* Held if in critical section.  */
+
+    spin_lock_t lock;		/* Locks most of the rest of the structure.  */
+
+    /* The signal state holds a reference on the thread port.  */
+    thread_t thread;
+
+    struct hurd_sigstate *next; /* Linked-list of thread sigstates.  */
+
+    sigset_t blocked;		/* What signals are blocked.  */
+    sigset_t pending;		/* Pending signals, possibly blocked.  */
+
+    /* Signal handlers.  ACTIONS[0] is used to mark the threads with POSIX
+       semantics: if sa_handler is SIG_IGN instead of SIG_DFL, this thread
+       will receive global signals and use the process-wide action vector
+       instead of this one.  */
+    struct sigaction actions[NSIG];
+
+    struct sigaltstack sigaltstack;
+
+    /* Chain of thread-local signal preemptors; see <hurd/sigpreempt.h>.
+       Each element of this chain is in local stack storage, and the chain
+       parallels the stack: the head of this chain is in the innermost
+       stack frame, and each next element in an outermore frame.  */
+    struct hurd_signal_preemptor *preemptors;
+
+    /* For each signal that may be pending, the details to deliver it with.  */
+    struct hurd_signal_detail pending_data[NSIG];
+
+    /* If `suspended' is set when this thread gets a signal,
+       the signal thread sends an empty message to it.  */
+    mach_port_t suspended;
+
+    /* The following members are not locked.  They are used only by this
+       thread, or by the signal thread with this thread suspended.  */
+
+    volatile mach_port_t intr_port; /* Port interruptible RPC was sent on.  */
+
+    /* If this is not null, the thread is in sigreturn awaiting delivery of
+       pending signals.  This context (the machine-dependent portions only)
+       will be passed to sigreturn after running the handler for a pending
+       signal, instead of examining the thread state.  */
+    struct sigcontext *context;
+
+    /* This is the head of the thread's list of active resources; see
+       <hurd/userlink.h> for details.  This member is only used by the
+       thread itself, and always inside a critical section.  */
+    struct hurd_userlink *active_resources;
+
+    /* These are locked normally.  */
+    int cancel;			/* Flag set by hurd_thread_cancel.  */
+    void (*cancel_hook) (void);	/* Called on cancellation.  */
+  };
+
+/* Linked list of states of all threads whose state has been asked for.  */
+
+extern struct hurd_sigstate *_hurd_sigstates;
+
+extern struct mutex _hurd_siglock; /* Locks _hurd_sigstates.  */
+
+/* Get the sigstate of a given thread.  If there was no sigstate for
+   the thread, one is created, and the thread gains a reference.  If
+   the given thread is MACH_PORT_NULL, return the global sigstate.  */
+
+extern struct hurd_sigstate *_hurd_thread_sigstate (thread_t);
+
+/* Get the sigstate of the current thread.
+   This uses a per-thread variable to optimize the lookup.  */
+
+extern struct hurd_sigstate *_hurd_self_sigstate (void)
+     /* This declaration tells the compiler that the value is constant.
+	We assume this won't be called twice from the same stack frame
+	by different threads.  */
+     __attribute__ ((__const__));
+
+/* Process-wide signal state.  */
+
+extern struct hurd_sigstate *_hurd_global_sigstate;
+
+/* Mark the given thread as a process-wide signal receiver.  */
+
+extern void _hurd_sigstate_set_global_rcv (struct hurd_sigstate *ss);
+
+/* A thread can either use its own action vector and pending signal set
+   or use the global ones, depending on wether it has been marked as a
+   global receiver. The accessors below take that into account.  */
+
+extern void _hurd_sigstate_lock (struct hurd_sigstate *ss);
+extern struct sigaction *_hurd_sigstate_actions (struct hurd_sigstate *ss);
+extern sigset_t _hurd_sigstate_pending (const struct hurd_sigstate *ss);
+extern void _hurd_sigstate_unlock (struct hurd_sigstate *ss);
+
+/* Used by libpthread to remove stale sigstate structures.  */
+extern void _hurd_sigstate_delete (thread_t thread);
+
+#ifndef _HURD_SIGNAL_H_EXTERN_INLINE
+#define _HURD_SIGNAL_H_EXTERN_INLINE __extern_inline
+#endif
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_SIGNAL_H_EXTERN_INLINE struct hurd_sigstate *
+_hurd_self_sigstate (void)
+{
+  struct hurd_sigstate **location = &THREAD_SELF->_hurd_sigstate;
+  if (*location == NULL)
+    {
+      thread_t self = __mach_thread_self ();
+      *location = _hurd_thread_sigstate (self);
+      __mach_port_deallocate (__mach_task_self (), self);
+    }
+  return *location;
+}
+#endif
+
+/* Thread listening on our message port; also called the "signal thread".  */
+
+extern thread_t _hurd_msgport_thread;
+
+/* Our message port.  We hold the receive right and _hurd_msgport_thread
+   listens for messages on it.  We also hold a send right, for convenience.  */
+
+extern mach_port_t _hurd_msgport;
+
+/* Resource limit on core file size.  Enforced by hurdsig.c.  */
+extern int _hurd_core_limit;
+
+/* Critical sections.
+
+   A critical section is a section of code which cannot safely be interrupted
+   to run a signal handler; for example, code that holds any lock cannot be
+   interrupted lest the signal handler try to take the same lock and
+   deadlock result.  */
+
+void *_hurd_critical_section_lock (void);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_SIGNAL_H_EXTERN_INLINE void *
+_hurd_critical_section_lock (void)
+{
+  struct hurd_sigstate **location;
+  struct hurd_sigstate *ss;
+
+#ifdef __LIBC_NO_TLS
+  if (__LIBC_NO_TLS())
+    /* TLS is currently initializing, no need to enter critical section.  */
+    return NULL;
+#endif
+
+  location = &THREAD_SELF->_hurd_sigstate;
+  ss = *location;
+  if (ss == NULL)
+    {
+      thread_t self = __mach_thread_self ();
+
+      /* The thread variable is unset; this must be the first time we've
+	 asked for it.  In this case, the critical section flag cannot
+	 possible already be set.  Look up our sigstate structure the slow
+	 way.  */
+      ss = *location = _hurd_thread_sigstate (self);
+      __mach_port_deallocate (__mach_task_self (), self);
+    }
+
+  if (! __spin_try_lock (&ss->critical_section_lock))
+    /* We are already in a critical section, so do nothing.  */
+    return NULL;
+
+  /* With the critical section lock held no signal handler will run.
+     Return our sigstate pointer; this will be passed to
+     _hurd_critical_section_unlock to unlock it.  */
+  return ss;
+}
+#endif
+
+void _hurd_critical_section_unlock (void *our_lock);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_SIGNAL_H_EXTERN_INLINE void
+_hurd_critical_section_unlock (void *our_lock)
+{
+  if (our_lock == NULL)
+    /* The critical section lock was held when we began.  Do nothing.  */
+    return;
+  else
+    {
+      /* It was us who acquired the critical section lock.  Unlock it.  */
+      struct hurd_sigstate *ss = our_lock;
+      sigset_t pending;
+      _hurd_sigstate_lock (ss);
+      __spin_unlock (&ss->critical_section_lock);
+      pending = _hurd_sigstate_pending(ss) & ~ss->blocked;
+      _hurd_sigstate_unlock (ss);
+      if (! __sigisemptyset (&pending))
+	/* There are unblocked signals pending, which weren't
+	   delivered because we were in the critical section.
+	   Tell the signal thread to deliver them now.  */
+	__msg_sig_post (_hurd_msgport, 0, 0, __mach_task_self ());
+    }
+}
+#endif
+
+/* Convenient macros for simple uses of critical sections.
+   These two must be used as a pair at the same C scoping level.  */
+
+#define HURD_CRITICAL_BEGIN \
+  { void *__hurd_critical__ = _hurd_critical_section_lock ()
+#define HURD_CRITICAL_END \
+      _hurd_critical_section_unlock (__hurd_critical__); } while (0)
+
+/* Initialize the signal code, and start the signal thread.
+   Arguments give the "init ints" from exec_startup.  */
+
+extern void _hurdsig_init (const int *intarray, size_t intarraysize);
+
+/* Initialize proc server-assisted fault recovery for the signal thread.  */
+
+extern void _hurdsig_fault_init (void);
+
+/* Raise a signal as described by SIGNO an DETAIL, on the thread whose
+   sigstate SS points to.  If SS is a null pointer, this instead affects
+   the calling thread.  */
+
+extern int _hurd_raise_signal (struct hurd_sigstate *ss, int signo,
+			       const struct hurd_signal_detail *detail);
+
+/* Translate a Mach exception into a signal (machine-dependent).  */
+
+extern void _hurd_exception2signal (struct hurd_signal_detail *detail,
+				    int *signo);
+
+/* Translate a Mach exception into a signal with a legacy sigcode.  */
+
+extern void _hurd_exception2signal_legacy (struct hurd_signal_detail *detail,
+					   int *signo);
+
+
+/* Make the thread described by SS take the signal described by SIGNO and
+   DETAIL.  If the process is traced, this will in fact stop with a SIGNO
+   as the stop signal unless UNTRACED is nonzero.  When the signal can be
+   considered delivered, sends a sig_post reply message on REPLY_PORT
+   indicating success.  SS is not locked.  */
+
+extern void _hurd_internal_post_signal (struct hurd_sigstate *ss,
+					int signo,
+					struct hurd_signal_detail *detail,
+					mach_port_t reply_port,
+					mach_msg_type_name_t reply_port_type,
+					int untraced);
+
+/* Set up STATE and SS to handle signal SIGNO by running HANDLER.  If
+   RPC_WAIT is nonzero, the thread needs to wait for a pending RPC to
+   finish before running the signal handler.  The handler is passed SIGNO,
+   SIGCODE, and the returned `struct sigcontext' (which resides on the
+   stack the handler will use, and which describes the state of the thread
+   encoded in STATE before running the handler).  */
+
+struct machine_thread_all_state;
+extern struct sigcontext *
+_hurd_setup_sighandler (struct hurd_sigstate *ss, __sighandler_t handler,
+			int signo, struct hurd_signal_detail *detail,
+			int rpc_wait, struct machine_thread_all_state *state);
+
+/* Function run by the signal thread to receive from the signal port.  */
+
+extern void _hurd_msgport_receive (void);
+
+/* Set up STATE with a thread state that, when resumed, is
+   like `longjmp (_hurd_sigthread_fault_env, 1)'.  */
+
+extern void _hurd_initialize_fault_recovery_state (void *state);
+
+/* Set up STATE to do the equivalent of `longjmp (ENV, VAL);'.  */
+
+extern void _hurd_longjmp_thread_state (void *state, jmp_buf env, int value);
+
+/* Function run for SIGINFO when its action is SIG_DFL and the current
+   process is the session leader.  */
+
+extern void _hurd_siginfo_handler (int);
+
+/* Replacement for mach_msg used in RPCs to provide Hurd interruption
+   semantics.  Args are all the same as for mach_msg.  intr-rpc.h arranges
+   for this version to be used automatically by the RPC stubs the library
+   builds in place of the normal mach_msg. */
+error_t _hurd_intr_rpc_mach_msg (mach_msg_header_t *msg,
+				 mach_msg_option_t option,
+				 mach_msg_size_t send_size,
+				 mach_msg_size_t rcv_size,
+				 mach_port_t rcv_name,
+				 mach_msg_timeout_t timeout,
+				 mach_port_t notify);
+
+
+/* Milliseconds to wait for an interruptible RPC to return after
+   `interrupt_operation'.  */
+
+extern mach_msg_timeout_t _hurd_interrupted_rpc_timeout;
+
+
+/* Mask of signals that cannot be caught, blocked, or ignored.  */
+#define	_SIG_CANT_MASK	(__sigmask (SIGSTOP) | __sigmask (SIGKILL))
+
+/* Do an RPC to a process's message port.
+
+   Each argument is an expression which returns an error code; each
+   expression may be evaluated several times.  FETCH_MSGPORT_EXPR should
+   fetch the appropriate message port and store it in the local variable
+   `msgport'; it will be deallocated after use.  FETCH_REFPORT_EXPR should
+   fetch the appropriate message port and store it in the local variable
+   `refport' (if no reference port is needed in the call, then
+   FETCH_REFPORT_EXPR should be simply KERN_SUCCESS or 0); if
+   DEALLOC_REFPORT evaluates to nonzero it will be deallocated after use,
+   otherwise the FETCH_REFPORT_EXPR must take care of user references to
+   `refport'.  RPC_EXPR should perform the desired RPC operation using
+   `msgport' and `refport'.
+
+   The reason for the complexity is that a process's message port and
+   reference port may change between fetching those ports and completing an
+   RPC using them (usually they change only when a process execs).  The RPC
+   will fail with MACH_SEND_INVALID_DEST if the msgport dies before we can
+   send the RPC request; or with MIG_SERVER_DIED if the msgport was
+   destroyed after we sent the RPC request but before it was serviced.  In
+   either of these cases, we retry the entire operation, discarding the old
+   message and reference ports and fetch them anew.  */
+
+#define HURD_MSGPORT_RPC(fetch_msgport_expr,				      \
+			 fetch_refport_expr, dealloc_refport,		      \
+			 rpc_expr) 					      \
+({									      \
+    error_t __err;							      \
+    mach_port_t msgport, refport = MACH_PORT_NULL;			      \
+    do									      \
+      {									      \
+	/* Get the message port.  */					      \
+	__err = (fetch_msgport_expr);					      \
+	if (__err)							      \
+	  break;							      \
+	/* Get the reference port.  */					      \
+	__err = (fetch_refport_expr);					      \
+	if (__err)							      \
+	  {								      \
+	    /* Couldn't get it; deallocate MSGPORT and fail.  */	      \
+	    __mach_port_deallocate (__mach_task_self (), msgport);	      \
+	    break;							      \
+	  }								      \
+	__err = (rpc_expr);						      \
+	__mach_port_deallocate (__mach_task_self (), msgport);		      \
+	if ((dealloc_refport) && refport != MACH_PORT_NULL)		      \
+	  __mach_port_deallocate (__mach_task_self (), refport);    	      \
+      } while (__err == MACH_SEND_INVALID_DEST ||			      \
+	       __err == MIG_SERVER_DIED);				      \
+    __err;								      \
+})
+
+
+#endif	/* hurd/signal.h */
diff --git a/include/hurd/sigpreempt.h b/include/hurd/sigpreempt.h
new file mode 100644
index 0000000..3b2e99a
--- /dev/null
+++ b/include/hurd/sigpreempt.h
@@ -0,0 +1,102 @@
+/* Preemption of Hurd signals before POSIX.1 semantics take over.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_HURD_SIGPREEMPT_H
+
+#define	_HURD_SIGPREEMPT_H	1
+#include <errno.h>
+#include <signal.h>		/* For sigset_t, sighandler_t, SIG_ERR.  */
+struct hurd_sigstate;		/* <hurd/signal.h> */
+struct hurd_signal_detail;	/* <hurd/signal.h> */
+
+struct hurd_signal_preemptor
+  {
+    /* These members select which signals this structure will apply to.
+       The rest of the structure is only consulted if these match.  */
+    sigset_t signals;		/* Signals preempted.  */
+    unsigned long int first, last; /* Range of sigcode values preempted.  */
+
+    /* This function will be called (with SS->lock held) to decide what to
+       do with the signal described.  It may modify the codes of the signal
+       passed.  If the return value is SIG_ERR, the next matching preemptor
+       is tried, or the normal handling is done for the signal (which may
+       have been changed by the preemptor function).  Otherwise, the signal
+       is processed as if the return value were its handler setting.  */
+    sighandler_t (*preemptor) (struct hurd_signal_preemptor *preemptor,
+			       struct hurd_sigstate *ss,
+			       int *signo, struct hurd_signal_detail *detail);
+    /* If PREEMPTOR is null, act as if it returned HANDLER.  */
+    sighandler_t handler;
+
+    struct hurd_signal_preemptor *next;	/* List structure.  */
+  };
+
+#define HURD_PREEMPT_SIGNAL_P(preemptor, signo, sigcode) \
+  (((preemptor)->signals & sigmask (signo)) && \
+   (sigcode) >= (preemptor)->first && (sigcode) <= (preemptor)->last)
+
+
+/* Signal preemptors applying to all threads; locked by _hurd_siglock.  */
+extern struct hurd_signal_preemptor *_hurdsig_preemptors;
+extern sigset_t _hurdsig_preempted_set;
+
+
+/* The caller must initialize all members of *PREEMPTOR except `next'.
+   The preemptor is registered on the global list.  */
+void hurd_preempt_signals (struct hurd_signal_preemptor *preemptor);
+
+/* Remove a preemptor registered with hurd_preempt_signals.  */
+void hurd_unpreempt_signals (struct hurd_signal_preemptor *preemptor);
+
+
+/* Call *OPERATE and return its value.  If a signal in SIGSET with a sigcode
+   in the range [FIRST,LAST] arrives during the call, catch it.  If HANDLER
+   is a function, it handles the signal in the normal way (i.e. it should
+   longjmp unless it can restart the insn on return).  If it is SIG_ERR,
+   hurd_catch_signal returns the sc_error value from the signal (or
+   EGRATUITOUS if that is zero).
+
+   The preemptor structure is passed to *OPERATE, which may modify its
+   sigcode range or functions at any time during which it is guaranteed no
+   signal in SIGSET will arrive.  */
+
+error_t hurd_catch_signal (sigset_t sigset,
+			   unsigned long int first, unsigned long int last,
+			   error_t (*operate) (struct hurd_signal_preemptor *),
+			   sighandler_t handler);
+
+
+/* Convenience functions using `hurd_catch_signal'.  */
+
+
+/* Like `memset', but catch faults in DEST.  */
+error_t hurd_safe_memset (void *dest, int byte, size_t nbytes);
+
+/* Like `memcpy', but catch faults in SRC.  */
+error_t hurd_safe_copyin (void *dest, const void *src, size_t nbytes);
+
+/* Like `memcpy', but catch faults in DEST.  */
+error_t hurd_safe_copyout (void *dest, const void *src, size_t nbytes);
+
+/* Like `memmove', but catch faults in SRC or DEST.
+   If only one region is expected to fault, it is more efficient
+   to use `hurd_safe_copyin' or `hurd_safe_copyout' as appropriate.  */
+error_t hurd_safe_memmove (void *dest, const void *src, size_t nbytes);
+
+
+#endif	/* hurd/sigpreempt.h */
diff --git a/include/hurd/socket.h b/include/hurd/socket.h
new file mode 100644
index 0000000..7497e24
--- /dev/null
+++ b/include/hurd/socket.h
@@ -0,0 +1,489 @@
+#ifndef	_socket_user_
+#define	_socket_user_
+
+/* Module socket */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine socket_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_create
+(
+	pf_t server,
+	int sock_type,
+	int protocol,
+	mach_port_t *sock
+);
+
+/* Routine socket_listen */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_listen
+(
+	socket_t sock,
+	int queue_limit
+);
+
+/* Routine socket_accept */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_accept
+(
+	socket_t sock,
+	mach_port_t *conn_sock,
+	mach_port_t *peer_addr
+);
+
+/* Routine socket_connect */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_connect
+(
+	socket_t sock,
+	addr_port_t addr
+);
+
+/* Routine socket_bind */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_bind
+(
+	socket_t sock,
+	addr_port_t addr
+);
+
+/* Routine socket_name */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_name
+(
+	socket_t sock,
+	mach_port_t *addr
+);
+
+/* Routine socket_peername */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_peername
+(
+	socket_t sock,
+	mach_port_t *addr
+);
+
+/* Routine socket_connect2 */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_connect2
+(
+	socket_t sock1,
+	socket_t sock2
+);
+
+/* Routine socket_create_address */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_create_address
+(
+	mach_port_t server,
+	int sockaddr_type,
+	data_t sockaddr,
+	mach_msg_type_number_t sockaddrCnt,
+	mach_port_t *addr
+);
+
+/* Routine socket_fabricate_address */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_fabricate_address
+(
+	mach_port_t server,
+	int sockaddr_type,
+	mach_port_t *addr
+);
+
+/* Routine socket_whatis_address */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_whatis_address
+(
+	addr_port_t addr,
+	int *sockaddr_type,
+	data_t *sockaddr,
+	mach_msg_type_number_t *sockaddrCnt
+);
+
+/* Routine socket_shutdown */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_shutdown
+(
+	socket_t sock,
+	int direction
+);
+
+/* Routine socket_getopt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_getopt
+(
+	socket_t sock,
+	int level,
+	int option,
+	data_t *optval,
+	mach_msg_type_number_t *optvalCnt
+);
+
+/* Routine socket_setopt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_setopt
+(
+	socket_t sock,
+	int level,
+	int option,
+	data_t optval,
+	mach_msg_type_number_t optvalCnt
+);
+
+/* Routine socket_send */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_send
+(
+	socket_t sock,
+	addr_port_t addr,
+	int flags,
+	data_t data,
+	mach_msg_type_number_t dataCnt,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt,
+	data_t control,
+	mach_msg_type_number_t controlCnt,
+	vm_size_t *amount
+);
+
+/* Routine socket_recv */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __socket_recv
+(
+	socket_t sock,
+	mach_port_t *addr,
+	int flags,
+	data_t *data,
+	mach_msg_type_number_t *dataCnt,
+	portarray_t *ports,
+	mach_msg_type_number_t *portsCnt,
+	data_t *control,
+	mach_msg_type_number_t *controlCnt,
+	int *outflags,
+	vm_size_t amount
+);
+
+
+/* Module socket */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine socket_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_create
+(
+	pf_t server,
+	int sock_type,
+	int protocol,
+	mach_port_t *sock
+);
+
+/* Routine socket_listen */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_listen
+(
+	socket_t sock,
+	int queue_limit
+);
+
+/* Routine socket_accept */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_accept
+(
+	socket_t sock,
+	mach_port_t *conn_sock,
+	mach_port_t *peer_addr
+);
+
+/* Routine socket_connect */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_connect
+(
+	socket_t sock,
+	addr_port_t addr
+);
+
+/* Routine socket_bind */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_bind
+(
+	socket_t sock,
+	addr_port_t addr
+);
+
+/* Routine socket_name */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_name
+(
+	socket_t sock,
+	mach_port_t *addr
+);
+
+/* Routine socket_peername */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_peername
+(
+	socket_t sock,
+	mach_port_t *addr
+);
+
+/* Routine socket_connect2 */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_connect2
+(
+	socket_t sock1,
+	socket_t sock2
+);
+
+/* Routine socket_create_address */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_create_address
+(
+	mach_port_t server,
+	int sockaddr_type,
+	data_t sockaddr,
+	mach_msg_type_number_t sockaddrCnt,
+	mach_port_t *addr
+);
+
+/* Routine socket_fabricate_address */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_fabricate_address
+(
+	mach_port_t server,
+	int sockaddr_type,
+	mach_port_t *addr
+);
+
+/* Routine socket_whatis_address */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_whatis_address
+(
+	addr_port_t addr,
+	int *sockaddr_type,
+	data_t *sockaddr,
+	mach_msg_type_number_t *sockaddrCnt
+);
+
+/* Routine socket_shutdown */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_shutdown
+(
+	socket_t sock,
+	int direction
+);
+
+/* Routine socket_getopt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_getopt
+(
+	socket_t sock,
+	int level,
+	int option,
+	data_t *optval,
+	mach_msg_type_number_t *optvalCnt
+);
+
+/* Routine socket_setopt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_setopt
+(
+	socket_t sock,
+	int level,
+	int option,
+	data_t optval,
+	mach_msg_type_number_t optvalCnt
+);
+
+/* Routine socket_send */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_send
+(
+	socket_t sock,
+	addr_port_t addr,
+	int flags,
+	data_t data,
+	mach_msg_type_number_t dataCnt,
+	portarray_t ports,
+	mach_msg_type_name_t portsPoly,
+	mach_msg_type_number_t portsCnt,
+	data_t control,
+	mach_msg_type_number_t controlCnt,
+	vm_size_t *amount
+);
+
+/* Routine socket_recv */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t socket_recv
+(
+	socket_t sock,
+	mach_port_t *addr,
+	int flags,
+	data_t *data,
+	mach_msg_type_number_t *dataCnt,
+	portarray_t *ports,
+	mach_msg_type_number_t *portsCnt,
+	data_t *control,
+	mach_msg_type_number_t *controlCnt,
+	int *outflags,
+	vm_size_t amount
+);
+
+#endif	/* not defined(_socket_user_) */
diff --git a/include/hurd/startup.h b/include/hurd/startup.h
new file mode 100644
index 0000000..1ced463
--- /dev/null
+++ b/include/hurd/startup.h
@@ -0,0 +1,183 @@
+#ifndef	_startup_user_
+#define	_startup_user_
+
+/* Module startup */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine startup_essential_task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __startup_essential_task
+(
+	startup_t server,
+	mach_port_t task,
+	mach_port_t excpt,
+	string_t name,
+	mach_port_t credential
+);
+
+/* Routine startup_request_notification */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __startup_request_notification
+(
+	startup_t server,
+	mach_port_t notify_port,
+	mach_msg_type_name_t notify_portPoly,
+	string_t name
+);
+
+/* Routine startup_reboot */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __startup_reboot
+(
+	startup_t server,
+	mach_port_t refport,
+	int reboot_code
+);
+
+/* Routine startup_procinit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __startup_procinit
+(
+	startup_t server,
+	process_t startup_proc,
+	mach_port_t *startup_task,
+	auth_t *auth,
+	mach_port_t *host_priv,
+	mach_port_t *device_master
+);
+
+/* Routine startup_authinit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __startup_authinit
+(
+	startup_t server,
+	mach_port_t auth,
+	mach_msg_type_name_t authPoly,
+	mach_port_t *proc
+);
+
+
+/* Module startup */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine startup_essential_task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t startup_essential_task
+(
+	startup_t server,
+	mach_port_t task,
+	mach_port_t excpt,
+	string_t name,
+	mach_port_t credential
+);
+
+/* Routine startup_request_notification */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t startup_request_notification
+(
+	startup_t server,
+	mach_port_t notify_port,
+	mach_msg_type_name_t notify_portPoly,
+	string_t name
+);
+
+/* Routine startup_reboot */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t startup_reboot
+(
+	startup_t server,
+	mach_port_t refport,
+	int reboot_code
+);
+
+/* Routine startup_procinit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t startup_procinit
+(
+	startup_t server,
+	process_t startup_proc,
+	mach_port_t *startup_task,
+	auth_t *auth,
+	mach_port_t *host_priv,
+	mach_port_t *device_master
+);
+
+/* Routine startup_authinit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t startup_authinit
+(
+	startup_t server,
+	mach_port_t auth,
+	mach_msg_type_name_t authPoly,
+	mach_port_t *proc
+);
+
+#endif	/* not defined(_startup_user_) */
diff --git a/include/hurd/term.h b/include/hurd/term.h
new file mode 100644
index 0000000..0792a18
--- /dev/null
+++ b/include/hurd/term.h
@@ -0,0 +1,309 @@
+#ifndef	_term_user_
+#define	_term_user_
+
+/* Module term */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine term_getctty */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_getctty
+(
+	io_t terminal,
+	mach_port_t *ctty
+);
+
+/* Routine term_open_ctty */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_open_ctty
+(
+	io_t terminal,
+	pid_t pid,
+	pid_t pgrp,
+	mach_port_t *newtty
+);
+
+/* Routine term_set_nodename */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_set_nodename
+(
+	io_t terminal,
+	string_t name
+);
+
+/* Routine term_get_nodename */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_get_nodename
+(
+	io_t terminal,
+	string_t name
+);
+
+/* Routine term_set_filenode */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_set_filenode
+(
+	io_t terminal,
+	file_t filenode
+);
+
+/* Routine term_get_bottom_type */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_get_bottom_type
+(
+	io_t terminal,
+	int *ttype
+);
+
+/* Routine term_on_machdev */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_on_machdev
+(
+	io_t terminal,
+	mach_port_t machdev
+);
+
+/* Routine term_on_hurddev */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_on_hurddev
+(
+	io_t terminal,
+	io_t hurddev
+);
+
+/* Routine term_on_pty */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_on_pty
+(
+	io_t terminal,
+	io_t *ptymaster
+);
+
+/* Routine termctty_open_terminal */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __termctty_open_terminal
+(
+	ctty_t ctty,
+	int flags,
+	mach_port_t *terminal
+);
+
+/* Routine term_get_peername */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __term_get_peername
+(
+	io_t terminal,
+	string_t name
+);
+
+
+/* Module term */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+
+/* Routine term_getctty */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_getctty
+(
+	io_t terminal,
+	mach_port_t *ctty
+);
+
+/* Routine term_open_ctty */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_open_ctty
+(
+	io_t terminal,
+	pid_t pid,
+	pid_t pgrp,
+	mach_port_t *newtty
+);
+
+/* Routine term_set_nodename */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_set_nodename
+(
+	io_t terminal,
+	string_t name
+);
+
+/* Routine term_get_nodename */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_get_nodename
+(
+	io_t terminal,
+	string_t name
+);
+
+/* Routine term_set_filenode */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_set_filenode
+(
+	io_t terminal,
+	file_t filenode
+);
+
+/* Routine term_get_bottom_type */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_get_bottom_type
+(
+	io_t terminal,
+	int *ttype
+);
+
+/* Routine term_on_machdev */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_on_machdev
+(
+	io_t terminal,
+	mach_port_t machdev
+);
+
+/* Routine term_on_hurddev */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_on_hurddev
+(
+	io_t terminal,
+	io_t hurddev
+);
+
+/* Routine term_on_pty */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_on_pty
+(
+	io_t terminal,
+	io_t *ptymaster
+);
+
+/* Routine termctty_open_terminal */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t termctty_open_terminal
+(
+	ctty_t ctty,
+	int flags,
+	mach_port_t *terminal
+);
+
+/* Routine term_get_peername */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t term_get_peername
+(
+	io_t terminal,
+	string_t name
+);
+
+#endif	/* not defined(_term_user_) */
diff --git a/include/hurd/threadvar.h b/include/hurd/threadvar.h
new file mode 100644
index 0000000..41cf2d5
--- /dev/null
+++ b/include/hurd/threadvar.h
@@ -0,0 +1,54 @@
+/* Internal per-thread variables for the Hurd.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _HURD_THREADVAR_H
+#define	_HURD_THREADVAR_H
+
+#include <features.h>
+#include <tls.h>
+
+/* The per-thread variables are found by ANDing this mask
+   with the value of the stack pointer and then adding this offset.
+
+   In the multi-threaded case, cthreads initialization sets
+   __hurd_threadvar_stack_mask to ~(cthread_stack_size - 1), a mask which
+   finds the base of the fixed-size cthreads stack; and
+   __hurd_threadvar_stack_offset to a small offset that skips the data
+   cthreads itself maintains at the base of each thread's stack.
+
+   In the single-threaded or libpthread case, __hurd_threadvar_stack_mask is
+   zero, so the stack pointer is ignored. */
+
+extern unsigned long int __hurd_threadvar_stack_mask;
+extern unsigned long int __hurd_threadvar_stack_offset;
+
+/* The variables __hurd_sigthread_stack_base and
+   __hurd_sigthread_stack_end define the bounds of the stack used by the
+   signal thread, so that thread can always be specifically identified.  */
+
+extern unsigned long int __hurd_sigthread_stack_base;
+extern unsigned long int __hurd_sigthread_stack_end;
+
+
+/* We do not use threadvars any more, this is kept as zero for compatibility with cthreads */
+extern unsigned int __hurd_threadvar_max;
+
+extern mach_port_t __hurd_reply_port0;
+#define __hurd_local_reply_port (*(__LIBC_NO_TLS() ? &__hurd_reply_port0 : &THREAD_SELF->reply_port))
+
+#endif	/* hurd/threadvar.h */
diff --git a/include/hurd/tioctl.h b/include/hurd/tioctl.h
new file mode 100644
index 0000000..84d80b1
--- /dev/null
+++ b/include/hurd/tioctl.h
@@ -0,0 +1,831 @@
+#ifndef	_tioctl_user_
+#define	_tioctl_user_
+
+/* Module tioctl */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+#include <hurd/ioctl_types.h>
+
+/* Routine tioctl_tiocmodg */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocmodg
+(
+	io_t reqport,
+	int *state
+);
+
+/* Routine tioctl_tiocmods */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocmods
+(
+	io_t reqport,
+	int state
+);
+
+/* Routine tioctl_tiocexcl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocexcl
+(
+	io_t reqport
+);
+
+/* Routine tioctl_tiocnxcl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocnxcl
+(
+	io_t reqport
+);
+
+/* Routine tioctl_tiocflush */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocflush
+(
+	io_t reqport,
+	int queue_selector
+);
+
+/* Routine tioctl_tiocgeta */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocgeta
+(
+	io_t port,
+	modes_t modes,
+	ccs_t ccs,
+	speeds_t speeds
+);
+
+/* Routine tioctl_tiocseta */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocseta
+(
+	io_t port,
+	modes_t modes,
+	ccs_t ccs,
+	speeds_t speeds
+);
+
+/* Routine tioctl_tiocsetaw */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocsetaw
+(
+	io_t port,
+	modes_t modes,
+	ccs_t ccs,
+	speeds_t speeds
+);
+
+/* Routine tioctl_tiocsetaf */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocsetaf
+(
+	io_t port,
+	modes_t modes,
+	ccs_t ccs,
+	speeds_t speeds
+);
+
+/* Routine tioctl_tiocgetd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocgetd
+(
+	io_t port,
+	int *discipline
+);
+
+/* Routine tioctl_tiocsetd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocsetd
+(
+	io_t port,
+	int discipline
+);
+
+/* Routine tioctl_tiocdrain */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocdrain
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocsig */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocsig
+(
+	io_t port,
+	int signal
+);
+
+/* Routine tioctl_tiocext */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocext
+(
+	io_t port,
+	int mode
+);
+
+/* Routine tioctl_tiocucntl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocucntl
+(
+	io_t port,
+	int set_or_clear
+);
+
+/* Routine tioctl_tiocswinsz */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocswinsz
+(
+	io_t port,
+	winsize_t sizes
+);
+
+/* Routine tioctl_tiocgwinsz */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocgwinsz
+(
+	io_t port,
+	winsize_t *sizes
+);
+
+/* Routine tioctl_tiocremote */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocremote
+(
+	io_t port,
+	int on_or_off
+);
+
+/* Routine tioctl_tiocmget */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocmget
+(
+	io_t port,
+	int *bits
+);
+
+/* Routine tioctl_tiocmbic */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocmbic
+(
+	io_t port,
+	int bits
+);
+
+/* Routine tioctl_tiocmbis */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocmbis
+(
+	io_t port,
+	int bits
+);
+
+/* Routine tioctl_tiocmset */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocmset
+(
+	io_t port,
+	int bits
+);
+
+/* Routine tioctl_tiocstart */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocstart
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocstop */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocstop
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocpkt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocpkt
+(
+	io_t port,
+	int on_or_off
+);
+
+/* Routine tioctl_tiocsti */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocsti
+(
+	io_t port,
+	char datum
+);
+
+/* Routine tioctl_tiocoutq */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocoutq
+(
+	io_t port,
+	int *queue_size
+);
+
+/* Routine tioctl_tiocspgrp */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocspgrp
+(
+	io_t port,
+	int pgrp
+);
+
+/* Routine tioctl_tiocgpgrp */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocgpgrp
+(
+	io_t port,
+	int *pgrp
+);
+
+/* Routine tioctl_tioccdtr */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tioccdtr
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocsdtr */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocsdtr
+(
+	io_t port
+);
+
+/* Routine tioctl_tioccbrk */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tioccbrk
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocsbrk */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __tioctl_tiocsbrk
+(
+	io_t port
+);
+
+
+/* Module tioctl */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <device/device_types.h>
+#include <device/net_status.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <hurd/hurd_types.h>
+#include <hurd/ioctl_types.h>
+
+/* Routine tioctl_tiocmodg */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocmodg
+(
+	io_t reqport,
+	int *state
+);
+
+/* Routine tioctl_tiocmods */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocmods
+(
+	io_t reqport,
+	int state
+);
+
+/* Routine tioctl_tiocexcl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocexcl
+(
+	io_t reqport
+);
+
+/* Routine tioctl_tiocnxcl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocnxcl
+(
+	io_t reqport
+);
+
+/* Routine tioctl_tiocflush */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocflush
+(
+	io_t reqport,
+	int queue_selector
+);
+
+/* Routine tioctl_tiocgeta */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocgeta
+(
+	io_t port,
+	modes_t modes,
+	ccs_t ccs,
+	speeds_t speeds
+);
+
+/* Routine tioctl_tiocseta */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocseta
+(
+	io_t port,
+	modes_t modes,
+	ccs_t ccs,
+	speeds_t speeds
+);
+
+/* Routine tioctl_tiocsetaw */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocsetaw
+(
+	io_t port,
+	modes_t modes,
+	ccs_t ccs,
+	speeds_t speeds
+);
+
+/* Routine tioctl_tiocsetaf */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocsetaf
+(
+	io_t port,
+	modes_t modes,
+	ccs_t ccs,
+	speeds_t speeds
+);
+
+/* Routine tioctl_tiocgetd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocgetd
+(
+	io_t port,
+	int *discipline
+);
+
+/* Routine tioctl_tiocsetd */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocsetd
+(
+	io_t port,
+	int discipline
+);
+
+/* Routine tioctl_tiocdrain */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocdrain
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocsig */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocsig
+(
+	io_t port,
+	int signal
+);
+
+/* Routine tioctl_tiocext */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocext
+(
+	io_t port,
+	int mode
+);
+
+/* Routine tioctl_tiocucntl */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocucntl
+(
+	io_t port,
+	int set_or_clear
+);
+
+/* Routine tioctl_tiocswinsz */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocswinsz
+(
+	io_t port,
+	winsize_t sizes
+);
+
+/* Routine tioctl_tiocgwinsz */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocgwinsz
+(
+	io_t port,
+	winsize_t *sizes
+);
+
+/* Routine tioctl_tiocremote */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocremote
+(
+	io_t port,
+	int on_or_off
+);
+
+/* Routine tioctl_tiocmget */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocmget
+(
+	io_t port,
+	int *bits
+);
+
+/* Routine tioctl_tiocmbic */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocmbic
+(
+	io_t port,
+	int bits
+);
+
+/* Routine tioctl_tiocmbis */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocmbis
+(
+	io_t port,
+	int bits
+);
+
+/* Routine tioctl_tiocmset */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocmset
+(
+	io_t port,
+	int bits
+);
+
+/* Routine tioctl_tiocstart */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocstart
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocstop */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocstop
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocpkt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocpkt
+(
+	io_t port,
+	int on_or_off
+);
+
+/* Routine tioctl_tiocsti */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocsti
+(
+	io_t port,
+	char datum
+);
+
+/* Routine tioctl_tiocoutq */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocoutq
+(
+	io_t port,
+	int *queue_size
+);
+
+/* Routine tioctl_tiocspgrp */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocspgrp
+(
+	io_t port,
+	int pgrp
+);
+
+/* Routine tioctl_tiocgpgrp */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocgpgrp
+(
+	io_t port,
+	int *pgrp
+);
+
+/* Routine tioctl_tioccdtr */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tioccdtr
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocsdtr */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocsdtr
+(
+	io_t port
+);
+
+/* Routine tioctl_tioccbrk */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tioccbrk
+(
+	io_t port
+);
+
+/* Routine tioctl_tiocsbrk */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t tioctl_tiocsbrk
+(
+	io_t port
+);
+
+#endif	/* not defined(_tioctl_user_) */
diff --git a/include/hurd/userlink.h b/include/hurd/userlink.h
new file mode 100644
index 0000000..03a9d60
--- /dev/null
+++ b/include/hurd/userlink.h
@@ -0,0 +1,161 @@
+/* Support for chains recording users of a resource; `struct hurd_userlink'.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_HURD_USERLINK_H
+
+#define	_HURD_USERLINK_H	1
+#include <features.h>
+
+#define __need_NULL
+#include <stddef.h>
+
+#include <hurd/signal.h>
+#include <setjmp.h>
+
+
+/* This structure records a link in two doubly-linked lists.
+   We call these the per-resource user list and the per-thread
+   active-resource list.
+
+   Users of a given resource are recorded by their presence in a list
+   associated with that resource.  A user attaches his own link (in local
+   storage on his stack) to a shared chain at the time he begins using some
+   resource.  When finished with that resource, the user removes his link
+   from the chain.  If his link is the last (there are no other users of
+   the resource), and his chain has been detached from the shared cell (the
+   resource in the cell has been replaced), then the user deallocates the
+   resource that he used.
+
+   All uses of shared resources by a single thread are linked together by
+   its `active-resource' list; the head of this list is stored in the
+   per-thread sigstate structure.  When the thread makes a non-local exit
+   (i.e. longjmp), it will examine its active-resource list, and each link
+   residing in a stack frame being jumped out of will be unlinked from both
+   the resource's user list and the thread's active-resource list, and
+   deallocate the resource if that was the last user link for that resource.
+
+   NOTE: Access to a thread's active-resource list must always be done
+   inside a signal-proof critical section; the functions in this file
+   assume they are called inside a critical section, and do no locking of
+   their own.  Also important: the longjmp cleanup relies on all userlink
+   structures residing on the stack of the using thread.  */
+
+struct hurd_userlink
+  {
+    struct
+      {
+	struct hurd_userlink *next, **prevp;
+      } resource, thread;
+
+    /* This function is called when a non-local exit
+       unwinds the frame containing this link.  */
+    void (*cleanup) (void *cleanup_data, jmp_buf env, int val);
+    void *cleanup_data;
+  };
+
+
+#ifndef _HURD_USERLINK_H_EXTERN_INLINE
+#define _HURD_USERLINK_H_EXTERN_INLINE __extern_inline
+#endif
+
+
+/* Attach LINK to the chain of users at *CHAINP.  */
+
+void
+_hurd_userlink_link (struct hurd_userlink **chainp,
+		     struct hurd_userlink *link);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_USERLINK_H_EXTERN_INLINE void
+_hurd_userlink_link (struct hurd_userlink **chainp,
+		     struct hurd_userlink *link)
+{
+  struct hurd_userlink **thread_chainp;
+
+  link->resource.next = *chainp;
+  if (link->resource.next)
+    link->resource.next->resource.prevp = &link->resource.next;
+  link->resource.prevp = chainp;
+  *chainp = link;
+
+  /* Also chain it on the current thread's list of active resources.  */
+  thread_chainp = &_hurd_self_sigstate ()->active_resources;
+  link->thread.next = *thread_chainp;
+  if (link->thread.next)
+    link->thread.next->thread.prevp = &link->thread.next;
+  link->thread.prevp = thread_chainp;
+  *thread_chainp = link;
+}
+#endif
+
+
+/* Detach LINK from its chain.  Returns nonzero iff this was the
+   last user of the resource and it should be deallocated.  */
+
+int _hurd_userlink_unlink (struct hurd_userlink *link);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_USERLINK_H_EXTERN_INLINE int
+_hurd_userlink_unlink (struct hurd_userlink *link)
+{
+  /* We should deallocate the resource used if this chain has been detached
+     from the cell (and thus has a nil `prevp'), and there is no next link
+     representing another user reference to the same resource. */
+  int dealloc = ! link->resource.next && ! link->resource.prevp;
+
+  /* Remove our link from the chain of current users.  */
+  if (link->resource.prevp)
+    *link->resource.prevp = link->resource.next;
+  if (link->resource.next)
+    link->resource.next->resource.prevp = link->resource.prevp;
+
+  /* Remove our link from the chain of currently active resources
+     for this thread.  */
+  *link->thread.prevp = link->thread.next;
+  if (link->thread.next)
+    link->thread.next->thread.prevp = link->thread.prevp;
+
+  return dealloc;
+}
+#endif
+
+
+/* Clear all users from *CHAINP.  Call this when the resource *CHAINP
+   protects is changing.  If the return value is nonzero, no users are on
+   the chain and the caller should deallocate the resource.  If the return
+   value is zero, someone is still using the resource and they will
+   deallocate it when they are finished.  */
+
+int _hurd_userlink_clear (struct hurd_userlink **chainp);
+
+#if defined __USE_EXTERN_INLINES && defined _LIBC && !defined NOT_IN_libc
+_HURD_USERLINK_H_EXTERN_INLINE int
+_hurd_userlink_clear (struct hurd_userlink **chainp)
+{
+  if (*chainp == NULL)
+    return 1;
+
+  /* Detach the chain of current users from the cell.  The last user to
+     remove his link from that chain will deallocate the old resource.  */
+  (*chainp)->resource.prevp = NULL;
+  *chainp = NULL;
+  return 0;
+}
+#endif
+
+#endif	/* hurd/userlink.h */
diff --git a/include/iconv.h b/include/iconv.h
new file mode 100644
index 0000000..a2be49d
--- /dev/null
+++ b/include/iconv.h
@@ -0,0 +1,55 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ICONV_H
+#define _ICONV_H	1
+
+#include <features.h>
+#define __need_size_t
+#include <stddef.h>
+
+
+__BEGIN_DECLS
+
+/* Identifier for conversion method from one codeset to another.  */
+typedef void *iconv_t;
+
+
+/* Allocate descriptor for code conversion from codeset FROMCODE to
+   codeset TOCODE.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern iconv_t iconv_open (const char *__tocode, const char *__fromcode);
+
+/* Convert at most *INBYTESLEFT bytes from *INBUF according to the
+   code conversion algorithm specified by CD and place up to
+   *OUTBYTESLEFT bytes in buffer at *OUTBUF.  */
+extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
+		     size_t *__restrict __inbytesleft,
+		     char **__restrict __outbuf,
+		     size_t *__restrict __outbytesleft);
+
+/* Free resources allocated for descriptor CD for code conversion.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int iconv_close (iconv_t __cd);
+
+__END_DECLS
+
+#endif /* iconv.h */
diff --git a/include/ieee754.h b/include/ieee754.h
new file mode 100644
index 0000000..48d9360
--- /dev/null
+++ b/include/ieee754.h
@@ -0,0 +1,198 @@
+/* Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _IEEE754_H
+
+#define _IEEE754_H 1
+#include <features.h>
+
+#include <endian.h>
+
+__BEGIN_DECLS
+
+union ieee754_float
+  {
+    float f;
+
+    /* This is the IEEE 754 single-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int mantissa:23;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:23;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa:22;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:22;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee_nan;
+  };
+
+#define IEEE754_FLOAT_BIAS	0x7f /* Added to exponent.  */
+
+
+union ieee754_double
+  {
+    double d;
+
+    /* This is the IEEE 754 double-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:20;
+	unsigned int mantissa1:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:19;
+	unsigned int mantissa1:32;
+#else
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE754_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
+
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:32;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee;
+
+    /* This is for NaNs in the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int one:1;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa0:30;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS 0x3fff
+
+__END_DECLS
+
+#endif /* ieee754.h */
diff --git a/include/ifaddrs.h b/include/ifaddrs.h
new file mode 100644
index 0000000..e555102
--- /dev/null
+++ b/include/ifaddrs.h
@@ -0,0 +1,73 @@
+/* ifaddrs.h -- declarations for getting network interface addresses
+   Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _IFADDRS_H
+#define _IFADDRS_H	1
+
+#include <features.h>
+#include <sys/socket.h>
+
+__BEGIN_DECLS
+
+/* The `getifaddrs' function generates a linked list of these structures.
+   Each element of the list describes one network interface.  */
+struct ifaddrs
+{
+  struct ifaddrs *ifa_next;	/* Pointer to the next structure.  */
+
+  char *ifa_name;		/* Name of this network interface.  */
+  unsigned int ifa_flags;	/* Flags as from SIOCGIFFLAGS ioctl.  */
+
+  struct sockaddr *ifa_addr;	/* Network address of this interface.  */
+  struct sockaddr *ifa_netmask; /* Netmask of this interface.  */
+  union
+  {
+    /* At most one of the following two is valid.  If the IFF_BROADCAST
+       bit is set in `ifa_flags', then `ifa_broadaddr' is valid.  If the
+       IFF_POINTOPOINT bit is set, then `ifa_dstaddr' is valid.
+       It is never the case that both these bits are set at once.  */
+    struct sockaddr *ifu_broadaddr; /* Broadcast address of this interface. */
+    struct sockaddr *ifu_dstaddr; /* Point-to-point destination address.  */
+  } ifa_ifu;
+  /* These very same macros are defined by <net/if.h> for `struct ifaddr'.
+     So if they are defined already, the existing definitions will be fine.  */
+# ifndef ifa_broadaddr
+#  define ifa_broadaddr	ifa_ifu.ifu_broadaddr
+# endif
+# ifndef ifa_dstaddr
+#  define ifa_dstaddr	ifa_ifu.ifu_dstaddr
+# endif
+
+  void *ifa_data;		/* Address-specific data (may be unused).  */
+};
+
+
+/* Create a linked list of `struct ifaddrs' structures, one for each
+   network interface on the host machine.  If successful, store the
+   list in *IFAP and return 0.  On errors, return -1 and set `errno'.
+
+   The storage returned in *IFAP is allocated dynamically and can
+   only be properly freed by passing it to `freeifaddrs'.  */
+extern int getifaddrs (struct ifaddrs **__ifap) __THROW;
+
+/* Reclaim the storage allocated by a previous `getifaddrs' call.  */
+extern void freeifaddrs (struct ifaddrs *__ifa)  __THROW;
+
+__END_DECLS
+
+#endif /* ifaddrs.h */
diff --git a/include/inttypes.h b/include/inttypes.h
new file mode 100644
index 0000000..72837f3
--- /dev/null
+++ b/include/inttypes.h
@@ -0,0 +1,434 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>
+ */
+
+#ifndef _INTTYPES_H
+#define _INTTYPES_H	1
+
+#include <features.h>
+/* Get the type definitions.  */
+#include <stdint.h>
+
+/* Get a definition for wchar_t.  But we must not define wchar_t itself.  */
+#ifndef ____gwchar_t_defined
+# ifdef __cplusplus
+#  define __gwchar_t wchar_t
+# elif defined __WCHAR_TYPE__
+typedef __WCHAR_TYPE__ __gwchar_t;
+# else
+#  define __need_wchar_t
+#  include <stddef.h>
+typedef wchar_t __gwchar_t;
+# endif
+# define ____gwchar_t_defined	1
+#endif
+
+# if __WORDSIZE == 64
+#  define __PRI64_PREFIX	"l"
+#  define __PRIPTR_PREFIX	"l"
+# else
+#  define __PRI64_PREFIX	"ll"
+#  define __PRIPTR_PREFIX
+# endif
+
+/* Macros for printing format specifiers.  */
+
+/* Decimal notation.  */
+# define PRId8		"d"
+# define PRId16		"d"
+# define PRId32		"d"
+# define PRId64		__PRI64_PREFIX "d"
+
+# define PRIdLEAST8	"d"
+# define PRIdLEAST16	"d"
+# define PRIdLEAST32	"d"
+# define PRIdLEAST64	__PRI64_PREFIX "d"
+
+# define PRIdFAST8	"d"
+# define PRIdFAST16	__PRIPTR_PREFIX "d"
+# define PRIdFAST32	__PRIPTR_PREFIX "d"
+# define PRIdFAST64	__PRI64_PREFIX "d"
+
+
+# define PRIi8		"i"
+# define PRIi16		"i"
+# define PRIi32		"i"
+# define PRIi64		__PRI64_PREFIX "i"
+
+# define PRIiLEAST8	"i"
+# define PRIiLEAST16	"i"
+# define PRIiLEAST32	"i"
+# define PRIiLEAST64	__PRI64_PREFIX "i"
+
+# define PRIiFAST8	"i"
+# define PRIiFAST16	__PRIPTR_PREFIX "i"
+# define PRIiFAST32	__PRIPTR_PREFIX "i"
+# define PRIiFAST64	__PRI64_PREFIX "i"
+
+/* Octal notation.  */
+# define PRIo8		"o"
+# define PRIo16		"o"
+# define PRIo32		"o"
+# define PRIo64		__PRI64_PREFIX "o"
+
+# define PRIoLEAST8	"o"
+# define PRIoLEAST16	"o"
+# define PRIoLEAST32	"o"
+# define PRIoLEAST64	__PRI64_PREFIX "o"
+
+# define PRIoFAST8	"o"
+# define PRIoFAST16	__PRIPTR_PREFIX "o"
+# define PRIoFAST32	__PRIPTR_PREFIX "o"
+# define PRIoFAST64	__PRI64_PREFIX "o"
+
+/* Unsigned integers.  */
+# define PRIu8		"u"
+# define PRIu16		"u"
+# define PRIu32		"u"
+# define PRIu64		__PRI64_PREFIX "u"
+
+# define PRIuLEAST8	"u"
+# define PRIuLEAST16	"u"
+# define PRIuLEAST32	"u"
+# define PRIuLEAST64	__PRI64_PREFIX "u"
+
+# define PRIuFAST8	"u"
+# define PRIuFAST16	__PRIPTR_PREFIX "u"
+# define PRIuFAST32	__PRIPTR_PREFIX "u"
+# define PRIuFAST64	__PRI64_PREFIX "u"
+
+/* lowercase hexadecimal notation.  */
+# define PRIx8		"x"
+# define PRIx16		"x"
+# define PRIx32		"x"
+# define PRIx64		__PRI64_PREFIX "x"
+
+# define PRIxLEAST8	"x"
+# define PRIxLEAST16	"x"
+# define PRIxLEAST32	"x"
+# define PRIxLEAST64	__PRI64_PREFIX "x"
+
+# define PRIxFAST8	"x"
+# define PRIxFAST16	__PRIPTR_PREFIX "x"
+# define PRIxFAST32	__PRIPTR_PREFIX "x"
+# define PRIxFAST64	__PRI64_PREFIX "x"
+
+/* UPPERCASE hexadecimal notation.  */
+# define PRIX8		"X"
+# define PRIX16		"X"
+# define PRIX32		"X"
+# define PRIX64		__PRI64_PREFIX "X"
+
+# define PRIXLEAST8	"X"
+# define PRIXLEAST16	"X"
+# define PRIXLEAST32	"X"
+# define PRIXLEAST64	__PRI64_PREFIX "X"
+
+# define PRIXFAST8	"X"
+# define PRIXFAST16	__PRIPTR_PREFIX "X"
+# define PRIXFAST32	__PRIPTR_PREFIX "X"
+# define PRIXFAST64	__PRI64_PREFIX "X"
+
+
+/* Macros for printing `intmax_t' and `uintmax_t'.  */
+# define PRIdMAX	__PRI64_PREFIX "d"
+# define PRIiMAX	__PRI64_PREFIX "i"
+# define PRIoMAX	__PRI64_PREFIX "o"
+# define PRIuMAX	__PRI64_PREFIX "u"
+# define PRIxMAX	__PRI64_PREFIX "x"
+# define PRIXMAX	__PRI64_PREFIX "X"
+
+
+/* Macros for printing `intptr_t' and `uintptr_t'.  */
+# define PRIdPTR	__PRIPTR_PREFIX "d"
+# define PRIiPTR	__PRIPTR_PREFIX "i"
+# define PRIoPTR	__PRIPTR_PREFIX "o"
+# define PRIuPTR	__PRIPTR_PREFIX "u"
+# define PRIxPTR	__PRIPTR_PREFIX "x"
+# define PRIXPTR	__PRIPTR_PREFIX "X"
+
+
+/* Macros for scanning format specifiers.  */
+
+/* Signed decimal notation.  */
+# define SCNd8		"hhd"
+# define SCNd16		"hd"
+# define SCNd32		"d"
+# define SCNd64		__PRI64_PREFIX "d"
+
+# define SCNdLEAST8	"hhd"
+# define SCNdLEAST16	"hd"
+# define SCNdLEAST32	"d"
+# define SCNdLEAST64	__PRI64_PREFIX "d"
+
+# define SCNdFAST8	"hhd"
+# define SCNdFAST16	__PRIPTR_PREFIX "d"
+# define SCNdFAST32	__PRIPTR_PREFIX "d"
+# define SCNdFAST64	__PRI64_PREFIX "d"
+
+/* Signed decimal notation.  */
+# define SCNi8		"hhi"
+# define SCNi16		"hi"
+# define SCNi32		"i"
+# define SCNi64		__PRI64_PREFIX "i"
+
+# define SCNiLEAST8	"hhi"
+# define SCNiLEAST16	"hi"
+# define SCNiLEAST32	"i"
+# define SCNiLEAST64	__PRI64_PREFIX "i"
+
+# define SCNiFAST8	"hhi"
+# define SCNiFAST16	__PRIPTR_PREFIX "i"
+# define SCNiFAST32	__PRIPTR_PREFIX "i"
+# define SCNiFAST64	__PRI64_PREFIX "i"
+
+/* Unsigned decimal notation.  */
+# define SCNu8		"hhu"
+# define SCNu16		"hu"
+# define SCNu32		"u"
+# define SCNu64		__PRI64_PREFIX "u"
+
+# define SCNuLEAST8	"hhu"
+# define SCNuLEAST16	"hu"
+# define SCNuLEAST32	"u"
+# define SCNuLEAST64	__PRI64_PREFIX "u"
+
+# define SCNuFAST8	"hhu"
+# define SCNuFAST16	__PRIPTR_PREFIX "u"
+# define SCNuFAST32	__PRIPTR_PREFIX "u"
+# define SCNuFAST64	__PRI64_PREFIX "u"
+
+/* Octal notation.  */
+# define SCNo8		"hho"
+# define SCNo16		"ho"
+# define SCNo32		"o"
+# define SCNo64		__PRI64_PREFIX "o"
+
+# define SCNoLEAST8	"hho"
+# define SCNoLEAST16	"ho"
+# define SCNoLEAST32	"o"
+# define SCNoLEAST64	__PRI64_PREFIX "o"
+
+# define SCNoFAST8	"hho"
+# define SCNoFAST16	__PRIPTR_PREFIX "o"
+# define SCNoFAST32	__PRIPTR_PREFIX "o"
+# define SCNoFAST64	__PRI64_PREFIX "o"
+
+/* Hexadecimal notation.  */
+# define SCNx8		"hhx"
+# define SCNx16		"hx"
+# define SCNx32		"x"
+# define SCNx64		__PRI64_PREFIX "x"
+
+# define SCNxLEAST8	"hhx"
+# define SCNxLEAST16	"hx"
+# define SCNxLEAST32	"x"
+# define SCNxLEAST64	__PRI64_PREFIX "x"
+
+# define SCNxFAST8	"hhx"
+# define SCNxFAST16	__PRIPTR_PREFIX "x"
+# define SCNxFAST32	__PRIPTR_PREFIX "x"
+# define SCNxFAST64	__PRI64_PREFIX "x"
+
+
+/* Macros for scanning `intmax_t' and `uintmax_t'.  */
+# define SCNdMAX	__PRI64_PREFIX "d"
+# define SCNiMAX	__PRI64_PREFIX "i"
+# define SCNoMAX	__PRI64_PREFIX "o"
+# define SCNuMAX	__PRI64_PREFIX "u"
+# define SCNxMAX	__PRI64_PREFIX "x"
+
+/* Macros for scaning `intptr_t' and `uintptr_t'.  */
+# define SCNdPTR	__PRIPTR_PREFIX "d"
+# define SCNiPTR	__PRIPTR_PREFIX "i"
+# define SCNoPTR	__PRIPTR_PREFIX "o"
+# define SCNuPTR	__PRIPTR_PREFIX "u"
+# define SCNxPTR	__PRIPTR_PREFIX "x"
+
+
+__BEGIN_DECLS
+
+#if __WORDSIZE == 64
+
+/* We have to define the `uintmax_t' type using `ldiv_t'.  */
+typedef struct
+  {
+    long int quot;		/* Quotient.  */
+    long int rem;		/* Remainder.  */
+  } imaxdiv_t;
+
+#else
+
+/* We have to define the `uintmax_t' type using `lldiv_t'.  */
+typedef struct
+  {
+    __extension__ long long int quot;	/* Quotient.  */
+    __extension__ long long int rem;	/* Remainder.  */
+  } imaxdiv_t;
+
+#endif
+
+
+/* Compute absolute value of N.  */
+extern intmax_t imaxabs (intmax_t __n) __THROW __attribute__ ((__const__));
+
+/* Return the `imaxdiv_t' representation of the value of NUMER over DENOM. */
+extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
+      __THROW __attribute__ ((__const__));
+
+/* Like `strtol' but convert to `intmax_t'.  */
+extern intmax_t strtoimax (const char *__restrict __nptr,
+			   char **__restrict __endptr, int __base) __THROW;
+
+/* Like `strtoul' but convert to `uintmax_t'.  */
+extern uintmax_t strtoumax (const char *__restrict __nptr,
+			    char ** __restrict __endptr, int __base) __THROW;
+
+/* Like `wcstol' but convert to `intmax_t'.  */
+extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
+			   __gwchar_t **__restrict __endptr, int __base)
+     __THROW;
+
+/* Like `wcstoul' but convert to `uintmax_t'.  */
+extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
+			    __gwchar_t ** __restrict __endptr, int __base)
+     __THROW;
+
+#ifdef __USE_EXTERN_INLINES
+
+# if __WORDSIZE == 64
+
+extern long int __strtol_internal (const char *__restrict __nptr,
+				   char **__restrict __endptr,
+				   int __base, int __group)
+  __THROW __nonnull ((1)) __wur;
+/* Like `strtol' but convert to `intmax_t'.  */
+__extern_inline intmax_t
+__NTH (strtoimax (const char *__restrict nptr, char **__restrict endptr,
+		  int base))
+{
+  return __strtol_internal (nptr, endptr, base, 0);
+}
+
+extern unsigned long int __strtoul_internal (const char *__restrict __nptr,
+					     char ** __restrict __endptr,
+					     int __base, int __group)
+  __THROW __nonnull ((1)) __wur;
+/* Like `strtoul' but convert to `uintmax_t'.  */
+__extern_inline uintmax_t
+__NTH (strtoumax (const char *__restrict nptr, char **__restrict endptr,
+		  int base))
+{
+  return __strtoul_internal (nptr, endptr, base, 0);
+}
+
+extern long int __wcstol_internal (const __gwchar_t * __restrict __nptr,
+				   __gwchar_t **__restrict __endptr,
+				   int __base, int __group)
+  __THROW __nonnull ((1)) __wur;
+/* Like `wcstol' but convert to `intmax_t'.  */
+__extern_inline intmax_t
+__NTH (wcstoimax (const __gwchar_t *__restrict nptr,
+		  __gwchar_t **__restrict endptr, int base))
+{
+  return __wcstol_internal (nptr, endptr, base, 0);
+}
+
+extern unsigned long int __wcstoul_internal (const __gwchar_t *
+					     __restrict __nptr,
+					     __gwchar_t **
+					     __restrict __endptr,
+					     int __base, int __group)
+  __THROW __nonnull ((1)) __wur;
+/* Like `wcstoul' but convert to `uintmax_t'.  */
+__extern_inline uintmax_t
+__NTH (wcstoumax (const __gwchar_t *__restrict nptr,
+		  __gwchar_t **__restrict endptr, int base))
+{
+  return __wcstoul_internal (nptr, endptr, base, 0);
+}
+
+# else /* __WORDSIZE == 32 */
+
+__extension__
+extern long long int __strtoll_internal (const char *__restrict __nptr,
+					 char **__restrict __endptr,
+					 int __base, int __group)
+  __THROW __nonnull ((1)) __wur;
+/* Like `strtol' but convert to `intmax_t'.  */
+__extern_inline intmax_t
+__NTH (strtoimax (const char *__restrict nptr, char **__restrict endptr,
+		  int base))
+{
+  return __strtoll_internal (nptr, endptr, base, 0);
+}
+
+__extension__
+extern unsigned long long int __strtoull_internal (const char *
+						   __restrict __nptr,
+						   char **
+						   __restrict __endptr,
+						   int __base,
+						   int __group)
+  __THROW __nonnull ((1)) __wur;
+/* Like `strtoul' but convert to `uintmax_t'.  */
+__extern_inline uintmax_t
+__NTH (strtoumax (const char *__restrict nptr, char **__restrict endptr,
+		  int base))
+{
+  return __strtoull_internal (nptr, endptr, base, 0);
+}
+
+__extension__
+extern long long int __wcstoll_internal (const __gwchar_t *__restrict __nptr,
+					 __gwchar_t **__restrict __endptr,
+					 int __base, int __group)
+  __THROW __nonnull ((1)) __wur;
+/* Like `wcstol' but convert to `intmax_t'.  */
+__extern_inline intmax_t
+__NTH (wcstoimax (const __gwchar_t *__restrict nptr,
+		  __gwchar_t **__restrict endptr, int base))
+{
+  return __wcstoll_internal (nptr, endptr, base, 0);
+}
+
+
+__extension__
+extern unsigned long long int __wcstoull_internal (const __gwchar_t *
+						   __restrict __nptr,
+						   __gwchar_t **
+						   __restrict __endptr,
+						   int __base,
+						   int __group)
+  __THROW __nonnull ((1)) __wur;
+/* Like `wcstoul' but convert to `uintmax_t'.  */
+__extern_inline uintmax_t
+__NTH (wcstoumax (const __gwchar_t *__restrict nptr,
+		  __gwchar_t **__restrict endptr, int base))
+{
+  return __wcstoull_internal (nptr, endptr, base, 0);
+}
+
+# endif	/* __WORDSIZE == 32	*/
+#endif	/* Use extern inlines.  */
+
+__END_DECLS
+
+#endif /* inttypes.h */
diff --git a/include/langinfo.h b/include/langinfo.h
new file mode 100644
index 0000000..a0155b5
--- /dev/null
+++ b/include/langinfo.h
@@ -0,0 +1,599 @@
+/* Access to locale-dependent parameters.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LANGINFO_H
+#define	_LANGINFO_H 1
+
+/* Get the type definition.  */
+#include <nl_types.h>
+
+#include <bits/locale.h>	/* Define the __LC_* category names.  */
+
+
+__BEGIN_DECLS
+
+/* Construct an `nl_item' value for `nl_langinfo' from a locale category
+   (LC_*) and an item index within the category.  Some code may depend on
+   the item values within a category increasing monotonically with the
+   indices.  */
+#define _NL_ITEM(category, index)	(((category) << 16) | (index))
+
+/* Extract the category and item index from a constructed `nl_item' value.  */
+#define _NL_ITEM_CATEGORY(item)		((int) (item) >> 16)
+#define _NL_ITEM_INDEX(item)		((int) (item) & 0xffff)
+
+/* Enumeration of locale items that can be queried with `nl_langinfo'.  */
+enum
+{
+  /* LC_TIME category: date and time formatting.  */
+
+  /* Abbreviated days of the week. */
+  ABDAY_1 = _NL_ITEM (__LC_TIME, 0), /* Sun */
+#define ABDAY_1			ABDAY_1
+  ABDAY_2,
+#define ABDAY_2			ABDAY_2
+  ABDAY_3,
+#define ABDAY_3			ABDAY_3
+  ABDAY_4,
+#define ABDAY_4			ABDAY_4
+  ABDAY_5,
+#define ABDAY_5			ABDAY_5
+  ABDAY_6,
+#define ABDAY_6			ABDAY_6
+  ABDAY_7,
+#define ABDAY_7			ABDAY_7
+
+  /* Long-named days of the week. */
+  DAY_1,			/* Sunday */
+#define DAY_1			DAY_1
+  DAY_2,			/* Monday */
+#define DAY_2			DAY_2
+  DAY_3,			/* Tuesday */
+#define DAY_3			DAY_3
+  DAY_4,			/* Wednesday */
+#define DAY_4			DAY_4
+  DAY_5,			/* Thursday */
+#define DAY_5			DAY_5
+  DAY_6,			/* Friday */
+#define DAY_6			DAY_6
+  DAY_7,			/* Saturday */
+#define DAY_7			DAY_7
+
+  /* Abbreviated month names.  */
+  ABMON_1,			/* Jan */
+#define ABMON_1			ABMON_1
+  ABMON_2,
+#define ABMON_2			ABMON_2
+  ABMON_3,
+#define ABMON_3			ABMON_3
+  ABMON_4,
+#define ABMON_4			ABMON_4
+  ABMON_5,
+#define ABMON_5			ABMON_5
+  ABMON_6,
+#define ABMON_6			ABMON_6
+  ABMON_7,
+#define ABMON_7			ABMON_7
+  ABMON_8,
+#define ABMON_8			ABMON_8
+  ABMON_9,
+#define ABMON_9			ABMON_9
+  ABMON_10,
+#define ABMON_10		ABMON_10
+  ABMON_11,
+#define ABMON_11		ABMON_11
+  ABMON_12,
+#define ABMON_12		ABMON_12
+
+  /* Long month names.  */
+  MON_1,			/* January */
+#define MON_1			MON_1
+  MON_2,
+#define MON_2			MON_2
+  MON_3,
+#define MON_3			MON_3
+  MON_4,
+#define MON_4			MON_4
+  MON_5,
+#define MON_5			MON_5
+  MON_6,
+#define MON_6			MON_6
+  MON_7,
+#define MON_7			MON_7
+  MON_8,
+#define MON_8			MON_8
+  MON_9,
+#define MON_9			MON_9
+  MON_10,
+#define MON_10			MON_10
+  MON_11,
+#define MON_11			MON_11
+  MON_12,
+#define MON_12			MON_12
+
+  AM_STR,			/* Ante meridiem string.  */
+#define AM_STR			AM_STR
+  PM_STR,			/* Post meridiem string.  */
+#define PM_STR			PM_STR
+
+  D_T_FMT,			/* Date and time format for strftime.  */
+#define D_T_FMT			D_T_FMT
+  D_FMT,			/* Date format for strftime.  */
+#define D_FMT			D_FMT
+  T_FMT,			/* Time format for strftime.  */
+#define T_FMT			T_FMT
+  T_FMT_AMPM,			/* 12-hour time format for strftime.  */
+#define T_FMT_AMPM		T_FMT_AMPM
+
+  ERA,				/* Alternate era.  */
+#define ERA			ERA
+  __ERA_YEAR,			/* Year in alternate era format.  */
+#ifdef __USE_GNU
+# define ERA_YEAR		__ERA_YEAR
+#endif
+  ERA_D_FMT,			/* Date in alternate era format.  */
+#define ERA_D_FMT		ERA_D_FMT
+  ALT_DIGITS,			/* Alternate symbols for digits.  */
+#define ALT_DIGITS		ALT_DIGITS
+  ERA_D_T_FMT,			/* Date and time in alternate era format.  */
+#define ERA_D_T_FMT		ERA_D_T_FMT
+  ERA_T_FMT,			/* Time in alternate era format.  */
+#define ERA_T_FMT		ERA_T_FMT
+
+  _NL_TIME_ERA_NUM_ENTRIES,	/* Number entries in the era arrays.  */
+  _NL_TIME_ERA_ENTRIES,		/* Structure with era entries in usable form.*/
+
+  _NL_WABDAY_1,		/* Sun */
+  _NL_WABDAY_2,
+  _NL_WABDAY_3,
+  _NL_WABDAY_4,
+  _NL_WABDAY_5,
+  _NL_WABDAY_6,
+  _NL_WABDAY_7,
+
+  /* Long-named days of the week. */
+  _NL_WDAY_1,		/* Sunday */
+  _NL_WDAY_2,		/* Monday */
+  _NL_WDAY_3,		/* Tuesday */
+  _NL_WDAY_4,		/* Wednesday */
+  _NL_WDAY_5,		/* Thursday */
+  _NL_WDAY_6,		/* Friday */
+  _NL_WDAY_7,		/* Saturday */
+
+  /* Abbreviated month names.  */
+  _NL_WABMON_1,		/* Jan */
+  _NL_WABMON_2,
+  _NL_WABMON_3,
+  _NL_WABMON_4,
+  _NL_WABMON_5,
+  _NL_WABMON_6,
+  _NL_WABMON_7,
+  _NL_WABMON_8,
+  _NL_WABMON_9,
+  _NL_WABMON_10,
+  _NL_WABMON_11,
+  _NL_WABMON_12,
+
+  /* Long month names.  */
+  _NL_WMON_1,		/* January */
+  _NL_WMON_2,
+  _NL_WMON_3,
+  _NL_WMON_4,
+  _NL_WMON_5,
+  _NL_WMON_6,
+  _NL_WMON_7,
+  _NL_WMON_8,
+  _NL_WMON_9,
+  _NL_WMON_10,
+  _NL_WMON_11,
+  _NL_WMON_12,
+
+  _NL_WAM_STR,		/* Ante meridiem string.  */
+  _NL_WPM_STR,		/* Post meridiem string.  */
+
+  _NL_WD_T_FMT,		/* Date and time format for strftime.  */
+  _NL_WD_FMT,		/* Date format for strftime.  */
+  _NL_WT_FMT,		/* Time format for strftime.  */
+  _NL_WT_FMT_AMPM,	/* 12-hour time format for strftime.  */
+
+  _NL_WERA_YEAR,	/* Year in alternate era format.  */
+  _NL_WERA_D_FMT,	/* Date in alternate era format.  */
+  _NL_WALT_DIGITS,	/* Alternate symbols for digits.  */
+  _NL_WERA_D_T_FMT,	/* Date and time in alternate era format.  */
+  _NL_WERA_T_FMT,	/* Time in alternate era format.  */
+
+  _NL_TIME_WEEK_NDAYS,
+  _NL_TIME_WEEK_1STDAY,
+  _NL_TIME_WEEK_1STWEEK,
+  _NL_TIME_FIRST_WEEKDAY,
+  _NL_TIME_FIRST_WORKDAY,
+  _NL_TIME_CAL_DIRECTION,
+  _NL_TIME_TIMEZONE,
+
+  _DATE_FMT,		/* strftime format for date.  */
+#define _DATE_FMT	_DATE_FMT
+  _NL_W_DATE_FMT,
+
+  _NL_TIME_CODESET,
+
+  _NL_NUM_LC_TIME,	/* Number of indices in LC_TIME category.  */
+
+  /* LC_COLLATE category: text sorting.
+     This information is accessed by the strcoll and strxfrm functions.
+     These `nl_langinfo' names are used only internally.  */
+  _NL_COLLATE_NRULES = _NL_ITEM (__LC_COLLATE, 0),
+  _NL_COLLATE_RULESETS,
+  _NL_COLLATE_TABLEMB,
+  _NL_COLLATE_WEIGHTMB,
+  _NL_COLLATE_EXTRAMB,
+  _NL_COLLATE_INDIRECTMB,
+  _NL_COLLATE_GAP1,
+  _NL_COLLATE_GAP2,
+  _NL_COLLATE_GAP3,
+  _NL_COLLATE_TABLEWC,
+  _NL_COLLATE_WEIGHTWC,
+  _NL_COLLATE_EXTRAWC,
+  _NL_COLLATE_INDIRECTWC,
+  _NL_COLLATE_SYMB_HASH_SIZEMB,
+  _NL_COLLATE_SYMB_TABLEMB,
+  _NL_COLLATE_SYMB_EXTRAMB,
+  _NL_COLLATE_COLLSEQMB,
+  _NL_COLLATE_COLLSEQWC,
+  _NL_COLLATE_CODESET,
+  _NL_NUM_LC_COLLATE,
+
+  /* LC_CTYPE category: character classification.
+     This information is accessed by the functions in <ctype.h>.
+     These `nl_langinfo' names are used only internally.  */
+  _NL_CTYPE_CLASS = _NL_ITEM (__LC_CTYPE, 0),
+  _NL_CTYPE_TOUPPER,
+  _NL_CTYPE_GAP1,
+  _NL_CTYPE_TOLOWER,
+  _NL_CTYPE_GAP2,
+  _NL_CTYPE_CLASS32,
+  _NL_CTYPE_GAP3,
+  _NL_CTYPE_GAP4,
+  _NL_CTYPE_GAP5,
+  _NL_CTYPE_GAP6,
+  _NL_CTYPE_CLASS_NAMES,
+  _NL_CTYPE_MAP_NAMES,
+  _NL_CTYPE_WIDTH,
+  _NL_CTYPE_MB_CUR_MAX,
+  _NL_CTYPE_CODESET_NAME,
+  CODESET = _NL_CTYPE_CODESET_NAME,
+#define CODESET			CODESET
+  _NL_CTYPE_TOUPPER32,
+  _NL_CTYPE_TOLOWER32,
+  _NL_CTYPE_CLASS_OFFSET,
+  _NL_CTYPE_MAP_OFFSET,
+  _NL_CTYPE_INDIGITS_MB_LEN,
+  _NL_CTYPE_INDIGITS0_MB,
+  _NL_CTYPE_INDIGITS1_MB,
+  _NL_CTYPE_INDIGITS2_MB,
+  _NL_CTYPE_INDIGITS3_MB,
+  _NL_CTYPE_INDIGITS4_MB,
+  _NL_CTYPE_INDIGITS5_MB,
+  _NL_CTYPE_INDIGITS6_MB,
+  _NL_CTYPE_INDIGITS7_MB,
+  _NL_CTYPE_INDIGITS8_MB,
+  _NL_CTYPE_INDIGITS9_MB,
+  _NL_CTYPE_INDIGITS_WC_LEN,
+  _NL_CTYPE_INDIGITS0_WC,
+  _NL_CTYPE_INDIGITS1_WC,
+  _NL_CTYPE_INDIGITS2_WC,
+  _NL_CTYPE_INDIGITS3_WC,
+  _NL_CTYPE_INDIGITS4_WC,
+  _NL_CTYPE_INDIGITS5_WC,
+  _NL_CTYPE_INDIGITS6_WC,
+  _NL_CTYPE_INDIGITS7_WC,
+  _NL_CTYPE_INDIGITS8_WC,
+  _NL_CTYPE_INDIGITS9_WC,
+  _NL_CTYPE_OUTDIGIT0_MB,
+  _NL_CTYPE_OUTDIGIT1_MB,
+  _NL_CTYPE_OUTDIGIT2_MB,
+  _NL_CTYPE_OUTDIGIT3_MB,
+  _NL_CTYPE_OUTDIGIT4_MB,
+  _NL_CTYPE_OUTDIGIT5_MB,
+  _NL_CTYPE_OUTDIGIT6_MB,
+  _NL_CTYPE_OUTDIGIT7_MB,
+  _NL_CTYPE_OUTDIGIT8_MB,
+  _NL_CTYPE_OUTDIGIT9_MB,
+  _NL_CTYPE_OUTDIGIT0_WC,
+  _NL_CTYPE_OUTDIGIT1_WC,
+  _NL_CTYPE_OUTDIGIT2_WC,
+  _NL_CTYPE_OUTDIGIT3_WC,
+  _NL_CTYPE_OUTDIGIT4_WC,
+  _NL_CTYPE_OUTDIGIT5_WC,
+  _NL_CTYPE_OUTDIGIT6_WC,
+  _NL_CTYPE_OUTDIGIT7_WC,
+  _NL_CTYPE_OUTDIGIT8_WC,
+  _NL_CTYPE_OUTDIGIT9_WC,
+  _NL_CTYPE_TRANSLIT_TAB_SIZE,
+  _NL_CTYPE_TRANSLIT_FROM_IDX,
+  _NL_CTYPE_TRANSLIT_FROM_TBL,
+  _NL_CTYPE_TRANSLIT_TO_IDX,
+  _NL_CTYPE_TRANSLIT_TO_TBL,
+  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN,
+  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING,
+  _NL_CTYPE_TRANSLIT_IGNORE_LEN,
+  _NL_CTYPE_TRANSLIT_IGNORE,
+  _NL_CTYPE_MAP_TO_NONASCII,
+  _NL_CTYPE_NONASCII_CASE,
+  _NL_CTYPE_EXTRA_MAP_1,
+  _NL_CTYPE_EXTRA_MAP_2,
+  _NL_CTYPE_EXTRA_MAP_3,
+  _NL_CTYPE_EXTRA_MAP_4,
+  _NL_CTYPE_EXTRA_MAP_5,
+  _NL_CTYPE_EXTRA_MAP_6,
+  _NL_CTYPE_EXTRA_MAP_7,
+  _NL_CTYPE_EXTRA_MAP_8,
+  _NL_CTYPE_EXTRA_MAP_9,
+  _NL_CTYPE_EXTRA_MAP_10,
+  _NL_CTYPE_EXTRA_MAP_11,
+  _NL_CTYPE_EXTRA_MAP_12,
+  _NL_CTYPE_EXTRA_MAP_13,
+  _NL_CTYPE_EXTRA_MAP_14,
+  _NL_NUM_LC_CTYPE,
+
+  /* LC_MONETARY category: formatting of monetary quantities.
+     These items each correspond to a member of `struct lconv',
+     defined in <locale.h>.  */
+  __INT_CURR_SYMBOL = _NL_ITEM (__LC_MONETARY, 0),
+#ifdef __USE_GNU
+# define INT_CURR_SYMBOL	__INT_CURR_SYMBOL
+#endif
+  __CURRENCY_SYMBOL,
+#ifdef __USE_GNU
+# define CURRENCY_SYMBOL	__CURRENCY_SYMBOL
+#endif
+  __MON_DECIMAL_POINT,
+#ifdef __USE_GNU
+# define MON_DECIMAL_POINT	__MON_DECIMAL_POINT
+#endif
+  __MON_THOUSANDS_SEP,
+#ifdef __USE_GNU
+# define MON_THOUSANDS_SEP	__MON_THOUSANDS_SEP
+#endif
+  __MON_GROUPING,
+#ifdef __USE_GNU
+# define MON_GROUPING		__MON_GROUPING
+#endif
+  __POSITIVE_SIGN,
+#ifdef __USE_GNU
+# define POSITIVE_SIGN		__POSITIVE_SIGN
+#endif
+  __NEGATIVE_SIGN,
+#ifdef __USE_GNU
+# define NEGATIVE_SIGN		__NEGATIVE_SIGN
+#endif
+  __INT_FRAC_DIGITS,
+#ifdef __USE_GNU
+# define INT_FRAC_DIGITS	__INT_FRAC_DIGITS
+#endif
+  __FRAC_DIGITS,
+#ifdef __USE_GNU
+# define FRAC_DIGITS		__FRAC_DIGITS
+#endif
+  __P_CS_PRECEDES,
+#ifdef __USE_GNU
+# define P_CS_PRECEDES		__P_CS_PRECEDES
+#endif
+  __P_SEP_BY_SPACE,
+#ifdef __USE_GNU
+# define P_SEP_BY_SPACE		__P_SEP_BY_SPACE
+#endif
+  __N_CS_PRECEDES,
+#ifdef __USE_GNU
+# define N_CS_PRECEDES		__N_CS_PRECEDES
+#endif
+  __N_SEP_BY_SPACE,
+#ifdef __USE_GNU
+# define N_SEP_BY_SPACE		__N_SEP_BY_SPACE
+#endif
+  __P_SIGN_POSN,
+#ifdef __USE_GNU
+# define P_SIGN_POSN		__P_SIGN_POSN
+#endif
+  __N_SIGN_POSN,
+#ifdef __USE_GNU
+# define N_SIGN_POSN		__N_SIGN_POSN
+#endif
+  _NL_MONETARY_CRNCYSTR,
+#define CRNCYSTR		_NL_MONETARY_CRNCYSTR
+  __INT_P_CS_PRECEDES,
+#ifdef __USE_GNU
+# define INT_P_CS_PRECEDES	__INT_P_CS_PRECEDES
+#endif
+  __INT_P_SEP_BY_SPACE,
+#ifdef __USE_GNU
+# define INT_P_SEP_BY_SPACE	__INT_P_SEP_BY_SPACE
+#endif
+  __INT_N_CS_PRECEDES,
+#ifdef __USE_GNU
+# define INT_N_CS_PRECEDES	__INT_N_CS_PRECEDES
+#endif
+  __INT_N_SEP_BY_SPACE,
+#ifdef __USE_GNU
+# define INT_N_SEP_BY_SPACE	__INT_N_SEP_BY_SPACE
+#endif
+  __INT_P_SIGN_POSN,
+#ifdef __USE_GNU
+# define INT_P_SIGN_POSN	__INT_P_SIGN_POSN
+#endif
+  __INT_N_SIGN_POSN,
+#ifdef __USE_GNU
+# define INT_N_SIGN_POSN	__INT_N_SIGN_POSN
+#endif
+  _NL_MONETARY_DUO_INT_CURR_SYMBOL,
+  _NL_MONETARY_DUO_CURRENCY_SYMBOL,
+  _NL_MONETARY_DUO_INT_FRAC_DIGITS,
+  _NL_MONETARY_DUO_FRAC_DIGITS,
+  _NL_MONETARY_DUO_P_CS_PRECEDES,
+  _NL_MONETARY_DUO_P_SEP_BY_SPACE,
+  _NL_MONETARY_DUO_N_CS_PRECEDES,
+  _NL_MONETARY_DUO_N_SEP_BY_SPACE,
+  _NL_MONETARY_DUO_INT_P_CS_PRECEDES,
+  _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE,
+  _NL_MONETARY_DUO_INT_N_CS_PRECEDES,
+  _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE,
+  _NL_MONETARY_DUO_P_SIGN_POSN,
+  _NL_MONETARY_DUO_N_SIGN_POSN,
+  _NL_MONETARY_DUO_INT_P_SIGN_POSN,
+  _NL_MONETARY_DUO_INT_N_SIGN_POSN,
+  _NL_MONETARY_UNO_VALID_FROM,
+  _NL_MONETARY_UNO_VALID_TO,
+  _NL_MONETARY_DUO_VALID_FROM,
+  _NL_MONETARY_DUO_VALID_TO,
+  _NL_MONETARY_CONVERSION_RATE,
+  _NL_MONETARY_DECIMAL_POINT_WC,
+  _NL_MONETARY_THOUSANDS_SEP_WC,
+  _NL_MONETARY_CODESET,
+  _NL_NUM_LC_MONETARY,
+
+  /* LC_NUMERIC category: formatting of numbers.
+     These also correspond to members of `struct lconv'; see <locale.h>.  */
+  __DECIMAL_POINT = _NL_ITEM (__LC_NUMERIC, 0),
+#ifdef __USE_GNU
+# define DECIMAL_POINT		__DECIMAL_POINT
+#endif
+  RADIXCHAR = __DECIMAL_POINT,
+#define RADIXCHAR		RADIXCHAR
+  __THOUSANDS_SEP,
+#ifdef __USE_GNU
+# define THOUSANDS_SEP		__THOUSANDS_SEP
+#endif
+  THOUSEP = __THOUSANDS_SEP,
+#define THOUSEP			THOUSEP
+  __GROUPING,
+#ifdef __USE_GNU
+# define GROUPING		__GROUPING
+#endif
+  _NL_NUMERIC_DECIMAL_POINT_WC,
+  _NL_NUMERIC_THOUSANDS_SEP_WC,
+  _NL_NUMERIC_CODESET,
+  _NL_NUM_LC_NUMERIC,
+
+  __YESEXPR = _NL_ITEM (__LC_MESSAGES, 0), /* Regex matching ``yes'' input.  */
+#define YESEXPR			__YESEXPR
+  __NOEXPR,			/* Regex matching ``no'' input.  */
+#define NOEXPR			__NOEXPR
+  __YESSTR,			/* Output string for ``yes''.  */
+#if defined __USE_GNU || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
+# define YESSTR			__YESSTR
+#endif
+  __NOSTR,			/* Output string for ``no''.  */
+#if defined __USE_GNU || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
+# define NOSTR			__NOSTR
+#endif
+  _NL_MESSAGES_CODESET,
+  _NL_NUM_LC_MESSAGES,
+
+  _NL_PAPER_HEIGHT = _NL_ITEM (__LC_PAPER, 0),
+  _NL_PAPER_WIDTH,
+  _NL_PAPER_CODESET,
+  _NL_NUM_LC_PAPER,
+
+  _NL_NAME_NAME_FMT = _NL_ITEM (__LC_NAME, 0),
+  _NL_NAME_NAME_GEN,
+  _NL_NAME_NAME_MR,
+  _NL_NAME_NAME_MRS,
+  _NL_NAME_NAME_MISS,
+  _NL_NAME_NAME_MS,
+  _NL_NAME_CODESET,
+  _NL_NUM_LC_NAME,
+
+  _NL_ADDRESS_POSTAL_FMT = _NL_ITEM (__LC_ADDRESS, 0),
+  _NL_ADDRESS_COUNTRY_NAME,
+  _NL_ADDRESS_COUNTRY_POST,
+  _NL_ADDRESS_COUNTRY_AB2,
+  _NL_ADDRESS_COUNTRY_AB3,
+  _NL_ADDRESS_COUNTRY_CAR,
+  _NL_ADDRESS_COUNTRY_NUM,
+  _NL_ADDRESS_COUNTRY_ISBN,
+  _NL_ADDRESS_LANG_NAME,
+  _NL_ADDRESS_LANG_AB,
+  _NL_ADDRESS_LANG_TERM,
+  _NL_ADDRESS_LANG_LIB,
+  _NL_ADDRESS_CODESET,
+  _NL_NUM_LC_ADDRESS,
+
+  _NL_TELEPHONE_TEL_INT_FMT = _NL_ITEM (__LC_TELEPHONE, 0),
+  _NL_TELEPHONE_TEL_DOM_FMT,
+  _NL_TELEPHONE_INT_SELECT,
+  _NL_TELEPHONE_INT_PREFIX,
+  _NL_TELEPHONE_CODESET,
+  _NL_NUM_LC_TELEPHONE,
+
+  _NL_MEASUREMENT_MEASUREMENT = _NL_ITEM (__LC_MEASUREMENT, 0),
+  _NL_MEASUREMENT_CODESET,
+  _NL_NUM_LC_MEASUREMENT,
+
+  _NL_IDENTIFICATION_TITLE = _NL_ITEM (__LC_IDENTIFICATION, 0),
+  _NL_IDENTIFICATION_SOURCE,
+  _NL_IDENTIFICATION_ADDRESS,
+  _NL_IDENTIFICATION_CONTACT,
+  _NL_IDENTIFICATION_EMAIL,
+  _NL_IDENTIFICATION_TEL,
+  _NL_IDENTIFICATION_FAX,
+  _NL_IDENTIFICATION_LANGUAGE,
+  _NL_IDENTIFICATION_TERRITORY,
+  _NL_IDENTIFICATION_AUDIENCE,
+  _NL_IDENTIFICATION_APPLICATION,
+  _NL_IDENTIFICATION_ABBREVIATION,
+  _NL_IDENTIFICATION_REVISION,
+  _NL_IDENTIFICATION_DATE,
+  _NL_IDENTIFICATION_CATEGORY,
+  _NL_IDENTIFICATION_CODESET,
+  _NL_NUM_LC_IDENTIFICATION,
+
+  /* This marks the highest value used.  */
+  _NL_NUM
+};
+
+/* This macro produces an item you can pass to `nl_langinfo' or
+   `nl_langinfo_l' to get the name of the locale in use for CATEGORY.  */
+#define _NL_LOCALE_NAME(category)	_NL_ITEM ((category),		      \
+						  _NL_ITEM_INDEX (-1))
+#ifdef __USE_GNU
+# define NL_LOCALE_NAME(category)	_NL_LOCALE_NAME (category)
+#endif
+
+
+/* Return the current locale's value for ITEM.
+   If ITEM is invalid, an empty string is returned.
+
+   The string returned will not change until `setlocale' is called;
+   it is usually in read-only memory and cannot be modified.  */
+
+extern char *nl_langinfo (nl_item __item) __THROW;
+
+
+#ifdef	__USE_XOPEN2K
+/* This interface is for the extended locale model.  See <locale.h> for
+   more information.  */
+
+/* Get locale datatype definition.  */
+# include <xlocale.h>
+
+/* Just like nl_langinfo but get the information from the locale object L.  */
+extern char *nl_langinfo_l (nl_item __item, __locale_t __l);
+#endif
+
+__END_DECLS
+
+#endif	/* langinfo.h */
diff --git a/include/lastlog.h b/include/lastlog.h
new file mode 100644
index 0000000..8cc4254
--- /dev/null
+++ b/include/lastlog.h
@@ -0,0 +1,4 @@
+/* This header file is used in 4.3BSD to define `struct lastlog',
+   which we define in <bits/utmp.h>.  */
+
+#include <utmp.h>
diff --git a/include/libgen.h b/include/libgen.h
new file mode 100644
index 0000000..19aeece
--- /dev/null
+++ b/include/libgen.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LIBGEN_H
+#define _LIBGEN_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Return directory part of PATH or "." if none is available.  */
+extern char *dirname (char *__path) __THROW;
+
+/* Return final component of PATH.
+
+   This is the weird XPG version of this function.  It sometimes will
+   modify its argument.  Therefore we normally use the GNU version (in
+   <string.h>) and only if this header is included make the XPG
+   version available under the real name.  */
+extern char *__xpg_basename (char *__path) __THROW;
+#define basename	__xpg_basename
+
+__END_DECLS
+
+#endif /* libgen.h */
diff --git a/include/libintl.h b/include/libintl.h
new file mode 100644
index 0000000..3530d07
--- /dev/null
+++ b/include/libintl.h
@@ -0,0 +1,123 @@
+/* Message catalogs for internationalization.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   This file is derived from the file libgettext.h in the GNU gettext package.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LIBINTL_H
+#define _LIBINTL_H	1
+
+#include <features.h>
+
+/* We define an additional symbol to signal that we use the GNU
+   implementation of gettext.  */
+#define __USE_GNU_GETTEXT 1
+
+/* Provide information about the supported file formats.  Returns the
+   maximum minor revision number supported for a given major revision.  */
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) \
+  ((major) == 0 ? 1 : -1)
+
+__BEGIN_DECLS
+
+/* Look up MSGID in the current default message catalog for the current
+   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
+   text).  */
+extern char *gettext (const char *__msgid)
+     __THROW __attribute_format_arg__ (1);
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current
+   LC_MESSAGES locale.  */
+extern char *dgettext (const char *__domainname, const char *__msgid)
+     __THROW __attribute_format_arg__ (2);
+extern char *__dgettext (const char *__domainname, const char *__msgid)
+     __THROW __attribute_format_arg__ (2);
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
+   locale.  */
+extern char *dcgettext (const char *__domainname,
+			const char *__msgid, int __category)
+     __THROW __attribute_format_arg__ (2);
+extern char *__dcgettext (const char *__domainname,
+			  const char *__msgid, int __category)
+     __THROW __attribute_format_arg__ (2);
+
+
+/* Similar to `gettext' but select the plural form corresponding to the
+   number N.  */
+extern char *ngettext (const char *__msgid1, const char *__msgid2,
+		       unsigned long int __n)
+     __THROW __attribute_format_arg__ (1) __attribute_format_arg__ (2);
+
+/* Similar to `dgettext' but select the plural form corresponding to the
+   number N.  */
+extern char *dngettext (const char *__domainname, const char *__msgid1,
+			const char *__msgid2, unsigned long int __n)
+     __THROW __attribute_format_arg__ (2) __attribute_format_arg__ (3);
+
+/* Similar to `dcgettext' but select the plural form corresponding to the
+   number N.  */
+extern char *dcngettext (const char *__domainname, const char *__msgid1,
+			 const char *__msgid2, unsigned long int __n,
+			 int __category)
+     __THROW __attribute_format_arg__ (2) __attribute_format_arg__ (3);
+
+
+/* Set the current default message catalog to DOMAINNAME.
+   If DOMAINNAME is null, return the current default.
+   If DOMAINNAME is "", reset to the default of "messages".  */
+extern char *textdomain (const char *__domainname) __THROW;
+
+/* Specify that the DOMAINNAME message catalog will be found
+   in DIRNAME rather than in the system locale data base.  */
+extern char *bindtextdomain (const char *__domainname,
+			     const char *__dirname) __THROW;
+
+/* Specify the character encoding in which the messages from the
+   DOMAINNAME message catalog will be returned.  */
+extern char *bind_textdomain_codeset (const char *__domainname,
+				      const char *__codeset) __THROW;
+
+
+/* Optimized version of the function above.  */
+#if defined __OPTIMIZE__ && !defined __cplusplus
+
+/* We need NULL for `gettext'.  */
+# define __need_NULL
+# include <stddef.h>
+
+/* We need LC_MESSAGES for `dgettext'.  */
+# include <locale.h>
+
+/* These must be macros.  Inlined functions are useless because the
+   `__builtin_constant_p' predicate in dcgettext would always return
+   false.  */
+
+# define gettext(msgid) dgettext (NULL, msgid)
+
+# define dgettext(domainname, msgid) \
+  dcgettext (domainname, msgid, LC_MESSAGES)
+
+# define ngettext(msgid1, msgid2, n) dngettext (NULL, msgid1, msgid2, n)
+
+# define dngettext(domainname, msgid1, msgid2, n) \
+  dcngettext (domainname, msgid1, msgid2, n, LC_MESSAGES)
+
+#endif	/* Optimizing.  */
+
+__END_DECLS
+
+#endif /* libintl.h */
diff --git a/include/libio.h b/include/libio.h
new file mode 100644
index 0000000..6077f5c
--- /dev/null
+++ b/include/libio.h
@@ -0,0 +1,529 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Written by Per Bothner <bothner@cygnus.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.
+
+   As a special exception, if you link the code in this file with
+   files compiled with a GNU compiler to produce an executable,
+   that does not cause the resulting executable to be covered by
+   the GNU Lesser General Public License.  This exception does not
+   however invalidate any other reasons why the executable file
+   might be covered by the GNU Lesser General Public License.
+   This exception applies to code released by its copyright holders
+   in files containing the exception.  */
+
+#ifndef _IO_STDIO_H
+#define _IO_STDIO_H
+
+#include <_G_config.h>
+/* ALL of these should be defined in _G_config.h */
+#define _IO_fpos_t _G_fpos_t
+#define _IO_fpos64_t _G_fpos64_t
+#define _IO_size_t size_t
+#define _IO_ssize_t __ssize_t
+#define _IO_off_t __off_t
+#define _IO_off64_t __off64_t
+#define _IO_pid_t __pid_t
+#define _IO_uid_t __uid_t
+#define _IO_iconv_t _G_iconv_t
+#define _IO_HAVE_ST_BLKSIZE _G_HAVE_ST_BLKSIZE
+#define _IO_BUFSIZ _G_BUFSIZ
+#define _IO_va_list _G_va_list
+#define _IO_wint_t wint_t
+
+/* This define avoids name pollution if we're using GNU stdarg.h */
+#define __need___va_list
+#include <stdarg.h>
+#ifdef __GNUC_VA_LIST
+# undef _IO_va_list
+# define _IO_va_list __gnuc_va_list
+#endif /* __GNUC_VA_LIST */
+
+#ifndef __P
+# include <sys/cdefs.h>
+#endif /*!__P*/
+
+#define _IO_UNIFIED_JUMPTABLES 1
+
+#ifndef EOF
+# define EOF (-1)
+#endif
+#ifndef NULL
+# if defined __GNUG__ && \
+    (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))
+#  define NULL (__null)
+# else
+#  if !defined(__cplusplus)
+#   define NULL ((void*)0)
+#  else
+#   define NULL (0)
+#  endif
+# endif
+#endif
+
+#define _IOS_INPUT	1
+#define _IOS_OUTPUT	2
+#define _IOS_ATEND	4
+#define _IOS_APPEND	8
+#define _IOS_TRUNC	16
+#define _IOS_NOCREATE	32
+#define _IOS_NOREPLACE	64
+#define _IOS_BIN	128
+
+/* Magic numbers and bits for the _flags field.
+   The magic numbers use the high-order bits of _flags;
+   the remaining bits are available for variable flags.
+   Note: The magic numbers must all be negative if stdio
+   emulation is desired. */
+
+#define _IO_MAGIC 0xFBAD0000 /* Magic number */
+#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */
+#define _IO_MAGIC_MASK 0xFFFF0000
+#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */
+#define _IO_UNBUFFERED 2
+#define _IO_NO_READS 4 /* Reading not allowed */
+#define _IO_NO_WRITES 8 /* Writing not allowd */
+#define _IO_EOF_SEEN 0x10
+#define _IO_ERR_SEEN 0x20
+#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */
+#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/
+#define _IO_IN_BACKUP 0x100
+#define _IO_LINE_BUF 0x200
+#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */
+#define _IO_CURRENTLY_PUTTING 0x800
+#define _IO_IS_APPENDING 0x1000
+#define _IO_IS_FILEBUF 0x2000
+#define _IO_BAD_SEEN 0x4000
+#define _IO_USER_LOCK 0x8000
+
+#define _IO_FLAGS2_MMAP 1
+#define _IO_FLAGS2_NOTCANCEL 2
+#ifdef _LIBC
+# define _IO_FLAGS2_FORTIFY 4
+#endif
+#define _IO_FLAGS2_USER_WBUF 8
+#ifdef _LIBC
+# define _IO_FLAGS2_SCANF_STD 16
+# define _IO_FLAGS2_NOCLOSE 32
+# define _IO_FLAGS2_CLOEXEC 64
+#endif
+
+/* These are "formatting flags" matching the iostream fmtflags enum values. */
+#define _IO_SKIPWS 01
+#define _IO_LEFT 02
+#define _IO_RIGHT 04
+#define _IO_INTERNAL 010
+#define _IO_DEC 020
+#define _IO_OCT 040
+#define _IO_HEX 0100
+#define _IO_SHOWBASE 0200
+#define _IO_SHOWPOINT 0400
+#define _IO_UPPERCASE 01000
+#define _IO_SHOWPOS 02000
+#define _IO_SCIENTIFIC 04000
+#define _IO_FIXED 010000
+#define _IO_UNITBUF 020000
+#define _IO_STDIO 040000
+#define _IO_DONT_CLOSE 0100000
+#define _IO_BOOLALPHA 0200000
+
+
+struct _IO_jump_t;  struct _IO_FILE;
+
+/* Handle lock.  */
+#ifdef _IO_MTSAFE_IO
+# if defined __GLIBC__ && __GLIBC__ >= 2
+#  include <bits/stdio-lock.h>
+# else
+/*# include <comthread.h>*/
+# endif
+#else
+typedef void _IO_lock_t;
+#endif
+
+
+/* A streammarker remembers a position in a buffer. */
+
+struct _IO_marker {
+  struct _IO_marker *_next;
+  struct _IO_FILE *_sbuf;
+  /* If _pos >= 0
+ it points to _buf->Gbase()+_pos. FIXME comment */
+  /* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment */
+  int _pos;
+#if 0
+    void set_streampos(streampos sp) { _spos = sp; }
+    void set_offset(int offset) { _pos = offset; _spos = (streampos)(-2); }
+  public:
+    streammarker(streambuf *sb);
+    ~streammarker();
+    int saving() { return  _spos == -2; }
+    int delta(streammarker&);
+    int delta();
+#endif
+};
+
+/* This is the structure from the libstdc++ codecvt class.  */
+enum __codecvt_result
+{
+  __codecvt_ok,
+  __codecvt_partial,
+  __codecvt_error,
+  __codecvt_noconv
+};
+
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+/* The order of the elements in the following struct must match the order
+   of the virtual functions in the libstdc++ codecvt class.  */
+struct _IO_codecvt
+{
+  void (*__codecvt_destr) (struct _IO_codecvt *);
+  enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *,
+					     __mbstate_t *,
+					     const wchar_t *,
+					     const wchar_t *,
+					     const wchar_t **, char *,
+					     char *, char **);
+  enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *,
+						 __mbstate_t *, char *,
+						 char *, char **);
+  enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *,
+					    __mbstate_t *,
+					    const char *, const char *,
+					    const char **, wchar_t *,
+					    wchar_t *, wchar_t **);
+  int (*__codecvt_do_encoding) (struct _IO_codecvt *);
+  int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);
+  int (*__codecvt_do_length) (struct _IO_codecvt *, __mbstate_t *,
+			      const char *, const char *, _IO_size_t);
+  int (*__codecvt_do_max_length) (struct _IO_codecvt *);
+
+  _IO_iconv_t __cd_in;
+  _IO_iconv_t __cd_out;
+};
+
+/* Extra data for wide character streams.  */
+struct _IO_wide_data
+{
+  wchar_t *_IO_read_ptr;	/* Current read pointer */
+  wchar_t *_IO_read_end;	/* End of get area. */
+  wchar_t *_IO_read_base;	/* Start of putback+get area. */
+  wchar_t *_IO_write_base;	/* Start of put area. */
+  wchar_t *_IO_write_ptr;	/* Current put pointer. */
+  wchar_t *_IO_write_end;	/* End of put area. */
+  wchar_t *_IO_buf_base;	/* Start of reserve area. */
+  wchar_t *_IO_buf_end;		/* End of reserve area. */
+  /* The following fields are used to support backing up and undo. */
+  wchar_t *_IO_save_base;	/* Pointer to start of non-current get area. */
+  wchar_t *_IO_backup_base;	/* Pointer to first valid character of
+				   backup area */
+  wchar_t *_IO_save_end;	/* Pointer to end of non-current get area. */
+
+  __mbstate_t _IO_state;
+  __mbstate_t _IO_last_state;
+  struct _IO_codecvt _codecvt;
+
+  wchar_t _shortbuf[1];
+
+  const struct _IO_jump_t *_wide_vtable;
+};
+#endif
+
+struct _IO_FILE {
+  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
+#define _IO_file_flags _flags
+
+  /* The following pointers correspond to the C++ streambuf protocol. */
+  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
+  char* _IO_read_ptr;	/* Current read pointer */
+  char* _IO_read_end;	/* End of get area. */
+  char* _IO_read_base;	/* Start of putback+get area. */
+  char* _IO_write_base;	/* Start of put area. */
+  char* _IO_write_ptr;	/* Current put pointer. */
+  char* _IO_write_end;	/* End of put area. */
+  char* _IO_buf_base;	/* Start of reserve area. */
+  char* _IO_buf_end;	/* End of reserve area. */
+  /* The following fields are used to support backing up and undo. */
+  char *_IO_save_base; /* Pointer to start of non-current get area. */
+  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
+  char *_IO_save_end; /* Pointer to end of non-current get area. */
+
+  struct _IO_marker *_markers;
+
+  struct _IO_FILE *_chain;
+
+  int _fileno;
+#if 0
+  int _blksize;
+#else
+  int _flags2;
+#endif
+  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */
+
+#define __HAVE_COLUMN /* temporary */
+  /* 1+column number of pbase(); 0 is unknown. */
+  unsigned short _cur_column;
+  signed char _vtable_offset;
+  char _shortbuf[1];
+
+  /*  char* _save_gptr;  char* _save_egptr; */
+
+  _IO_lock_t *_lock;
+#ifdef _IO_USE_OLD_IO_FILE
+};
+
+struct _IO_FILE_complete
+{
+  struct _IO_FILE _file;
+#endif
+#if defined _G_IO_IO_FILE_VERSION && _G_IO_IO_FILE_VERSION == 0x20001
+  _IO_off64_t _offset;
+# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+  /* Wide character stream stuff.  */
+  struct _IO_codecvt *_codecvt;
+  struct _IO_wide_data *_wide_data;
+  struct _IO_FILE *_freeres_list;
+  void *_freeres_buf;
+  size_t _freeres_size;
+# else
+  void *__pad1;
+  void *__pad2;
+  void *__pad3;
+  void *__pad4;
+  size_t __pad5;
+# endif
+  int _mode;
+  /* Make sure we don't get into trouble again.  */
+  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
+#endif
+};
+
+#ifndef __cplusplus
+typedef struct _IO_FILE _IO_FILE;
+#endif
+
+struct _IO_FILE_plus;
+
+extern struct _IO_FILE_plus _IO_2_1_stdin_;
+extern struct _IO_FILE_plus _IO_2_1_stdout_;
+extern struct _IO_FILE_plus _IO_2_1_stderr_;
+#ifndef _LIBC
+#define _IO_stdin ((_IO_FILE*)(&_IO_2_1_stdin_))
+#define _IO_stdout ((_IO_FILE*)(&_IO_2_1_stdout_))
+#define _IO_stderr ((_IO_FILE*)(&_IO_2_1_stderr_))
+#else
+extern _IO_FILE *_IO_stdin attribute_hidden;
+extern _IO_FILE *_IO_stdout attribute_hidden;
+extern _IO_FILE *_IO_stderr attribute_hidden;
+#endif
+
+
+/* Functions to do I/O and file management for a stream.  */
+
+/* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.
+   Return number of bytes read.  */
+typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);
+
+/* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes
+   unless there is an error.  Return number of bytes written.  If
+   there is an error, return 0 and do not write anything.  If the file
+   has been opened for append (__mode.__append set), then set the file
+   pointer to the end of the file and then do the write; if not, just
+   write at the current file pointer.  */
+typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
+				 size_t __n);
+
+/* Move COOKIE's file position to *POS bytes from the
+   beginning of the file (if W is SEEK_SET),
+   the current position (if W is SEEK_CUR),
+   or the end of the file (if W is SEEK_END).
+   Set *POS to the new file position.
+   Returns zero if successful, nonzero if not.  */
+typedef int __io_seek_fn (void *__cookie, _IO_off64_t *__pos, int __w);
+
+/* Close COOKIE.  */
+typedef int __io_close_fn (void *__cookie);
+
+
+#ifdef _GNU_SOURCE
+/* User-visible names for the above.  */
+typedef __io_read_fn cookie_read_function_t;
+typedef __io_write_fn cookie_write_function_t;
+typedef __io_seek_fn cookie_seek_function_t;
+typedef __io_close_fn cookie_close_function_t;
+
+/* The structure with the cookie function pointers.  */
+typedef struct
+{
+  __io_read_fn *read;		/* Read bytes.  */
+  __io_write_fn *write;		/* Write bytes.  */
+  __io_seek_fn *seek;		/* Seek/tell file position.  */
+  __io_close_fn *close;		/* Close file.  */
+} _IO_cookie_io_functions_t;
+typedef _IO_cookie_io_functions_t cookie_io_functions_t;
+
+struct _IO_cookie_file;
+
+/* Initialize one of those.  */
+extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
+			     void *__cookie, _IO_cookie_io_functions_t __fns);
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int __underflow (_IO_FILE *);
+extern int __uflow (_IO_FILE *);
+extern int __overflow (_IO_FILE *, int);
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+extern _IO_wint_t __wunderflow (_IO_FILE *);
+extern _IO_wint_t __wuflow (_IO_FILE *);
+extern _IO_wint_t __woverflow (_IO_FILE *, _IO_wint_t);
+#endif
+
+#if  __GNUC__ >= 3
+# define _IO_BE(expr, res) __builtin_expect ((expr), res)
+#else
+# define _IO_BE(expr, res) (expr)
+#endif
+
+#define _IO_getc_unlocked(_fp) \
+       (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) \
+	? __uflow (_fp) : *(unsigned char *) (_fp)->_IO_read_ptr++)
+#define _IO_peekc_unlocked(_fp) \
+       (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) \
+	  && __underflow (_fp) == EOF ? EOF \
+	: *(unsigned char *) (_fp)->_IO_read_ptr)
+#define _IO_putc_unlocked(_ch, _fp) \
+   (_IO_BE ((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end, 0) \
+    ? __overflow (_fp, (unsigned char) (_ch)) \
+    : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))
+
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# define _IO_getwc_unlocked(_fp) \
+  (_IO_BE ((_fp)->_wide_data == NULL					\
+	   || ((_fp)->_wide_data->_IO_read_ptr				\
+	       >= (_fp)->_wide_data->_IO_read_end), 0)			\
+   ? __wuflow (_fp) : (_IO_wint_t) *(_fp)->_wide_data->_IO_read_ptr++)
+# define _IO_putwc_unlocked(_wch, _fp) \
+  (_IO_BE ((_fp)->_wide_data == NULL					\
+	   || ((_fp)->_wide_data->_IO_write_ptr				\
+	       >= (_fp)->_wide_data->_IO_write_end), 0)			\
+   ? __woverflow (_fp, _wch)						\
+   : (_IO_wint_t) (*(_fp)->_wide_data->_IO_write_ptr++ = (_wch)))
+#endif
+
+#define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)
+#define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)
+
+extern int _IO_getc (_IO_FILE *__fp);
+extern int _IO_putc (int __c, _IO_FILE *__fp);
+extern int _IO_feof (_IO_FILE *__fp) __THROW;
+extern int _IO_ferror (_IO_FILE *__fp) __THROW;
+
+extern int _IO_peekc_locked (_IO_FILE *__fp);
+
+/* This one is for Emacs. */
+#define _IO_PENDING_OUTPUT_COUNT(_fp)	\
+	((_fp)->_IO_write_ptr - (_fp)->_IO_write_base)
+
+extern void _IO_flockfile (_IO_FILE *) __THROW;
+extern void _IO_funlockfile (_IO_FILE *) __THROW;
+extern int _IO_ftrylockfile (_IO_FILE *) __THROW;
+
+#ifdef _IO_MTSAFE_IO
+# define _IO_peekc(_fp) _IO_peekc_locked (_fp)
+# define _IO_flockfile(_fp) \
+  if (((_fp)->_flags & _IO_USER_LOCK) == 0) _IO_flockfile (_fp)
+# define _IO_funlockfile(_fp) \
+  if (((_fp)->_flags & _IO_USER_LOCK) == 0) _IO_funlockfile (_fp)
+#else
+# define _IO_peekc(_fp) _IO_peekc_unlocked (_fp)
+# define _IO_flockfile(_fp) /**/
+# define _IO_funlockfile(_fp) /**/
+# define _IO_ftrylockfile(_fp) /**/
+# define _IO_cleanup_region_start(_fct, _fp) /**/
+# define _IO_cleanup_region_end(_Doit) /**/
+#endif /* !_IO_MTSAFE_IO */
+
+extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
+			_IO_va_list, int *__restrict);
+extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
+			 _IO_va_list);
+extern _IO_ssize_t _IO_padn (_IO_FILE *, int, _IO_ssize_t);
+extern _IO_size_t _IO_sgetn (_IO_FILE *, void *, _IO_size_t);
+
+extern _IO_off64_t _IO_seekoff (_IO_FILE *, _IO_off64_t, int, int);
+extern _IO_off64_t _IO_seekpos (_IO_FILE *, _IO_off64_t, int);
+
+extern void _IO_free_backup_area (_IO_FILE *) __THROW;
+
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+extern _IO_wint_t _IO_getwc (_IO_FILE *__fp);
+extern _IO_wint_t _IO_putwc (wchar_t __wc, _IO_FILE *__fp);
+extern int _IO_fwide (_IO_FILE *__fp, int __mode) __THROW;
+# if __GNUC__ >= 2
+/* While compiling glibc we have to handle compatibility with very old
+   versions.  */
+#  if defined _LIBC && defined SHARED
+#   include <shlib-compat.h>
+#   if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+#    define _IO_fwide_maybe_incompatible \
+  (__builtin_expect (&_IO_stdin_used == NULL, 0))
+extern const int _IO_stdin_used;
+weak_extern (_IO_stdin_used);
+#   endif
+#  endif
+#  ifndef _IO_fwide_maybe_incompatible
+#   define _IO_fwide_maybe_incompatible (0)
+#  endif
+/* A special optimized version of the function above.  It optimizes the
+   case of initializing an unoriented byte stream.  */
+#  define _IO_fwide(__fp, __mode) \
+  ({ int __result = (__mode);						      \
+     if (__result < 0 && ! _IO_fwide_maybe_incompatible)		      \
+       {								      \
+	 if ((__fp)->_mode == 0)					      \
+	   /* We know that all we have to do is to set the flag.  */	      \
+	   (__fp)->_mode = -1;						      \
+	 __result = (__fp)->_mode;					      \
+       }								      \
+     else if (__builtin_constant_p (__mode) && (__mode) == 0)		      \
+       __result = _IO_fwide_maybe_incompatible ? -1 : (__fp)->_mode;	      \
+     else								      \
+       __result = _IO_fwide (__fp, __result);				      \
+     __result; })
+# endif
+
+extern int _IO_vfwscanf (_IO_FILE * __restrict, const wchar_t * __restrict,
+			 _IO_va_list, int *__restrict);
+extern int _IO_vfwprintf (_IO_FILE *__restrict, const wchar_t *__restrict,
+			  _IO_va_list);
+extern _IO_ssize_t _IO_wpadn (_IO_FILE *, wint_t, _IO_ssize_t);
+extern void _IO_free_wbackup_area (_IO_FILE *) __THROW;
+#endif
+
+#ifdef __LDBL_COMPAT
+# include <bits/libio-ldbl.h>
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IO_STDIO_H */
diff --git a/include/limits.h b/include/limits.h
new file mode 100644
index 0000000..311386a
--- /dev/null
+++ b/include/limits.h
@@ -0,0 +1,152 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
+ */
+
+#ifndef _LIBC_LIMITS_H_
+#define _LIBC_LIMITS_H_	1
+
+#include <features.h>
+
+
+/* Maximum length of any multibyte character in any locale.
+   We define this value here since the gcc header does not define
+   the correct value.  */
+#define MB_LEN_MAX	16
+
+
+/* If we are not using GNU CC we have to define all the symbols ourself.
+   Otherwise use gcc's definitions (see below).  */
+#if !defined __GNUC__ || __GNUC__ < 2
+
+/* We only protect from multiple inclusion here, because all the other
+   #include's protect themselves, and in GCC 2 we may #include_next through
+   multiple copies of this file before we get to GCC's.  */
+# ifndef _LIMITS_H
+#  define _LIMITS_H	1
+
+#include <bits/wordsize.h>
+
+/* We don't have #include_next.
+   Define ANSI <limits.h> for standard 32-bit words.  */
+
+/* These assume 8-bit `char's, 16-bit `short int's,
+   and 32-bit `int's and `long int's.  */
+
+/* Number of bits in a `char'.	*/
+#  define CHAR_BIT	8
+
+/* Minimum and maximum values a `signed char' can hold.  */
+#  define SCHAR_MIN	(-128)
+#  define SCHAR_MAX	127
+
+/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */
+#  define UCHAR_MAX	255
+
+/* Minimum and maximum values a `char' can hold.  */
+#  ifdef __CHAR_UNSIGNED__
+#   define CHAR_MIN	0
+#   define CHAR_MAX	UCHAR_MAX
+#  else
+#   define CHAR_MIN	SCHAR_MIN
+#   define CHAR_MAX	SCHAR_MAX
+#  endif
+
+/* Minimum and maximum values a `signed short int' can hold.  */
+#  define SHRT_MIN	(-32768)
+#  define SHRT_MAX	32767
+
+/* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  */
+#  define USHRT_MAX	65535
+
+/* Minimum and maximum values a `signed int' can hold.  */
+#  define INT_MIN	(-INT_MAX - 1)
+#  define INT_MAX	2147483647
+
+/* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  */
+#  define UINT_MAX	4294967295U
+
+/* Minimum and maximum values a `signed long int' can hold.  */
+#  if __WORDSIZE == 64
+#   define LONG_MAX	9223372036854775807L
+#  else
+#   define LONG_MAX	2147483647L
+#  endif
+#  define LONG_MIN	(-LONG_MAX - 1L)
+
+/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */
+#  if __WORDSIZE == 64
+#   define ULONG_MAX	18446744073709551615UL
+#  else
+#   define ULONG_MAX	4294967295UL
+#  endif
+
+#  ifdef __USE_ISOC99
+
+/* Minimum and maximum values a `signed long long int' can hold.  */
+#   define LLONG_MAX	9223372036854775807LL
+#   define LLONG_MIN	(-LLONG_MAX - 1LL)
+
+/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  */
+#   define ULLONG_MAX	18446744073709551615ULL
+
+#  endif /* ISO C99 */
+
+# endif	/* limits.h  */
+#endif	/* GCC 2.  */
+
+#endif	/* !_LIBC_LIMITS_H_ */
+
+ /* Get the compiler's limits.h, which defines almost all the ISO constants.
+
+    We put this #include_next outside the double inclusion check because
+    it should be possible to include this file more than once and still get
+    the definitions from gcc's header.  */
+#if defined __GNUC__ && !defined _GCC_LIMITS_H_
+/* `_GCC_LIMITS_H_' is what GCC's file defines.  */
+# include_next <limits.h>
+#endif
+
+/* The <limits.h> files in some gcc versions don't define LLONG_MIN,
+   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
+   ages are available.  */
+#if defined __USE_ISOC99 && defined __GNUC__
+# ifndef LLONG_MIN
+#  define LLONG_MIN	(-LLONG_MAX-1)
+# endif
+# ifndef LLONG_MAX
+#  define LLONG_MAX	__LONG_LONG_MAX__
+# endif
+# ifndef ULLONG_MAX
+#  define ULLONG_MAX	(LLONG_MAX * 2ULL + 1)
+# endif
+#endif
+
+#ifdef	__USE_POSIX
+/* POSIX adds things to <limits.h>.  */
+# include <bits/posix1_lim.h>
+#endif
+
+#ifdef	__USE_POSIX2
+# include <bits/posix2_lim.h>
+#endif
+
+#ifdef	__USE_XOPEN
+# include <bits/xopen_lim.h>
+#endif
diff --git a/include/link.h b/include/link.h
new file mode 100644
index 0000000..d5905d1
--- /dev/null
+++ b/include/link.h
@@ -0,0 +1,194 @@
+/* Data structure for communication from the run-time dynamic linker for
+   loaded ELF shared objects.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_LINK_H
+#define	_LINK_H	1
+
+#include <features.h>
+#include <elf.h>
+#include <dlfcn.h>
+#include <sys/types.h>
+
+/* We use this macro to refer to ELF types independent of the native wordsize.
+   `ElfW(TYPE)' is used in place of `Elf32_TYPE' or `Elf64_TYPE'.  */
+#define ElfW(type)	_ElfW (Elf, __ELF_NATIVE_CLASS, type)
+#define _ElfW(e,w,t)	_ElfW_1 (e, w, _##t)
+#define _ElfW_1(e,w,t)	e##w##t
+
+#include <bits/elfclass.h>		/* Defines __ELF_NATIVE_CLASS.  */
+#include <bits/link.h>
+
+/* Rendezvous structure used by the run-time dynamic linker to communicate
+   details of shared object loading to the debugger.  If the executable's
+   dynamic section has a DT_DEBUG element, the run-time linker sets that
+   element's value to the address where this structure can be found.  */
+
+struct r_debug
+  {
+    int r_version;		/* Version number for this protocol.  */
+
+    struct link_map *r_map;	/* Head of the chain of loaded objects.  */
+
+    /* This is the address of a function internal to the run-time linker,
+       that will always be called when the linker begins to map in a
+       library or unmap it, and again when the mapping change is complete.
+       The debugger can set a breakpoint at this address if it wants to
+       notice shared object mapping changes.  */
+    ElfW(Addr) r_brk;
+    enum
+      {
+	/* This state value describes the mapping change taking place when
+	   the `r_brk' address is called.  */
+	RT_CONSISTENT,		/* Mapping change is complete.  */
+	RT_ADD,			/* Beginning to add a new object.  */
+	RT_DELETE		/* Beginning to remove an object mapping.  */
+      } r_state;
+
+    ElfW(Addr) r_ldbase;	/* Base address the linker is loaded at.  */
+  };
+
+/* This is the instance of that structure used by the dynamic linker.  */
+extern struct r_debug _r_debug;
+
+/* This symbol refers to the "dynamic structure" in the `.dynamic' section
+   of whatever module refers to `_DYNAMIC'.  So, to find its own
+   `struct r_debug', a program could do:
+     for (dyn = _DYNAMIC; dyn->d_tag != DT_NULL; ++dyn)
+       if (dyn->d_tag == DT_DEBUG)
+	 r_debug = (struct r_debug *) dyn->d_un.d_ptr;
+   */
+extern ElfW(Dyn) _DYNAMIC[];
+
+/* Structure describing a loaded shared object.  The `l_next' and `l_prev'
+   members form a chain of all the shared objects loaded at startup.
+
+   These data structures exist in space used by the run-time dynamic linker;
+   modifying them may have disastrous results.  */
+
+struct link_map
+  {
+    /* These first few members are part of the protocol with the debugger.
+       This is the same format used in SVR4.  */
+
+    ElfW(Addr) l_addr;		/* Difference between the address in the ELF
+				   file and the addresses in memory.  */
+    char *l_name;		/* Absolute file name object was found in.  */
+    ElfW(Dyn) *l_ld;		/* Dynamic section of the shared object.  */
+    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */
+  };
+
+#ifdef __USE_GNU
+
+/* Version numbers for la_version handshake interface.  */
+#define LAV_CURRENT	1
+
+/* Activity types signaled through la_activity.  */
+enum
+  {
+    LA_ACT_CONSISTENT,		/* Link map consistent again.  */
+    LA_ACT_ADD,			/* New object will be added.  */
+    LA_ACT_DELETE		/* Objects will be removed.  */
+  };
+
+/* Values representing origin of name for dynamic loading.  */
+enum
+  {
+    LA_SER_ORIG = 0x01,		/* Original name.  */
+    LA_SER_LIBPATH = 0x02,	/* Directory from LD_LIBRARY_PATH.  */
+    LA_SER_RUNPATH = 0x04,	/* Directory from RPATH/RUNPATH.  */
+    LA_SER_CONFIG = 0x08,	/* Found through ldconfig.  */
+    LA_SER_DEFAULT = 0x40,	/* Default directory.  */
+    LA_SER_SECURE = 0x80	/* Unused.  */
+  };
+
+/* Values for la_objopen return value.  */
+enum
+  {
+    LA_FLG_BINDTO = 0x01,	/* Audit symbols bound to this object.  */
+    LA_FLG_BINDFROM = 0x02	/* Audit symbols bound from this object.  */
+  };
+
+/* Values for la_symbind flags parameter.  */
+enum
+  {
+    LA_SYMB_NOPLTENTER = 0x01,	/* la_pltenter will not be called.  */
+    LA_SYMB_NOPLTEXIT = 0x02,	/* la_pltexit will not be called.  */
+    LA_SYMB_STRUCTCALL = 0x04,	/* Return value is a structure.  */
+    LA_SYMB_DLSYM = 0x08,	/* Binding due to dlsym call.  */
+    LA_SYMB_ALTVALUE = 0x10	/* Value has been changed by a previous
+				   la_symbind call.  */
+  };
+
+struct dl_phdr_info
+  {
+    ElfW(Addr) dlpi_addr;
+    const char *dlpi_name;
+    const ElfW(Phdr) *dlpi_phdr;
+    ElfW(Half) dlpi_phnum;
+
+    /* Note: Following members were introduced after the first
+       version of this structure was available.  Check the SIZE
+       argument passed to the dl_iterate_phdr callback to determine
+       whether or not each later member is available.  */
+
+    /* Incremented when a new object may have been added.  */
+    __extension__ unsigned long long int dlpi_adds;
+    /* Incremented when an object may have been removed.  */
+    __extension__ unsigned long long int dlpi_subs;
+
+    /* If there is a PT_TLS segment, its module ID as used in
+       TLS relocations, else zero.  */
+    size_t dlpi_tls_modid;
+
+    /* The address of the calling thread's instance of this module's
+       PT_TLS segment, if it has one and it has been allocated
+       in the calling thread, otherwise a null pointer.  */
+    void *dlpi_tls_data;
+  };
+
+__BEGIN_DECLS
+
+extern int dl_iterate_phdr (int (*__callback) (struct dl_phdr_info *,
+					       size_t, void *),
+			    void *__data);
+
+
+/* Prototypes for the ld.so auditing interfaces.  These are not
+   defined anywhere in ld.so but instead have to be provided by the
+   auditing DSO.  */
+extern unsigned int la_version (unsigned int __version);
+extern void la_activity (uintptr_t *__cookie, unsigned int __flag);
+extern char *la_objsearch (const char *__name, uintptr_t *__cookie,
+			   unsigned int __flag);
+extern unsigned int la_objopen (struct link_map *__map, Lmid_t __lmid,
+				uintptr_t *__cookie);
+extern void la_preinit (uintptr_t *__cookie);
+extern uintptr_t la_symbind32 (Elf32_Sym *__sym, unsigned int __ndx,
+			       uintptr_t *__refcook, uintptr_t *__defcook,
+			       unsigned int *__flags, const char *__symname);
+extern uintptr_t la_symbind64 (Elf64_Sym *__sym, unsigned int __ndx,
+			       uintptr_t *__refcook, uintptr_t *__defcook,
+			       unsigned int *__flags, const char *__symname);
+extern unsigned int la_objclose (uintptr_t *__cookie);
+
+__END_DECLS
+
+#endif
+
+#endif /* link.h */
diff --git a/include/locale.h b/include/locale.h
new file mode 100644
index 0000000..269b61c
--- /dev/null
+++ b/include/locale.h
@@ -0,0 +1,207 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.11 Localization	<locale.h>
+ */
+
+#ifndef	_LOCALE_H
+#define	_LOCALE_H	1
+
+#include <features.h>
+
+#define __need_NULL
+#include <stddef.h>
+#include <bits/locale.h>
+
+__BEGIN_DECLS
+
+/* These are the possibilities for the first argument to setlocale.
+   The code assumes that the lowest LC_* symbol has the value zero.  */
+#define LC_CTYPE          __LC_CTYPE
+#define LC_NUMERIC        __LC_NUMERIC
+#define LC_TIME           __LC_TIME
+#define LC_COLLATE        __LC_COLLATE
+#define LC_MONETARY       __LC_MONETARY
+#define LC_MESSAGES       __LC_MESSAGES
+#define	LC_ALL		  __LC_ALL
+#define LC_PAPER	  __LC_PAPER
+#define LC_NAME		  __LC_NAME
+#define LC_ADDRESS	  __LC_ADDRESS
+#define LC_TELEPHONE	  __LC_TELEPHONE
+#define LC_MEASUREMENT	  __LC_MEASUREMENT
+#define LC_IDENTIFICATION __LC_IDENTIFICATION
+
+
+__BEGIN_NAMESPACE_STD
+
+/* Structure giving information about numeric and monetary notation.  */
+struct lconv
+{
+  /* Numeric (non-monetary) information.  */
+
+  char *decimal_point;		/* Decimal point character.  */
+  char *thousands_sep;		/* Thousands separator.  */
+  /* Each element is the number of digits in each group;
+     elements with higher indices are farther left.
+     An element with value CHAR_MAX means that no further grouping is done.
+     An element with value 0 means that the previous element is used
+     for all groups farther left.  */
+  char *grouping;
+
+  /* Monetary information.  */
+
+  /* First three chars are a currency symbol from ISO 4217.
+     Fourth char is the separator.  Fifth char is '\0'.  */
+  char *int_curr_symbol;
+  char *currency_symbol;	/* Local currency symbol.  */
+  char *mon_decimal_point;	/* Decimal point character.  */
+  char *mon_thousands_sep;	/* Thousands separator.  */
+  char *mon_grouping;		/* Like `grouping' element (above).  */
+  char *positive_sign;		/* Sign for positive values.  */
+  char *negative_sign;		/* Sign for negative values.  */
+  char int_frac_digits;		/* Int'l fractional digits.  */
+  char frac_digits;		/* Local fractional digits.  */
+  /* 1 if currency_symbol precedes a positive value, 0 if succeeds.  */
+  char p_cs_precedes;
+  /* 1 iff a space separates currency_symbol from a positive value.  */
+  char p_sep_by_space;
+  /* 1 if currency_symbol precedes a negative value, 0 if succeeds.  */
+  char n_cs_precedes;
+  /* 1 iff a space separates currency_symbol from a negative value.  */
+  char n_sep_by_space;
+  /* Positive and negative sign positions:
+     0 Parentheses surround the quantity and currency_symbol.
+     1 The sign string precedes the quantity and currency_symbol.
+     2 The sign string follows the quantity and currency_symbol.
+     3 The sign string immediately precedes the currency_symbol.
+     4 The sign string immediately follows the currency_symbol.  */
+  char p_sign_posn;
+  char n_sign_posn;
+#ifdef __USE_ISOC99
+  /* 1 if int_curr_symbol precedes a positive value, 0 if succeeds.  */
+  char int_p_cs_precedes;
+  /* 1 iff a space separates int_curr_symbol from a positive value.  */
+  char int_p_sep_by_space;
+  /* 1 if int_curr_symbol precedes a negative value, 0 if succeeds.  */
+  char int_n_cs_precedes;
+  /* 1 iff a space separates int_curr_symbol from a negative value.  */
+  char int_n_sep_by_space;
+  /* Positive and negative sign positions:
+     0 Parentheses surround the quantity and int_curr_symbol.
+     1 The sign string precedes the quantity and int_curr_symbol.
+     2 The sign string follows the quantity and int_curr_symbol.
+     3 The sign string immediately precedes the int_curr_symbol.
+     4 The sign string immediately follows the int_curr_symbol.  */
+  char int_p_sign_posn;
+  char int_n_sign_posn;
+#else
+  char __int_p_cs_precedes;
+  char __int_p_sep_by_space;
+  char __int_n_cs_precedes;
+  char __int_n_sep_by_space;
+  char __int_p_sign_posn;
+  char __int_n_sign_posn;
+#endif
+};
+
+
+/* Set and/or return the current locale.  */
+extern char *setlocale (int __category, const char *__locale) __THROW;
+
+/* Return the numeric/monetary information for the current locale.  */
+extern struct lconv *localeconv (void) __THROW;
+
+__END_NAMESPACE_STD
+
+
+#ifdef	__USE_XOPEN2K8
+/* The concept of one static locale per category is not very well
+   thought out.  Many applications will need to process its data using
+   information from several different locales.  Another application is
+   the implementation of the internationalization handling in the
+   upcoming ISO C++ standard library.  To support this another set of
+   the functions using locale data exist which have an additional
+   argument.
+
+   Attention: all these functions are *not* standardized in any form.
+   This is a proof-of-concept implementation.  */
+
+/* Get locale datatype definition.  */
+# include <xlocale.h>
+
+/* Return a reference to a data structure representing a set of locale
+   datasets.  Unlike for the CATEGORY parameter for `setlocale' the
+   CATEGORY_MASK parameter here uses a single bit for each category,
+   made by OR'ing together LC_*_MASK bits above.  */
+extern __locale_t newlocale (int __category_mask, const char *__locale,
+			     __locale_t __base) __THROW;
+
+/* These are the bits that can be set in the CATEGORY_MASK argument to
+   `newlocale'.  In the GNU implementation, LC_FOO_MASK has the value
+   of (1 << LC_FOO), but this is not a part of the interface that
+   callers can assume will be true.  */
+# define LC_CTYPE_MASK		(1 << __LC_CTYPE)
+# define LC_NUMERIC_MASK	(1 << __LC_NUMERIC)
+# define LC_TIME_MASK		(1 << __LC_TIME)
+# define LC_COLLATE_MASK	(1 << __LC_COLLATE)
+# define LC_MONETARY_MASK	(1 << __LC_MONETARY)
+# define LC_MESSAGES_MASK	(1 << __LC_MESSAGES)
+# define LC_PAPER_MASK		(1 << __LC_PAPER)
+# define LC_NAME_MASK		(1 << __LC_NAME)
+# define LC_ADDRESS_MASK	(1 << __LC_ADDRESS)
+# define LC_TELEPHONE_MASK	(1 << __LC_TELEPHONE)
+# define LC_MEASUREMENT_MASK	(1 << __LC_MEASUREMENT)
+# define LC_IDENTIFICATION_MASK	(1 << __LC_IDENTIFICATION)
+# define LC_ALL_MASK		(LC_CTYPE_MASK \
+				 | LC_NUMERIC_MASK \
+				 | LC_TIME_MASK \
+				 | LC_COLLATE_MASK \
+				 | LC_MONETARY_MASK \
+				 | LC_MESSAGES_MASK \
+				 | LC_PAPER_MASK \
+				 | LC_NAME_MASK \
+				 | LC_ADDRESS_MASK \
+				 | LC_TELEPHONE_MASK \
+				 | LC_MEASUREMENT_MASK \
+				 | LC_IDENTIFICATION_MASK \
+				 )
+
+/* Return a duplicate of the set of locale in DATASET.  All usage
+   counters are increased if necessary.  */
+extern __locale_t duplocale (__locale_t __dataset) __THROW;
+
+/* Free the data associated with a locale dataset previously returned
+   by a call to `setlocale_r'.  */
+extern void freelocale (__locale_t __dataset) __THROW;
+
+/* Switch the current thread's locale to DATASET.
+   If DATASET is null, instead just return the current setting.
+   The special value LC_GLOBAL_LOCALE is the initial setting
+   for all threads and can also be installed any time, meaning
+   the thread uses the global settings controlled by `setlocale'.  */
+extern __locale_t uselocale (__locale_t __dataset) __THROW;
+
+/* This value can be passed to `uselocale' and may be returned by it.
+   Passing this value to any other function has undefined behavior.  */
+# define LC_GLOBAL_LOCALE	((__locale_t) -1L)
+
+#endif
+
+__END_DECLS
+
+#endif /* locale.h  */
diff --git a/include/lock-intern.h b/include/lock-intern.h
new file mode 100644
index 0000000..6d315bb
--- /dev/null
+++ b/include/lock-intern.h
@@ -0,0 +1,116 @@
+/* Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LOCK_INTERN_H
+#define	_LOCK_INTERN_H
+
+#include <sys/cdefs.h>
+#include <machine-lock.h>
+
+#ifndef _EXTERN_INLINE
+#define _EXTERN_INLINE __extern_inline
+#endif
+
+
+/* Initialize LOCK.  */
+
+void __spin_lock_init (__spin_lock_t *__lock);
+
+#ifdef __USE_EXTERN_INLINES
+_EXTERN_INLINE void
+__spin_lock_init (__spin_lock_t *__lock)
+{
+  *__lock = __SPIN_LOCK_INITIALIZER;
+}
+#endif
+
+
+/* Lock LOCK, blocking if we can't get it.  */
+extern void __spin_lock_solid (__spin_lock_t *__lock);
+
+/* Lock the spin lock LOCK.  */
+
+void __spin_lock (__spin_lock_t *__lock);
+
+#ifdef __USE_EXTERN_INLINES
+_EXTERN_INLINE void
+__spin_lock (__spin_lock_t *__lock)
+{
+  if (! __spin_try_lock (__lock))
+    __spin_lock_solid (__lock);
+}
+#endif
+
+/* Name space-clean internal interface to mutex locks.
+
+   Code internal to the C library uses these functions to lock and unlock
+   mutex locks.  These locks are of type `struct mutex', defined in
+   <cthreads.h>.  The functions here are name space-clean.  If the program
+   is linked with the cthreads library, `__mutex_lock_solid' and
+   `__mutex_unlock_solid' will invoke the corresponding cthreads functions
+   to implement real mutex locks.  If not, simple stub versions just use
+   spin locks.  */
+
+
+/* Initialize the newly allocated mutex lock LOCK for further use.  */
+extern void __mutex_init (void *__lock);
+
+/* Lock LOCK, blocking if we can't get it.  */
+extern void __mutex_lock_solid (void *__lock);
+
+/* Finish unlocking LOCK, after the spin lock LOCK->held has already been
+   unlocked.  This function will wake up any thread waiting on LOCK.  */
+extern void __mutex_unlock_solid (void *__lock);
+
+/* Lock the mutex lock LOCK.  */
+
+void __mutex_lock (void *__lock);
+
+#ifdef __USE_EXTERN_INLINES
+_EXTERN_INLINE void
+__mutex_lock (void *__lock)
+{
+  if (! __spin_try_lock ((__spin_lock_t *) __lock))
+    __mutex_lock_solid (__lock);
+}
+#endif
+
+/* Unlock the mutex lock LOCK.  */
+
+void __mutex_unlock (void *__lock);
+
+#ifdef __USE_EXTERN_INLINES
+_EXTERN_INLINE void
+__mutex_unlock (void *__lock)
+{
+  __spin_unlock ((__spin_lock_t *) __lock);
+  __mutex_unlock_solid (__lock);
+}
+#endif
+
+
+int __mutex_trylock (void *__lock);
+
+#ifdef __USE_EXTERN_INLINES
+_EXTERN_INLINE int
+__mutex_trylock (void *__lock)
+{
+  return __spin_try_lock ((__spin_lock_t *) __lock);
+}
+#endif
+
+#endif /* lock-intern.h */
diff --git a/include/mach-shortcuts.h b/include/mach-shortcuts.h
new file mode 100644
index 0000000..12d8f3f
--- /dev/null
+++ b/include/mach-shortcuts.h
@@ -0,0 +1,318 @@
+/* Routine task_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_create
+(
+	mach_port_t target_task,
+	boolean_t inherit_memory,
+	mach_port_t *child_task
+);
+
+/* Routine task_terminate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_terminate
+(
+	mach_port_t target_task
+);
+
+/* Routine vm_allocate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_allocate
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t size,
+	boolean_t anywhere
+);
+
+/* Routine vm_deallocate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_deallocate
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size
+);
+
+/* Routine task_suspend */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_suspend
+(
+	mach_port_t target_task
+);
+
+/* Routine task_set_special_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_set_special_port
+(
+	mach_port_t task,
+	int which_port,
+	mach_port_t special_port
+);
+
+/* Routine vm_map */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_map
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t size,
+	vm_address_t mask,
+	boolean_t anywhere,
+	mach_port_t memory_object,
+	vm_offset_t offset,
+	boolean_t copy,
+	vm_prot_t cur_protection,
+	vm_prot_t max_protection,
+	vm_inherit_t inheritance
+);
+
+/* Routine task_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_create
+(
+	mach_port_t target_task,
+	boolean_t inherit_memory,
+	mach_port_t *child_task
+);
+
+/* Routine task_terminate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_terminate
+(
+	mach_port_t target_task
+);
+
+/* Routine vm_allocate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_allocate
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t size,
+	boolean_t anywhere
+);
+
+/* Routine vm_deallocate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_deallocate
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size
+);
+
+/* Routine task_suspend */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_suspend
+(
+	mach_port_t target_task
+);
+
+/* Routine task_set_special_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_set_special_port
+(
+	mach_port_t task,
+	int which_port,
+	mach_port_t special_port
+);
+
+/* Routine vm_map */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_map
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t size,
+	vm_address_t mask,
+	boolean_t anywhere,
+	mach_port_t memory_object,
+	vm_offset_t offset,
+	boolean_t copy,
+	vm_prot_t cur_protection,
+	vm_prot_t max_protection,
+	vm_inherit_t inheritance
+);
+
+/* Routine thread_depress_abort */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_depress_abort
+(
+	mach_port_t thread
+);
+
+/* Routine thread_depress_abort */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_depress_abort
+(
+	mach_port_t thread
+);
+
+/* Routine mach_port_allocate_name */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_allocate_name
+(
+	mach_port_t task,
+	mach_port_right_t right,
+	mach_port_t name
+);
+
+/* Routine mach_port_allocate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_allocate
+(
+	mach_port_t task,
+	mach_port_right_t right,
+	mach_port_t *name
+);
+
+/* Routine mach_port_deallocate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_deallocate
+(
+	mach_port_t task,
+	mach_port_t name
+);
+
+/* Routine mach_port_insert_right */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_insert_right
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_t poly,
+	mach_msg_type_name_t polyPoly
+);
+
+/* Routine mach_port_allocate_name */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_allocate_name
+(
+	mach_port_t task,
+	mach_port_right_t right,
+	mach_port_t name
+);
+
+/* Routine mach_port_allocate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_allocate
+(
+	mach_port_t task,
+	mach_port_right_t right,
+	mach_port_t *name
+);
+
+/* Routine mach_port_deallocate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_deallocate
+(
+	mach_port_t task,
+	mach_port_t name
+);
+
+/* Routine mach_port_insert_right */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_insert_right
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_t poly,
+	mach_msg_type_name_t polyPoly
+);
+
diff --git a/include/mach.h b/include/mach.h
new file mode 100644
index 0000000..f70a453
--- /dev/null
+++ b/include/mach.h
@@ -0,0 +1,107 @@
+/* Standard header for all Mach programs.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_MACH_H
+
+#define	_MACH_H	1
+
+/* We must include this before using __need_FILE with <stdio.h> below.  */
+#include <features.h>
+
+
+/* Get the basic types used by Mach.  */
+#include <mach/mach_types.h>
+
+/* This declares the basic variables and macros everything needs.  */
+#include <mach_init.h>
+
+/* This declares all the real system call functions.  */
+#include <mach/mach_traps.h>
+
+/* These are MiG-generated headers for the kernel interfaces commonly used.  */
+#include <mach/mach_interface.h> /* From <mach/mach.defs>.  */
+#include <mach/mach_port.h>
+#include <mach/mach_host.h>
+
+/* For the kernel RPCs which have system call shortcut versions,
+   the MiG-generated header in fact declares `CALL_rpc' rather than `CALL'.
+   This file declares the simple `CALL' functions.  */
+#include <mach-shortcuts.h>
+
+
+/* Receive RPC request messages on RCV_NAME and pass them to DEMUX, which
+   decodes them and produces reply messages.  MAX_SIZE is the maximum size
+   (in bytes) of the request and reply buffers.  */
+extern mach_msg_return_t
+__mach_msg_server (boolean_t (*__demux) (mach_msg_header_t *__request,
+					 mach_msg_header_t *__reply),
+		   mach_msg_size_t __max_size,
+		   mach_port_t __rcv_name),
+mach_msg_server (boolean_t (*__demux) (mach_msg_header_t *__request,
+				       mach_msg_header_t *__reply),
+		 mach_msg_size_t __max_size,
+		 mach_port_t __rcv_name);
+
+/* Just like `mach_msg_server', but the OPTION and TIMEOUT parameters are
+   passed on to `mach_msg'.  */
+extern mach_msg_return_t
+__mach_msg_server_timeout (boolean_t (*__demux) (mach_msg_header_t *__request,
+						 mach_msg_header_t *__reply),
+			   mach_msg_size_t __max_size,
+			   mach_port_t __rcv_name,
+			   mach_msg_option_t __option,
+			   mach_msg_timeout_t __timeout),
+mach_msg_server_timeout (boolean_t (*__demux) (mach_msg_header_t *__request,
+					       mach_msg_header_t *__reply),
+			 mach_msg_size_t __max_size,
+			 mach_port_t __rcv_name,
+			 mach_msg_option_t __option,
+			 mach_msg_timeout_t __timeout);
+
+
+/* Deallocate all port rights and out-of-line memory in MSG. */
+extern void
+__mach_msg_destroy (mach_msg_header_t *msg),
+mach_msg_destroy (mach_msg_header_t *msg);
+
+
+#define __need_FILE
+#include <stdio.h>
+
+/* Open a stream on a Mach device.  */
+extern FILE *mach_open_devstream (mach_port_t device_port, const char *mode);
+
+/* Give THREAD a stack and set it to run at PC when resumed.
+   If *STACK_SIZE is nonzero, that size of stack is allocated.
+   If *STACK_BASE is nonzero, that stack location is used.
+   If STACK_BASE is not null it is filled in with the chosen stack base.
+   If STACK_SIZE is not null it is filled in with the chosen stack size.
+   Regardless, an extra page of red zone is allocated off the end; this
+   is not included in *STACK_SIZE.  */
+kern_return_t __mach_setup_thread (task_t task, thread_t thread, void *pc,
+				   vm_address_t *stack_base,
+				   vm_size_t *stack_size);
+kern_return_t mach_setup_thread (task_t task, thread_t thread, void *pc,
+				 vm_address_t *stack_base,
+				 vm_size_t *stack_size);
+
+/* Give THREAD a TLS area.  */
+kern_return_t __mach_setup_tls (thread_t thread);
+kern_return_t mach_setup_tls (thread_t thread);
+
+#endif	/* mach.h */
diff --git a/include/mach/default_pager.h b/include/mach/default_pager.h
new file mode 100644
index 0000000..4d50972
--- /dev/null
+++ b/include/mach/default_pager.h
@@ -0,0 +1,185 @@
+#ifndef	_default_pager_user_
+#define	_default_pager_user_
+
+/* Module default_pager */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <mach/default_pager_types.h>
+
+/* Routine default_pager_object_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __default_pager_object_create
+(
+	mach_port_t default_pager,
+	memory_object_t *memory_object,
+	vm_size_t object_size
+);
+
+/* Routine default_pager_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __default_pager_info
+(
+	mach_port_t default_pager,
+	default_pager_info_t *info
+);
+
+/* Routine default_pager_objects */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __default_pager_objects
+(
+	mach_port_t default_pager,
+	default_pager_object_array_t *objects,
+	mach_msg_type_number_t *objectsCnt,
+	mach_port_array_t *ports,
+	mach_msg_type_number_t *portsCnt
+);
+
+/* Routine default_pager_object_pages */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __default_pager_object_pages
+(
+	mach_port_t default_pager,
+	mach_port_t memory_object,
+	default_pager_page_array_t *pages,
+	mach_msg_type_number_t *pagesCnt
+);
+
+/* Routine default_pager_paging_file */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __default_pager_paging_file
+(
+	mach_port_t default_pager,
+	mach_port_t master_device_port,
+	default_pager_filename_t filename,
+	boolean_t add
+);
+
+/* Routine default_pager_register_fileserver */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __default_pager_register_fileserver
+(
+	mach_port_t default_pager,
+	mach_port_t fileserver_port
+);
+
+
+/* Module default_pager */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <mach/default_pager_types.h>
+
+/* Routine default_pager_object_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t default_pager_object_create
+(
+	mach_port_t default_pager,
+	memory_object_t *memory_object,
+	vm_size_t object_size
+);
+
+/* Routine default_pager_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t default_pager_info
+(
+	mach_port_t default_pager,
+	default_pager_info_t *info
+);
+
+/* Routine default_pager_objects */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t default_pager_objects
+(
+	mach_port_t default_pager,
+	default_pager_object_array_t *objects,
+	mach_msg_type_number_t *objectsCnt,
+	mach_port_array_t *ports,
+	mach_msg_type_number_t *portsCnt
+);
+
+/* Routine default_pager_object_pages */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t default_pager_object_pages
+(
+	mach_port_t default_pager,
+	mach_port_t memory_object,
+	default_pager_page_array_t *pages,
+	mach_msg_type_number_t *pagesCnt
+);
+
+/* Routine default_pager_paging_file */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t default_pager_paging_file
+(
+	mach_port_t default_pager,
+	mach_port_t master_device_port,
+	default_pager_filename_t filename,
+	boolean_t add
+);
+
+/* Routine default_pager_register_fileserver */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t default_pager_register_fileserver
+(
+	mach_port_t default_pager,
+	mach_port_t fileserver_port
+);
+
+#endif	/* not defined(_default_pager_user_) */
diff --git a/include/mach/error.h b/include/mach/error.h
new file mode 100644
index 0000000..084d8af
--- /dev/null
+++ b/include/mach/error.h
@@ -0,0 +1,137 @@
+/*  err_hurd added by roland@gnu.ai.mit.edu for GNU Hurd.
+ *
+ * Mach Operating System
+ * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ *
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ *
+ * Carnegie Mellon requests users of this software to return to
+ *
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ *
+ * any improvements or extensions that they make and grant Carnegie Mellon
+ * the rights to redistribute these changes.
+ */
+/*
+ * (pre-GNU) HISTORY
+ *
+ * Revision 2.6  93/01/14  17:41:31  danner
+ * 	Standardized include symbol name.
+ * 	[92/06/10            pds]
+ *
+ * Revision 2.5  92/03/31  15:18:11  rpd
+ * 	Added err_bootstrap for bootstrap errors.
+ * 	[92/03/09            rpd]
+ *
+ * Revision 2.4  91/05/14  16:51:24  mrt
+ * 	Correcting copyright
+ *
+ * Revision 2.3  91/02/05  17:31:48  mrt
+ * 	Changed to new Mach copyright
+ * 	[91/02/01  17:16:50  mrt]
+ *
+ * Revision 2.2  90/06/02  14:57:47  rpd
+ * 	Added err_mach_ipc for new IPC.
+ * 	[90/03/26  22:28:42  rpd]
+ *
+ * Revision 2.1  89/08/03  16:02:07  rwd
+ * Created.
+ *
+ * Revision 2.4  89/02/25  18:13:18  gm0w
+ * 	Changes for cleanup.
+ *
+ * Revision 2.3  89/02/07  00:51:57  mwyoung
+ * Relocated from sys/error.h
+ *
+ * Revision 2.2  88/10/18  00:37:31  mwyoung
+ * 	Added {system,sub and code}_emask
+ * 	[88/10/17  17:06:58  mrt]
+ *
+ *	Added {system,sub and code}_emask
+ *
+ *  12-May-88 Mary Thompson (mrt) at Carnegie Mellon
+ *	Changed mach_error_t from unsigned int to kern_return_t
+ *	which is a 32 bit integer regardless of machine type.
+ *      unsigned int was incompatible with old usages of mach_error.
+ *
+ *  10-May-88 Douglas Orr (dorr) at Carnegie-Mellon University
+ *	Missing endif replaced
+ *
+ *   5-May-88 Mary Thompson (mrt) at Carnegie Mellon
+ *	Changed typedef of mach_error_t from long to unsigned int
+ *	to keep our Camelot users happy. Also moved the nonkernel
+ *	function declarations from here to mach_error.h.
+ *
+ *  10-Feb-88 Douglas Orr (dorr) at Carnegie-Mellon University
+ *	Created.
+ *
+ */
+/*
+ * File:	mach/error.h
+ * Purpose:
+ *	error module definitions
+ *
+ */
+
+#ifndef	_MACH_ERROR_H_
+#define _MACH_ERROR_H_
+#include <mach/kern_return.h>
+
+/*
+ *	error number layout as follows:
+ *
+ *	hi		 		       lo
+ *	| system(6) | subsystem(12) | code(14) |
+ */
+
+
+#define	err_none		(mach_error_t)0
+#define ERR_SUCCESS		(mach_error_t)0
+#define	ERR_ROUTINE_NIL		(mach_error_fn_t)0
+
+
+#define	err_system(x)		(((x)&0x3f)<<26)
+#define err_sub(x)		(((x)&0xfff)<<14)
+
+#define err_get_system(err)	(((err)>>26)&0x3f)
+#define err_get_sub(err)	(((err)>>14)&0xfff)
+#define err_get_code(err)	((err)&0x3fff)
+
+#define system_emask		(err_system(0x3f))
+#define sub_emask		(err_sub(0xfff))
+#define code_emask		(0x3fff)
+
+
+/*	major error systems	*/
+#define	err_kern		err_system(0x0)		/* kernel */
+#define	err_us			err_system(0x1)		/* user space library */
+#define	err_server		err_system(0x2)		/* user space servers */
+#define	err_ipc			err_system(0x3)		/* old ipc errors */
+#define err_mach_ipc		err_system(0x4)		/* mach-ipc errors */
+#define err_bootstrap		err_system(0x5)		/* bootstrap errors */
+#define err_hurd		err_system(0x10) /* GNU Hurd server errors */
+#define err_local		err_system(0x3e)	/* user defined errors */
+#define	err_ipc_compat		err_system(0x3f)	/* (compatibility) mach-ipc errors */
+
+#define	err_max_system		0x3f
+
+
+/*	unix errors get lumped into one subsystem  */
+#define	unix_err(errno)		(err_kern|err_sub(3)|errno)
+
+typedef	kern_return_t	mach_error_t;
+/* typedef mach_error_t	(* mach_error_fn_t)(); */
+
+#endif	/* _MACH_ERROR_H_ */
diff --git a/include/mach/exc.h b/include/mach/exc.h
new file mode 100644
index 0000000..4767586
--- /dev/null
+++ b/include/mach/exc.h
@@ -0,0 +1,53 @@
+#ifndef	_exc_user_
+#define	_exc_user_
+
+/* Module exc */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+
+/* Routine exception_raise */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __exception_raise
+(
+	mach_port_t exception_port,
+	mach_port_t thread,
+	mach_port_t task,
+	integer_t exception,
+	integer_t code,
+	integer_t subcode
+);
+
+
+/* Module exc */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+
+/* Routine exception_raise */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t exception_raise
+(
+	mach_port_t exception_port,
+	mach_port_t thread,
+	mach_port_t task,
+	integer_t exception,
+	integer_t code,
+	integer_t subcode
+);
+
+#endif	/* not defined(_exc_user_) */
diff --git a/include/mach/exc_server.h b/include/mach/exc_server.h
new file mode 100644
index 0000000..6816098
--- /dev/null
+++ b/include/mach/exc_server.h
@@ -0,0 +1,43 @@
+#ifndef	_exc_server_
+#define	_exc_server_
+
+/* Module exc */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/mig_errors.h>
+#include <mach/std_types.h>
+
+/* Routine exception_raise */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t _S_catch_exception_raise
+(
+	mach_port_t exception_port,
+	mach_port_t thread,
+	mach_port_t task,
+	integer_t exception,
+	integer_t code,
+	integer_t subcode
+);
+
+extern mig_routine_t _S_exc_server_routines[];
+static inline mig_routine_t _S_exc_server_routine
+	(const mach_msg_header_t *InHeadP)
+{
+	int msgh_id;
+
+	msgh_id = InHeadP->msgh_id - 2400;
+
+	if ((msgh_id > 0) || (msgh_id < 0))
+		return 0;
+
+	return _S_exc_server_routines[msgh_id];
+}
+
+#endif	/* not defined(_exc_server_) */
diff --git a/include/mach/gnumach.h b/include/mach/gnumach.h
new file mode 100644
index 0000000..70f9dd4
--- /dev/null
+++ b/include/mach/gnumach.h
@@ -0,0 +1,221 @@
+#ifndef	_gnumach_user_
+#define	_gnumach_user_
+
+/* Module gnumach */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <mach_debug/mach_debug_types.h>
+
+/* Routine vm_cache_statistics */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_cache_statistics
+(
+	mach_port_t target_task,
+	vm_cache_statistics_data_t *vm_cache_stats
+);
+
+/* SimpleRoutine thread_terminate_release */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_terminate_release
+(
+	mach_port_t thread,
+	mach_port_t task,
+	mach_port_t thread_name,
+	mach_port_t reply_port,
+	vm_address_t address,
+	vm_size_t size
+);
+
+/* SimpleRoutine task_set_name */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_set_name
+(
+	mach_port_t task,
+	kernel_debug_name_t name
+);
+
+/* Routine register_new_task_notification */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __register_new_task_notification
+(
+	mach_port_t host_priv,
+	mach_port_t notification,
+	mach_msg_type_name_t notificationPoly
+);
+
+/* Routine gsync_wait */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __gsync_wait
+(
+	mach_port_t task,
+	vm_offset_t addr,
+	unsigned val1,
+	unsigned val2,
+	natural_t msec,
+	int flags
+);
+
+/* SimpleRoutine gsync_wake */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __gsync_wake
+(
+	mach_port_t task,
+	vm_offset_t addr,
+	unsigned val,
+	int flags
+);
+
+/* SimpleRoutine gsync_requeue */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __gsync_requeue
+(
+	mach_port_t task,
+	vm_offset_t src_addr,
+	vm_offset_t dst_addr,
+	boolean_t wake_one,
+	int flags
+);
+
+
+/* Module gnumach */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <mach_debug/mach_debug_types.h>
+
+/* Routine vm_cache_statistics */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_cache_statistics
+(
+	mach_port_t target_task,
+	vm_cache_statistics_data_t *vm_cache_stats
+);
+
+/* SimpleRoutine thread_terminate_release */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_terminate_release
+(
+	mach_port_t thread,
+	mach_port_t task,
+	mach_port_t thread_name,
+	mach_port_t reply_port,
+	vm_address_t address,
+	vm_size_t size
+);
+
+/* SimpleRoutine task_set_name */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_set_name
+(
+	mach_port_t task,
+	kernel_debug_name_t name
+);
+
+/* Routine register_new_task_notification */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t register_new_task_notification
+(
+	mach_port_t host_priv,
+	mach_port_t notification,
+	mach_msg_type_name_t notificationPoly
+);
+
+/* Routine gsync_wait */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t gsync_wait
+(
+	mach_port_t task,
+	vm_offset_t addr,
+	unsigned val1,
+	unsigned val2,
+	natural_t msec,
+	int flags
+);
+
+/* SimpleRoutine gsync_wake */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t gsync_wake
+(
+	mach_port_t task,
+	vm_offset_t addr,
+	unsigned val,
+	int flags
+);
+
+/* SimpleRoutine gsync_requeue */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t gsync_requeue
+(
+	mach_port_t task,
+	vm_offset_t src_addr,
+	vm_offset_t dst_addr,
+	boolean_t wake_one,
+	int flags
+);
+
+#endif	/* not defined(_gnumach_user_) */
diff --git a/include/mach/i386/mach_i386.h b/include/mach/i386/mach_i386.h
new file mode 100644
index 0000000..3c5bd9f
--- /dev/null
+++ b/include/mach/i386/mach_i386.h
@@ -0,0 +1,189 @@
+#ifndef	_mach_i386_user_
+#define	_mach_i386_user_
+
+/* Module mach_i386 */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <mach/machine/mach_i386_types.h>
+
+/* Routine i386_set_ldt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __i386_set_ldt
+(
+	mach_port_t target_thread,
+	int first_selector,
+	descriptor_list_t desc_list,
+	mach_msg_type_number_t desc_listCnt
+);
+
+/* Routine i386_get_ldt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __i386_get_ldt
+(
+	mach_port_t target_thread,
+	int first_selector,
+	int selector_count,
+	descriptor_list_t *desc_list,
+	mach_msg_type_number_t *desc_listCnt
+);
+
+/* Routine i386_io_perm_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __i386_io_perm_create
+(
+	mach_port_t master_port,
+	io_port_t from,
+	io_port_t to,
+	mach_port_t *io_perm
+);
+
+/* Routine i386_io_perm_modify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __i386_io_perm_modify
+(
+	mach_port_t target_task,
+	mach_port_t io_perm,
+	boolean_t enable
+);
+
+/* Routine i386_set_gdt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __i386_set_gdt
+(
+	mach_port_t target_thread,
+	int *selector,
+	descriptor_t desc
+);
+
+/* Routine i386_get_gdt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __i386_get_gdt
+(
+	mach_port_t target_thread,
+	int selector,
+	descriptor_t *desc
+);
+
+
+/* Module mach_i386 */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+#include <mach/machine/mach_i386_types.h>
+
+/* Routine i386_set_ldt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t i386_set_ldt
+(
+	mach_port_t target_thread,
+	int first_selector,
+	descriptor_list_t desc_list,
+	mach_msg_type_number_t desc_listCnt
+);
+
+/* Routine i386_get_ldt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t i386_get_ldt
+(
+	mach_port_t target_thread,
+	int first_selector,
+	int selector_count,
+	descriptor_list_t *desc_list,
+	mach_msg_type_number_t *desc_listCnt
+);
+
+/* Routine i386_io_perm_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t i386_io_perm_create
+(
+	mach_port_t master_port,
+	io_port_t from,
+	io_port_t to,
+	mach_port_t *io_perm
+);
+
+/* Routine i386_io_perm_modify */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t i386_io_perm_modify
+(
+	mach_port_t target_task,
+	mach_port_t io_perm,
+	boolean_t enable
+);
+
+/* Routine i386_set_gdt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t i386_set_gdt
+(
+	mach_port_t target_thread,
+	int *selector,
+	descriptor_t desc
+);
+
+/* Routine i386_get_gdt */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t i386_get_gdt
+(
+	mach_port_t target_thread,
+	int selector,
+	descriptor_t *desc
+);
+
+#endif	/* not defined(_mach_i386_user_) */
diff --git a/include/mach/mach.h b/include/mach/mach.h
new file mode 100644
index 0000000..826e717
--- /dev/null
+++ b/include/mach/mach.h
@@ -0,0 +1,3 @@
+/* Some old programs may expect to find <mach.h> in <mach/mach.h>.  */
+
+#include <mach.h>
diff --git a/include/mach/mach4.h b/include/mach/mach4.h
new file mode 100644
index 0000000..aacb6de
--- /dev/null
+++ b/include/mach/mach4.h
@@ -0,0 +1,221 @@
+#ifndef	_mach4_user_
+#define	_mach4_user_
+
+/* Module mach4 */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* Routine task_enable_pc_sampling */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_enable_pc_sampling
+(
+	mach_port_t host,
+	int *tick,
+	sampled_pc_flavor_t flavor
+);
+
+/* Routine task_disable_pc_sampling */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_disable_pc_sampling
+(
+	mach_port_t host,
+	int *samplecnt
+);
+
+/* Routine task_get_sampled_pcs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_get_sampled_pcs
+(
+	mach_port_t host,
+	sampled_pc_seqno_t *seqno,
+	sampled_pc_array_t sampled_pcs,
+	mach_msg_type_number_t *sampled_pcsCnt
+);
+
+/* Routine thread_enable_pc_sampling */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_enable_pc_sampling
+(
+	mach_port_t host,
+	int *tick,
+	sampled_pc_flavor_t flavor
+);
+
+/* Routine thread_disable_pc_sampling */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_disable_pc_sampling
+(
+	mach_port_t host,
+	int *samplecnt
+);
+
+/* Routine thread_get_sampled_pcs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_get_sampled_pcs
+(
+	mach_port_t host,
+	sampled_pc_seqno_t *seqno,
+	sampled_pc_array_t sampled_pcs,
+	mach_msg_type_number_t *sampled_pcsCnt
+);
+
+/* Routine memory_object_create_proxy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_create_proxy
+(
+	mach_port_t task,
+	vm_prot_t max_protection,
+	memory_object_array_t object,
+	mach_msg_type_number_t objectCnt,
+	vm_offset_array_t offset,
+	mach_msg_type_number_t offsetCnt,
+	vm_offset_array_t start,
+	mach_msg_type_number_t startCnt,
+	vm_offset_array_t len,
+	mach_msg_type_number_t lenCnt,
+	mach_port_t *proxy
+);
+
+
+/* Module mach4 */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* Routine task_enable_pc_sampling */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_enable_pc_sampling
+(
+	mach_port_t host,
+	int *tick,
+	sampled_pc_flavor_t flavor
+);
+
+/* Routine task_disable_pc_sampling */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_disable_pc_sampling
+(
+	mach_port_t host,
+	int *samplecnt
+);
+
+/* Routine task_get_sampled_pcs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_get_sampled_pcs
+(
+	mach_port_t host,
+	sampled_pc_seqno_t *seqno,
+	sampled_pc_array_t sampled_pcs,
+	mach_msg_type_number_t *sampled_pcsCnt
+);
+
+/* Routine thread_enable_pc_sampling */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_enable_pc_sampling
+(
+	mach_port_t host,
+	int *tick,
+	sampled_pc_flavor_t flavor
+);
+
+/* Routine thread_disable_pc_sampling */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_disable_pc_sampling
+(
+	mach_port_t host,
+	int *samplecnt
+);
+
+/* Routine thread_get_sampled_pcs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_get_sampled_pcs
+(
+	mach_port_t host,
+	sampled_pc_seqno_t *seqno,
+	sampled_pc_array_t sampled_pcs,
+	mach_msg_type_number_t *sampled_pcsCnt
+);
+
+/* Routine memory_object_create_proxy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_create_proxy
+(
+	mach_port_t task,
+	vm_prot_t max_protection,
+	memory_object_array_t object,
+	mach_msg_type_number_t objectCnt,
+	vm_offset_array_t offset,
+	mach_msg_type_number_t offsetCnt,
+	vm_offset_array_t start,
+	mach_msg_type_number_t startCnt,
+	vm_offset_array_t len,
+	mach_msg_type_number_t lenCnt,
+	mach_port_t *proxy
+);
+
+#endif	/* not defined(_mach4_user_) */
diff --git a/include/mach/mach_host.h b/include/mach/mach_host.h
new file mode 100644
index 0000000..81772b5
--- /dev/null
+++ b/include/mach/mach_host.h
@@ -0,0 +1,981 @@
+#ifndef	_mach_host_user_
+#define	_mach_host_user_
+
+/* Module mach_host */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* Routine host_processors */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_processors
+(
+	mach_port_t host_priv,
+	processor_array_t *processor_list,
+	mach_msg_type_number_t *processor_listCnt
+);
+
+/* Routine processor_start */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_start
+(
+	mach_port_t processor
+);
+
+/* Routine processor_exit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_exit
+(
+	mach_port_t processor
+);
+
+/* Routine processor_set_default */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_set_default
+(
+	mach_port_t host,
+	mach_port_t *default_set
+);
+
+/* Routine processor_set_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_set_create
+(
+	mach_port_t host,
+	mach_port_t *new_set,
+	mach_port_t *new_name
+);
+
+/* Routine processor_set_destroy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_set_destroy
+(
+	mach_port_t set
+);
+
+/* Routine processor_assign */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_assign
+(
+	mach_port_t processor,
+	mach_port_t new_set,
+	boolean_t wait
+);
+
+/* Routine processor_get_assignment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_get_assignment
+(
+	mach_port_t processor,
+	mach_port_t *assigned_set
+);
+
+/* Routine thread_assign */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_assign
+(
+	mach_port_t thread,
+	mach_port_t new_set
+);
+
+/* Routine thread_assign_default */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_assign_default
+(
+	mach_port_t thread
+);
+
+/* Routine thread_get_assignment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_get_assignment
+(
+	mach_port_t thread,
+	mach_port_t *assigned_set
+);
+
+/* Routine task_assign */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_assign
+(
+	mach_port_t task,
+	mach_port_t new_set,
+	boolean_t assign_threads
+);
+
+/* Routine task_assign_default */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_assign_default
+(
+	mach_port_t task,
+	boolean_t assign_threads
+);
+
+/* Routine task_get_assignment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_get_assignment
+(
+	mach_port_t task,
+	mach_port_t *assigned_set
+);
+
+/* Routine host_kernel_version */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_kernel_version
+(
+	mach_port_t host,
+	kernel_version_t kernel_version
+);
+
+/* Routine thread_priority */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_priority
+(
+	mach_port_t thread,
+	int priority,
+	boolean_t set_max
+);
+
+/* Routine thread_max_priority */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_max_priority
+(
+	mach_port_t thread,
+	mach_port_t processor_set,
+	int max_priority
+);
+
+/* Routine task_priority */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_priority
+(
+	mach_port_t task,
+	int priority,
+	boolean_t change_threads
+);
+
+/* Routine processor_set_max_priority */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_set_max_priority
+(
+	mach_port_t processor_set,
+	int max_priority,
+	boolean_t change_threads
+);
+
+/* Routine thread_policy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_policy
+(
+	mach_port_t thread,
+	int policy,
+	int data
+);
+
+/* Routine processor_set_policy_enable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_set_policy_enable
+(
+	mach_port_t processor_set,
+	int policy
+);
+
+/* Routine processor_set_policy_disable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_set_policy_disable
+(
+	mach_port_t processor_set,
+	int policy,
+	boolean_t change_threads
+);
+
+/* Routine processor_set_tasks */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_set_tasks
+(
+	mach_port_t processor_set,
+	task_array_t *task_list,
+	mach_msg_type_number_t *task_listCnt
+);
+
+/* Routine processor_set_threads */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_set_threads
+(
+	mach_port_t processor_set,
+	thread_array_t *thread_list,
+	mach_msg_type_number_t *thread_listCnt
+);
+
+/* Routine host_processor_sets */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_processor_sets
+(
+	mach_port_t host,
+	processor_set_name_array_t *processor_sets,
+	mach_msg_type_number_t *processor_setsCnt
+);
+
+/* Routine host_processor_set_priv */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_processor_set_priv
+(
+	mach_port_t host_priv,
+	mach_port_t set_name,
+	mach_port_t *set
+);
+
+/* Routine thread_depress_abort_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_depress_abort_rpc
+(
+	mach_port_t thread
+);
+
+/* Routine host_set_time */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_set_time
+(
+	mach_port_t host_priv,
+	time_value_t new_time
+);
+
+/* Routine host_adjust_time */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_adjust_time
+(
+	mach_port_t host_priv,
+	time_value_t new_adjustment,
+	time_value_t *old_adjustment
+);
+
+/* Routine host_get_time */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_get_time
+(
+	mach_port_t host,
+	time_value_t *current_time
+);
+
+/* Routine host_reboot */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_reboot
+(
+	mach_port_t host_priv,
+	int options
+);
+
+/* Routine vm_wire */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_wire
+(
+	mach_port_t host,
+	mach_port_t task,
+	vm_address_t address,
+	vm_size_t size,
+	vm_prot_t access
+);
+
+/* Routine thread_wire */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_wire
+(
+	mach_port_t host_priv,
+	mach_port_t thread,
+	boolean_t wired
+);
+
+/* Routine host_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_info
+(
+	mach_port_t host,
+	int flavor,
+	host_info_t host_info_out,
+	mach_msg_type_number_t *host_info_outCnt
+);
+
+/* Routine processor_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_info
+(
+	mach_port_t processor,
+	int flavor,
+	mach_port_t *host,
+	processor_info_t processor_info_out,
+	mach_msg_type_number_t *processor_info_outCnt
+);
+
+/* Routine processor_set_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_set_info
+(
+	mach_port_t set_name,
+	int flavor,
+	mach_port_t *host,
+	processor_set_info_t info_out,
+	mach_msg_type_number_t *info_outCnt
+);
+
+/* Routine processor_control */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __processor_control
+(
+	mach_port_t processor,
+	processor_info_t processor_cmd,
+	mach_msg_type_number_t processor_cmdCnt
+);
+
+/* Routine host_get_boot_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __host_get_boot_info
+(
+	mach_port_t host_priv,
+	kernel_boot_info_t boot_info
+);
+
+
+/* Module mach_host */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* Routine host_processors */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_processors
+(
+	mach_port_t host_priv,
+	processor_array_t *processor_list,
+	mach_msg_type_number_t *processor_listCnt
+);
+
+/* Routine processor_start */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_start
+(
+	mach_port_t processor
+);
+
+/* Routine processor_exit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_exit
+(
+	mach_port_t processor
+);
+
+/* Routine processor_set_default */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_set_default
+(
+	mach_port_t host,
+	mach_port_t *default_set
+);
+
+/* Routine processor_set_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_set_create
+(
+	mach_port_t host,
+	mach_port_t *new_set,
+	mach_port_t *new_name
+);
+
+/* Routine processor_set_destroy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_set_destroy
+(
+	mach_port_t set
+);
+
+/* Routine processor_assign */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_assign
+(
+	mach_port_t processor,
+	mach_port_t new_set,
+	boolean_t wait
+);
+
+/* Routine processor_get_assignment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_get_assignment
+(
+	mach_port_t processor,
+	mach_port_t *assigned_set
+);
+
+/* Routine thread_assign */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_assign
+(
+	mach_port_t thread,
+	mach_port_t new_set
+);
+
+/* Routine thread_assign_default */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_assign_default
+(
+	mach_port_t thread
+);
+
+/* Routine thread_get_assignment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_get_assignment
+(
+	mach_port_t thread,
+	mach_port_t *assigned_set
+);
+
+/* Routine task_assign */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_assign
+(
+	mach_port_t task,
+	mach_port_t new_set,
+	boolean_t assign_threads
+);
+
+/* Routine task_assign_default */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_assign_default
+(
+	mach_port_t task,
+	boolean_t assign_threads
+);
+
+/* Routine task_get_assignment */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_get_assignment
+(
+	mach_port_t task,
+	mach_port_t *assigned_set
+);
+
+/* Routine host_kernel_version */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_kernel_version
+(
+	mach_port_t host,
+	kernel_version_t kernel_version
+);
+
+/* Routine thread_priority */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_priority
+(
+	mach_port_t thread,
+	int priority,
+	boolean_t set_max
+);
+
+/* Routine thread_max_priority */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_max_priority
+(
+	mach_port_t thread,
+	mach_port_t processor_set,
+	int max_priority
+);
+
+/* Routine task_priority */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_priority
+(
+	mach_port_t task,
+	int priority,
+	boolean_t change_threads
+);
+
+/* Routine processor_set_max_priority */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_set_max_priority
+(
+	mach_port_t processor_set,
+	int max_priority,
+	boolean_t change_threads
+);
+
+/* Routine thread_policy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_policy
+(
+	mach_port_t thread,
+	int policy,
+	int data
+);
+
+/* Routine processor_set_policy_enable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_set_policy_enable
+(
+	mach_port_t processor_set,
+	int policy
+);
+
+/* Routine processor_set_policy_disable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_set_policy_disable
+(
+	mach_port_t processor_set,
+	int policy,
+	boolean_t change_threads
+);
+
+/* Routine processor_set_tasks */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_set_tasks
+(
+	mach_port_t processor_set,
+	task_array_t *task_list,
+	mach_msg_type_number_t *task_listCnt
+);
+
+/* Routine processor_set_threads */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_set_threads
+(
+	mach_port_t processor_set,
+	thread_array_t *thread_list,
+	mach_msg_type_number_t *thread_listCnt
+);
+
+/* Routine host_processor_sets */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_processor_sets
+(
+	mach_port_t host,
+	processor_set_name_array_t *processor_sets,
+	mach_msg_type_number_t *processor_setsCnt
+);
+
+/* Routine host_processor_set_priv */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_processor_set_priv
+(
+	mach_port_t host_priv,
+	mach_port_t set_name,
+	mach_port_t *set
+);
+
+/* Routine thread_depress_abort_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_depress_abort_rpc
+(
+	mach_port_t thread
+);
+
+/* Routine host_set_time */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_set_time
+(
+	mach_port_t host_priv,
+	time_value_t new_time
+);
+
+/* Routine host_adjust_time */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_adjust_time
+(
+	mach_port_t host_priv,
+	time_value_t new_adjustment,
+	time_value_t *old_adjustment
+);
+
+/* Routine host_get_time */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_get_time
+(
+	mach_port_t host,
+	time_value_t *current_time
+);
+
+/* Routine host_reboot */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_reboot
+(
+	mach_port_t host_priv,
+	int options
+);
+
+/* Routine vm_wire */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_wire
+(
+	mach_port_t host,
+	mach_port_t task,
+	vm_address_t address,
+	vm_size_t size,
+	vm_prot_t access
+);
+
+/* Routine thread_wire */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_wire
+(
+	mach_port_t host_priv,
+	mach_port_t thread,
+	boolean_t wired
+);
+
+/* Routine host_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_info
+(
+	mach_port_t host,
+	int flavor,
+	host_info_t host_info_out,
+	mach_msg_type_number_t *host_info_outCnt
+);
+
+/* Routine processor_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_info
+(
+	mach_port_t processor,
+	int flavor,
+	mach_port_t *host,
+	processor_info_t processor_info_out,
+	mach_msg_type_number_t *processor_info_outCnt
+);
+
+/* Routine processor_set_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_set_info
+(
+	mach_port_t set_name,
+	int flavor,
+	mach_port_t *host,
+	processor_set_info_t info_out,
+	mach_msg_type_number_t *info_outCnt
+);
+
+/* Routine processor_control */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t processor_control
+(
+	mach_port_t processor,
+	processor_info_t processor_cmd,
+	mach_msg_type_number_t processor_cmdCnt
+);
+
+/* Routine host_get_boot_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t host_get_boot_info
+(
+	mach_port_t host_priv,
+	kernel_boot_info_t boot_info
+);
+
+#endif	/* not defined(_mach_host_user_) */
diff --git a/include/mach/mach_interface.h b/include/mach/mach_interface.h
new file mode 100644
index 0000000..af9e010
--- /dev/null
+++ b/include/mach/mach_interface.h
@@ -0,0 +1,1275 @@
+#ifndef	_mach_user_
+#define	_mach_user_
+
+/* Module mach */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* Routine task_create_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_create_rpc
+(
+	mach_port_t target_task,
+	boolean_t inherit_memory,
+	mach_port_t *child_task
+);
+
+/* Routine task_terminate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_terminate_rpc
+(
+	mach_port_t target_task
+);
+
+/* Routine task_get_emulation_vector */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_get_emulation_vector
+(
+	mach_port_t task,
+	int *vector_start,
+	emulation_vector_t *emulation_vector,
+	mach_msg_type_number_t *emulation_vectorCnt
+);
+
+/* Routine task_set_emulation_vector */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_set_emulation_vector
+(
+	mach_port_t task,
+	int vector_start,
+	emulation_vector_t emulation_vector,
+	mach_msg_type_number_t emulation_vectorCnt
+);
+
+/* Routine task_threads */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_threads
+(
+	mach_port_t target_task,
+	thread_array_t *thread_list,
+	mach_msg_type_number_t *thread_listCnt
+);
+
+/* Routine task_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_info
+(
+	mach_port_t target_task,
+	int flavor,
+	task_info_t task_info_out,
+	mach_msg_type_number_t *task_info_outCnt
+);
+
+/* Routine thread_terminate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_terminate
+(
+	mach_port_t target_thread
+);
+
+/* Routine thread_get_state */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_get_state
+(
+	mach_port_t target_thread,
+	int flavor,
+	thread_state_t old_state,
+	mach_msg_type_number_t *old_stateCnt
+);
+
+/* Routine thread_set_state */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_set_state
+(
+	mach_port_t target_thread,
+	int flavor,
+	thread_state_t new_state,
+	mach_msg_type_number_t new_stateCnt
+);
+
+/* Routine thread_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_info
+(
+	mach_port_t target_thread,
+	int flavor,
+	thread_info_t thread_info_out,
+	mach_msg_type_number_t *thread_info_outCnt
+);
+
+/* Routine vm_allocate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_allocate_rpc
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t size,
+	boolean_t anywhere
+);
+
+/* Routine vm_deallocate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_deallocate_rpc
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size
+);
+
+/* Routine vm_protect */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_protect
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size,
+	boolean_t set_maximum,
+	vm_prot_t new_protection
+);
+
+/* Routine vm_inherit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_inherit
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size,
+	vm_inherit_t new_inheritance
+);
+
+/* Routine vm_read */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_read
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size,
+	vm_offset_t *data,
+	mach_msg_type_number_t *dataCnt
+);
+
+/* Routine vm_write */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_write
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* Routine vm_copy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_copy
+(
+	mach_port_t target_task,
+	vm_address_t source_address,
+	vm_size_t size,
+	vm_address_t dest_address
+);
+
+/* Routine vm_region */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_region
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t *size,
+	vm_prot_t *protection,
+	vm_prot_t *max_protection,
+	vm_inherit_t *inheritance,
+	boolean_t *is_shared,
+	mach_port_t *object_name,
+	vm_offset_t *offset
+);
+
+/* Routine vm_statistics */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_statistics
+(
+	mach_port_t target_task,
+	vm_statistics_data_t *vm_stats
+);
+
+/* Routine mach_ports_register */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_ports_register
+(
+	mach_port_t target_task,
+	mach_port_array_t init_port_set,
+	mach_msg_type_number_t init_port_setCnt
+);
+
+/* Routine mach_ports_lookup */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_ports_lookup
+(
+	mach_port_t target_task,
+	mach_port_array_t *init_port_set,
+	mach_msg_type_number_t *init_port_setCnt
+);
+
+/* SimpleRoutine memory_object_data_provided */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_data_provided
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt,
+	vm_prot_t lock_value
+);
+
+/* SimpleRoutine memory_object_data_unavailable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_data_unavailable
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t size
+);
+
+/* Routine memory_object_get_attributes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_get_attributes
+(
+	mach_port_t memory_control,
+	boolean_t *object_ready,
+	boolean_t *may_cache,
+	memory_object_copy_strategy_t *copy_strategy
+);
+
+/* Routine vm_set_default_memory_manager */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_set_default_memory_manager
+(
+	mach_port_t host_priv,
+	mach_port_t *default_manager
+);
+
+/* SimpleRoutine memory_object_lock_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_lock_request
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t size,
+	memory_object_return_t should_return,
+	boolean_t should_flush,
+	vm_prot_t lock_value,
+	mach_port_t reply_to
+);
+
+/* Routine task_suspend_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_suspend_rpc
+(
+	mach_port_t target_task
+);
+
+/* Routine task_resume */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_resume
+(
+	mach_port_t target_task
+);
+
+/* Routine task_get_special_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_get_special_port
+(
+	mach_port_t task,
+	int which_port,
+	mach_port_t *special_port
+);
+
+/* Routine task_set_special_port_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_set_special_port_rpc
+(
+	mach_port_t task,
+	int which_port,
+	mach_port_t special_port
+);
+
+/* Routine thread_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_create
+(
+	mach_port_t parent_task,
+	mach_port_t *child_thread
+);
+
+/* Routine thread_suspend */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_suspend
+(
+	mach_port_t target_thread
+);
+
+/* Routine thread_resume */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_resume
+(
+	mach_port_t target_thread
+);
+
+/* Routine thread_abort */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_abort
+(
+	mach_port_t target_thread
+);
+
+/* Routine thread_get_special_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_get_special_port
+(
+	mach_port_t thread,
+	int which_port,
+	mach_port_t *special_port
+);
+
+/* Routine thread_set_special_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __thread_set_special_port
+(
+	mach_port_t thread,
+	int which_port,
+	mach_port_t special_port
+);
+
+/* Routine task_set_emulation */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_set_emulation
+(
+	mach_port_t target_port,
+	vm_address_t routine_entry_pt,
+	int routine_number
+);
+
+/* Routine task_ras_control */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __task_ras_control
+(
+	mach_port_t target_task,
+	vm_address_t basepc,
+	vm_address_t boundspc,
+	int flavor
+);
+
+/* Routine vm_map_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_map_rpc
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t size,
+	vm_address_t mask,
+	boolean_t anywhere,
+	mach_port_t memory_object,
+	vm_offset_t offset,
+	boolean_t copy,
+	vm_prot_t cur_protection,
+	vm_prot_t max_protection,
+	vm_inherit_t inheritance
+);
+
+/* SimpleRoutine memory_object_data_error */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_data_error
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t size,
+	kern_return_t error_value
+);
+
+/* SimpleRoutine memory_object_set_attributes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_set_attributes
+(
+	mach_port_t memory_control,
+	boolean_t object_ready,
+	boolean_t may_cache,
+	memory_object_copy_strategy_t copy_strategy
+);
+
+/* SimpleRoutine memory_object_destroy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_destroy
+(
+	mach_port_t memory_control,
+	kern_return_t reason
+);
+
+/* SimpleRoutine memory_object_data_supply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_data_supply
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt,
+	boolean_t dataDealloc,
+	vm_prot_t lock_value,
+	boolean_t precious,
+	mach_port_t reply_to
+);
+
+/* SimpleRoutine memory_object_ready */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_ready
+(
+	mach_port_t memory_control,
+	boolean_t may_cache,
+	memory_object_copy_strategy_t copy_strategy
+);
+
+/* SimpleRoutine memory_object_change_attributes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_change_attributes
+(
+	mach_port_t memory_control,
+	boolean_t may_cache,
+	memory_object_copy_strategy_t copy_strategy,
+	mach_port_t reply_to
+);
+
+/* Routine vm_machine_attribute */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __vm_machine_attribute
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size,
+	vm_machine_attribute_t attribute,
+	vm_machine_attribute_val_t *value
+);
+
+
+/* Module mach */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* Routine task_create_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_create_rpc
+(
+	mach_port_t target_task,
+	boolean_t inherit_memory,
+	mach_port_t *child_task
+);
+
+/* Routine task_terminate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_terminate_rpc
+(
+	mach_port_t target_task
+);
+
+/* Routine task_get_emulation_vector */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_get_emulation_vector
+(
+	mach_port_t task,
+	int *vector_start,
+	emulation_vector_t *emulation_vector,
+	mach_msg_type_number_t *emulation_vectorCnt
+);
+
+/* Routine task_set_emulation_vector */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_set_emulation_vector
+(
+	mach_port_t task,
+	int vector_start,
+	emulation_vector_t emulation_vector,
+	mach_msg_type_number_t emulation_vectorCnt
+);
+
+/* Routine task_threads */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_threads
+(
+	mach_port_t target_task,
+	thread_array_t *thread_list,
+	mach_msg_type_number_t *thread_listCnt
+);
+
+/* Routine task_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_info
+(
+	mach_port_t target_task,
+	int flavor,
+	task_info_t task_info_out,
+	mach_msg_type_number_t *task_info_outCnt
+);
+
+/* Routine thread_terminate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_terminate
+(
+	mach_port_t target_thread
+);
+
+/* Routine thread_get_state */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_get_state
+(
+	mach_port_t target_thread,
+	int flavor,
+	thread_state_t old_state,
+	mach_msg_type_number_t *old_stateCnt
+);
+
+/* Routine thread_set_state */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_set_state
+(
+	mach_port_t target_thread,
+	int flavor,
+	thread_state_t new_state,
+	mach_msg_type_number_t new_stateCnt
+);
+
+/* Routine thread_info */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_info
+(
+	mach_port_t target_thread,
+	int flavor,
+	thread_info_t thread_info_out,
+	mach_msg_type_number_t *thread_info_outCnt
+);
+
+/* Routine vm_allocate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_allocate_rpc
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t size,
+	boolean_t anywhere
+);
+
+/* Routine vm_deallocate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_deallocate_rpc
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size
+);
+
+/* Routine vm_protect */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_protect
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size,
+	boolean_t set_maximum,
+	vm_prot_t new_protection
+);
+
+/* Routine vm_inherit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_inherit
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size,
+	vm_inherit_t new_inheritance
+);
+
+/* Routine vm_read */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_read
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size,
+	vm_offset_t *data,
+	mach_msg_type_number_t *dataCnt
+);
+
+/* Routine vm_write */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_write
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* Routine vm_copy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_copy
+(
+	mach_port_t target_task,
+	vm_address_t source_address,
+	vm_size_t size,
+	vm_address_t dest_address
+);
+
+/* Routine vm_region */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_region
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t *size,
+	vm_prot_t *protection,
+	vm_prot_t *max_protection,
+	vm_inherit_t *inheritance,
+	boolean_t *is_shared,
+	mach_port_t *object_name,
+	vm_offset_t *offset
+);
+
+/* Routine vm_statistics */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_statistics
+(
+	mach_port_t target_task,
+	vm_statistics_data_t *vm_stats
+);
+
+/* Routine mach_ports_register */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_ports_register
+(
+	mach_port_t target_task,
+	mach_port_array_t init_port_set,
+	mach_msg_type_number_t init_port_setCnt
+);
+
+/* Routine mach_ports_lookup */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_ports_lookup
+(
+	mach_port_t target_task,
+	mach_port_array_t *init_port_set,
+	mach_msg_type_number_t *init_port_setCnt
+);
+
+/* SimpleRoutine memory_object_data_provided */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_data_provided
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt,
+	vm_prot_t lock_value
+);
+
+/* SimpleRoutine memory_object_data_unavailable */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_data_unavailable
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t size
+);
+
+/* Routine memory_object_get_attributes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_get_attributes
+(
+	mach_port_t memory_control,
+	boolean_t *object_ready,
+	boolean_t *may_cache,
+	memory_object_copy_strategy_t *copy_strategy
+);
+
+/* Routine vm_set_default_memory_manager */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_set_default_memory_manager
+(
+	mach_port_t host_priv,
+	mach_port_t *default_manager
+);
+
+/* SimpleRoutine memory_object_lock_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_lock_request
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t size,
+	memory_object_return_t should_return,
+	boolean_t should_flush,
+	vm_prot_t lock_value,
+	mach_port_t reply_to
+);
+
+/* Routine task_suspend_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_suspend_rpc
+(
+	mach_port_t target_task
+);
+
+/* Routine task_resume */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_resume
+(
+	mach_port_t target_task
+);
+
+/* Routine task_get_special_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_get_special_port
+(
+	mach_port_t task,
+	int which_port,
+	mach_port_t *special_port
+);
+
+/* Routine task_set_special_port_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_set_special_port_rpc
+(
+	mach_port_t task,
+	int which_port,
+	mach_port_t special_port
+);
+
+/* Routine thread_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_create
+(
+	mach_port_t parent_task,
+	mach_port_t *child_thread
+);
+
+/* Routine thread_suspend */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_suspend
+(
+	mach_port_t target_thread
+);
+
+/* Routine thread_resume */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_resume
+(
+	mach_port_t target_thread
+);
+
+/* Routine thread_abort */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_abort
+(
+	mach_port_t target_thread
+);
+
+/* Routine thread_get_special_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_get_special_port
+(
+	mach_port_t thread,
+	int which_port,
+	mach_port_t *special_port
+);
+
+/* Routine thread_set_special_port */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t thread_set_special_port
+(
+	mach_port_t thread,
+	int which_port,
+	mach_port_t special_port
+);
+
+/* Routine task_set_emulation */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_set_emulation
+(
+	mach_port_t target_port,
+	vm_address_t routine_entry_pt,
+	int routine_number
+);
+
+/* Routine task_ras_control */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t task_ras_control
+(
+	mach_port_t target_task,
+	vm_address_t basepc,
+	vm_address_t boundspc,
+	int flavor
+);
+
+/* Routine vm_map_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_map_rpc
+(
+	mach_port_t target_task,
+	vm_address_t *address,
+	vm_size_t size,
+	vm_address_t mask,
+	boolean_t anywhere,
+	mach_port_t memory_object,
+	vm_offset_t offset,
+	boolean_t copy,
+	vm_prot_t cur_protection,
+	vm_prot_t max_protection,
+	vm_inherit_t inheritance
+);
+
+/* SimpleRoutine memory_object_data_error */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_data_error
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t size,
+	kern_return_t error_value
+);
+
+/* SimpleRoutine memory_object_set_attributes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_set_attributes
+(
+	mach_port_t memory_control,
+	boolean_t object_ready,
+	boolean_t may_cache,
+	memory_object_copy_strategy_t copy_strategy
+);
+
+/* SimpleRoutine memory_object_destroy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_destroy
+(
+	mach_port_t memory_control,
+	kern_return_t reason
+);
+
+/* SimpleRoutine memory_object_data_supply */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_data_supply
+(
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt,
+	boolean_t dataDealloc,
+	vm_prot_t lock_value,
+	boolean_t precious,
+	mach_port_t reply_to
+);
+
+/* SimpleRoutine memory_object_ready */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_ready
+(
+	mach_port_t memory_control,
+	boolean_t may_cache,
+	memory_object_copy_strategy_t copy_strategy
+);
+
+/* SimpleRoutine memory_object_change_attributes */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_change_attributes
+(
+	mach_port_t memory_control,
+	boolean_t may_cache,
+	memory_object_copy_strategy_t copy_strategy,
+	mach_port_t reply_to
+);
+
+/* Routine vm_machine_attribute */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t vm_machine_attribute
+(
+	mach_port_t target_task,
+	vm_address_t address,
+	vm_size_t size,
+	vm_machine_attribute_t attribute,
+	vm_machine_attribute_val_t *value
+);
+
+#endif	/* not defined(_mach_user_) */
diff --git a/include/mach/mach_port.h b/include/mach/mach_port.h
new file mode 100644
index 0000000..a4c0b32
--- /dev/null
+++ b/include/mach/mach_port.h
@@ -0,0 +1,561 @@
+#ifndef	_mach_port_user_
+#define	_mach_port_user_
+
+/* Module mach_port */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* Routine mach_port_names */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_names
+(
+	mach_port_t task,
+	mach_port_array_t *names,
+	mach_msg_type_number_t *namesCnt,
+	mach_port_type_array_t *types,
+	mach_msg_type_number_t *typesCnt
+);
+
+/* Routine mach_port_type */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_type
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_type_t *ptype
+);
+
+/* Routine mach_port_rename */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_rename
+(
+	mach_port_t task,
+	mach_port_t old_name,
+	mach_port_t new_name
+);
+
+/* Routine mach_port_allocate_name_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_allocate_name_rpc
+(
+	mach_port_t task,
+	mach_port_right_t right,
+	mach_port_t name
+);
+
+/* Routine mach_port_allocate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_allocate_rpc
+(
+	mach_port_t task,
+	mach_port_right_t right,
+	mach_port_t *name
+);
+
+/* Routine mach_port_destroy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_destroy
+(
+	mach_port_t task,
+	mach_port_t name
+);
+
+/* Routine mach_port_deallocate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_deallocate_rpc
+(
+	mach_port_t task,
+	mach_port_t name
+);
+
+/* Routine mach_port_get_refs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_get_refs
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_right_t right,
+	mach_port_urefs_t *refs
+);
+
+/* Routine mach_port_mod_refs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_mod_refs
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_right_t right,
+	mach_port_delta_t delta
+);
+
+/* Routine mach_port_set_qlimit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_set_qlimit
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_msgcount_t qlimit
+);
+
+/* Routine mach_port_set_mscount */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_set_mscount
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_mscount_t mscount
+);
+
+/* Routine mach_port_get_set_status */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_get_set_status
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_array_t *members,
+	mach_msg_type_number_t *membersCnt
+);
+
+/* Routine mach_port_move_member */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_move_member
+(
+	mach_port_t task,
+	mach_port_t member,
+	mach_port_t after
+);
+
+/* Routine mach_port_request_notification */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_request_notification
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_msg_id_t id,
+	mach_port_mscount_t sync,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly,
+	mach_port_t *previous
+);
+
+/* Routine mach_port_insert_right_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_insert_right_rpc
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_t poly,
+	mach_msg_type_name_t polyPoly
+);
+
+/* Routine mach_port_extract_right */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_extract_right
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_msg_type_name_t msgt_name,
+	mach_port_t *poly,
+	mach_msg_type_name_t *polyPoly
+);
+
+/* Routine mach_port_get_receive_status */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_get_receive_status
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_status_t *status
+);
+
+/* Routine mach_port_set_seqno */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_set_seqno
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_seqno_t seqno
+);
+
+/* Routine mach_port_set_protected_payload */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_set_protected_payload
+(
+	mach_port_t task,
+	mach_port_t name,
+	natural_t payload
+);
+
+/* Routine mach_port_clear_protected_payload */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_port_clear_protected_payload
+(
+	mach_port_t task,
+	mach_port_t name
+);
+
+
+/* Module mach_port */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* Routine mach_port_names */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_names
+(
+	mach_port_t task,
+	mach_port_array_t *names,
+	mach_msg_type_number_t *namesCnt,
+	mach_port_type_array_t *types,
+	mach_msg_type_number_t *typesCnt
+);
+
+/* Routine mach_port_type */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_type
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_type_t *ptype
+);
+
+/* Routine mach_port_rename */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_rename
+(
+	mach_port_t task,
+	mach_port_t old_name,
+	mach_port_t new_name
+);
+
+/* Routine mach_port_allocate_name_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_allocate_name_rpc
+(
+	mach_port_t task,
+	mach_port_right_t right,
+	mach_port_t name
+);
+
+/* Routine mach_port_allocate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_allocate_rpc
+(
+	mach_port_t task,
+	mach_port_right_t right,
+	mach_port_t *name
+);
+
+/* Routine mach_port_destroy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_destroy
+(
+	mach_port_t task,
+	mach_port_t name
+);
+
+/* Routine mach_port_deallocate_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_deallocate_rpc
+(
+	mach_port_t task,
+	mach_port_t name
+);
+
+/* Routine mach_port_get_refs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_get_refs
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_right_t right,
+	mach_port_urefs_t *refs
+);
+
+/* Routine mach_port_mod_refs */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_mod_refs
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_right_t right,
+	mach_port_delta_t delta
+);
+
+/* Routine mach_port_set_qlimit */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_set_qlimit
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_msgcount_t qlimit
+);
+
+/* Routine mach_port_set_mscount */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_set_mscount
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_mscount_t mscount
+);
+
+/* Routine mach_port_get_set_status */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_get_set_status
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_array_t *members,
+	mach_msg_type_number_t *membersCnt
+);
+
+/* Routine mach_port_move_member */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_move_member
+(
+	mach_port_t task,
+	mach_port_t member,
+	mach_port_t after
+);
+
+/* Routine mach_port_request_notification */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_request_notification
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_msg_id_t id,
+	mach_port_mscount_t sync,
+	mach_port_t notify,
+	mach_msg_type_name_t notifyPoly,
+	mach_port_t *previous
+);
+
+/* Routine mach_port_insert_right_rpc */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_insert_right_rpc
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_t poly,
+	mach_msg_type_name_t polyPoly
+);
+
+/* Routine mach_port_extract_right */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_extract_right
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_msg_type_name_t msgt_name,
+	mach_port_t *poly,
+	mach_msg_type_name_t *polyPoly
+);
+
+/* Routine mach_port_get_receive_status */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_get_receive_status
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_status_t *status
+);
+
+/* Routine mach_port_set_seqno */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_set_seqno
+(
+	mach_port_t task,
+	mach_port_t name,
+	mach_port_seqno_t seqno
+);
+
+/* Routine mach_port_set_protected_payload */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_set_protected_payload
+(
+	mach_port_t task,
+	mach_port_t name,
+	natural_t payload
+);
+
+/* Routine mach_port_clear_protected_payload */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_port_clear_protected_payload
+(
+	mach_port_t task,
+	mach_port_t name
+);
+
+#endif	/* not defined(_mach_port_user_) */
diff --git a/include/mach/mach_traps.h b/include/mach/mach_traps.h
new file mode 100644
index 0000000..1c0bdf2
--- /dev/null
+++ b/include/mach/mach_traps.h
@@ -0,0 +1,78 @@
+/* Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Declare the few Mach system calls (except mach_msg, in <mach/message.h>).
+   This does not include the kernel RPC shortcut calls (in <mach-shortcuts.h>).
+
+   This file omits the MACH_IPC_COMPAT functions.  */
+
+#ifndef	_MACH_MACH_TRAPS_H
+
+#define _MACH_MACH_TRAPS_H_	1
+
+#include <mach/port.h>
+#include <mach/message.h>	/* mach_msg_timeout_t */
+#include <mach/kern_return.h>
+
+/* Create and return a new receive right.  */
+extern mach_port_t mach_reply_port (void);
+extern mach_port_t __mach_reply_port (void);
+
+/* Return the thread control port for the calling thread.  */
+extern mach_port_t mach_thread_self (void);
+extern mach_port_t __mach_thread_self (void);
+
+/* Return the task control port for the calling task.
+   The parens are needed to protect against the macro in <mach_init.h>.  */
+extern mach_port_t (mach_task_self) (void);
+extern mach_port_t (__mach_task_self) (void);
+
+/* Return the host information port for the host of the calling task.  */
+extern mach_port_t mach_host_self (void);
+extern mach_port_t __mach_host_self (void);
+
+/* Attempt to context switch the current thread off the processor.  Returns
+   true if there are other threads that can be run and false if not.  */
+extern boolean_t swtch (void);
+extern boolean_t __swtch (void);
+
+/* Attempt to context switch the current thread off the processor.  Lower
+   the thread's priority as much as possible.  The thread's priority will
+   be restored when it runs again.  PRIORITY is currently unused.  Return
+   true if there are other threads that can be run and false if not.  */
+extern boolean_t swtch_pri (int priority);
+extern boolean_t __swtch_pri (int priority);
+
+/* Attempt to context switch the current thread of the processor.  Try
+   to run NEW_THREAD next, ignoring normal scheduling policies.  The
+   OPTION value comes from <mach/thread_switch.h>.  If OPTION is
+   SWITCH_OPTION_WAIT, then block the current thread for TIME
+   milliseconds.  If OPTION is SWITCH_OPTION_DEPRESS, then block for
+   TIME milliseconds and depress the thread's priority as done by
+   swtch_pri.  If OPTION is SWITCH_OPTION_NONE, ignore TIME.  */
+kern_return_t thread_switch (mach_port_t new_thread,
+			     int option, mach_msg_timeout_t option_time);
+kern_return_t __thread_switch (mach_port_t new_thread,
+			     int option, mach_msg_timeout_t option_time);
+
+/* Block the current thread until the kernel (or device) event
+   identified by EVENT occurs.  */
+kern_return_t evc_wait (unsigned int event);
+kern_return_t __evc_wait (unsigned int event);
+
+
+#endif	/* mach/mach_traps.h */
diff --git a/include/mach/memory_object_default.h b/include/mach/memory_object_default.h
new file mode 100644
index 0000000..1fb9016
--- /dev/null
+++ b/include/mach/memory_object_default.h
@@ -0,0 +1,85 @@
+#ifndef	_memory_object_default_user_
+#define	_memory_object_default_user_
+
+/* Module memory_object_default */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* SimpleRoutine memory_object_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_create
+(
+	mach_port_t old_memory_object,
+	mach_port_t new_memory_object,
+	vm_size_t new_object_size,
+	mach_port_t new_control_port,
+	mach_port_t new_name,
+	vm_size_t new_page_size
+);
+
+/* SimpleRoutine memory_object_data_initialize */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_data_initialize
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control_port,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+
+/* Module memory_object_default */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* SimpleRoutine memory_object_create */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_create
+(
+	mach_port_t old_memory_object,
+	mach_port_t new_memory_object,
+	vm_size_t new_object_size,
+	mach_port_t new_control_port,
+	mach_port_t new_name,
+	vm_size_t new_page_size
+);
+
+/* SimpleRoutine memory_object_data_initialize */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_data_initialize
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control_port,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+#endif	/* not defined(_memory_object_default_user_) */
diff --git a/include/mach/memory_object_user.h b/include/mach/memory_object_user.h
new file mode 100644
index 0000000..c8d6aab
--- /dev/null
+++ b/include/mach/memory_object_user.h
@@ -0,0 +1,323 @@
+#ifndef	_memory_object_user_
+#define	_memory_object_user_
+
+/* Module memory_object */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* SimpleRoutine memory_object_init */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_init
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	mach_port_t memory_object_name,
+	vm_size_t memory_object_page_size
+);
+
+/* SimpleRoutine memory_object_terminate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_terminate
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	mach_port_t memory_object_name
+);
+
+/* SimpleRoutine memory_object_copy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_copy
+(
+	mach_port_t old_memory_object,
+	mach_port_t old_memory_control,
+	vm_offset_t offset,
+	vm_size_t length,
+	mach_port_t new_memory_object
+);
+
+/* SimpleRoutine memory_object_data_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_data_request
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t length,
+	vm_prot_t desired_access
+);
+
+/* SimpleRoutine memory_object_data_unlock */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_data_unlock
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t length,
+	vm_prot_t desired_access
+);
+
+/* SimpleRoutine memory_object_data_write */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_data_write
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* SimpleRoutine memory_object_lock_completed */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_lock_completed
+(
+	mach_port_t memory_object,
+	mach_msg_type_name_t memory_objectPoly,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t length
+);
+
+/* SimpleRoutine memory_object_supply_completed */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_supply_completed
+(
+	mach_port_t memory_object,
+	mach_msg_type_name_t memory_objectPoly,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t length,
+	kern_return_t result,
+	vm_offset_t error_offset
+);
+
+/* SimpleRoutine memory_object_data_return */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_data_return
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt,
+	boolean_t dirty,
+	boolean_t kernel_copy
+);
+
+/* SimpleRoutine memory_object_change_completed */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __memory_object_change_completed
+(
+	mach_port_t memory_object,
+	mach_msg_type_name_t memory_objectPoly,
+	boolean_t may_cache,
+	memory_object_copy_strategy_t copy_strategy
+);
+
+
+/* Module memory_object */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* SimpleRoutine memory_object_init */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_init
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	mach_port_t memory_object_name,
+	vm_size_t memory_object_page_size
+);
+
+/* SimpleRoutine memory_object_terminate */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_terminate
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	mach_port_t memory_object_name
+);
+
+/* SimpleRoutine memory_object_copy */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_copy
+(
+	mach_port_t old_memory_object,
+	mach_port_t old_memory_control,
+	vm_offset_t offset,
+	vm_size_t length,
+	mach_port_t new_memory_object
+);
+
+/* SimpleRoutine memory_object_data_request */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_data_request
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t length,
+	vm_prot_t desired_access
+);
+
+/* SimpleRoutine memory_object_data_unlock */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_data_unlock
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t length,
+	vm_prot_t desired_access
+);
+
+/* SimpleRoutine memory_object_data_write */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_data_write
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt
+);
+
+/* SimpleRoutine memory_object_lock_completed */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_lock_completed
+(
+	mach_port_t memory_object,
+	mach_msg_type_name_t memory_objectPoly,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t length
+);
+
+/* SimpleRoutine memory_object_supply_completed */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_supply_completed
+(
+	mach_port_t memory_object,
+	mach_msg_type_name_t memory_objectPoly,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_size_t length,
+	kern_return_t result,
+	vm_offset_t error_offset
+);
+
+/* SimpleRoutine memory_object_data_return */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_data_return
+(
+	mach_port_t memory_object,
+	mach_port_t memory_control,
+	vm_offset_t offset,
+	vm_offset_t data,
+	mach_msg_type_number_t dataCnt,
+	boolean_t dirty,
+	boolean_t kernel_copy
+);
+
+/* SimpleRoutine memory_object_change_completed */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t memory_object_change_completed
+(
+	mach_port_t memory_object,
+	mach_msg_type_name_t memory_objectPoly,
+	boolean_t may_cache,
+	memory_object_copy_strategy_t copy_strategy
+);
+
+#endif	/* not defined(_memory_object_user_) */
diff --git a/include/mach/mig_support.h b/include/mach/mig_support.h
new file mode 100644
index 0000000..0d0a61b
--- /dev/null
+++ b/include/mach/mig_support.h
@@ -0,0 +1,85 @@
+/* Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Useful declarations and support functions for MiG-generated stubs.  */
+
+#ifndef	_MACH_MIG_SUPPORT_H
+
+#define	_MACH_MIG_SUPPORT_H	1
+
+#include <mach/std_types.h>
+#include <mach/message.h>
+#include <sys/types.h>
+#include <string.h>
+
+#ifndef __USE_GNU
+/* The only problem that has come up so far is __stpncpy being undeclared
+   below because <string.h> doesn't declare it without __USE_GNU.  We could
+   work around that problem by just adding the declaration there, or by
+   eliding the inline functions in the absence of __USE_GNU.  But either of
+   these would result in unoptimized calls (because no inline version of
+   __stpncpy will have been defined), and there may be other niggling
+   problems lurking.  Instead we simply insist on _GNU_SOURCE for
+   compiling mig output; anyway, that better reflects the fact that mig
+   output requires nonstandard special support code not found elsewhere.  */
+# error mig stubs must be compiled with -D_GNU_SOURCE
+#endif
+
+/* MiG initialization.  */
+extern void __mig_init (void *__first);
+extern void mig_init (void *__first);
+
+/* Shorthand functions for vm_allocate and vm_deallocate on
+   mach_task_self () (and with ANYWHERE=1).  */
+extern void __mig_allocate (vm_address_t *__addr_p, vm_size_t __size);
+extern void mig_allocate (vm_address_t *__addr_p, vm_size_t __size);
+extern void __mig_deallocate (vm_address_t __addr, vm_size_t __size);
+extern void mig_deallocate (vm_address_t __addr, vm_size_t __size);
+
+/* Reply-port management support functions.  */
+extern void __mig_dealloc_reply_port (mach_port_t);
+extern void mig_dealloc_reply_port (mach_port_t);
+extern mach_port_t __mig_get_reply_port (void);
+extern mach_port_t mig_get_reply_port (void);
+extern void __mig_put_reply_port (mach_port_t);
+extern void mig_put_reply_port (mach_port_t);
+
+extern void __mig_reply_setup (const mach_msg_header_t *__request,
+			       mach_msg_header_t *__reply);
+extern void mig_reply_setup (const mach_msg_header_t *__request,
+			     mach_msg_header_t *__reply);
+
+/* Idiocy support function.  */
+extern vm_size_t mig_strncpy (char *__dst, const char *__src, vm_size_t __len);
+extern vm_size_t __mig_strncpy (char *__dst, const char *__src, vm_size_t);
+
+#ifdef __USE_EXTERN_INLINES
+__extern_inline vm_size_t
+__mig_strncpy (char *__dst, const char *__src, vm_size_t __len)
+{
+  return __stpncpy (__dst, __src, __len) - __dst;
+}
+__extern_inline vm_size_t
+mig_strncpy (char *__dst, const char *__src, vm_size_t __len)
+{
+  return __mig_strncpy (__dst, __src, __len);
+}
+#endif
+
+
+
+#endif	/* mach/mig_support.h */
diff --git a/include/mach/task_notify.h b/include/mach/task_notify.h
new file mode 100644
index 0000000..a844c6a
--- /dev/null
+++ b/include/mach/task_notify.h
@@ -0,0 +1,49 @@
+#ifndef	_task_notify_user_
+#define	_task_notify_user_
+
+/* Module task_notify */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* SimpleRoutine mach_notify_new_task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t __mach_notify_new_task
+(
+	mach_port_t notify,
+	mach_port_t task,
+	mach_port_t parent
+);
+
+
+/* Module task_notify */
+
+#include <mach/kern_return.h>
+#include <mach/port.h>
+#include <mach/message.h>
+
+#include <mach/std_types.h>
+#include <mach/mach_types.h>
+
+/* SimpleRoutine mach_notify_new_task */
+#ifdef	mig_external
+mig_external
+#else
+extern
+#endif
+kern_return_t mach_notify_new_task
+(
+	mach_port_t notify,
+	mach_port_t task,
+	mach_port_t parent
+);
+
+#endif	/* not defined(_task_notify_user_) */
diff --git a/include/mach_error.h b/include/mach_error.h
new file mode 100644
index 0000000..fc4a3fe
--- /dev/null
+++ b/include/mach_error.h
@@ -0,0 +1,71 @@
+/*
+ * Mach Operating System
+ * Copyright (c) 1991,1990,1989 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ *
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ *
+ * Carnegie Mellon requests users of this software to return to
+ *
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ *
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+/*
+ * (pre-GNU) HISTORY
+ *
+ * Revision 2.2  92/01/16  00:08:10  rpd
+ * 	Moved from user collection to mk collection.
+ *
+ * Revision 2.2  91/03/27  15:39:13  mrt
+ * 	First checkin
+ *
+ */
+/*
+ *	File:	mach_error.h
+ *	Author:	Douglas Orr, Carnegie Mellon University
+ *	Date:	Mar. 1988
+ *
+ *	Definitions of routines in mach_error.c
+ */
+
+#ifndef	_MACH_ERROR_
+#define	_MACH_ERROR_	1
+
+#include <mach/error.h>
+
+const char	*mach_error_string(
+/*
+ *	Returns a string appropriate to the error argument given
+ */
+	mach_error_t error_value
+				);
+
+void		mach_error(
+/*
+ *	Prints an appropriate message on the standard error stream
+ */
+	char 		*str,
+	mach_error_t	error_value
+				);
+
+const char	*mach_error_type(
+/*
+ *	Returns a string with the error system, subsystem and code
+*/
+	mach_error_t	error_value
+				);
+
+#endif	/* _MACH_ERROR_ */
diff --git a/include/mach_init.h b/include/mach_init.h
new file mode 100644
index 0000000..d7ca27f
--- /dev/null
+++ b/include/mach_init.h
@@ -0,0 +1,47 @@
+/* Declarations and macros for the basic Mach things set at startup.
+   Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_MACH_INIT_H
+
+#define	_MACH_INIT_H	1
+
+#include <mach/mach_types.h>
+
+/* Return the current task's task port.  */
+extern mach_port_t __mach_task_self (void);
+extern mach_port_t mach_task_self (void);
+
+/* This cache is initialized at startup.  */
+extern mach_port_t __mach_task_self_;
+#define __mach_task_self()	(__mach_task_self_ + 0)	/* Not an lvalue.  */
+#define mach_task_self()	(__mach_task_self ())
+
+/* Kernel page size.  */
+extern vm_size_t __vm_page_size;
+extern vm_size_t vm_page_size;
+
+/* Round the address X up to a page boundary.  */
+#define round_page(x)	\
+  ((((vm_offset_t) (x) + __vm_page_size - 1) / __vm_page_size) * \
+   __vm_page_size)
+
+/* Truncate the address X down to a page boundary.  */
+#define trunc_page(x)	\
+  ((((vm_offset_t) (x)) / __vm_page_size) * __vm_page_size)
+
+#endif	/* mach_init.h */
diff --git a/include/machine-lock.h b/include/machine-lock.h
new file mode 100644
index 0000000..ea8d6f1
--- /dev/null
+++ b/include/machine-lock.h
@@ -0,0 +1,79 @@
+/* Machine-specific definition for spin locks.  i386 version.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MACHINE_LOCK_H
+#define	_MACHINE_LOCK_H
+
+/* The type of a spin lock variable.  */
+
+typedef volatile int __spin_lock_t;
+
+/* Value to initialize `__spin_lock_t' variables to.  */
+
+#define	__SPIN_LOCK_INITIALIZER	0
+
+
+#ifndef _EXTERN_INLINE
+#define _EXTERN_INLINE __extern_inline
+#endif
+
+/* Unlock LOCK.  */
+
+void __spin_unlock (__spin_lock_t *__lock);
+
+#ifdef __USE_EXTERN_INLINES
+_EXTERN_INLINE void
+__spin_unlock (__spin_lock_t *__lock)
+{
+   register int __unlocked;
+   __asm__ __volatile ("xchgl %0, %1"
+		       : "=&r" (__unlocked), "=m" (*__lock) : "0" (0)
+		       : "memory");
+}
+#endif
+
+/* Try to lock LOCK; return nonzero if we locked it, zero if another has.  */
+
+int __spin_try_lock (__spin_lock_t *__lock);
+
+#ifdef __USE_EXTERN_INLINES
+_EXTERN_INLINE int
+__spin_try_lock (__spin_lock_t *__lock)
+{
+  register int __locked;
+  __asm__ __volatile ("xchgl %0, %1"
+		      : "=&r" (__locked), "=m" (*__lock) : "0" (1)
+		      : "memory");
+  return !__locked;
+}
+#endif
+
+/* Return nonzero if LOCK is locked.  */
+
+int __spin_lock_locked (__spin_lock_t *__lock);
+
+#ifdef __USE_EXTERN_INLINES
+_EXTERN_INLINE int
+__spin_lock_locked (__spin_lock_t *__lock)
+{
+  return *__lock != 0;
+}
+#endif
+
+
+#endif /* machine-lock.h */
diff --git a/include/machine-sp.h b/include/machine-sp.h
new file mode 100644
index 0000000..020509c
--- /dev/null
+++ b/include/machine-sp.h
@@ -0,0 +1,30 @@
+/* Machine-specific function to return the stack pointer.  i386 version.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MACHINE_SP_H
+#define _MACHINE_SP_H
+
+/* Return the current stack pointer.  */
+
+#define __thread_stack_pointer() ({					      \
+  void *__sp__;								      \
+  __asm__ ("movl %%esp, %0" : "=r" (__sp__));				      \
+  __sp__;								      \
+})
+
+#endif	/* machine-sp.h */
diff --git a/include/malloc.h b/include/malloc.h
new file mode 100644
index 0000000..30bb91a
--- /dev/null
+++ b/include/malloc.h
@@ -0,0 +1,171 @@
+/* Prototypes and definition for malloc implementation.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MALLOC_H
+#define _MALLOC_H 1
+
+#include <features.h>
+#include <stddef.h>
+#include <stdio.h>
+
+#ifdef _LIBC
+# define __MALLOC_HOOK_VOLATILE
+# define __MALLOC_DEPRECATED
+#else
+# define __MALLOC_HOOK_VOLATILE volatile
+# define __MALLOC_DEPRECATED __attribute_deprecated__
+#endif
+
+
+__BEGIN_DECLS
+
+/* Allocate SIZE bytes of memory.  */
+extern void *malloc (size_t __size) __THROW __attribute_malloc__ __wur;
+
+/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
+extern void *calloc (size_t __nmemb, size_t __size)
+__THROW __attribute_malloc__ __wur;
+
+/* Re-allocate the previously allocated block in __ptr, making the new
+   block SIZE bytes long.  */
+/* __attribute_malloc__ is not used, because if realloc returns
+   the same pointer that was passed to it, aliasing needs to be allowed
+   between objects pointed by the old and new pointers.  */
+extern void *realloc (void *__ptr, size_t __size)
+__THROW __attribute_warn_unused_result__;
+
+/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
+extern void free (void *__ptr) __THROW;
+
+/* Free a block allocated by `calloc'. */
+extern void cfree (void *__ptr) __THROW;
+
+/* Allocate SIZE bytes allocated to ALIGNMENT bytes.  */
+extern void *memalign (size_t __alignment, size_t __size)
+__THROW __attribute_malloc__ __wur;
+
+/* Allocate SIZE bytes on a page boundary.  */
+extern void *valloc (size_t __size) __THROW __attribute_malloc__ __wur;
+
+/* Equivalent to valloc(minimum-page-that-holds(n)), that is, round up
+   __size to nearest pagesize. */
+extern void *pvalloc (size_t __size) __THROW __attribute_malloc__ __wur;
+
+/* Underlying allocation function; successive calls should return
+   contiguous pieces of memory.  */
+extern void *(*__morecore) (ptrdiff_t __size);
+
+/* Default value of `__morecore'.  */
+extern void *__default_morecore (ptrdiff_t __size)
+__THROW __attribute_malloc__;
+
+/* SVID2/XPG mallinfo structure */
+
+struct mallinfo
+{
+  int arena;    /* non-mmapped space allocated from system */
+  int ordblks;  /* number of free chunks */
+  int smblks;   /* number of fastbin blocks */
+  int hblks;    /* number of mmapped regions */
+  int hblkhd;   /* space in mmapped regions */
+  int usmblks;  /* maximum total allocated space */
+  int fsmblks;  /* space available in freed fastbin blocks */
+  int uordblks; /* total allocated space */
+  int fordblks; /* total free space */
+  int keepcost; /* top-most, releasable (via malloc_trim) space */
+};
+
+/* Returns a copy of the updated current mallinfo. */
+extern struct mallinfo mallinfo (void) __THROW;
+
+/* SVID2/XPG mallopt options */
+#ifndef M_MXFAST
+# define M_MXFAST  1    /* maximum request size for "fastbins" */
+#endif
+#ifndef M_NLBLKS
+# define M_NLBLKS  2    /* UNUSED in this malloc */
+#endif
+#ifndef M_GRAIN
+# define M_GRAIN   3    /* UNUSED in this malloc */
+#endif
+#ifndef M_KEEP
+# define M_KEEP    4    /* UNUSED in this malloc */
+#endif
+
+/* mallopt options that actually do something */
+#define M_TRIM_THRESHOLD    -1
+#define M_TOP_PAD           -2
+#define M_MMAP_THRESHOLD    -3
+#define M_MMAP_MAX          -4
+#define M_CHECK_ACTION      -5
+#define M_PERTURB           -6
+#define M_ARENA_TEST        -7
+#define M_ARENA_MAX         -8
+
+/* General SVID/XPG interface to tunable parameters. */
+extern int mallopt (int __param, int __val) __THROW;
+
+/* Release all but __pad bytes of freed top-most memory back to the
+   system. Return 1 if successful, else 0. */
+extern int malloc_trim (size_t __pad) __THROW;
+
+/* Report the number of usable allocated bytes associated with allocated
+   chunk __ptr. */
+extern size_t malloc_usable_size (void *__ptr) __THROW;
+
+/* Prints brief summary statistics on stderr. */
+extern void malloc_stats (void) __THROW;
+
+/* Output information about state of allocator to stream FP.  */
+extern int malloc_info (int __options, FILE *__fp) __THROW;
+
+/* Record the state of all malloc variables in an opaque data structure. */
+extern void *malloc_get_state (void) __THROW;
+
+/* Restore the state of all malloc variables from data obtained with
+   malloc_get_state(). */
+extern int malloc_set_state (void *__ptr) __THROW;
+
+/* Called once when malloc is initialized; redefining this variable in
+   the application provides the preferred way to set up the hook
+   pointers. */
+extern void (*__MALLOC_HOOK_VOLATILE __malloc_initialize_hook) (void)
+__MALLOC_DEPRECATED;
+/* Hooks for debugging and user-defined versions. */
+extern void (*__MALLOC_HOOK_VOLATILE __free_hook) (void *__ptr,
+                                                   const void *)
+__MALLOC_DEPRECATED;
+extern void *(*__MALLOC_HOOK_VOLATILE __malloc_hook)(size_t __size,
+                                                     const void *)
+__MALLOC_DEPRECATED;
+extern void *(*__MALLOC_HOOK_VOLATILE __realloc_hook)(void *__ptr,
+                                                      size_t __size,
+                                                      const void *)
+__MALLOC_DEPRECATED;
+extern void *(*__MALLOC_HOOK_VOLATILE __memalign_hook)(size_t __alignment,
+                                                       size_t __size,
+                                                       const void *)
+__MALLOC_DEPRECATED;
+extern void (*__MALLOC_HOOK_VOLATILE __after_morecore_hook) (void);
+
+/* Activate a standard set of debugging hooks. */
+extern void __malloc_check_init (void) __THROW __MALLOC_DEPRECATED;
+
+
+__END_DECLS
+#endif /* malloc.h */
diff --git a/include/math.h b/include/math.h
new file mode 100644
index 0000000..4cdbd08
--- /dev/null
+++ b/include/math.h
@@ -0,0 +1,491 @@
+/* Declarations for math functions.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.12 Mathematics	<math.h>
+ */
+
+#ifndef	_MATH_H
+#define	_MATH_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Get machine-dependent HUGE_VAL value (returned on overflow).
+   On all IEEE754 machines, this is +Infinity.  */
+#include <bits/huge_val.h>
+#ifdef __USE_ISOC99
+# include <bits/huge_valf.h>
+# include <bits/huge_vall.h>
+
+/* Get machine-dependent INFINITY value.  */
+# include <bits/inf.h>
+
+/* Get machine-dependent NAN value (returned for some domain errors).  */
+# include <bits/nan.h>
+#endif /* __USE_ISOC99 */
+
+/* Get general and ISO C99 specific information.  */
+#include <bits/mathdef.h>
+
+/* The file <bits/mathcalls.h> contains the prototypes for all the
+   actual math functions.  These macros are used for those prototypes,
+   so we can easily declare each function as both `name' and `__name',
+   and can declare the float versions `namef' and `__namef'.  */
+
+#define __MATHCALL(function,suffix, args)	\
+  __MATHDECL (_Mdouble_,function,suffix, args)
+#define __MATHDECL(type, function,suffix, args) \
+  __MATHDECL_1(type, function,suffix, args); \
+  __MATHDECL_1(type, __CONCAT(__,function),suffix, args)
+#define __MATHCALLX(function,suffix, args, attrib)	\
+  __MATHDECLX (_Mdouble_,function,suffix, args, attrib)
+#define __MATHDECLX(type, function,suffix, args, attrib) \
+  __MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); \
+  __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)
+#define __MATHDECL_1(type, function,suffix, args) \
+  extern type __MATH_PRECNAME(function,suffix) args __THROW
+
+#define _Mdouble_		double
+#define __MATH_PRECNAME(name,r)	__CONCAT(name,r)
+#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_STD
+#define _Mdouble_END_NAMESPACE   __END_NAMESPACE_STD
+#include <bits/mathcalls.h>
+#undef	_Mdouble_
+#undef _Mdouble_BEGIN_NAMESPACE
+#undef _Mdouble_END_NAMESPACE
+#undef	__MATH_PRECNAME
+
+#if defined __USE_MISC || defined __USE_ISOC99
+
+
+/* Include the file of declarations again, this time using `float'
+   instead of `double' and appending f to each function name.  */
+
+# ifndef _Mfloat_
+#  define _Mfloat_		float
+# endif
+# define _Mdouble_		_Mfloat_
+# define __MATH_PRECNAME(name,r) name##f##r
+# define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
+# define _Mdouble_END_NAMESPACE   __END_NAMESPACE_C99
+# include <bits/mathcalls.h>
+# undef	_Mdouble_
+# undef _Mdouble_BEGIN_NAMESPACE
+# undef _Mdouble_END_NAMESPACE
+# undef	__MATH_PRECNAME
+
+# if !(defined __NO_LONG_DOUBLE_MATH && defined _LIBC) \
+     || defined __LDBL_COMPAT
+#  ifdef __LDBL_COMPAT
+
+#   ifdef __USE_ISOC99
+extern float __nldbl_nexttowardf (float __x, long double __y)
+				  __THROW __attribute__ ((__const__));
+#    ifdef __REDIRECT_NTH
+extern float __REDIRECT_NTH (nexttowardf, (float __x, long double __y),
+			     __nldbl_nexttowardf)
+     __attribute__ ((__const__));
+extern double __REDIRECT_NTH (nexttoward, (double __x, long double __y),
+			      nextafter) __attribute__ ((__const__));
+extern long double __REDIRECT_NTH (nexttowardl,
+				   (long double __x, long double __y),
+				   nextafter) __attribute__ ((__const__));
+#    endif
+#   endif
+
+#   undef __MATHDECL_1
+#   define __MATHDECL_2(type, function,suffix, args, alias) \
+  extern type __REDIRECT_NTH(__MATH_PRECNAME(function,suffix), \
+			     args, alias)
+#   define __MATHDECL_1(type, function,suffix, args) \
+  __MATHDECL_2(type, function,suffix, args, __CONCAT(function,suffix))
+#  endif
+
+/* Include the file of declarations again, this time using `long double'
+   instead of `double' and appending l to each function name.  */
+
+#  ifndef _Mlong_double_
+#   define _Mlong_double_	long double
+#  endif
+#  define _Mdouble_		_Mlong_double_
+#  define __MATH_PRECNAME(name,r) name##l##r
+#  define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
+#  define _Mdouble_END_NAMESPACE   __END_NAMESPACE_C99
+#  define __MATH_DECLARE_LDOUBLE   1
+#  include <bits/mathcalls.h>
+#  undef _Mdouble_
+#  undef _Mdouble_BEGIN_NAMESPACE
+#  undef _Mdouble_END_NAMESPACE
+#  undef __MATH_PRECNAME
+
+# endif /* !(__NO_LONG_DOUBLE_MATH && _LIBC) || __LDBL_COMPAT */
+
+#endif	/* Use misc or ISO C99.  */
+#undef	__MATHDECL_1
+#undef	__MATHDECL
+#undef	__MATHCALL
+
+
+#if defined __USE_MISC || defined __USE_XOPEN
+/* This variable is used by `gamma' and `lgamma'.  */
+extern int signgam;
+#endif
+
+
+/* ISO C99 defines some generic macros which work on any data type.  */
+#ifdef __USE_ISOC99
+
+/* Get the architecture specific values describing the floating-point
+   evaluation.  The following symbols will get defined:
+
+    float_t	floating-point type at least as wide as `float' used
+		to evaluate `float' expressions
+    double_t	floating-point type at least as wide as `double' used
+		to evaluate `double' expressions
+
+    FLT_EVAL_METHOD
+		Defined to
+		  0	if `float_t' is `float' and `double_t' is `double'
+		  1	if `float_t' and `double_t' are `double'
+		  2	if `float_t' and `double_t' are `long double'
+		  else	`float_t' and `double_t' are unspecified
+
+    INFINITY	representation of the infinity value of type `float'
+
+    FP_FAST_FMA
+    FP_FAST_FMAF
+    FP_FAST_FMAL
+		If defined it indicates that the `fma' function
+		generally executes about as fast as a multiply and an add.
+		This macro is defined only iff the `fma' function is
+		implemented directly with a hardware multiply-add instructions.
+
+    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
+    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.
+
+    DECIMAL_DIG	Number of decimal digits supported by conversion between
+		decimal and all internal floating-point formats.
+
+*/
+
+/* All floating-point numbers can be put in one of these categories.  */
+enum
+  {
+    FP_NAN =
+# define FP_NAN 0
+      FP_NAN,
+    FP_INFINITE =
+# define FP_INFINITE 1
+      FP_INFINITE,
+    FP_ZERO =
+# define FP_ZERO 2
+      FP_ZERO,
+    FP_SUBNORMAL =
+# define FP_SUBNORMAL 3
+      FP_SUBNORMAL,
+    FP_NORMAL =
+# define FP_NORMAL 4
+      FP_NORMAL
+  };
+
+/* Return number of classification appropriate for X.  */
+# ifdef __NO_LONG_DOUBLE_MATH
+#  define fpclassify(x) \
+     (sizeof (x) == sizeof (float) ? __fpclassifyf (x) : __fpclassify (x))
+# else
+#  define fpclassify(x) \
+     (sizeof (x) == sizeof (float)					      \
+      ? __fpclassifyf (x)						      \
+      : sizeof (x) == sizeof (double)					      \
+      ? __fpclassify (x) : __fpclassifyl (x))
+# endif
+
+/* Return nonzero value if sign of X is negative.  */
+# ifdef __NO_LONG_DOUBLE_MATH
+#  define signbit(x) \
+     (sizeof (x) == sizeof (float) ? __signbitf (x) : __signbit (x))
+# else
+#  define signbit(x) \
+     (sizeof (x) == sizeof (float)					      \
+      ? __signbitf (x)							      \
+      : sizeof (x) == sizeof (double)					      \
+      ? __signbit (x) : __signbitl (x))
+# endif
+
+/* Return nonzero value if X is not +-Inf or NaN.  */
+# ifdef __NO_LONG_DOUBLE_MATH
+#  define isfinite(x) \
+     (sizeof (x) == sizeof (float) ? __finitef (x) : __finite (x))
+# else
+#  define isfinite(x) \
+     (sizeof (x) == sizeof (float)					      \
+      ? __finitef (x)							      \
+      : sizeof (x) == sizeof (double)					      \
+      ? __finite (x) : __finitel (x))
+# endif
+
+/* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  */
+# define isnormal(x) (fpclassify (x) == FP_NORMAL)
+
+/* Return nonzero value if X is a NaN.  We could use `fpclassify' but
+   we already have this functions `__isnan' and it is faster.  */
+# ifdef __NO_LONG_DOUBLE_MATH
+#  define isnan(x) \
+     (sizeof (x) == sizeof (float) ? __isnanf (x) : __isnan (x))
+# else
+#  define isnan(x) \
+     (sizeof (x) == sizeof (float)					      \
+      ? __isnanf (x)							      \
+      : sizeof (x) == sizeof (double)					      \
+      ? __isnan (x) : __isnanl (x))
+# endif
+
+/* Return nonzero value if X is positive or negative infinity.  */
+# ifdef __NO_LONG_DOUBLE_MATH
+#  define isinf(x) \
+     (sizeof (x) == sizeof (float) ? __isinff (x) : __isinf (x))
+# else
+#  define isinf(x) \
+     (sizeof (x) == sizeof (float)					      \
+      ? __isinff (x)							      \
+      : sizeof (x) == sizeof (double)					      \
+      ? __isinf (x) : __isinfl (x))
+# endif
+
+/* Bitmasks for the math_errhandling macro.  */
+# define MATH_ERRNO	1	/* errno set by math functions.  */
+# define MATH_ERREXCEPT	2	/* Exceptions raised by math functions.  */
+
+/* By default all functions support both errno and exception handling.
+   In gcc's fast math mode and if inline functions are defined this
+   might not be true.  */
+# ifndef __FAST_MATH__
+#  define math_errhandling	(MATH_ERRNO | MATH_ERREXCEPT)
+# endif
+
+#endif /* Use ISO C99.  */
+
+#ifdef __USE_GNU
+/* Return nonzero value if X is a signaling NaN.  */
+# ifdef __NO_LONG_DOUBLE_MATH
+#  define issignaling(x) \
+     (sizeof (x) == sizeof (float) ? __issignalingf (x) : __issignaling (x))
+# else
+#  define issignaling(x) \
+     (sizeof (x) == sizeof (float)					      \
+      ? __issignalingf (x)						      \
+      : sizeof (x) == sizeof (double)					      \
+      ? __issignaling (x) : __issignalingl (x))
+# endif
+#endif /* Use GNU.  */
+
+#ifdef	__USE_MISC
+/* Support for various different standard error handling behaviors.  */
+typedef enum
+{
+  _IEEE_ = -1,	/* According to IEEE 754/IEEE 854.  */
+  _SVID_,	/* According to System V, release 4.  */
+  _XOPEN_,	/* Nowadays also Unix98.  */
+  _POSIX_,
+  _ISOC_	/* Actually this is ISO C99.  */
+} _LIB_VERSION_TYPE;
+
+/* This variable can be changed at run-time to any of the values above to
+   affect floating point error handling behavior (it may also be necessary
+   to change the hardware FPU exception settings).  */
+extern _LIB_VERSION_TYPE _LIB_VERSION;
+#endif
+
+
+#ifdef __USE_SVID
+/* In SVID error handling, `matherr' is called with this description
+   of the exceptional condition.
+
+   We have a problem when using C++ since `exception' is a reserved
+   name in C++.  */
+# ifdef __cplusplus
+struct __exception
+# else
+struct exception
+# endif
+  {
+    int type;
+    char *name;
+    double arg1;
+    double arg2;
+    double retval;
+  };
+
+# ifdef __cplusplus
+extern int matherr (struct __exception *__exc) throw ();
+# else
+extern int matherr (struct exception *__exc);
+# endif
+
+# define X_TLOSS	1.41484755040568800000e+16
+
+/* Types of exceptions in the `type' field.  */
+# define DOMAIN		1
+# define SING		2
+# define OVERFLOW	3
+# define UNDERFLOW	4
+# define TLOSS		5
+# define PLOSS		6
+
+/* SVID mode specifies returning this large value instead of infinity.  */
+# define HUGE		3.40282347e+38F
+
+#else	/* !SVID */
+
+# ifdef __USE_XOPEN
+/* X/Open wants another strange constant.  */
+#  define MAXFLOAT	3.40282347e+38F
+# endif
+
+#endif	/* SVID */
+
+
+/* Some useful constants.  */
+#if defined __USE_BSD || defined __USE_XOPEN
+# define M_E		2.7182818284590452354	/* e */
+# define M_LOG2E	1.4426950408889634074	/* log_2 e */
+# define M_LOG10E	0.43429448190325182765	/* log_10 e */
+# define M_LN2		0.69314718055994530942	/* log_e 2 */
+# define M_LN10		2.30258509299404568402	/* log_e 10 */
+# define M_PI		3.14159265358979323846	/* pi */
+# define M_PI_2		1.57079632679489661923	/* pi/2 */
+# define M_PI_4		0.78539816339744830962	/* pi/4 */
+# define M_1_PI		0.31830988618379067154	/* 1/pi */
+# define M_2_PI		0.63661977236758134308	/* 2/pi */
+# define M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */
+# define M_SQRT2	1.41421356237309504880	/* sqrt(2) */
+# define M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */
+#endif
+
+/* The above constants are not adequate for computation using `long double's.
+   Therefore we provide as an extension constants with similar names as a
+   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */
+#ifdef __USE_GNU
+# define M_El		2.718281828459045235360287471352662498L /* e */
+# define M_LOG2El	1.442695040888963407359924681001892137L /* log_2 e */
+# define M_LOG10El	0.434294481903251827651128918916605082L /* log_10 e */
+# define M_LN2l		0.693147180559945309417232121458176568L /* log_e 2 */
+# define M_LN10l	2.302585092994045684017991454684364208L /* log_e 10 */
+# define M_PIl		3.141592653589793238462643383279502884L /* pi */
+# define M_PI_2l	1.570796326794896619231321691639751442L /* pi/2 */
+# define M_PI_4l	0.785398163397448309615660845819875721L /* pi/4 */
+# define M_1_PIl	0.318309886183790671537767526745028724L /* 1/pi */
+# define M_2_PIl	0.636619772367581343075535053490057448L /* 2/pi */
+# define M_2_SQRTPIl	1.128379167095512573896158903121545172L /* 2/sqrt(pi) */
+# define M_SQRT2l	1.414213562373095048801688724209698079L /* sqrt(2) */
+# define M_SQRT1_2l	0.707106781186547524400844362104849039L /* 1/sqrt(2) */
+#endif
+
+
+/* When compiling in strict ISO C compatible mode we must not use the
+   inline functions since they, among other things, do not set the
+   `errno' variable correctly.  */
+#if defined __STRICT_ANSI__ && !defined __NO_MATH_INLINES
+# define __NO_MATH_INLINES	1
+#endif
+
+#if defined __USE_ISOC99 && __GNUC_PREREQ(2,97)
+/* ISO C99 defines some macros to compare number while taking care for
+   unordered numbers.  Many FPUs provide special instructions to support
+   these operations.  Generic support in GCC for these as builtins went
+   in before 3.0.0, but not all cpus added their patterns.  We define
+   versions that use the builtins here, and <bits/mathinline.h> will
+   undef/redefine as appropriate for the specific GCC version in use.  */
+# define isgreater(x, y)	__builtin_isgreater(x, y)
+# define isgreaterequal(x, y)	__builtin_isgreaterequal(x, y)
+# define isless(x, y)		__builtin_isless(x, y)
+# define islessequal(x, y)	__builtin_islessequal(x, y)
+# define islessgreater(x, y)	__builtin_islessgreater(x, y)
+# define isunordered(u, v)	__builtin_isunordered(u, v)
+#endif
+
+/* Get machine-dependent inline versions (if there are any).  */
+#ifdef __USE_EXTERN_INLINES
+# include <bits/mathinline.h>
+#endif
+
+/* Define special entry points to use when the compiler got told to
+   only expect finite results.  */
+#if defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ > 0
+# include <bits/math-finite.h>
+#endif
+
+#ifdef __USE_ISOC99
+/* If we've still got undefined comparison macros, provide defaults.  */
+
+/* Return nonzero value if X is greater than Y.  */
+# ifndef isgreater
+#  define isgreater(x, y) \
+  (__extension__							      \
+   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
+      !isunordered (__x, __y) && __x > __y; }))
+# endif
+
+/* Return nonzero value if X is greater than or equal to Y.  */
+# ifndef isgreaterequal
+#  define isgreaterequal(x, y) \
+  (__extension__							      \
+   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
+      !isunordered (__x, __y) && __x >= __y; }))
+# endif
+
+/* Return nonzero value if X is less than Y.  */
+# ifndef isless
+#  define isless(x, y) \
+  (__extension__							      \
+   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
+      !isunordered (__x, __y) && __x < __y; }))
+# endif
+
+/* Return nonzero value if X is less than or equal to Y.  */
+# ifndef islessequal
+#  define islessequal(x, y) \
+  (__extension__							      \
+   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
+      !isunordered (__x, __y) && __x <= __y; }))
+# endif
+
+/* Return nonzero value if either X is less than Y or Y is less than X.  */
+# ifndef islessgreater
+#  define islessgreater(x, y) \
+  (__extension__							      \
+   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
+      !isunordered (__x, __y) && (__x < __y || __y < __x); }))
+# endif
+
+/* Return nonzero value if arguments are unordered.  */
+# ifndef isunordered
+#  define isunordered(u, v) \
+  (__extension__							      \
+   ({ __typeof__(u) __u = (u); __typeof__(v) __v = (v);			      \
+      fpclassify (__u) == FP_NAN || fpclassify (__v) == FP_NAN; }))
+# endif
+
+#endif
+
+__END_DECLS
+
+
+#endif /* math.h  */
diff --git a/include/mcheck.h b/include/mcheck.h
new file mode 100644
index 0000000..7fee5b2
--- /dev/null
+++ b/include/mcheck.h
@@ -0,0 +1,60 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MCHECK_H
+#define _MCHECK_H       1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Return values for `mprobe': these are the kinds of inconsistencies that
+   `mcheck' enables detection of.  */
+enum mcheck_status
+{
+  MCHECK_DISABLED = -1,         /* Consistency checking is not turned on.  */
+  MCHECK_OK,                    /* Block is fine.  */
+  MCHECK_FREE,                  /* Block freed twice.  */
+  MCHECK_HEAD,                  /* Memory before the block was clobbered.  */
+  MCHECK_TAIL                   /* Memory after the block was clobbered.  */
+};
+
+
+/* Activate a standard collection of debugging hooks.  This must be called
+   before `malloc' is ever called.  ABORTFUNC is called with an error code
+   (see enum above) when an inconsistency is detected.  If ABORTFUNC is
+   null, the standard function prints on stderr and then calls `abort'.  */
+extern int mcheck (void (*__abortfunc)(enum mcheck_status)) __THROW;
+
+/* Similar to `mcheck' but performs checks for all block whenever one of
+   the memory handling functions is called.  This can be very slow.  */
+extern int mcheck_pedantic (void (*__abortfunc)(enum mcheck_status)) __THROW;
+
+/* Force check of all blocks now.  */
+extern void mcheck_check_all (void);
+
+/* Check for aberrations in a particular malloc'd block.  You must have
+   called `mcheck' already.  These are the same checks that `mcheck' does
+   when you free or reallocate a block.  */
+extern enum mcheck_status mprobe (void *__ptr) __THROW;
+
+/* Activate a standard collection of tracing hooks.  */
+extern void mtrace (void) __THROW;
+extern void muntrace (void) __THROW;
+
+__END_DECLS
+#endif /* mcheck.h */
diff --git a/include/memory.h b/include/memory.h
new file mode 100644
index 0000000..6d3c3d5
--- /dev/null
+++ b/include/memory.h
@@ -0,0 +1,33 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * SVID
+ */
+
+#ifndef	_MEMORY_H
+#define	_MEMORY_H	1
+
+#include <features.h>
+
+
+#ifndef	_STRING_H
+# include <string.h>
+#endif	/* string.h  */
+
+
+#endif	/* memory.h  */
diff --git a/include/mntent.h b/include/mntent.h
new file mode 100644
index 0000000..879264c
--- /dev/null
+++ b/include/mntent.h
@@ -0,0 +1,97 @@
+/* Utilities for reading/writing fstab, mtab, etc.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_MNTENT_H
+#define	_MNTENT_H	1
+
+#include <features.h>
+#define __need_FILE
+#include <stdio.h>
+#include <paths.h>
+
+
+/* File listing canonical interesting mount points.  */
+#define	MNTTAB		_PATH_MNTTAB	/* Deprecated alias.  */
+
+/* File listing currently active mount points.  */
+#define	MOUNTED		_PATH_MOUNTED	/* Deprecated alias.  */
+
+
+/* General filesystem types.  */
+#define MNTTYPE_IGNORE	"ignore"	/* Ignore this entry.  */
+#define MNTTYPE_NFS	"nfs"		/* Network file system.  */
+#define MNTTYPE_SWAP	"swap"		/* Swap device.  */
+
+
+/* Generic mount options.  */
+#define MNTOPT_DEFAULTS	"defaults"	/* Use all default options.  */
+#define MNTOPT_RO	"ro"		/* Read only.  */
+#define MNTOPT_RW	"rw"		/* Read/write.  */
+#define MNTOPT_SUID	"suid"		/* Set uid allowed.  */
+#define MNTOPT_NOSUID	"nosuid"	/* No set uid allowed.  */
+#define MNTOPT_NOAUTO	"noauto"	/* Do not auto mount.  */
+
+
+__BEGIN_DECLS
+
+/* Structure describing a mount table entry.  */
+struct mntent
+  {
+    char *mnt_fsname;		/* Device or server for filesystem.  */
+    char *mnt_dir;		/* Directory mounted on.  */
+    char *mnt_type;		/* Type of filesystem: ufs, nfs, etc.  */
+    char *mnt_opts;		/* Comma-separated options for fs.  */
+    int mnt_freq;		/* Dump frequency (in days).  */
+    int mnt_passno;		/* Pass number for `fsck'.  */
+  };
+
+
+/* Prepare to begin reading and/or writing mount table entries from the
+   beginning of FILE.  MODE is as for `fopen'.  */
+extern FILE *setmntent (const char *__file, const char *__mode) __THROW;
+
+/* Read one mount table entry from STREAM.  Returns a pointer to storage
+   reused on the next call, or null for EOF or error (use feof/ferror to
+   check).  */
+extern struct mntent *getmntent (FILE *__stream) __THROW;
+
+#ifdef __USE_MISC
+/* Reentrant version of the above function.  */
+extern struct mntent *getmntent_r (FILE *__restrict __stream,
+				   struct mntent *__restrict __result,
+				   char *__restrict __buffer,
+				   int __bufsize) __THROW;
+#endif
+
+/* Write the mount table entry described by MNT to STREAM.
+   Return zero on success, nonzero on failure.  */
+extern int addmntent (FILE *__restrict __stream,
+		      const struct mntent *__restrict __mnt) __THROW;
+
+/* Close a stream opened with `setmntent'.  */
+extern int endmntent (FILE *__stream) __THROW;
+
+/* Search MNT->mnt_opts for an option matching OPT.
+   Returns the address of the substring, or null if none found.  */
+extern char *hasmntopt (const struct mntent *__mnt,
+			const char *__opt) __THROW;
+
+
+__END_DECLS
+
+#endif	/* mntent.h */
diff --git a/include/monetary.h b/include/monetary.h
new file mode 100644
index 0000000..f371d26
--- /dev/null
+++ b/include/monetary.h
@@ -0,0 +1,58 @@
+/* Header file for monetary value formatting functions.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_MONETARY_H
+#define	_MONETARY_H	1
+
+#include <features.h>
+
+/* Get needed types.  */
+#define __need_size_t
+#include <stddef.h>
+#include <bits/types.h>
+
+#ifndef	__ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+#endif
+
+
+__BEGIN_DECLS
+
+/* Formatting a monetary value according to the current locale.  */
+extern ssize_t strfmon (char *__restrict __s, size_t __maxsize,
+			const char *__restrict __format, ...)
+     __THROW __attribute_format_strfmon__ (3, 4);
+
+#ifdef __USE_XOPEN2K8
+# include <xlocale.h>
+
+/* Formatting a monetary value according to the current locale.  */
+extern ssize_t strfmon_l (char *__restrict __s, size_t __maxsize,
+			  __locale_t __loc,
+			  const char *__restrict __format, ...)
+     __THROW __attribute_format_strfmon__ (4, 5);
+#endif
+
+#ifdef __LDBL_COMPAT
+# include <bits/monetary-ldbl.h>
+#endif
+
+__END_DECLS
+
+#endif	/* monetary.h */
diff --git a/include/mqueue.h b/include/mqueue.h
new file mode 100644
index 0000000..e92f009
--- /dev/null
+++ b/include/mqueue.h
@@ -0,0 +1,100 @@
+/* Copyright (C) 2004-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MQUEUE_H
+#define _MQUEUE_H	1
+
+#include <features.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#define __need_sigevent_t
+#include <bits/siginfo.h>
+#define __need_timespec
+#include <time.h>
+/* Get the definition of mqd_t and struct mq_attr.  */
+#include <bits/mqueue.h>
+
+__BEGIN_DECLS
+
+/* Establish connection between a process and a message queue NAME and
+   return message queue descriptor or (mqd_t) -1 on error.  OFLAG determines
+   the type of access used.  If O_CREAT is on OFLAG, the third argument is
+   taken as a `mode_t', the mode of the created message queue, and the fourth
+   argument is taken as `struct mq_attr *', pointer to message queue
+   attributes.  If the fourth argument is NULL, default attributes are
+   used.  */
+extern mqd_t mq_open (const char *__name, int __oflag, ...)
+  __THROW __nonnull ((1));
+
+/* Removes the association between message queue descriptor MQDES and its
+   message queue.  */
+extern int mq_close (mqd_t __mqdes) __THROW;
+
+/* Query status and attributes of message queue MQDES.  */
+extern int mq_getattr (mqd_t __mqdes, struct mq_attr *__mqstat)
+  __THROW __nonnull ((2));
+
+/* Set attributes associated with message queue MQDES and if OMQSTAT is
+   not NULL also query its old attributes.  */
+extern int mq_setattr (mqd_t __mqdes,
+		       const struct mq_attr *__restrict __mqstat,
+		       struct mq_attr *__restrict __omqstat)
+  __THROW __nonnull ((2));
+
+/* Remove message queue named NAME.  */
+extern int mq_unlink (const char *__name) __THROW __nonnull ((1));
+
+/* Register notification issued upon message arrival to an empty
+   message queue MQDES.  */
+extern int mq_notify (mqd_t __mqdes, const struct sigevent *__notification)
+     __THROW;
+
+/* Receive the oldest from highest priority messages in message queue
+   MQDES.  */
+extern ssize_t mq_receive (mqd_t __mqdes, char *__msg_ptr, size_t __msg_len,
+			   unsigned int *__msg_prio) __nonnull ((2));
+
+/* Add message pointed by MSG_PTR to message queue MQDES.  */
+extern int mq_send (mqd_t __mqdes, const char *__msg_ptr, size_t __msg_len,
+		    unsigned int __msg_prio) __nonnull ((2));
+
+#ifdef __USE_XOPEN2K
+/* Receive the oldest from highest priority messages in message queue
+   MQDES, stop waiting if ABS_TIMEOUT expires.  */
+extern ssize_t mq_timedreceive (mqd_t __mqdes, char *__restrict __msg_ptr,
+				size_t __msg_len,
+				unsigned int *__restrict __msg_prio,
+				const struct timespec *__restrict __abs_timeout)
+  __nonnull ((2, 5));
+
+/* Add message pointed by MSG_PTR to message queue MQDES, stop blocking
+   on full message queue if ABS_TIMEOUT expires.  */
+extern int mq_timedsend (mqd_t __mqdes, const char *__msg_ptr,
+			 size_t __msg_len, unsigned int __msg_prio,
+			 const struct timespec *__abs_timeout)
+  __nonnull ((2, 5));
+#endif
+
+/* Define some inlines helping to catch common problems.  */
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function \
+    && defined __va_arg_pack_len
+# include <bits/mqueue2.h>
+#endif
+
+__END_DECLS
+
+#endif /* mqueue.h */
diff --git a/include/net/ethernet.h b/include/net/ethernet.h
new file mode 100644
index 0000000..3b2b473
--- /dev/null
+++ b/include/net/ethernet.h
@@ -0,0 +1,75 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Based on the FreeBSD version of this file. Curiously, that file
+   lacks a copyright in the header. */
+
+#ifndef __NET_ETHERNET_H
+#define __NET_ETHERNET_H 1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <net/if_ether.h>     /* IEEE 802.3 Ethernet constants */
+
+__BEGIN_DECLS
+
+/* This is a name for the 48 bit ethernet address available on many
+   systems.  */
+struct ether_addr
+{
+  u_int8_t ether_addr_octet[ETH_ALEN];
+};
+
+/* 10Mb/s ethernet header */
+struct ether_header
+{
+  u_int8_t  ether_dhost[ETH_ALEN];	/* destination eth addr	*/
+  u_int8_t  ether_shost[ETH_ALEN];	/* source ether addr	*/
+  u_int16_t ether_type;		        /* packet type ID field	*/
+};
+
+/* Ethernet protocol ID's */
+#define	ETHERTYPE_PUP		0x0200          /* Xerox PUP */
+#define	ETHERTYPE_IP		0x0800		/* IP */
+#define	ETHERTYPE_ARP		0x0806		/* Address resolution */
+#define	ETHERTYPE_REVARP	0x8035		/* Reverse ARP */
+
+#define	ETHER_ADDR_LEN	ETH_ALEN                 /* size of ethernet addr */
+#define	ETHER_TYPE_LEN	2                        /* bytes in type field */
+#define	ETHER_CRC_LEN	4                        /* bytes in CRC field */
+#define	ETHER_HDR_LEN	ETH_HLEN                 /* total octets in header */
+#define	ETHER_MIN_LEN	(ETH_ZLEN + ETH_CRC_LEN) /* min packet length */
+#define	ETHER_MAX_LEN	(ETH_FRAME_LEN + ETH_CRC_LEN) /* max packet length */
+
+/* make sure ethenet length is valid */
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+/*
+ * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
+ * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
+ * by an ETHER type (as given above) and then the (variable-length) header.
+ */
+#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
+#define	ETHERTYPE_NTRAILER	16
+
+#define	ETHERMTU	ETH_DATA_LEN
+#define	ETHERMIN	(ETHER_MIN_LEN-ETHER_HDR_LEN-ETHER_CRC_LEN)
+
+__END_DECLS
+
+#endif /* net/ethernet.h */
diff --git a/include/net/if.h b/include/net/if.h
new file mode 100644
index 0000000..a36990f
--- /dev/null
+++ b/include/net/if.h
@@ -0,0 +1,204 @@
+/* net/if.h -- declarations for inquiring about network interfaces
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NET_IF_H
+#define _NET_IF_H	1
+
+#include <features.h>
+
+#ifdef __USE_MISC
+# include <sys/types.h>
+# include <sys/socket.h>
+#endif
+
+
+/* Length of interface name.  */
+#define IF_NAMESIZE	16
+
+struct if_nameindex
+  {
+    unsigned int if_index;	/* 1, 2, ... */
+    char *if_name;		/* null terminated name: "eth0", ... */
+  };
+
+
+#ifdef __USE_MISC
+/* Standard interface flags. */
+enum
+  {
+    IFF_UP = 0x1,		/* Interface is up.  */
+# define IFF_UP	IFF_UP
+    IFF_BROADCAST = 0x2,	/* Broadcast address valid.  */
+# define IFF_BROADCAST	IFF_BROADCAST
+    IFF_DEBUG = 0x4,		/* Turn on debugging.  */
+# define IFF_DEBUG	IFF_DEBUG
+    IFF_LOOPBACK = 0x8,		/* Is a loopback net.  */
+# define IFF_LOOPBACK	IFF_LOOPBACK
+    IFF_POINTOPOINT = 0x10,	/* Interface is point-to-point link.  */
+# define IFF_POINTOPOINT IFF_POINTOPOINT
+    IFF_NOTRAILERS = 0x20,	/* Avoid use of trailers.  */
+# define IFF_NOTRAILERS	IFF_NOTRAILERS
+    IFF_RUNNING = 0x40,		/* Resources allocated.  */
+# define IFF_RUNNING	IFF_RUNNING
+    IFF_NOARP = 0x80,		/* No address resolution protocol.  */
+# define IFF_NOARP	IFF_NOARP
+    IFF_PROMISC = 0x100,	/* Receive all packets.  */
+# define IFF_PROMISC	IFF_PROMISC
+
+    /* Not supported */
+    IFF_ALLMULTI = 0x200,	/* Receive all multicast packets.  */
+# define IFF_ALLMULTI	IFF_ALLMULTI
+
+    IFF_MASTER = 0x400,		/* Master of a load balancer.  */
+# define IFF_MASTER	IFF_MASTER
+    IFF_SLAVE = 0x800,		/* Slave of a load balancer.  */
+# define IFF_SLAVE	IFF_SLAVE
+
+    IFF_MULTICAST = 0x1000,	/* Supports multicast.  */
+# define IFF_MULTICAST	IFF_MULTICAST
+
+    IFF_PORTSEL = 0x2000,	/* Can set media type.  */
+# define IFF_PORTSEL	IFF_PORTSEL
+    IFF_AUTOMEDIA = 0x4000,	/* Auto media select active.  */
+# define IFF_AUTOMEDIA	IFF_AUTOMEDIA
+    IFF_DYNAMIC = 0x8000	/* Dialup device with changing addresses.  */
+# define IFF_DYNAMIC	IFF_DYNAMIC
+  };
+
+/* The ifaddr structure contains information about one address of an
+   interface.  They are maintained by the different address families,
+   are allocated and attached when an address is set, and are linked
+   together so all addresses for an interface can be located.  */
+
+struct ifaddr
+  {
+    struct sockaddr ifa_addr;	/* Address of interface.  */
+    union
+      {
+	struct sockaddr	ifu_broadaddr;
+	struct sockaddr	ifu_dstaddr;
+      } ifa_ifu;
+    struct iface *ifa_ifp;	/* Back-pointer to interface.  */
+    struct ifaddr *ifa_next;	/* Next address for interface.  */
+  };
+
+# define ifa_broadaddr	ifa_ifu.ifu_broadaddr	/* broadcast address	*/
+# define ifa_dstaddr	ifa_ifu.ifu_dstaddr	/* other end of link	*/
+
+/* Device mapping structure. I'd just gone off and designed a
+   beautiful scheme using only loadable modules with arguments for
+   driver options and along come the PCMCIA people 8)
+
+   Ah well. The get() side of this is good for WDSETUP, and it'll be
+   handy for debugging things. The set side is fine for now and being
+   very small might be worth keeping for clean configuration.  */
+
+struct ifmap
+  {
+    unsigned long int mem_start;
+    unsigned long int mem_end;
+    unsigned short int base_addr;
+    unsigned char irq;
+    unsigned char dma;
+    unsigned char port;
+    /* 3 bytes spare */
+  };
+
+/* Interface request structure used for socket ioctl's.  All interface
+   ioctl's must have parameter definitions which begin with ifr_name.
+   The remainder may be interface specific.  */
+
+struct ifreq
+  {
+# define IFHWADDRLEN	6
+# define IFNAMSIZ	IF_NAMESIZE
+    union
+      {
+	char ifrn_name[IFNAMSIZ];	/* Interface name, e.g. "en0".  */
+      } ifr_ifrn;
+
+    union
+      {
+	struct sockaddr ifru_addr;
+	struct sockaddr ifru_dstaddr;
+	struct sockaddr ifru_broadaddr;
+	struct sockaddr ifru_netmask;
+	struct sockaddr ifru_hwaddr;
+	short int ifru_flags;
+	int ifru_ivalue;
+	int ifru_mtu;
+	struct ifmap ifru_map;
+	char ifru_slave[IFNAMSIZ];	/* Just fits the size */
+	char ifru_newname[IFNAMSIZ];
+	__caddr_t ifru_data;
+      } ifr_ifru;
+  };
+# define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
+# define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* MAC address 		*/
+# define ifr_addr	ifr_ifru.ifru_addr	/* address		*/
+# define ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
+# define ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address	*/
+# define ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask	*/
+# define ifr_flags	ifr_ifru.ifru_flags	/* flags		*/
+# define ifr_metric	ifr_ifru.ifru_ivalue	/* metric		*/
+# define ifr_mtu	ifr_ifru.ifru_mtu	/* mtu			*/
+# define ifr_map	ifr_ifru.ifru_map	/* device map		*/
+# define ifr_slave	ifr_ifru.ifru_slave	/* slave device		*/
+# define ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
+# define ifr_ifindex	ifr_ifru.ifru_ivalue    /* interface index      */
+# define ifr_bandwidth	ifr_ifru.ifru_ivalue	/* link bandwidth	*/
+# define ifr_qlen	ifr_ifru.ifru_ivalue	/* queue length		*/
+# define ifr_newname	ifr_ifru.ifru_newname	/* New name		*/
+# define _IOT_ifreq	_IOT(_IOTS(char),IFNAMSIZ,_IOTS(char),16,0,0)
+# define _IOT_ifreq_short _IOT(_IOTS(char),IFNAMSIZ,_IOTS(short),1,0,0)
+# define _IOT_ifreq_int	_IOT(_IOTS(char),IFNAMSIZ,_IOTS(int),1,0,0)
+
+
+/* Structure used in SIOCGIFCONF request.  Used to retrieve interface
+   configuration for machine (useful for programs which must know all
+   networks accessible).  */
+
+struct ifconf
+  {
+    int	ifc_len;			/* Size of buffer.  */
+    union
+      {
+	__caddr_t ifcu_buf;
+	struct ifreq *ifcu_req;
+      } ifc_ifcu;
+  };
+# define ifc_buf	ifc_ifcu.ifcu_buf	/* Buffer address.  */
+# define ifc_req	ifc_ifcu.ifcu_req	/* Array of structures.  */
+# define _IOT_ifconf _IOT(_IOTS(struct ifconf),1,0,0,0,0) /* not right */
+#endif	/* Misc.  */
+
+__BEGIN_DECLS
+
+/* Convert an interface name to an index, and vice versa.  */
+extern unsigned int if_nametoindex (const char *__ifname) __THROW;
+extern char *if_indextoname (unsigned int __ifindex, char *__ifname) __THROW;
+
+/* Return a list of all interfaces and their indices.  */
+extern struct if_nameindex *if_nameindex (void) __THROW;
+
+/* Free the data returned from if_nameindex.  */
+extern void if_freenameindex (struct if_nameindex *__ptr) __THROW;
+
+__END_DECLS
+
+#endif /* net/if.h */
diff --git a/include/net/if_arp.h b/include/net/if_arp.h
new file mode 100644
index 0000000..6ac89d7
--- /dev/null
+++ b/include/net/if_arp.h
@@ -0,0 +1,144 @@
+/* Definitions for Address Resolution Protocol.
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Based on the 4.4BSD and Linux version of this file.  */
+
+#ifndef _NET_IF_ARP_H
+
+#define _NET_IF_ARP_H 1
+#include <sys/cdefs.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+__BEGIN_DECLS
+
+/* Some internals from deep down in the kernel.  */
+#define MAX_ADDR_LEN	7
+
+
+/* This structure defines an ethernet arp header.  */
+
+/* ARP protocol opcodes. */
+#define	ARPOP_REQUEST	1		/* ARP request.  */
+#define	ARPOP_REPLY	2		/* ARP reply.  */
+#define	ARPOP_RREQUEST	3		/* RARP request.  */
+#define	ARPOP_RREPLY	4		/* RARP reply.  */
+
+/* See RFC 826 for protocol description.  ARP packets are variable
+   in size; the arphdr structure defines the fixed-length portion.
+   Protocol type values are the same as those for 10 Mb/s Ethernet.
+   It is followed by the variable-sized fields ar_sha, arp_spa,
+   arp_tha and arp_tpa in that order, according to the lengths
+   specified.  Field names used correspond to RFC 826.  */
+
+struct arphdr
+  {
+    unsigned short int ar_hrd;		/* Format of hardware address.  */
+    unsigned short int ar_pro;		/* Format of protocol address.  */
+    unsigned char ar_hln;		/* Length of hardware address.  */
+    unsigned char ar_pln;		/* Length of protocol address.  */
+    unsigned short int ar_op;		/* ARP opcode (command).  */
+#if 0
+    /* Ethernet looks like this : This bit is variable sized
+       however...  */
+    unsigned char __ar_sha[ETH_ALEN];	/* Sender hardware address.  */
+    unsigned char __ar_sip[4];		/* Sender IP address.  */
+    unsigned char __ar_tha[ETH_ALEN];	/* Target hardware address.  */
+    unsigned char __ar_tip[4];		/* Target IP address.  */
+#endif
+  };
+
+
+/* ARP protocol HARDWARE identifiers. */
+#define ARPHRD_NETROM	0		/* From KA9Q: NET/ROM pseudo. */
+#define ARPHRD_ETHER 	1		/* Ethernet 10Mbps.  */
+#define	ARPHRD_EETHER	2		/* Experimental Ethernet.  */
+#define	ARPHRD_AX25	3		/* AX.25 Level 2.  */
+#define	ARPHRD_PRONET	4		/* PROnet token ring.  */
+#define	ARPHRD_CHAOS	5		/* Chaosnet.  */
+#define	ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet/TR/TB.  */
+#define	ARPHRD_ARCNET	7		/* ARCnet.  */
+#define	ARPHRD_APPLETLK	8		/* APPLEtalk.  */
+#define ARPHRD_DLCI	15		/* Frame Relay DLCI.  */
+#define ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id).  */
+
+/* Dummy types for non ARP hardware */
+#define ARPHRD_SLIP	256
+#define ARPHRD_CSLIP	257
+#define ARPHRD_SLIP6	258
+#define ARPHRD_CSLIP6	259
+#define ARPHRD_RSRVD	260		/* Notional KISS type.  */
+#define ARPHRD_ADAPT	264
+#define ARPHRD_ROSE	270
+#define ARPHRD_X25	271		/* CCITT X.25.  */
+#define ARPHRD_PPP	512
+#define ARPHRD_HDLC	513		/* (Cisco) HDLC.  */
+#define ARPHRD_LAPB	516		/* LAPB.  */
+
+#define ARPHRD_TUNNEL	768		/* IPIP tunnel.  */
+#define ARPHRD_TUNNEL6	769		/* IPIP6 tunnel.  */
+#define ARPHRD_FRAD	770             /* Frame Relay Access Device.  */
+#define ARPHRD_SKIP	771		/* SKIP vif.  */
+#define ARPHRD_LOOPBACK	772		/* Loopback device.  */
+#define ARPHRD_LOCALTLK 773		/* Localtalk device.  */
+#define ARPHRD_FDDI	774		/* Fiber Distributed Data Interface. */
+#define ARPHRD_BIF      775             /* AP1000 BIF.  */
+#define ARPHRD_SIT	776		/* sit0 device - IPv6-in-IPv4.  */
+
+
+/* ARP ioctl request.  */
+struct arpreq
+  {
+    struct sockaddr arp_pa;		/* Protocol address.  */
+    struct sockaddr arp_ha;		/* Hardware address.  */
+    int arp_flags;			/* Flags.  */
+    struct sockaddr arp_netmask;	/* Netmask (only for proxy arps).  */
+    char arp_dev[16];
+  };
+
+/* ARP Flag values.  */
+#define ATF_COM		0x02		/* Completed entry (ha valid).  */
+#define	ATF_PERM	0x04		/* Permanent entry.  */
+#define	ATF_PUBL	0x08		/* Publish entry.  */
+#define	ATF_USETRAILERS	0x10		/* Has requested trailers.  */
+#define ATF_NETMASK     0x20            /* Want to use a netmask (only
+					   for proxy entries).  */
+#define ATF_DONTPUB	0x40		/* Don't answer this addresses.  */
+#define ATF_MAGIC	0x80		/* Automatically added entry.  */
+
+
+/* Support for the user space arp daemon, arpd.  */
+#define ARPD_UPDATE	0x01
+#define ARPD_LOOKUP	0x02
+#define ARPD_FLUSH	0x03
+
+struct arpd_request
+  {
+    unsigned short int req;		/* Request type.  */
+    u_int32_t ip;			/* IP address of entry.  */
+    unsigned long int dev;		/* Device entry is tied to.  */
+    unsigned long int stamp;
+    unsigned long int updated;
+    unsigned char ha[MAX_ADDR_LEN];	/* Hardware address.  */
+  };
+
+__END_DECLS
+
+#endif	/* net/if_arp.h */
diff --git a/include/net/if_ether.h b/include/net/if_ether.h
new file mode 100644
index 0000000..270993c
--- /dev/null
+++ b/include/net/if_ether.h
@@ -0,0 +1,84 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NET_IF_ETHER_H
+#define _NET_IF_ETHER_H	1
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_ECHO	0x0200		/* Ethernet Echo packet		*/
+#define ETH_P_PUP	0x0400		/* Xerox PUP packet		*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr
+{
+  unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+  unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+  unsigned short int h_proto;		/* packet type ID field	*/
+};
+
+#endif	/* net/if_ether.h */
diff --git a/include/net/if_ppp.h b/include/net/if_ppp.h
new file mode 100644
index 0000000..1b1c3ea
--- /dev/null
+++ b/include/net/if_ppp.h
@@ -0,0 +1,169 @@
+/*	From: if_ppp.h,v 1.3 1995/06/12 11:36:50 paulus Exp */
+
+/*
+ * if_ppp.h - Point-to-Point Protocol definitions.
+ *
+ * Copyright (c) 1989 Carnegie Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY AND
+ * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ *  ==FILEVERSION 960926==
+ *
+ *  NOTE TO MAINTAINERS:
+ *     If you modify this file at all, please set the above date.
+ *     if_ppp.h is shipped with a PPP distribution as well as with the kernel;
+ *     if everyone increases the FILEVERSION number above, then scripts
+ *     can do the right thing when deciding whether to install a new if_ppp.h
+ *     file.  Don't change the format of that line otherwise, so the
+ *     installation script can recognize it.
+ */
+
+
+#ifndef __NET_IF_PPP_H
+#define __NET_IF_PPP_H 1
+
+#include <sys/types.h>
+#include <sys/cdefs.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <net/ppp_defs.h>
+
+__BEGIN_DECLS
+
+/*
+ * Packet sizes
+ */
+
+#define	PPP_MTU		1500	/* Default MTU (size of Info field) */
+#define PPP_MAXMRU	65000	/* Largest MRU we allow */
+#define PPP_VERSION	"2.2.0"
+#define PPP_MAGIC	0x5002	/* Magic value for the ppp structure */
+#define PROTO_IPX	0x002b	/* protocol numbers */
+#define PROTO_DNA_RT    0x0027  /* DNA Routing */
+
+
+/*
+ * Bit definitions for flags.
+ */
+
+#define SC_COMP_PROT	0x00000001	/* protocol compression (output) */
+#define SC_COMP_AC	0x00000002	/* header compression (output) */
+#define	SC_COMP_TCP	0x00000004	/* TCP (VJ) compression (output) */
+#define SC_NO_TCP_CCID	0x00000008	/* disable VJ connection-id comp. */
+#define SC_REJ_COMP_AC	0x00000010	/* reject adrs/ctrl comp. on input */
+#define SC_REJ_COMP_TCP	0x00000020	/* reject TCP (VJ) comp. on input */
+#define SC_CCP_OPEN	0x00000040	/* Look at CCP packets */
+#define SC_CCP_UP	0x00000080	/* May send/recv compressed packets */
+#define SC_ENABLE_IP	0x00000100	/* IP packets may be exchanged */
+#define SC_COMP_RUN	0x00001000	/* compressor has been inited */
+#define SC_DECOMP_RUN	0x00002000	/* decompressor has been inited */
+#define SC_DEBUG	0x00010000	/* enable debug messages */
+#define SC_LOG_INPKT	0x00020000	/* log contents of good pkts recvd */
+#define SC_LOG_OUTPKT	0x00040000	/* log contents of pkts sent */
+#define SC_LOG_RAWIN	0x00080000	/* log all chars received */
+#define SC_LOG_FLUSH	0x00100000	/* log all chars flushed */
+#define	SC_MASK		0x0fE0ffff	/* bits that user can change */
+
+/* state bits */
+#define	SC_ESCAPED	0x80000000	/* saw a PPP_ESCAPE */
+#define	SC_FLUSH	0x40000000	/* flush input until next PPP_FLAG */
+#define SC_VJ_RESET	0x20000000	/* Need to reset the VJ decompressor */
+#define SC_XMIT_BUSY	0x10000000	/* ppp_write_wakeup is active */
+#define SC_RCV_ODDP	0x08000000	/* have rcvd char with odd parity */
+#define SC_RCV_EVNP	0x04000000	/* have rcvd char with even parity */
+#define SC_RCV_B7_1	0x02000000	/* have rcvd char with bit 7 = 1 */
+#define SC_RCV_B7_0	0x01000000	/* have rcvd char with bit 7 = 0 */
+#define SC_DC_FERROR	0x00800000	/* fatal decomp error detected */
+#define SC_DC_ERROR	0x00400000	/* non-fatal decomp error detected */
+
+/*
+ * Ioctl definitions.
+ */
+
+struct npioctl {
+    int		protocol;	/* PPP protocol, e.g. PPP_IP */
+    enum NPmode	mode;
+};
+
+/* Structure describing a CCP configuration option, for PPPIOCSCOMPRESS */
+struct ppp_option_data {
+	u_int8_t  *ptr;
+	u_int32_t length;
+	int	  transmit;
+};
+
+struct ifpppstatsreq {
+  struct ifreq	   b;
+  struct ppp_stats stats;			/* statistic information */
+};
+
+struct ifpppcstatsreq {
+  struct ifreq		b;
+  struct ppp_comp_stats stats;
+};
+
+#define ifr__name       b.ifr_ifrn.ifrn_name
+#define stats_ptr       b.ifr_ifru.ifru_data
+
+/*
+ * Ioctl definitions.
+ */
+
+#define	PPPIOCGFLAGS	_IOR('t', 90, int)	/* get configuration flags */
+#define	PPPIOCSFLAGS	_IOW('t', 89, int)	/* set configuration flags */
+#define	PPPIOCGASYNCMAP	_IOR('t', 88, int)	/* get async map */
+#define	PPPIOCSASYNCMAP	_IOW('t', 87, int)	/* set async map */
+#define	PPPIOCGUNIT	_IOR('t', 86, int)	/* get ppp unit number */
+#define	PPPIOCGRASYNCMAP _IOR('t', 85, int)	/* get receive async map */
+#define	PPPIOCSRASYNCMAP _IOW('t', 84, int)	/* set receive async map */
+#define	PPPIOCGMRU	_IOR('t', 83, int)	/* get max receive unit */
+#define	PPPIOCSMRU	_IOW('t', 82, int)	/* set max receive unit */
+#define	PPPIOCSMAXCID	_IOW('t', 81, int)	/* set VJ max slot ID */
+#define PPPIOCGXASYNCMAP _IOR('t', 80, ext_accm) /* get extended ACCM */
+#define PPPIOCSXASYNCMAP _IOW('t', 79, ext_accm) /* set extended ACCM */
+#define PPPIOCXFERUNIT	_IO('t', 78)		/* transfer PPP unit */
+#define PPPIOCSCOMPRESS	_IOW('t', 77, struct ppp_option_data)
+#define PPPIOCGNPMODE	_IOWR('t', 76, struct npioctl) /* get NP mode */
+#define PPPIOCSNPMODE	_IOW('t', 75, struct npioctl)  /* set NP mode */
+#define PPPIOCGDEBUG	_IOR('t', 65, int)	/* Read debug level */
+#define PPPIOCSDEBUG	_IOW('t', 64, int)	/* Set debug level */
+#define PPPIOCGIDLE	_IOR('t', 63, struct ppp_idle) /* get idle time */
+
+#define SIOCGPPPSTATS   (SIOCDEVPRIVATE + 0)
+#define SIOCGPPPVER     (SIOCDEVPRIVATE + 1)  /* NEVER change this!! */
+#define SIOCGPPPCSTATS  (SIOCDEVPRIVATE + 2)
+
+#if !defined(ifr_mtu)
+#define ifr_mtu	ifr_ifru.ifru_metric
+#endif
+
+__END_DECLS
+
+#endif /* net/if_ppp.h */
diff --git a/include/net/route.h b/include/net/route.h
new file mode 100644
index 0000000..d18a68a
--- /dev/null
+++ b/include/net/route.h
@@ -0,0 +1,140 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc..
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Based on the 4.4BSD and Linux version of this file.  */
+
+#ifndef _NET_ROUTE_H
+
+#define _NET_ROUTE_H	1
+#include <features.h>
+
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+
+
+/* This structure gets passed by the SIOCADDRT and SIOCDELRT calls. */
+struct rtentry
+  {
+    unsigned long int rt_pad1;
+    struct sockaddr rt_dst;		/* Target address.  */
+    struct sockaddr rt_gateway;		/* Gateway addr (RTF_GATEWAY).  */
+    struct sockaddr rt_genmask;		/* Target network mask (IP).  */
+    unsigned short int rt_flags;
+    short int rt_pad2;
+    unsigned long int rt_pad3;
+    unsigned char rt_tos;
+    unsigned char rt_class;
+    short int rt_pad4;
+    short int rt_metric;		/* +1 for binary compatibility!  */
+    char *rt_dev;			/* Forcing the device at add.  */
+    unsigned long int rt_mtu;		/* Per route MTU/Window.  */
+    unsigned long int rt_window;	/* Window clamping.  */
+    unsigned short int rt_irtt;		/* Initial RTT.  */
+  };
+/* Compatibility hack.  */
+#define rt_mss	rt_mtu
+
+
+struct in6_rtmsg
+  {
+    struct in6_addr rtmsg_dst;
+    struct in6_addr rtmsg_src;
+    struct in6_addr rtmsg_gateway;
+    u_int32_t rtmsg_type;
+    u_int16_t rtmsg_dst_len;
+    u_int16_t rtmsg_src_len;
+    u_int32_t rtmsg_metric;
+    unsigned long int rtmsg_info;
+    u_int32_t rtmsg_flags;
+    int rtmsg_ifindex;
+  };
+
+
+#define	RTF_UP		0x0001		/* Route usable.  */
+#define	RTF_GATEWAY	0x0002		/* Destination is a gateway.  */
+
+#define	RTF_HOST	0x0004		/* Host entry (net otherwise).  */
+#define RTF_REINSTATE	0x0008		/* Reinstate route after timeout.  */
+#define	RTF_DYNAMIC	0x0010		/* Created dyn. (by redirect).  */
+#define	RTF_MODIFIED	0x0020		/* Modified dyn. (by redirect).  */
+#define RTF_MTU		0x0040		/* Specific MTU for this route.  */
+#define RTF_MSS		RTF_MTU		/* Compatibility.  */
+#define RTF_WINDOW	0x0080		/* Per route window clamping.  */
+#define RTF_IRTT	0x0100		/* Initial round trip time.  */
+#define RTF_REJECT	0x0200		/* Reject route.  */
+#define	RTF_STATIC	0x0400		/* Manually injected route.  */
+#define	RTF_XRESOLVE	0x0800		/* External resolver.  */
+#define RTF_NOFORWARD   0x1000		/* Forwarding inhibited.  */
+#define RTF_THROW	0x2000		/* Go to next class.  */
+#define RTF_NOPMTUDISC  0x4000		/* Do not send packets with DF.  */
+
+/* for IPv6 */
+#define RTF_DEFAULT	0x00010000	/* default - learned via ND	*/
+#define RTF_ALLONLINK	0x00020000	/* fallback, no routers on link	*/
+#define RTF_ADDRCONF	0x00040000	/* addrconf route - RA		*/
+
+#define RTF_LINKRT	0x00100000	/* link specific - device match	*/
+#define RTF_NONEXTHOP	0x00200000	/* route with no nexthop	*/
+
+#define RTF_CACHE	0x01000000	/* cache entry			*/
+#define RTF_FLOW	0x02000000	/* flow significant route	*/
+#define RTF_POLICY	0x04000000	/* policy route			*/
+
+#define RTCF_VALVE	0x00200000
+#define RTCF_MASQ	0x00400000
+#define RTCF_NAT	0x00800000
+#define RTCF_DOREDIRECT 0x01000000
+#define RTCF_LOG	0x02000000
+#define RTCF_DIRECTSRC	0x04000000
+
+#define RTF_LOCAL	0x80000000
+#define RTF_INTERFACE	0x40000000
+#define RTF_MULTICAST	0x20000000
+#define RTF_BROADCAST	0x10000000
+#define RTF_NAT		0x08000000
+
+#define RTF_ADDRCLASSMASK	0xF8000000
+#define RT_ADDRCLASS(flags)	((__u_int32_t) flags >> 23)
+
+#define RT_TOS(tos)		((tos) & IPTOS_TOS_MASK)
+
+#define RT_LOCALADDR(flags)	((flags & RTF_ADDRCLASSMASK) \
+				 == (RTF_LOCAL|RTF_INTERFACE))
+
+#define RT_CLASS_UNSPEC		0
+#define RT_CLASS_DEFAULT	253
+
+#define RT_CLASS_MAIN		254
+#define RT_CLASS_LOCAL		255
+#define RT_CLASS_MAX		255
+
+
+#define RTMSG_ACK		NLMSG_ACK
+#define RTMSG_OVERRUN		NLMSG_OVERRUN
+
+#define RTMSG_NEWDEVICE		0x11
+#define RTMSG_DELDEVICE		0x12
+#define RTMSG_NEWROUTE		0x21
+#define RTMSG_DELROUTE		0x22
+#define RTMSG_NEWRULE		0x31
+#define RTMSG_DELRULE		0x32
+#define RTMSG_CONTROL		0x40
+
+#define RTMSG_AR_FAILED		0x51	/* Address Resolution failed.  */
+
+#endif /* net/route.h */
diff --git a/include/netdb.h b/include/netdb.h
new file mode 100644
index 0000000..f9e2bf0
--- /dev/null
+++ b/include/netdb.h
@@ -0,0 +1,715 @@
+  /* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* All data returned by the network data base library are supplied in
+   host order and returned in network order (suitable for use in
+   system calls).  */
+
+#ifndef	_NETDB_H
+#define	_NETDB_H	1
+
+#include <features.h>
+
+#include <netinet/in.h>
+#include <stdint.h>
+#ifdef __USE_MISC
+/* This is necessary to make this include file properly replace the
+   Sun version.  */
+# include <rpc/netdb.h>
+#endif
+
+#ifdef __USE_GNU
+# define __need_sigevent_t
+# include <bits/siginfo.h>
+# define __need_timespec
+# include <time.h>
+#endif
+
+#include <bits/netdb.h>
+
+/* Absolute file name for network data base files.  */
+#define	_PATH_HEQUIV		"/etc/hosts.equiv"
+#define	_PATH_HOSTS		"/etc/hosts"
+#define	_PATH_NETWORKS		"/etc/networks"
+#define	_PATH_NSSWITCH_CONF	"/etc/nsswitch.conf"
+#define	_PATH_PROTOCOLS		"/etc/protocols"
+#define	_PATH_SERVICES		"/etc/services"
+
+
+__BEGIN_DECLS
+
+#if defined __USE_MISC || !defined __USE_XOPEN2K8
+/* Error status for non-reentrant lookup functions.
+   We use a macro to access always the thread-specific `h_errno' variable.  */
+# define h_errno (*__h_errno_location ())
+
+/* Function to get address of global `h_errno' variable.  */
+extern int *__h_errno_location (void) __THROW __attribute__ ((__const__));
+
+
+/* Possible values left in `h_errno'.  */
+# define HOST_NOT_FOUND	1	/* Authoritative Answer Host not found.  */
+# define TRY_AGAIN	2	/* Non-Authoritative Host not found,
+				   or SERVERFAIL.  */
+# define NO_RECOVERY	3	/* Non recoverable errors, FORMERR, REFUSED,
+				   NOTIMP.  */
+# define NO_DATA	4	/* Valid name, no data record of requested
+				   type.  */
+#endif
+#if defined __USE_MISC || defined __USE_GNU
+# define NETDB_INTERNAL	-1	/* See errno.  */
+# define NETDB_SUCCESS	0	/* No problem.  */
+# define NO_ADDRESS	NO_DATA	/* No address, look for MX record.  */
+#endif
+
+#if defined __USE_XOPEN2K || defined __USE_XOPEN_EXTENDED
+/* Highest reserved Internet port number.  */
+# define IPPORT_RESERVED	1024
+#endif
+
+#ifdef __USE_GNU
+/* Scope delimiter for getaddrinfo(), getnameinfo().  */
+# define SCOPE_DELIMITER	'%'
+#endif
+
+#ifdef __USE_MISC
+/* Print error indicated by `h_errno' variable on standard error.  STR
+   if non-null is printed before the error string.  */
+extern void herror (const char *__str) __THROW;
+
+/* Return string associated with error ERR_NUM.  */
+extern const char *hstrerror (int __err_num) __THROW;
+#endif
+
+
+/* Description of data base entry for a single host.  */
+struct hostent
+{
+  char *h_name;			/* Official name of host.  */
+  char **h_aliases;		/* Alias list.  */
+  int h_addrtype;		/* Host address type.  */
+  int h_length;			/* Length of address.  */
+  char **h_addr_list;		/* List of addresses from name server.  */
+#if defined __USE_MISC || defined __USE_GNU
+# define	h_addr	h_addr_list[0] /* Address, for backward compatibility.*/
+#endif
+};
+
+/* Open host data base files and mark them as staying open even after
+   a later search if STAY_OPEN is non-zero.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void sethostent (int __stay_open);
+
+/* Close host data base files and clear `stay open' flag.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void endhostent (void);
+
+/* Get next entry from host data base file.  Open data base if
+   necessary.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct hostent *gethostent (void);
+
+/* Return entry from host data base which address match ADDR with
+   length LEN and type TYPE.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
+				      int __type);
+
+/* Return entry from host data base for host with NAME.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct hostent *gethostbyname (const char *__name);
+
+#ifdef __USE_MISC
+/* Return entry from host data base for host with NAME.  AF must be
+   set to the address type which is `AF_INET' for IPv4 or `AF_INET6'
+   for IPv6.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct hostent *gethostbyname2 (const char *__name, int __af);
+
+/* Reentrant versions of the functions above.  The additional
+   arguments specify a buffer of BUFLEN starting at BUF.  The last
+   argument is a pointer to a variable which gets the value which
+   would be stored in the global variable `herrno' by the
+   non-reentrant functions.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern int gethostent_r (struct hostent *__restrict __result_buf,
+			 char *__restrict __buf, size_t __buflen,
+			 struct hostent **__restrict __result,
+			 int *__restrict __h_errnop);
+
+extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
+			    int __type,
+			    struct hostent *__restrict __result_buf,
+			    char *__restrict __buf, size_t __buflen,
+			    struct hostent **__restrict __result,
+			    int *__restrict __h_errnop);
+
+extern int gethostbyname_r (const char *__restrict __name,
+			    struct hostent *__restrict __result_buf,
+			    char *__restrict __buf, size_t __buflen,
+			    struct hostent **__restrict __result,
+			    int *__restrict __h_errnop);
+
+extern int gethostbyname2_r (const char *__restrict __name, int __af,
+			     struct hostent *__restrict __result_buf,
+			     char *__restrict __buf, size_t __buflen,
+			     struct hostent **__restrict __result,
+			     int *__restrict __h_errnop);
+#endif	/* misc */
+
+
+/* Open network data base files and mark them as staying open even
+   after a later search if STAY_OPEN is non-zero.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void setnetent (int __stay_open);
+
+/* Close network data base files and clear `stay open' flag.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void endnetent (void);
+
+/* Get next entry from network data base file.  Open data base if
+   necessary.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct netent *getnetent (void);
+
+/* Return entry from network data base which address match NET and
+   type TYPE.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct netent *getnetbyaddr (uint32_t __net, int __type);
+
+/* Return entry from network data base for network with NAME.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct netent *getnetbyname (const char *__name);
+
+#ifdef	__USE_MISC
+/* Reentrant versions of the functions above.  The additional
+   arguments specify a buffer of BUFLEN starting at BUF.  The last
+   argument is a pointer to a variable which gets the value which
+   would be stored in the global variable `herrno' by the
+   non-reentrant functions.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern int getnetent_r (struct netent *__restrict __result_buf,
+			char *__restrict __buf, size_t __buflen,
+			struct netent **__restrict __result,
+			int *__restrict __h_errnop);
+
+extern int getnetbyaddr_r (uint32_t __net, int __type,
+			   struct netent *__restrict __result_buf,
+			   char *__restrict __buf, size_t __buflen,
+			   struct netent **__restrict __result,
+			   int *__restrict __h_errnop);
+
+extern int getnetbyname_r (const char *__restrict __name,
+			   struct netent *__restrict __result_buf,
+			   char *__restrict __buf, size_t __buflen,
+			   struct netent **__restrict __result,
+			   int *__restrict __h_errnop);
+#endif	/* misc */
+
+
+/* Description of data base entry for a single service.  */
+struct servent
+{
+  char *s_name;			/* Official service name.  */
+  char **s_aliases;		/* Alias list.  */
+  int s_port;			/* Port number.  */
+  char *s_proto;		/* Protocol to use.  */
+};
+
+/* Open service data base files and mark them as staying open even
+   after a later search if STAY_OPEN is non-zero.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void setservent (int __stay_open);
+
+/* Close service data base files and clear `stay open' flag.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void endservent (void);
+
+/* Get next entry from service data base file.  Open data base if
+   necessary.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct servent *getservent (void);
+
+/* Return entry from network data base for network with NAME and
+   protocol PROTO.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct servent *getservbyname (const char *__name, const char *__proto);
+
+/* Return entry from service data base which matches port PORT and
+   protocol PROTO.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct servent *getservbyport (int __port, const char *__proto);
+
+
+#ifdef	__USE_MISC
+/* Reentrant versions of the functions above.  The additional
+   arguments specify a buffer of BUFLEN starting at BUF.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern int getservent_r (struct servent *__restrict __result_buf,
+			 char *__restrict __buf, size_t __buflen,
+			 struct servent **__restrict __result);
+
+extern int getservbyname_r (const char *__restrict __name,
+			    const char *__restrict __proto,
+			    struct servent *__restrict __result_buf,
+			    char *__restrict __buf, size_t __buflen,
+			    struct servent **__restrict __result);
+
+extern int getservbyport_r (int __port, const char *__restrict __proto,
+			    struct servent *__restrict __result_buf,
+			    char *__restrict __buf, size_t __buflen,
+			    struct servent **__restrict __result);
+#endif	/* misc */
+
+
+/* Description of data base entry for a single service.  */
+struct protoent
+{
+  char *p_name;			/* Official protocol name.  */
+  char **p_aliases;		/* Alias list.  */
+  int p_proto;			/* Protocol number.  */
+};
+
+/* Open protocol data base files and mark them as staying open even
+   after a later search if STAY_OPEN is non-zero.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void setprotoent (int __stay_open);
+
+/* Close protocol data base files and clear `stay open' flag.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void endprotoent (void);
+
+/* Get next entry from protocol data base file.  Open data base if
+   necessary.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct protoent *getprotoent (void);
+
+/* Return entry from protocol data base for network with NAME.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct protoent *getprotobyname (const char *__name);
+
+/* Return entry from protocol data base which number is PROTO.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct protoent *getprotobynumber (int __proto);
+
+
+#ifdef	__USE_MISC
+/* Reentrant versions of the functions above.  The additional
+   arguments specify a buffer of BUFLEN starting at BUF.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern int getprotoent_r (struct protoent *__restrict __result_buf,
+			  char *__restrict __buf, size_t __buflen,
+			  struct protoent **__restrict __result);
+
+extern int getprotobyname_r (const char *__restrict __name,
+			     struct protoent *__restrict __result_buf,
+			     char *__restrict __buf, size_t __buflen,
+			     struct protoent **__restrict __result);
+
+extern int getprotobynumber_r (int __proto,
+			       struct protoent *__restrict __result_buf,
+			       char *__restrict __buf, size_t __buflen,
+			       struct protoent **__restrict __result);
+
+
+/* Establish network group NETGROUP for enumeration.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int setnetgrent (const char *__netgroup);
+
+/* Free all space allocated by previous `setnetgrent' call.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern void endnetgrent (void);
+
+/* Get next member of netgroup established by last `setnetgrent' call
+   and return pointers to elements in HOSTP, USERP, and DOMAINP.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int getnetgrent (char **__restrict __hostp,
+			char **__restrict __userp,
+			char **__restrict __domainp);
+
+
+/* Test whether NETGROUP contains the triple (HOST,USER,DOMAIN).
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int innetgr (const char *__netgroup, const char *__host,
+		    const char *__user, const char *__domain);
+
+/* Reentrant version of `getnetgrent' where result is placed in BUFFER.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int getnetgrent_r (char **__restrict __hostp,
+			  char **__restrict __userp,
+			  char **__restrict __domainp,
+			  char *__restrict __buffer, size_t __buflen);
+#endif	/* misc */
+
+
+#ifdef __USE_BSD
+/* Call `rshd' at port RPORT on remote machine *AHOST to execute CMD.
+   The local user is LOCUSER, on the remote machine the command is
+   executed as REMUSER.  In *FD2P the descriptor to the socket for the
+   connection is returned.  The caller must have the right to use a
+   reserved port.  When the function returns *AHOST contains the
+   official host name.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
+		 const char *__restrict __locuser,
+		 const char *__restrict __remuser,
+		 const char *__restrict __cmd, int *__restrict __fd2p);
+
+/* This is the equivalent function where the protocol can be selected
+   and which therefore can be used for IPv6.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
+		    const char *__restrict __locuser,
+		    const char *__restrict __remuser,
+		    const char *__restrict __cmd, int *__restrict __fd2p,
+		    sa_family_t __af);
+
+/* Call `rexecd' at port RPORT on remote machine *AHOST to execute
+   CMD.  The process runs at the remote machine using the ID of user
+   NAME whose cleartext password is PASSWD.  In *FD2P the descriptor
+   to the socket for the connection is returned.  When the function
+   returns *AHOST contains the official host name.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int rexec (char **__restrict __ahost, int __rport,
+		  const char *__restrict __name,
+		  const char *__restrict __pass,
+		  const char *__restrict __cmd, int *__restrict __fd2p);
+
+/* This is the equivalent function where the protocol can be selected
+   and which therefore can be used for IPv6.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int rexec_af (char **__restrict __ahost, int __rport,
+		     const char *__restrict __name,
+		     const char *__restrict __pass,
+		     const char *__restrict __cmd, int *__restrict __fd2p,
+		     sa_family_t __af);
+
+/* Check whether user REMUSER on system RHOST is allowed to login as LOCUSER.
+   If SUSER is not zero the user tries to become superuser.  Return 0 if
+   it is possible.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int ruserok (const char *__rhost, int __suser,
+		    const char *__remuser, const char *__locuser);
+
+/* This is the equivalent function where the protocol can be selected
+   and which therefore can be used for IPv6.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int ruserok_af (const char *__rhost, int __suser,
+		       const char *__remuser, const char *__locuser,
+		       sa_family_t __af);
+
+/* Check whether user REMUSER on system indicated by IPv4 address
+   RADDR is allowed to login as LOCUSER.  Non-IPv4 (e.g., IPv6) are
+   not supported.  If SUSER is not zero the user tries to become
+   superuser.  Return 0 if it is possible.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int iruserok (uint32_t __raddr, int __suser,
+		     const char *__remuser, const char *__locuser);
+
+/* This is the equivalent function where the pfamiliy if the address
+   pointed to by RADDR is determined by the value of AF.  It therefore
+   can be used for IPv6
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int iruserok_af (const void *__raddr, int __suser,
+			const char *__remuser, const char *__locuser,
+			sa_family_t __af);
+
+/* Try to allocate reserved port, returning a descriptor for a socket opened
+   at this port or -1 if unsuccessful.  The search for an available port
+   will start at ALPORT and continues with lower numbers.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int rresvport (int *__alport);
+
+/* This is the equivalent function where the protocol can be selected
+   and which therefore can be used for IPv6.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int rresvport_af (int *__alport, sa_family_t __af);
+#endif
+
+
+/* Extension from POSIX.1g.  */
+#ifdef	__USE_POSIX
+/* Structure to contain information about address of a service provider.  */
+struct addrinfo
+{
+  int ai_flags;			/* Input flags.  */
+  int ai_family;		/* Protocol family for socket.  */
+  int ai_socktype;		/* Socket type.  */
+  int ai_protocol;		/* Protocol for socket.  */
+  socklen_t ai_addrlen;		/* Length of socket address.  */
+  struct sockaddr *ai_addr;	/* Socket address for socket.  */
+  char *ai_canonname;		/* Canonical name for service location.  */
+  struct addrinfo *ai_next;	/* Pointer to next in list.  */
+};
+
+# ifdef __USE_GNU
+/* Structure used as control block for asynchronous lookup.  */
+struct gaicb
+{
+  const char *ar_name;		/* Name to look up.  */
+  const char *ar_service;	/* Service name.  */
+  const struct addrinfo *ar_request; /* Additional request specification.  */
+  struct addrinfo *ar_result;	/* Pointer to result.  */
+  /* The following are internal elements.  */
+  int __return;
+  int __glibc_reserved[5];
+};
+
+/* Lookup mode.  */
+#  define GAI_WAIT	0
+#  define GAI_NOWAIT	1
+# endif
+
+/* Possible values for `ai_flags' field in `addrinfo' structure.  */
+# define AI_PASSIVE	0x0001	/* Socket address is intended for `bind'.  */
+# define AI_CANONNAME	0x0002	/* Request for canonical name.  */
+# define AI_NUMERICHOST	0x0004	/* Don't use name resolution.  */
+# define AI_V4MAPPED	0x0008	/* IPv4 mapped addresses are acceptable.  */
+# define AI_ALL		0x0010	/* Return IPv4 mapped and IPv6 addresses.  */
+# define AI_ADDRCONFIG	0x0020	/* Use configuration of this host to choose
+				   returned address type..  */
+# ifdef __USE_GNU
+#  define AI_IDN	0x0040	/* IDN encode input (assuming it is encoded
+				   in the current locale's character set)
+				   before looking it up. */
+#  define AI_CANONIDN	0x0080	/* Translate canonical name from IDN format. */
+#  define AI_IDN_ALLOW_UNASSIGNED 0x0100 /* Don't reject unassigned Unicode
+					    code points.  */
+#  define AI_IDN_USE_STD3_ASCII_RULES 0x0200 /* Validate strings according to
+						STD3 rules.  */
+# endif
+# define AI_NUMERICSERV	0x0400	/* Don't use name resolution.  */
+
+/* Error values for `getaddrinfo' function.  */
+# define EAI_BADFLAGS	  -1	/* Invalid value for `ai_flags' field.  */
+# define EAI_NONAME	  -2	/* NAME or SERVICE is unknown.  */
+# define EAI_AGAIN	  -3	/* Temporary failure in name resolution.  */
+# define EAI_FAIL	  -4	/* Non-recoverable failure in name res.  */
+# define EAI_FAMILY	  -6	/* `ai_family' not supported.  */
+# define EAI_SOCKTYPE	  -7	/* `ai_socktype' not supported.  */
+# define EAI_SERVICE	  -8	/* SERVICE not supported for `ai_socktype'.  */
+# define EAI_MEMORY	  -10	/* Memory allocation failure.  */
+# define EAI_SYSTEM	  -11	/* System error returned in `errno'.  */
+# define EAI_OVERFLOW	  -12	/* Argument buffer overflow.  */
+# ifdef __USE_GNU
+#  define EAI_NODATA	  -5	/* No address associated with NAME.  */
+#  define EAI_ADDRFAMILY  -9	/* Address family for NAME not supported.  */
+#  define EAI_INPROGRESS  -100	/* Processing request in progress.  */
+#  define EAI_CANCELED	  -101	/* Request canceled.  */
+#  define EAI_NOTCANCELED -102	/* Request not canceled.  */
+#  define EAI_ALLDONE	  -103	/* All requests done.  */
+#  define EAI_INTR	  -104	/* Interrupted by a signal.  */
+#  define EAI_IDN_ENCODE  -105	/* IDN encoding failed.  */
+# endif
+
+# ifdef __USE_MISC
+#  define NI_MAXHOST      1025
+#  define NI_MAXSERV      32
+# endif
+
+# define NI_NUMERICHOST	1	/* Don't try to look up hostname.  */
+# define NI_NUMERICSERV 2	/* Don't convert port number to name.  */
+# define NI_NOFQDN	4	/* Only return nodename portion.  */
+# define NI_NAMEREQD	8	/* Don't return numeric addresses.  */
+# define NI_DGRAM	16	/* Look up UDP service rather than TCP.  */
+# ifdef __USE_GNU
+#  define NI_IDN	32	/* Convert name from IDN format.  */
+#  define NI_IDN_ALLOW_UNASSIGNED 64 /* Don't reject unassigned Unicode
+					code points.  */
+#  define NI_IDN_USE_STD3_ASCII_RULES 128 /* Validate strings according to
+					     STD3 rules.  */
+# endif
+
+/* Translate name of a service location and/or a service name to set of
+   socket addresses.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int getaddrinfo (const char *__restrict __name,
+			const char *__restrict __service,
+			const struct addrinfo *__restrict __req,
+			struct addrinfo **__restrict __pai);
+
+/* Free `addrinfo' structure AI including associated storage.  */
+extern void freeaddrinfo (struct addrinfo *__ai) __THROW;
+
+/* Convert error return from getaddrinfo() to a string.  */
+extern const char *gai_strerror (int __ecode) __THROW;
+
+/* Translate a socket address to a location and service name.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int getnameinfo (const struct sockaddr *__restrict __sa,
+			socklen_t __salen, char *__restrict __host,
+			socklen_t __hostlen, char *__restrict __serv,
+			socklen_t __servlen, int __flags);
+#endif	/* POSIX */
+
+#ifdef __USE_GNU
+/* Enqueue ENT requests from the LIST.  If MODE is GAI_WAIT wait until all
+   requests are handled.  If WAIT is GAI_NOWAIT return immediately after
+   queueing the requests and signal completion according to SIG.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int getaddrinfo_a (int __mode, struct gaicb *__list[__restrict_arr],
+			  int __ent, struct sigevent *__restrict __sig);
+
+/* Suspend execution of the thread until at least one of the ENT requests
+   in LIST is handled.  If TIMEOUT is not a null pointer it specifies the
+   longest time the function keeps waiting before returning with an error.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int gai_suspend (const struct gaicb *const __list[], int __ent,
+			const struct timespec *__timeout);
+
+/* Get the error status of the request REQ.  */
+extern int gai_error (struct gaicb *__req) __THROW;
+
+/* Cancel the requests associated with GAICBP.  */
+extern int gai_cancel (struct gaicb *__gaicbp) __THROW;
+#endif	/* GNU */
+
+__END_DECLS
+
+#endif	/* netdb.h */
diff --git a/include/netinet/ether.h b/include/netinet/ether.h
new file mode 100644
index 0000000..4d78f76
--- /dev/null
+++ b/include/netinet/ether.h
@@ -0,0 +1,53 @@
+/* Functions for storing Ethernet addresses in ASCII and mapping to hostnames.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NETINET_ETHER_H
+#define _NETINET_ETHER_H	1
+
+#include <features.h>
+
+/* Get definition of `struct ether_addr'.  */
+#include <netinet/if_ether.h>
+
+__BEGIN_DECLS
+
+/* Convert 48 bit Ethernet ADDRess to ASCII.  */
+extern char *ether_ntoa (const struct ether_addr *__addr) __THROW;
+extern char *ether_ntoa_r (const struct ether_addr *__addr, char *__buf)
+     __THROW;
+
+/* Convert ASCII string S to 48 bit Ethernet address.  */
+extern struct ether_addr *ether_aton (const char *__asc) __THROW;
+extern struct ether_addr *ether_aton_r (const char *__asc,
+					struct ether_addr *__addr) __THROW;
+
+/* Map 48 bit Ethernet number ADDR to HOSTNAME.  */
+extern int ether_ntohost (char *__hostname, const struct ether_addr *__addr)
+     __THROW;
+
+/* Map HOSTNAME to 48 bit Ethernet address.  */
+extern int ether_hostton (const char *__hostname, struct ether_addr *__addr)
+     __THROW;
+
+/* Scan LINE and set ADDR and HOSTNAME.  */
+extern int ether_line (const char *__line, struct ether_addr *__addr,
+		       char *__hostname) __THROW;
+
+__END_DECLS
+
+#endif /* netinet/ether.h */
diff --git a/include/netinet/icmp6.h b/include/netinet/icmp6.h
new file mode 100644
index 0000000..baaeb26
--- /dev/null
+++ b/include/netinet/icmp6.h
@@ -0,0 +1,345 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NETINET_ICMP6_H
+#define _NETINET_ICMP6_H 1
+
+#include <inttypes.h>
+#include <string.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+
+#define ICMP6_FILTER 1
+
+#define ICMP6_FILTER_BLOCK		1
+#define ICMP6_FILTER_PASS		2
+#define ICMP6_FILTER_BLOCKOTHERS	3
+#define ICMP6_FILTER_PASSONLY		4
+
+struct icmp6_filter
+  {
+    uint32_t icmp6_filt[8];
+  };
+
+struct icmp6_hdr
+  {
+    uint8_t     icmp6_type;   /* type field */
+    uint8_t     icmp6_code;   /* code field */
+    uint16_t    icmp6_cksum;  /* checksum field */
+    union
+      {
+	uint32_t  icmp6_un_data32[1]; /* type-specific field */
+	uint16_t  icmp6_un_data16[2]; /* type-specific field */
+	uint8_t   icmp6_un_data8[4];  /* type-specific field */
+      } icmp6_dataun;
+  };
+
+#define icmp6_data32    icmp6_dataun.icmp6_un_data32
+#define icmp6_data16    icmp6_dataun.icmp6_un_data16
+#define icmp6_data8     icmp6_dataun.icmp6_un_data8
+#define icmp6_pptr      icmp6_data32[0]  /* parameter prob */
+#define icmp6_mtu       icmp6_data32[0]  /* packet too big */
+#define icmp6_id        icmp6_data16[0]  /* echo request/reply */
+#define icmp6_seq       icmp6_data16[1]  /* echo request/reply */
+#define icmp6_maxdelay  icmp6_data16[0]  /* mcast group membership */
+
+#define ICMP6_DST_UNREACH             1
+#define ICMP6_PACKET_TOO_BIG          2
+#define ICMP6_TIME_EXCEEDED           3
+#define ICMP6_PARAM_PROB              4
+
+#define ICMP6_INFOMSG_MASK  0x80    /* all informational messages */
+
+#define ICMP6_ECHO_REQUEST          128
+#define ICMP6_ECHO_REPLY            129
+#define MLD_LISTENER_QUERY          130
+#define MLD_LISTENER_REPORT         131
+#define MLD_LISTENER_REDUCTION      132
+
+#define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to destination */
+#define ICMP6_DST_UNREACH_ADMIN       1 /* communication with destination */
+                                        /* administratively prohibited */
+#define ICMP6_DST_UNREACH_BEYONDSCOPE 2 /* beyond scope of source address */
+#define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */
+#define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */
+
+#define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in transit */
+#define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */
+
+#define ICMP6_PARAMPROB_HEADER        0 /* erroneous header field */
+#define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized Next Header */
+#define ICMP6_PARAMPROB_OPTION        2 /* unrecognized IPv6 option */
+
+#define ICMP6_FILTER_WILLPASS(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) == 0)
+
+#define ICMP6_FILTER_WILLBLOCK(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) != 0)
+
+#define ICMP6_FILTER_SETPASS(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) &= ~(1 << ((type) & 31))))
+
+#define ICMP6_FILTER_SETBLOCK(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) |=  (1 << ((type) & 31))))
+
+#define ICMP6_FILTER_SETPASSALL(filterp) \
+	memset (filterp, 0, sizeof (struct icmp6_filter));
+
+#define ICMP6_FILTER_SETBLOCKALL(filterp) \
+	memset (filterp, 0xFF, sizeof (struct icmp6_filter));
+
+#define ND_ROUTER_SOLICIT           133
+#define ND_ROUTER_ADVERT            134
+#define ND_NEIGHBOR_SOLICIT         135
+#define ND_NEIGHBOR_ADVERT          136
+#define ND_REDIRECT                 137
+
+struct nd_router_solicit      /* router solicitation */
+  {
+    struct icmp6_hdr  nd_rs_hdr;
+    /* could be followed by options */
+  };
+
+#define nd_rs_type               nd_rs_hdr.icmp6_type
+#define nd_rs_code               nd_rs_hdr.icmp6_code
+#define nd_rs_cksum              nd_rs_hdr.icmp6_cksum
+#define nd_rs_reserved           nd_rs_hdr.icmp6_data32[0]
+
+struct nd_router_advert       /* router advertisement */
+  {
+    struct icmp6_hdr  nd_ra_hdr;
+    uint32_t   nd_ra_reachable;   /* reachable time */
+    uint32_t   nd_ra_retransmit;  /* retransmit timer */
+    /* could be followed by options */
+  };
+
+#define nd_ra_type               nd_ra_hdr.icmp6_type
+#define nd_ra_code               nd_ra_hdr.icmp6_code
+#define nd_ra_cksum              nd_ra_hdr.icmp6_cksum
+#define nd_ra_curhoplimit        nd_ra_hdr.icmp6_data8[0]
+#define nd_ra_flags_reserved     nd_ra_hdr.icmp6_data8[1]
+#define ND_RA_FLAG_MANAGED       0x80
+#define ND_RA_FLAG_OTHER         0x40
+#define ND_RA_FLAG_HOME_AGENT    0x20
+#define nd_ra_router_lifetime    nd_ra_hdr.icmp6_data16[1]
+
+struct nd_neighbor_solicit    /* neighbor solicitation */
+  {
+    struct icmp6_hdr  nd_ns_hdr;
+    struct in6_addr   nd_ns_target; /* target address */
+    /* could be followed by options */
+  };
+
+#define nd_ns_type               nd_ns_hdr.icmp6_type
+#define nd_ns_code               nd_ns_hdr.icmp6_code
+#define nd_ns_cksum              nd_ns_hdr.icmp6_cksum
+#define nd_ns_reserved           nd_ns_hdr.icmp6_data32[0]
+
+struct nd_neighbor_advert     /* neighbor advertisement */
+  {
+    struct icmp6_hdr  nd_na_hdr;
+    struct in6_addr   nd_na_target; /* target address */
+    /* could be followed by options */
+  };
+
+#define nd_na_type               nd_na_hdr.icmp6_type
+#define nd_na_code               nd_na_hdr.icmp6_code
+#define nd_na_cksum              nd_na_hdr.icmp6_cksum
+#define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]
+#if     BYTE_ORDER == BIG_ENDIAN
+#define ND_NA_FLAG_ROUTER        0x80000000
+#define ND_NA_FLAG_SOLICITED     0x40000000
+#define ND_NA_FLAG_OVERRIDE      0x20000000
+#else   /* BYTE_ORDER == LITTLE_ENDIAN */
+#define ND_NA_FLAG_ROUTER        0x00000080
+#define ND_NA_FLAG_SOLICITED     0x00000040
+#define ND_NA_FLAG_OVERRIDE      0x00000020
+#endif
+
+struct nd_redirect            /* redirect */
+  {
+    struct icmp6_hdr  nd_rd_hdr;
+    struct in6_addr   nd_rd_target; /* target address */
+    struct in6_addr   nd_rd_dst;    /* destination address */
+    /* could be followed by options */
+  };
+
+#define nd_rd_type               nd_rd_hdr.icmp6_type
+#define nd_rd_code               nd_rd_hdr.icmp6_code
+#define nd_rd_cksum              nd_rd_hdr.icmp6_cksum
+#define nd_rd_reserved           nd_rd_hdr.icmp6_data32[0]
+
+struct nd_opt_hdr             /* Neighbor discovery option header */
+  {
+    uint8_t  nd_opt_type;
+    uint8_t  nd_opt_len;        /* in units of 8 octets */
+    /* followed by option specific data */
+  };
+
+#define ND_OPT_SOURCE_LINKADDR		1
+#define ND_OPT_TARGET_LINKADDR		2
+#define ND_OPT_PREFIX_INFORMATION	3
+#define ND_OPT_REDIRECTED_HEADER	4
+#define ND_OPT_MTU			5
+#define ND_OPT_RTR_ADV_INTERVAL		7
+#define ND_OPT_HOME_AGENT_INFO		8
+
+struct nd_opt_prefix_info     /* prefix information */
+  {
+    uint8_t   nd_opt_pi_type;
+    uint8_t   nd_opt_pi_len;
+    uint8_t   nd_opt_pi_prefix_len;
+    uint8_t   nd_opt_pi_flags_reserved;
+    uint32_t  nd_opt_pi_valid_time;
+    uint32_t  nd_opt_pi_preferred_time;
+    uint32_t  nd_opt_pi_reserved2;
+    struct in6_addr  nd_opt_pi_prefix;
+  };
+
+#define ND_OPT_PI_FLAG_ONLINK	0x80
+#define ND_OPT_PI_FLAG_AUTO	0x40
+#define ND_OPT_PI_FLAG_RADDR	0x20
+
+struct nd_opt_rd_hdr          /* redirected header */
+  {
+    uint8_t   nd_opt_rh_type;
+    uint8_t   nd_opt_rh_len;
+    uint16_t  nd_opt_rh_reserved1;
+    uint32_t  nd_opt_rh_reserved2;
+    /* followed by IP header and data */
+  };
+
+struct nd_opt_mtu             /* MTU option */
+  {
+    uint8_t   nd_opt_mtu_type;
+    uint8_t   nd_opt_mtu_len;
+    uint16_t  nd_opt_mtu_reserved;
+    uint32_t  nd_opt_mtu_mtu;
+  };
+
+struct mld_hdr
+  {
+    struct icmp6_hdr    mld_icmp6_hdr;
+    struct in6_addr     mld_addr; /* multicast address */
+  };
+
+#define mld_type        mld_icmp6_hdr.icmp6_type
+#define mld_code        mld_icmp6_hdr.icmp6_code
+#define mld_cksum       mld_icmp6_hdr.icmp6_cksum
+#define mld_maxdelay    mld_icmp6_hdr.icmp6_data16[0]
+#define mld_reserved    mld_icmp6_hdr.icmp6_data16[1]
+
+#define ICMP6_ROUTER_RENUMBERING    138
+
+struct icmp6_router_renum    /* router renumbering header */
+  {
+    struct icmp6_hdr    rr_hdr;
+    uint8_t             rr_segnum;
+    uint8_t             rr_flags;
+    uint16_t            rr_maxdelay;
+    uint32_t            rr_reserved;
+  };
+
+#define rr_type		rr_hdr.icmp6_type
+#define rr_code         rr_hdr.icmp6_code
+#define rr_cksum        rr_hdr.icmp6_cksum
+#define rr_seqnum       rr_hdr.icmp6_data32[0]
+
+/* Router renumbering flags */
+#define ICMP6_RR_FLAGS_TEST             0x80
+#define ICMP6_RR_FLAGS_REQRESULT        0x40
+#define ICMP6_RR_FLAGS_FORCEAPPLY       0x20
+#define ICMP6_RR_FLAGS_SPECSITE         0x10
+#define ICMP6_RR_FLAGS_PREVDONE         0x08
+
+struct rr_pco_match    /* match prefix part */
+  {
+    uint8_t             rpm_code;
+    uint8_t             rpm_len;
+    uint8_t             rpm_ordinal;
+    uint8_t             rpm_matchlen;
+    uint8_t             rpm_minlen;
+    uint8_t             rpm_maxlen;
+    uint16_t            rpm_reserved;
+    struct in6_addr     rpm_prefix;
+  };
+
+/* PCO code values */
+#define RPM_PCO_ADD             1
+#define RPM_PCO_CHANGE          2
+#define RPM_PCO_SETGLOBAL       3
+
+struct rr_pco_use      /* use prefix part */
+  {
+    uint8_t             rpu_uselen;
+    uint8_t             rpu_keeplen;
+    uint8_t             rpu_ramask;
+    uint8_t             rpu_raflags;
+    uint32_t            rpu_vltime;
+    uint32_t            rpu_pltime;
+    uint32_t            rpu_flags;
+    struct in6_addr     rpu_prefix;
+  };
+
+#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK  0x20
+#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO    0x10
+
+#if BYTE_ORDER == BIG_ENDIAN
+# define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80000000
+# define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40000000
+#elif BYTE_ORDER == LITTLE_ENDIAN
+# define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80
+# define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40
+#endif
+
+struct rr_result       /* router renumbering result message */
+  {
+    uint16_t            rrr_flags;
+    uint8_t             rrr_ordinal;
+    uint8_t             rrr_matchedlen;
+    uint32_t            rrr_ifid;
+    struct in6_addr     rrr_prefix;
+  };
+
+#if BYTE_ORDER == BIG_ENDIAN
+# define ICMP6_RR_RESULT_FLAGS_OOB       0x0002
+# define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0001
+#elif BYTE_ORDER == LITTLE_ENDIAN
+# define ICMP6_RR_RESULT_FLAGS_OOB       0x0200
+# define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0100
+#endif
+
+/* Mobile IPv6 extension: Advertisement Interval.  */
+struct nd_opt_adv_interval
+  {
+    uint8_t   nd_opt_adv_interval_type;
+    uint8_t   nd_opt_adv_interval_len;
+    uint16_t  nd_opt_adv_interval_reserved;
+    uint32_t  nd_opt_adv_interval_ival;
+  };
+
+/* Mobile IPv6 extension: Home Agent Info.  */
+struct nd_opt_home_agent_info
+  {
+    uint8_t   nd_opt_home_agent_info_type;
+    uint8_t   nd_opt_home_agent_info_len;
+    uint16_t  nd_opt_home_agent_info_reserved;
+    uint16_t  nd_opt_home_agent_info_preference;
+    uint16_t  nd_opt_home_agent_info_lifetime;
+  };
+
+#endif /* netinet/icmpv6.h */
diff --git a/include/netinet/if_ether.h b/include/netinet/if_ether.h
new file mode 100644
index 0000000..a52883e
--- /dev/null
+++ b/include/netinet/if_ether.h
@@ -0,0 +1,32 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef __NETINET_IF_ETHER_H
+
+#define __NETINET_IF_ETHER_H	1
+#include <features.h>
+
+#include <sys/types.h>
+
+/* This is a name for the 48 bit ethernet address available on many
+   systems.  */
+struct ether_addr
+{
+  u_int8_t ether_addr_octet[6];
+} __attribute__ ((__packed__));
+
+#endif /* netinet/if_ether.h */
diff --git a/include/netinet/igmp.h b/include/netinet/igmp.h
new file mode 100644
index 0000000..c12552c
--- /dev/null
+++ b/include/netinet/igmp.h
@@ -0,0 +1,125 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NETINET_IGMP_H
+#define	_NETINET_IGMP_H 1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#ifdef __USE_BSD
+
+#include <netinet/in.h>
+
+__BEGIN_DECLS
+
+/*
+ * Copyright (c) 1988 Stephen Deering.
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Stephen Deering of Stanford University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)igmp.h	8.1 (Berkeley) 6/10/93
+ *	$FreeBSD$
+ */
+
+struct igmp {
+  u_int8_t igmp_type;             /* IGMP type */
+  u_int8_t igmp_code;             /* routing code */
+  u_int16_t igmp_cksum;           /* checksum */
+  struct in_addr igmp_group;      /* group address */
+};
+
+#define IGMP_MINLEN			8
+
+/*
+ * Message types, including version number.
+ */
+#define IGMP_MEMBERSHIP_QUERY   	0x11	/* membership query         */
+#define IGMP_V1_MEMBERSHIP_REPORT	0x12	/* Ver. 1 membership report */
+#define IGMP_V2_MEMBERSHIP_REPORT	0x16	/* Ver. 2 membership report */
+#define IGMP_V2_LEAVE_GROUP		0x17	/* Leave-group message	    */
+
+#define IGMP_DVMRP			0x13	/* DVMRP routing message    */
+#define IGMP_PIM			0x14	/* PIM routing message      */
+#define IGMP_TRACE			0x15
+
+#define IGMP_MTRACE_RESP		0x1e	/* traceroute resp.(to sender)*/
+#define IGMP_MTRACE			0x1f	/* mcast traceroute messages  */
+
+#define IGMP_MAX_HOST_REPORT_DELAY	10	/* max delay for response to     */
+						/*  query (in seconds) according */
+						/*  to RFC1112                   */
+#define IGMP_TIMER_SCALE		10	/* denotes that the igmp code field */
+						/* specifies time in 10th of seconds*/
+
+/*
+ * States for the IGMP v2 state table.
+ */
+#define IGMP_DELAYING_MEMBER	1
+#define IGMP_IDLE_MEMBER	2
+#define IGMP_LAZY_MEMBER	3
+#define IGMP_SLEEPING_MEMBER	4
+#define IGMP_AWAKENING_MEMBER	5
+
+/*
+ * States for IGMP router version cache.
+ */
+#define IGMP_v1_ROUTER		1
+#define IGMP_v2_ROUTER		2
+
+/*
+ * The following four defininitions are for backwards compatibility.
+ * They should be removed as soon as all applications are updated to
+ * use the new constant names.
+ */
+#define IGMP_HOST_MEMBERSHIP_QUERY	IGMP_MEMBERSHIP_QUERY
+#define IGMP_HOST_MEMBERSHIP_REPORT	IGMP_V1_MEMBERSHIP_REPORT
+#define IGMP_HOST_NEW_MEMBERSHIP_REPORT	IGMP_V2_MEMBERSHIP_REPORT
+#define IGMP_HOST_LEAVE_MESSAGE		IGMP_V2_LEAVE_GROUP
+
+__END_DECLS
+
+#endif
+
+#endif	/* netinet/igmp.h */
diff --git a/include/netinet/in.h b/include/netinet/in.h
new file mode 100644
index 0000000..d8d8e53
--- /dev/null
+++ b/include/netinet/in.h
@@ -0,0 +1,630 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_NETINET_IN_H
+#define	_NETINET_IN_H	1
+
+#include <features.h>
+#include <stdint.h>
+#include <sys/socket.h>
+#include <bits/types.h>
+
+
+__BEGIN_DECLS
+
+/* Internet address.  */
+typedef uint32_t in_addr_t;
+struct in_addr
+  {
+    in_addr_t s_addr;
+  };
+
+/* Get system-specific definitions.  */
+#include <bits/in.h>
+
+/* Standard well-defined IP protocols.  */
+enum
+  {
+    IPPROTO_IP = 0,	   /* Dummy protocol for TCP.  */
+#define IPPROTO_IP		IPPROTO_IP
+    IPPROTO_ICMP = 1,	   /* Internet Control Message Protocol.  */
+#define IPPROTO_ICMP		IPPROTO_ICMP
+    IPPROTO_IGMP = 2,	   /* Internet Group Management Protocol. */
+#define IPPROTO_IGMP		IPPROTO_IGMP
+    IPPROTO_IPIP = 4,	   /* IPIP tunnels (older KA9Q tunnels use 94).  */
+#define IPPROTO_IPIP		IPPROTO_IPIP
+    IPPROTO_TCP = 6,	   /* Transmission Control Protocol.  */
+#define IPPROTO_TCP		IPPROTO_TCP
+    IPPROTO_EGP = 8,	   /* Exterior Gateway Protocol.  */
+#define IPPROTO_EGP		IPPROTO_EGP
+    IPPROTO_PUP = 12,	   /* PUP protocol.  */
+#define IPPROTO_PUP		IPPROTO_PUP
+    IPPROTO_UDP = 17,	   /* User Datagram Protocol.  */
+#define IPPROTO_UDP		IPPROTO_UDP
+    IPPROTO_IDP = 22,	   /* XNS IDP protocol.  */
+#define IPPROTO_IDP		IPPROTO_IDP
+    IPPROTO_TP = 29,	   /* SO Transport Protocol Class 4.  */
+#define IPPROTO_TP		IPPROTO_TP
+    IPPROTO_DCCP = 33,	   /* Datagram Congestion Control Protocol.  */
+#define IPPROTO_DCCP		IPPROTO_DCCP
+    IPPROTO_IPV6 = 41,     /* IPv6 header.  */
+#define IPPROTO_IPV6		IPPROTO_IPV6
+    IPPROTO_RSVP = 46,	   /* Reservation Protocol.  */
+#define IPPROTO_RSVP		IPPROTO_RSVP
+    IPPROTO_GRE = 47,	   /* General Routing Encapsulation.  */
+#define IPPROTO_GRE		IPPROTO_GRE
+    IPPROTO_ESP = 50,      /* encapsulating security payload.  */
+#define IPPROTO_ESP		IPPROTO_ESP
+    IPPROTO_AH = 51,       /* authentication header.  */
+#define IPPROTO_AH		IPPROTO_AH
+    IPPROTO_MTP = 92,	   /* Multicast Transport Protocol.  */
+#define IPPROTO_MTP		IPPROTO_MTP
+    IPPROTO_BEETPH = 94,   /* IP option pseudo header for BEET.  */
+#define IPPROTO_BEETPH		IPPROTO_BEETPH
+    IPPROTO_ENCAP = 98,	   /* Encapsulation Header.  */
+#define IPPROTO_ENCAP		IPPROTO_ENCAP
+    IPPROTO_PIM = 103,	   /* Protocol Independent Multicast.  */
+#define IPPROTO_PIM		IPPROTO_PIM
+    IPPROTO_COMP = 108,	   /* Compression Header Protocol.  */
+#define IPPROTO_COMP		IPPROTO_COMP
+    IPPROTO_SCTP = 132,	   /* Stream Control Transmission Protocol.  */
+#define IPPROTO_SCTP		IPPROTO_SCTP
+    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */
+#define IPPROTO_UDPLITE		IPPROTO_UDPLITE
+    IPPROTO_RAW = 255,	   /* Raw IP packets.  */
+#define IPPROTO_RAW		IPPROTO_RAW
+    IPPROTO_MAX
+  };
+
+/* If __USE_KERNEL_IPV6_DEFS is defined then the user has included the kernel
+   network headers first and we should use those ABI-identical definitions
+   instead of our own.  */
+#ifndef __USE_KERNEL_IPV6_DEFS
+enum
+  {
+    IPPROTO_HOPOPTS = 0,   /* IPv6 Hop-by-Hop options.  */
+#define IPPROTO_HOPOPTS		IPPROTO_HOPOPTS
+    IPPROTO_ROUTING = 43,  /* IPv6 routing header.  */
+#define IPPROTO_ROUTING		IPPROTO_ROUTING
+    IPPROTO_FRAGMENT = 44, /* IPv6 fragmentation header.  */
+#define IPPROTO_FRAGMENT	IPPROTO_FRAGMENT
+    IPPROTO_ICMPV6 = 58,   /* ICMPv6.  */
+#define IPPROTO_ICMPV6		IPPROTO_ICMPV6
+    IPPROTO_NONE = 59,     /* IPv6 no next header.  */
+#define IPPROTO_NONE		IPPROTO_NONE
+    IPPROTO_DSTOPTS = 60,  /* IPv6 destination options.  */
+#define IPPROTO_DSTOPTS		IPPROTO_DSTOPTS
+    IPPROTO_MH = 135       /* IPv6 mobility header.  */
+#define IPPROTO_MH		IPPROTO_MH
+  };
+#endif /* !__USE_KERNEL_IPV6_DEFS */
+
+/* Type to represent a port.  */
+typedef uint16_t in_port_t;
+
+/* Standard well-known ports.  */
+enum
+  {
+    IPPORT_ECHO = 7,		/* Echo service.  */
+    IPPORT_DISCARD = 9,		/* Discard transmissions service.  */
+    IPPORT_SYSTAT = 11,		/* System status service.  */
+    IPPORT_DAYTIME = 13,	/* Time of day service.  */
+    IPPORT_NETSTAT = 15,	/* Network status service.  */
+    IPPORT_FTP = 21,		/* File Transfer Protocol.  */
+    IPPORT_TELNET = 23,		/* Telnet protocol.  */
+    IPPORT_SMTP = 25,		/* Simple Mail Transfer Protocol.  */
+    IPPORT_TIMESERVER = 37,	/* Timeserver service.  */
+    IPPORT_NAMESERVER = 42,	/* Domain Name Service.  */
+    IPPORT_WHOIS = 43,		/* Internet Whois service.  */
+    IPPORT_MTP = 57,
+
+    IPPORT_TFTP = 69,		/* Trivial File Transfer Protocol.  */
+    IPPORT_RJE = 77,
+    IPPORT_FINGER = 79,		/* Finger service.  */
+    IPPORT_TTYLINK = 87,
+    IPPORT_SUPDUP = 95,		/* SUPDUP protocol.  */
+
+
+    IPPORT_EXECSERVER = 512,	/* execd service.  */
+    IPPORT_LOGINSERVER = 513,	/* rlogind service.  */
+    IPPORT_CMDSERVER = 514,
+    IPPORT_EFSSERVER = 520,
+
+    /* UDP ports.  */
+    IPPORT_BIFFUDP = 512,
+    IPPORT_WHOSERVER = 513,
+    IPPORT_ROUTESERVER = 520,
+
+    /* Ports less than this value are reserved for privileged processes.  */
+    IPPORT_RESERVED = 1024,
+
+    /* Ports greater this value are reserved for (non-privileged) servers.  */
+    IPPORT_USERRESERVED = 5000
+  };
+
+/* Definitions of the bits in an Internet address integer.
+
+   On subnets, host and network parts are found according to
+   the subnet mask, not these masks.  */
+
+#define	IN_CLASSA(a)		((((in_addr_t)(a)) & 0x80000000) == 0)
+#define	IN_CLASSA_NET		0xff000000
+#define	IN_CLASSA_NSHIFT	24
+#define	IN_CLASSA_HOST		(0xffffffff & ~IN_CLASSA_NET)
+#define	IN_CLASSA_MAX		128
+
+#define	IN_CLASSB(a)		((((in_addr_t)(a)) & 0xc0000000) == 0x80000000)
+#define	IN_CLASSB_NET		0xffff0000
+#define	IN_CLASSB_NSHIFT	16
+#define	IN_CLASSB_HOST		(0xffffffff & ~IN_CLASSB_NET)
+#define	IN_CLASSB_MAX		65536
+
+#define	IN_CLASSC(a)		((((in_addr_t)(a)) & 0xe0000000) == 0xc0000000)
+#define	IN_CLASSC_NET		0xffffff00
+#define	IN_CLASSC_NSHIFT	8
+#define	IN_CLASSC_HOST		(0xffffffff & ~IN_CLASSC_NET)
+
+#define	IN_CLASSD(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xe0000000)
+#define	IN_MULTICAST(a)		IN_CLASSD(a)
+
+#define	IN_EXPERIMENTAL(a)	((((in_addr_t)(a)) & 0xe0000000) == 0xe0000000)
+#define	IN_BADCLASS(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xf0000000)
+
+/* Address to accept any incoming messages.  */
+#define	INADDR_ANY		((in_addr_t) 0x00000000)
+/* Address to send to all hosts.  */
+#define	INADDR_BROADCAST	((in_addr_t) 0xffffffff)
+/* Address indicating an error return.  */
+#define	INADDR_NONE		((in_addr_t) 0xffffffff)
+
+/* Network number for local host loopback.  */
+#define	IN_LOOPBACKNET		127
+/* Address to loopback in software to local host.  */
+#ifndef INADDR_LOOPBACK
+# define INADDR_LOOPBACK	((in_addr_t) 0x7f000001) /* Inet 127.0.0.1.  */
+#endif
+
+/* Defines for Multicast INADDR.  */
+#define INADDR_UNSPEC_GROUP	((in_addr_t) 0xe0000000) /* 224.0.0.0 */
+#define INADDR_ALLHOSTS_GROUP	((in_addr_t) 0xe0000001) /* 224.0.0.1 */
+#define INADDR_ALLRTRS_GROUP    ((in_addr_t) 0xe0000002) /* 224.0.0.2 */
+#define INADDR_MAX_LOCAL_GROUP  ((in_addr_t) 0xe00000ff) /* 224.0.0.255 */
+
+#ifndef __USE_KERNEL_IPV6_DEFS
+/* IPv6 address */
+struct in6_addr
+  {
+    union
+      {
+	uint8_t	__u6_addr8[16];
+#if defined __USE_MISC || defined __USE_GNU
+	uint16_t __u6_addr16[8];
+	uint32_t __u6_addr32[4];
+#endif
+      } __in6_u;
+#define s6_addr			__in6_u.__u6_addr8
+#if defined __USE_MISC || defined __USE_GNU
+# define s6_addr16		__in6_u.__u6_addr16
+# define s6_addr32		__in6_u.__u6_addr32
+#endif
+  };
+#endif /* !__USE_KERNEL_IPV6_DEFS */
+
+extern const struct in6_addr in6addr_any;        /* :: */
+extern const struct in6_addr in6addr_loopback;   /* ::1 */
+#define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
+#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }
+
+#define INET_ADDRSTRLEN 16
+#define INET6_ADDRSTRLEN 46
+
+
+/* Structure describing an Internet socket address.  */
+struct sockaddr_in
+  {
+    __SOCKADDR_COMMON (sin_);
+    in_port_t sin_port;			/* Port number.  */
+    struct in_addr sin_addr;		/* Internet address.  */
+
+    /* Pad to size of `struct sockaddr'.  */
+    unsigned char sin_zero[sizeof (struct sockaddr) -
+			   __SOCKADDR_COMMON_SIZE -
+			   sizeof (in_port_t) -
+			   sizeof (struct in_addr)];
+  };
+
+#ifndef __USE_KERNEL_IPV6_DEFS
+/* Ditto, for IPv6.  */
+struct sockaddr_in6
+  {
+    __SOCKADDR_COMMON (sin6_);
+    in_port_t sin6_port;	/* Transport layer port # */
+    uint32_t sin6_flowinfo;	/* IPv6 flow information */
+    struct in6_addr sin6_addr;	/* IPv6 address */
+    uint32_t sin6_scope_id;	/* IPv6 scope-id */
+  };
+#endif /* !__USE_KERNEL_IPV6_DEFS */
+
+#if defined __USE_MISC || defined __USE_GNU
+/* IPv4 multicast request.  */
+struct ip_mreq
+  {
+    /* IP multicast address of group.  */
+    struct in_addr imr_multiaddr;
+
+    /* Local IP address of interface.  */
+    struct in_addr imr_interface;
+  };
+
+struct ip_mreq_source
+  {
+    /* IP multicast address of group.  */
+    struct in_addr imr_multiaddr;
+
+    /* IP address of source.  */
+    struct in_addr imr_interface;
+
+    /* IP address of interface.  */
+    struct in_addr imr_sourceaddr;
+  };
+#endif
+
+#ifndef __USE_KERNEL_IPV6_DEFS
+/* Likewise, for IPv6.  */
+struct ipv6_mreq
+  {
+    /* IPv6 multicast address of group */
+    struct in6_addr ipv6mr_multiaddr;
+
+    /* local interface */
+    unsigned int ipv6mr_interface;
+  };
+#endif /* !__USE_KERNEL_IPV6_DEFS */
+
+#if defined __USE_MISC || defined __USE_GNU
+/* Multicast group request.  */
+struct group_req
+  {
+    /* Interface index.  */
+    uint32_t gr_interface;
+
+    /* Group address.  */
+    struct sockaddr_storage gr_group;
+  };
+
+struct group_source_req
+  {
+    /* Interface index.  */
+    uint32_t gsr_interface;
+
+    /* Group address.  */
+    struct sockaddr_storage gsr_group;
+
+    /* Source address.  */
+    struct sockaddr_storage gsr_source;
+  };
+
+
+/* Full-state filter operations.  */
+struct ip_msfilter
+  {
+    /* IP multicast address of group.  */
+    struct in_addr imsf_multiaddr;
+
+    /* Local IP address of interface.  */
+    struct in_addr imsf_interface;
+
+    /* Filter mode.  */
+    uint32_t imsf_fmode;
+
+    /* Number of source addresses.  */
+    uint32_t imsf_numsrc;
+    /* Source addresses.  */
+    struct in_addr imsf_slist[1];
+  };
+
+#define IP_MSFILTER_SIZE(numsrc) (sizeof (struct ip_msfilter) \
+				  - sizeof (struct in_addr)		      \
+				  + (numsrc) * sizeof (struct in_addr))
+
+struct group_filter
+  {
+    /* Interface index.  */
+    uint32_t gf_interface;
+
+    /* Group address.  */
+    struct sockaddr_storage gf_group;
+
+    /* Filter mode.  */
+    uint32_t gf_fmode;
+
+    /* Number of source addresses.  */
+    uint32_t gf_numsrc;
+    /* Source addresses.  */
+    struct sockaddr_storage gf_slist[1];
+};
+
+#define GROUP_FILTER_SIZE(numsrc) (sizeof (struct group_filter) \
+				   - sizeof (struct sockaddr_storage)	      \
+				   + ((numsrc)				      \
+				      * sizeof (struct sockaddr_storage)))
+#endif
+
+/* Functions to convert between host and network byte order.
+
+   Please note that these functions normally take `unsigned long int' or
+   `unsigned short int' values as arguments and also return them.  But
+   this was a short-sighted decision since on different systems the types
+   may have different representations but the values are always the same.  */
+
+extern uint32_t ntohl (uint32_t __netlong) __THROW __attribute__ ((__const__));
+extern uint16_t ntohs (uint16_t __netshort)
+     __THROW __attribute__ ((__const__));
+extern uint32_t htonl (uint32_t __hostlong)
+     __THROW __attribute__ ((__const__));
+extern uint16_t htons (uint16_t __hostshort)
+     __THROW __attribute__ ((__const__));
+
+#include <endian.h>
+
+/* Get machine dependent optimized versions of byte swapping functions.  */
+#include <bits/byteswap.h>
+
+#ifdef __OPTIMIZE__
+/* We can optimize calls to the conversion functions.  Either nothing has
+   to be done or we are using directly the byte-swapping functions which
+   often can be inlined.  */
+# if __BYTE_ORDER == __BIG_ENDIAN
+/* The host byte order is the same as network byte order,
+   so these functions are all just identity.  */
+# define ntohl(x)	(x)
+# define ntohs(x)	(x)
+# define htonl(x)	(x)
+# define htons(x)	(x)
+# else
+#  if __BYTE_ORDER == __LITTLE_ENDIAN
+#   define ntohl(x)	__bswap_32 (x)
+#   define ntohs(x)	__bswap_16 (x)
+#   define htonl(x)	__bswap_32 (x)
+#   define htons(x)	__bswap_16 (x)
+#  endif
+# endif
+#endif
+
+#ifdef __GNUC__
+# define IN6_IS_ADDR_UNSPECIFIED(a) \
+  (__extension__							      \
+   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);	      \
+      __a->s6_addr32[0] == 0						      \
+      && __a->s6_addr32[1] == 0						      \
+      && __a->s6_addr32[2] == 0						      \
+      && __a->s6_addr32[3] == 0; }))
+
+# define IN6_IS_ADDR_LOOPBACK(a) \
+  (__extension__							      \
+   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);	      \
+      __a->s6_addr32[0] == 0						      \
+      && __a->s6_addr32[1] == 0						      \
+      && __a->s6_addr32[2] == 0						      \
+      && __a->s6_addr32[3] == htonl (1); }))
+
+# define IN6_IS_ADDR_LINKLOCAL(a) \
+  (__extension__							      \
+   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);	      \
+      (__a->s6_addr32[0] & htonl (0xffc00000)) == htonl (0xfe800000); }))
+
+# define IN6_IS_ADDR_SITELOCAL(a) \
+  (__extension__							      \
+   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);	      \
+      (__a->s6_addr32[0] & htonl (0xffc00000)) == htonl (0xfec00000); }))
+
+# define IN6_IS_ADDR_V4MAPPED(a) \
+  (__extension__							      \
+   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);	      \
+      __a->s6_addr32[0] == 0						      \
+      && __a->s6_addr32[1] == 0						      \
+      && __a->s6_addr32[2] == htonl (0xffff); }))
+
+# define IN6_IS_ADDR_V4COMPAT(a) \
+  (__extension__							      \
+   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);	      \
+      __a->s6_addr32[0] == 0						      \
+      && __a->s6_addr32[1] == 0						      \
+      && __a->s6_addr32[2] == 0						      \
+      && ntohl (__a->s6_addr32[3]) > 1; }))
+
+# define IN6_ARE_ADDR_EQUAL(a,b) \
+  (__extension__							      \
+   ({ const struct in6_addr *__a = (const struct in6_addr *) (a);	      \
+      const struct in6_addr *__b = (const struct in6_addr *) (b);	      \
+      __a->s6_addr32[0] == __b->s6_addr32[0]				      \
+      && __a->s6_addr32[1] == __b->s6_addr32[1]				      \
+      && __a->s6_addr32[2] == __b->s6_addr32[2]				      \
+      && __a->s6_addr32[3] == __b->s6_addr32[3]; }))
+#else
+# define IN6_IS_ADDR_UNSPECIFIED(a) \
+	(((const uint32_t *) (a))[0] == 0				      \
+	 && ((const uint32_t *) (a))[1] == 0				      \
+	 && ((const uint32_t *) (a))[2] == 0				      \
+	 && ((const uint32_t *) (a))[3] == 0)
+
+# define IN6_IS_ADDR_LOOPBACK(a) \
+	(((const uint32_t *) (a))[0] == 0				      \
+	 && ((const uint32_t *) (a))[1] == 0				      \
+	 && ((const uint32_t *) (a))[2] == 0				      \
+	 && ((const uint32_t *) (a))[3] == htonl (1))
+
+# define IN6_IS_ADDR_LINKLOCAL(a) \
+	((((const uint32_t *) (a))[0] & htonl (0xffc00000))		      \
+	 == htonl (0xfe800000))
+
+# define IN6_IS_ADDR_SITELOCAL(a) \
+	((((const uint32_t *) (a))[0] & htonl (0xffc00000))		      \
+	 == htonl (0xfec00000))
+
+# define IN6_IS_ADDR_V4MAPPED(a) \
+	((((const uint32_t *) (a))[0] == 0)				      \
+	 && (((const uint32_t *) (a))[1] == 0)				      \
+	 && (((const uint32_t *) (a))[2] == htonl (0xffff)))
+
+# define IN6_IS_ADDR_V4COMPAT(a) \
+	((((const uint32_t *) (a))[0] == 0)				      \
+	 && (((const uint32_t *) (a))[1] == 0)				      \
+	 && (((const uint32_t *) (a))[2] == 0)				      \
+	 && (ntohl (((const uint32_t *) (a))[3]) > 1))
+
+# define IN6_ARE_ADDR_EQUAL(a,b) \
+	((((const uint32_t *) (a))[0] == ((const uint32_t *) (b))[0])	      \
+	 && (((const uint32_t *) (a))[1] == ((const uint32_t *) (b))[1])      \
+	 && (((const uint32_t *) (a))[2] == ((const uint32_t *) (b))[2])      \
+	 && (((const uint32_t *) (a))[3] == ((const uint32_t *) (b))[3]))
+#endif
+
+#define IN6_IS_ADDR_MULTICAST(a) (((const uint8_t *) (a))[0] == 0xff)
+
+#if defined __USE_MISC || defined __USE_GNU
+/* Bind socket to a privileged IP port.  */
+extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __THROW;
+
+/* The IPv6 version of this function.  */
+extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
+     __THROW;
+#endif
+
+
+#define IN6_IS_ADDR_MC_NODELOCAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x1))
+
+#define IN6_IS_ADDR_MC_LINKLOCAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x2))
+
+#define IN6_IS_ADDR_MC_SITELOCAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x5))
+
+#define IN6_IS_ADDR_MC_ORGLOCAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x8))
+
+#define IN6_IS_ADDR_MC_GLOBAL(a) \
+	(IN6_IS_ADDR_MULTICAST(a)					      \
+	 && ((((const uint8_t *) (a))[1] & 0xf) == 0xe))
+
+
+#ifdef __USE_GNU
+struct cmsghdr;			/* Forward declaration.  */
+
+/* IPv6 packet information.  */
+struct in6_pktinfo
+  {
+    struct in6_addr ipi6_addr;	/* src/dst IPv6 address */
+    unsigned int ipi6_ifindex;	/* send/recv interface index */
+  };
+
+/* IPv6 MTU information.  */
+struct ip6_mtuinfo
+  {
+    struct sockaddr_in6 ip6m_addr; /* dst address including zone ID */
+    uint32_t ip6m_mtu;		   /* path MTU in host byte order */
+  };
+
+
+/* Obsolete hop-by-hop and Destination Options Processing (RFC 2292).  */
+extern int inet6_option_space (int __nbytes)
+     __THROW __attribute_deprecated__;
+extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
+			      int __type) __THROW __attribute_deprecated__;
+extern int inet6_option_append (struct cmsghdr *__cmsg,
+				const uint8_t *__typep, int __multx,
+				int __plusy) __THROW __attribute_deprecated__;
+extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
+				    int __multx, int __plusy)
+     __THROW __attribute_deprecated__;
+extern int inet6_option_next (const struct cmsghdr *__cmsg,
+			      uint8_t **__tptrp)
+     __THROW __attribute_deprecated__;
+extern int inet6_option_find (const struct cmsghdr *__cmsg,
+			      uint8_t **__tptrp, int __type)
+     __THROW __attribute_deprecated__;
+
+
+/* Hop-by-Hop and Destination Options Processing (RFC 3542).  */
+extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) __THROW;
+extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
+			     uint8_t __type, socklen_t __len, uint8_t __align,
+			     void **__databufp) __THROW;
+extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
+     __THROW;
+extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
+			      socklen_t __vallen) __THROW;
+extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
+			   uint8_t *__typep, socklen_t *__lenp,
+			   void **__databufp) __THROW;
+extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
+			   uint8_t __type, socklen_t *__lenp,
+			   void **__databufp) __THROW;
+extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
+			      socklen_t __vallen) __THROW;
+
+
+/* Routing Header Option (RFC 3542).  */
+extern socklen_t inet6_rth_space (int __type, int __segments) __THROW;
+extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
+			     int __segments) __THROW;
+extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) __THROW;
+extern int inet6_rth_reverse (const void *__in, void *__out) __THROW;
+extern int inet6_rth_segments (const void *__bp) __THROW;
+extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
+     __THROW;
+
+
+/* Multicast source filter support.  */
+
+/* Get IPv4 source filter.  */
+extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
+				struct in_addr __group, uint32_t *__fmode,
+				uint32_t *__numsrc, struct in_addr *__slist)
+     __THROW;
+
+/* Set IPv4 source filter.  */
+extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
+				struct in_addr __group, uint32_t __fmode,
+				uint32_t __numsrc,
+				const struct in_addr *__slist)
+     __THROW;
+
+
+/* Get source filter.  */
+extern int getsourcefilter (int __s, uint32_t __interface_addr,
+			    const struct sockaddr *__group,
+			    socklen_t __grouplen, uint32_t *__fmode,
+			    uint32_t *__numsrc,
+			    struct sockaddr_storage *__slist) __THROW;
+
+/* Set source filter.  */
+extern int setsourcefilter (int __s, uint32_t __interface_addr,
+			    const struct sockaddr *__group,
+			    socklen_t __grouplen, uint32_t __fmode,
+			    uint32_t __numsrc,
+			    const struct sockaddr_storage *__slist) __THROW;
+#endif	/* use GNU */
+
+__END_DECLS
+
+#endif	/* netinet/in.h */
diff --git a/include/netinet/in_systm.h b/include/netinet/in_systm.h
new file mode 100644
index 0000000..2bc56d9
--- /dev/null
+++ b/include/netinet/in_systm.h
@@ -0,0 +1,40 @@
+/* System specific type definitions for networking code.
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NETINET_IN_SYSTM_H
+#define _NETINET_IN_SYSTM_H 1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+/*
+ * Network order versions of various data types. Unfortunately, BSD
+ * assumes specific sizes for shorts (16 bit) and longs (32 bit) which
+ * don't hold in general. As a consequence, the network order versions
+ * may not reflect the actual size of the native data types.
+ */
+
+typedef u_int16_t n_short;      /* short as received from the net */
+typedef u_int32_t n_long;       /* long as received from the net  */
+typedef u_int32_t n_time;       /* ms since 00:00 GMT, byte rev   */
+
+__END_DECLS
+
+#endif /* netinet/in_systm.h */
diff --git a/include/netinet/ip.h b/include/netinet/ip.h
new file mode 100644
index 0000000..ecf340e
--- /dev/null
+++ b/include/netinet/ip.h
@@ -0,0 +1,302 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef __NETINET_IP_H
+#define __NETINET_IP_H 1
+
+#include <features.h>
+#include <sys/types.h>
+
+#include <netinet/in.h>
+
+__BEGIN_DECLS
+
+struct timestamp
+  {
+    u_int8_t len;
+    u_int8_t ptr;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+    unsigned int flags:4;
+    unsigned int overflow:4;
+#elif __BYTE_ORDER == __BIG_ENDIAN
+    unsigned int overflow:4;
+    unsigned int flags:4;
+#else
+# error	"Please fix <bits/endian.h>"
+#endif
+    u_int32_t data[9];
+  };
+
+struct iphdr
+  {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+    unsigned int ihl:4;
+    unsigned int version:4;
+#elif __BYTE_ORDER == __BIG_ENDIAN
+    unsigned int version:4;
+    unsigned int ihl:4;
+#else
+# error	"Please fix <bits/endian.h>"
+#endif
+    u_int8_t tos;
+    u_int16_t tot_len;
+    u_int16_t id;
+    u_int16_t frag_off;
+    u_int8_t ttl;
+    u_int8_t protocol;
+    u_int16_t check;
+    u_int32_t saddr;
+    u_int32_t daddr;
+    /*The options start here. */
+  };
+
+#ifdef __USE_BSD
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip.h	8.1 (Berkeley) 6/10/93
+ */
+
+/*
+ * Definitions for internet protocol version 4.
+ * Per RFC 791, September 1981.
+ */
+
+/*
+ * Structure of an internet header, naked of options.
+ */
+struct ip
+  {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+    unsigned int ip_hl:4;		/* header length */
+    unsigned int ip_v:4;		/* version */
+#endif
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned int ip_v:4;		/* version */
+    unsigned int ip_hl:4;		/* header length */
+#endif
+    u_int8_t ip_tos;			/* type of service */
+    u_short ip_len;			/* total length */
+    u_short ip_id;			/* identification */
+    u_short ip_off;			/* fragment offset field */
+#define	IP_RF 0x8000			/* reserved fragment flag */
+#define	IP_DF 0x4000			/* dont fragment flag */
+#define	IP_MF 0x2000			/* more fragments flag */
+#define	IP_OFFMASK 0x1fff		/* mask for fragmenting bits */
+    u_int8_t ip_ttl;			/* time to live */
+    u_int8_t ip_p;			/* protocol */
+    u_short ip_sum;			/* checksum */
+    struct in_addr ip_src, ip_dst;	/* source and dest address */
+  };
+
+/*
+ * Time stamp option structure.
+ */
+struct ip_timestamp
+  {
+    u_int8_t ipt_code;			/* IPOPT_TS */
+    u_int8_t ipt_len;			/* size of structure (variable) */
+    u_int8_t ipt_ptr;			/* index of current entry */
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+    unsigned int ipt_flg:4;		/* flags, see below */
+    unsigned int ipt_oflw:4;		/* overflow counter */
+#endif
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned int ipt_oflw:4;		/* overflow counter */
+    unsigned int ipt_flg:4;		/* flags, see below */
+#endif
+    u_int32_t data[9];
+  };
+#endif /* __USE_BSD */
+
+#define	IPVERSION	4               /* IP version number */
+#define	IP_MAXPACKET	65535		/* maximum packet size */
+
+/*
+ * Definitions for Explicit Congestion Notification (ECN)
+ *
+ * Taken from RFC-3168, Section 5.
+ */
+
+#define	IPTOS_ECN_MASK		0x03
+#define	IPTOS_ECN(x)		((x) & IPTOS_ECN_MASK)
+#define	IPTOS_ECN_NOT_ECT	0x00
+#define	IPTOS_ECN_ECT1		0x01
+#define	IPTOS_ECN_ECT0		0x02
+#define	IPTOS_ECN_CE		0x03
+
+/*
+ * Definitions for IP differentiated services code points (DSCP)
+ *
+ * Taken from RFC-2597, Section 6 and RFC-2598, Section 2.3.
+ */
+
+#define	IPTOS_DSCP_MASK		0xfc
+#define	IPTOS_DSCP(x)		((x) & IPTOS_DSCP_MASK)
+#define	IPTOS_DSCP_AF11		0x28
+#define	IPTOS_DSCP_AF12		0x30
+#define	IPTOS_DSCP_AF13		0x38
+#define	IPTOS_DSCP_AF21		0x48
+#define	IPTOS_DSCP_AF22		0x50
+#define	IPTOS_DSCP_AF23		0x58
+#define	IPTOS_DSCP_AF31		0x68
+#define	IPTOS_DSCP_AF32		0x70
+#define	IPTOS_DSCP_AF33		0x78
+#define	IPTOS_DSCP_AF41		0x88
+#define	IPTOS_DSCP_AF42		0x90
+#define	IPTOS_DSCP_AF43		0x98
+#define	IPTOS_DSCP_EF		0xb8
+
+/*
+ * In RFC 2474, Section 4.2.2.1, the Class Selector Codepoints subsume
+ * the old ToS Precedence values.
+ */
+
+#define	IPTOS_CLASS_MASK		0xe0
+#define	IPTOS_CLASS(class)		((class) & IPTOS_CLASS_MASK)
+#define	IPTOS_CLASS_CS0			0x00
+#define	IPTOS_CLASS_CS1			0x20
+#define	IPTOS_CLASS_CS2			0x40
+#define	IPTOS_CLASS_CS3			0x60
+#define	IPTOS_CLASS_CS4			0x80
+#define	IPTOS_CLASS_CS5			0xa0
+#define	IPTOS_CLASS_CS6			0xc0
+#define	IPTOS_CLASS_CS7			0xe0
+
+#define	IPTOS_CLASS_DEFAULT		IPTOS_CLASS_CS0
+
+/*
+ * Definitions for IP type of service (ip_tos) [deprecated; use DSCP
+ * and CS definitions above instead.]
+ */
+#define	IPTOS_TOS_MASK		0x1E
+#define	IPTOS_TOS(tos)		((tos) & IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_LOWCOST		0x02
+#define	IPTOS_MINCOST		IPTOS_LOWCOST
+
+/*
+ * Definitions for IP precedence (also in ip_tos) [also deprecated.]
+ */
+#define	IPTOS_PREC_MASK			IPTOS_CLASS_MASK
+#define	IPTOS_PREC(tos)			IPTOS_CLASS(tos)
+#define	IPTOS_PREC_NETCONTROL		IPTOS_CLASS_CS7
+#define	IPTOS_PREC_INTERNETCONTROL	IPTOS_CLASS_CS6
+#define	IPTOS_PREC_CRITIC_ECP		IPTOS_CLASS_CS5
+#define	IPTOS_PREC_FLASHOVERRIDE	IPTOS_CLASS_CS4
+#define	IPTOS_PREC_FLASH		IPTOS_CLASS_CS3
+#define	IPTOS_PREC_IMMEDIATE		IPTOS_CLASS_CS2
+#define	IPTOS_PREC_PRIORITY		IPTOS_CLASS_CS1
+#define	IPTOS_PREC_ROUTINE		IPTOS_CLASS_CS0
+
+/*
+ * Definitions for options.
+ */
+#define	IPOPT_COPY		0x80
+#define	IPOPT_CLASS_MASK	0x60
+#define	IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o) & IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o) & IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o) & IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_DEBMEAS		0x40
+#define	IPOPT_MEASUREMENT       IPOPT_DEBMEAS
+#define	IPOPT_RESERVED2		0x60
+
+#define	IPOPT_EOL		0		/* end of option list */
+#define	IPOPT_END		IPOPT_EOL
+#define	IPOPT_NOP		1		/* no operation */
+#define	IPOPT_NOOP		IPOPT_NOP
+
+#define	IPOPT_RR		7		/* record packet route */
+#define	IPOPT_TS		68		/* timestamp */
+#define	IPOPT_TIMESTAMP		IPOPT_TS
+#define	IPOPT_SECURITY		130		/* provide s,c,h,tcc */
+#define	IPOPT_SEC		IPOPT_SECURITY
+#define	IPOPT_LSRR		131		/* loose source route */
+#define	IPOPT_SATID		136		/* satnet id */
+#define	IPOPT_SID		IPOPT_SATID
+#define	IPOPT_SSRR		137		/* strict source route */
+#define	IPOPT_RA		148		/* router alert */
+
+/*
+ * Offsets to fields in options other than EOL and NOP.
+ */
+#define	IPOPT_OPTVAL		0		/* option ID */
+#define	IPOPT_OLEN		1		/* option length */
+#define	IPOPT_OFFSET		2		/* offset within option */
+#define	IPOPT_MINOFF		4		/* min value of above */
+
+#define	MAX_IPOPTLEN		40
+
+/* flag bits for ipt_flg */
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+/* bits for security (not byte swapped) */
+#define	IPOPT_SECUR_UNCLASS	0x0000
+#define	IPOPT_SECUR_CONFID	0xf135
+#define	IPOPT_SECUR_EFTO	0x789a
+#define	IPOPT_SECUR_MMMM	0xbc4d
+#define	IPOPT_SECUR_RESTR	0xaf13
+#define	IPOPT_SECUR_SECRET	0xd788
+#define	IPOPT_SECUR_TOPSECRET	0x6bc5
+
+/*
+ * Internet implementation parameters.
+ */
+#define	MAXTTL		255		/* maximum time to live (seconds) */
+#define	IPDEFTTL	64		/* default ttl, from RFC 1340 */
+#define	IPFRAGTTL	60		/* time to live for frags, slowhz */
+#define	IPTTLDEC	1		/* subtracted when forwarding */
+
+#define	IP_MSS		576		/* default maximum segment size */
+
+__END_DECLS
+
+#endif /* netinet/ip.h */
diff --git a/include/netinet/ip6.h b/include/netinet/ip6.h
new file mode 100644
index 0000000..3cebf9f
--- /dev/null
+++ b/include/netinet/ip6.h
@@ -0,0 +1,188 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NETINET_IP6_H
+#define _NETINET_IP6_H 1
+
+#include <inttypes.h>
+#include <netinet/in.h>
+
+struct ip6_hdr
+  {
+    union
+      {
+	struct ip6_hdrctl
+	  {
+	    uint32_t ip6_un1_flow;   /* 4 bits version, 8 bits TC,
+					20 bits flow-ID */
+	    uint16_t ip6_un1_plen;   /* payload length */
+	    uint8_t  ip6_un1_nxt;    /* next header */
+	    uint8_t  ip6_un1_hlim;   /* hop limit */
+	  } ip6_un1;
+	uint8_t ip6_un2_vfc;       /* 4 bits version, top 4 bits tclass */
+      } ip6_ctlun;
+    struct in6_addr ip6_src;      /* source address */
+    struct in6_addr ip6_dst;      /* destination address */
+  };
+
+#define ip6_vfc   ip6_ctlun.ip6_un2_vfc
+#define ip6_flow  ip6_ctlun.ip6_un1.ip6_un1_flow
+#define ip6_plen  ip6_ctlun.ip6_un1.ip6_un1_plen
+#define ip6_nxt   ip6_ctlun.ip6_un1.ip6_un1_nxt
+#define ip6_hlim  ip6_ctlun.ip6_un1.ip6_un1_hlim
+#define ip6_hops  ip6_ctlun.ip6_un1.ip6_un1_hlim
+
+/* Generic extension header.  */
+struct ip6_ext
+  {
+    uint8_t  ip6e_nxt;		/* next header.  */
+    uint8_t  ip6e_len;		/* length in units of 8 octets.  */
+  };
+
+/* Hop-by-Hop options header.  */
+struct ip6_hbh
+  {
+    uint8_t  ip6h_nxt;		/* next header.  */
+    uint8_t  ip6h_len;		/* length in units of 8 octets.  */
+    /* followed by options */
+  };
+
+/* Destination options header */
+struct ip6_dest
+  {
+    uint8_t  ip6d_nxt;		/* next header */
+    uint8_t  ip6d_len;		/* length in units of 8 octets */
+    /* followed by options */
+  };
+
+/* Routing header */
+struct ip6_rthdr
+  {
+    uint8_t  ip6r_nxt;		/* next header */
+    uint8_t  ip6r_len;		/* length in units of 8 octets */
+    uint8_t  ip6r_type;		/* routing type */
+    uint8_t  ip6r_segleft;	/* segments left */
+    /* followed by routing type specific data */
+  };
+
+/* Type 0 Routing header */
+struct ip6_rthdr0
+  {
+    uint8_t  ip6r0_nxt;		/* next header */
+    uint8_t  ip6r0_len;		/* length in units of 8 octets */
+    uint8_t  ip6r0_type;	/* always zero */
+    uint8_t  ip6r0_segleft;	/* segments left */
+    uint8_t  ip6r0_reserved;	/* reserved field */
+    uint8_t  ip6r0_slmap[3];	/* strict/loose bit map */
+    /* followed by up to 127 struct in6_addr */
+    struct in6_addr ip6r0_addr[0];
+  };
+
+/* Fragment header */
+struct ip6_frag
+  {
+    uint8_t   ip6f_nxt;		/* next header */
+    uint8_t   ip6f_reserved;	/* reserved field */
+    uint16_t  ip6f_offlg;	/* offset, reserved, and flag */
+    uint32_t  ip6f_ident;	/* identification */
+  };
+
+#if BYTE_ORDER == BIG_ENDIAN
+# define IP6F_OFF_MASK       0xfff8  /* mask out offset from _offlg */
+# define IP6F_RESERVED_MASK  0x0006  /* reserved bits in ip6f_offlg */
+# define IP6F_MORE_FRAG      0x0001  /* more-fragments flag */
+#else   /* BYTE_ORDER == LITTLE_ENDIAN */
+# define IP6F_OFF_MASK       0xf8ff  /* mask out offset from _offlg */
+# define IP6F_RESERVED_MASK  0x0600  /* reserved bits in ip6f_offlg */
+# define IP6F_MORE_FRAG      0x0100  /* more-fragments flag */
+#endif
+
+/* IPv6 options */
+struct ip6_opt
+  {
+    uint8_t  ip6o_type;
+    uint8_t  ip6o_len;
+  };
+
+/* The high-order 3 bits of the option type define the behavior
+ * when processing an unknown option and whether or not the option
+ * content changes in flight.
+ */
+#define IP6OPT_TYPE(o)		((o) & 0xc0)
+#define IP6OPT_TYPE_SKIP	0x00
+#define IP6OPT_TYPE_DISCARD	0x40
+#define IP6OPT_TYPE_FORCEICMP	0x80
+#define IP6OPT_TYPE_ICMP	0xc0
+#define IP6OPT_TYPE_MUTABLE	0x20
+
+/* Special option types for padding.  */
+#define IP6OPT_PAD1	0
+#define IP6OPT_PADN	1
+
+#define IP6OPT_JUMBO		0xc2
+#define IP6OPT_NSAP_ADDR	0xc3
+#define IP6OPT_TUNNEL_LIMIT	0x04
+#define IP6OPT_ROUTER_ALERT	0x05
+
+/* Jumbo Payload Option */
+struct ip6_opt_jumbo
+  {
+    uint8_t  ip6oj_type;
+    uint8_t  ip6oj_len;
+    uint8_t  ip6oj_jumbo_len[4];
+  };
+#define IP6OPT_JUMBO_LEN	6
+
+/* NSAP Address Option */
+struct ip6_opt_nsap
+  {
+    uint8_t  ip6on_type;
+    uint8_t  ip6on_len;
+    uint8_t  ip6on_src_nsap_len;
+    uint8_t  ip6on_dst_nsap_len;
+      /* followed by source NSAP */
+      /* followed by destination NSAP */
+  };
+
+/* Tunnel Limit Option */
+struct ip6_opt_tunnel
+  {
+    uint8_t  ip6ot_type;
+    uint8_t  ip6ot_len;
+    uint8_t  ip6ot_encap_limit;
+  };
+
+/* Router Alert Option */
+struct ip6_opt_router
+  {
+    uint8_t  ip6or_type;
+    uint8_t  ip6or_len;
+    uint8_t  ip6or_value[2];
+  };
+
+/* Router alert values (in network byte order) */
+#if BYTE_ORDER == BIG_ENDIAN
+# define IP6_ALERT_MLD	0x0000
+# define IP6_ALERT_RSVP	0x0001
+# define IP6_ALERT_AN	0x0002
+#else /* BYTE_ORDER == LITTLE_ENDING */
+# define IP6_ALERT_MLD	0x0000
+# define IP6_ALERT_RSVP	0x0100
+# define IP6_ALERT_AN	0x0200
+#endif
+
+#endif /* netinet/ip6.h */
diff --git a/include/netinet/ip_icmp.h b/include/netinet/ip_icmp.h
new file mode 100644
index 0000000..e7a351e
--- /dev/null
+++ b/include/netinet/ip_icmp.h
@@ -0,0 +1,282 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef __NETINET_IP_ICMP_H
+#define __NETINET_IP_ICMP_H    1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+struct icmphdr
+{
+  u_int8_t type;		/* message type */
+  u_int8_t code;		/* type sub-code */
+  u_int16_t checksum;
+  union
+  {
+    struct
+    {
+      u_int16_t	id;
+      u_int16_t	sequence;
+    } echo;			/* echo datagram */
+    u_int32_t	gateway;	/* gateway address */
+    struct
+    {
+      u_int16_t	__glibc_reserved;
+      u_int16_t	mtu;
+    } frag;			/* path mtu discovery */
+  } un;
+};
+
+#define ICMP_ECHOREPLY		0	/* Echo Reply			*/
+#define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
+#define ICMP_SOURCE_QUENCH	4	/* Source Quench		*/
+#define ICMP_REDIRECT		5	/* Redirect (change route)	*/
+#define ICMP_ECHO		8	/* Echo Request			*/
+#define ICMP_TIME_EXCEEDED	11	/* Time Exceeded		*/
+#define ICMP_PARAMETERPROB	12	/* Parameter Problem		*/
+#define ICMP_TIMESTAMP		13	/* Timestamp Request		*/
+#define ICMP_TIMESTAMPREPLY	14	/* Timestamp Reply		*/
+#define ICMP_INFO_REQUEST	15	/* Information Request		*/
+#define ICMP_INFO_REPLY		16	/* Information Reply		*/
+#define ICMP_ADDRESS		17	/* Address Mask Request		*/
+#define ICMP_ADDRESSREPLY	18	/* Address Mask Reply		*/
+#define NR_ICMP_TYPES		18
+
+
+/* Codes for UNREACH. */
+#define ICMP_NET_UNREACH	0	/* Network Unreachable		*/
+#define ICMP_HOST_UNREACH	1	/* Host Unreachable		*/
+#define ICMP_PROT_UNREACH	2	/* Protocol Unreachable		*/
+#define ICMP_PORT_UNREACH	3	/* Port Unreachable		*/
+#define ICMP_FRAG_NEEDED	4	/* Fragmentation Needed/DF set	*/
+#define ICMP_SR_FAILED		5	/* Source Route failed		*/
+#define ICMP_NET_UNKNOWN	6
+#define ICMP_HOST_UNKNOWN	7
+#define ICMP_HOST_ISOLATED	8
+#define ICMP_NET_ANO		9
+#define ICMP_HOST_ANO		10
+#define ICMP_NET_UNR_TOS	11
+#define ICMP_HOST_UNR_TOS	12
+#define ICMP_PKT_FILTERED	13	/* Packet filtered */
+#define ICMP_PREC_VIOLATION	14	/* Precedence violation */
+#define ICMP_PREC_CUTOFF	15	/* Precedence cut off */
+#define NR_ICMP_UNREACH		15	/* instead of hardcoding immediate value */
+
+/* Codes for REDIRECT. */
+#define ICMP_REDIR_NET		0	/* Redirect Net			*/
+#define ICMP_REDIR_HOST		1	/* Redirect Host		*/
+#define ICMP_REDIR_NETTOS	2	/* Redirect Net for TOS		*/
+#define ICMP_REDIR_HOSTTOS	3	/* Redirect Host for TOS	*/
+
+/* Codes for TIME_EXCEEDED. */
+#define ICMP_EXC_TTL		0	/* TTL count exceeded		*/
+#define ICMP_EXC_FRAGTIME	1	/* Fragment Reass time exceeded	*/
+
+
+#ifdef __USE_BSD
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#include <netinet/in.h>
+#include <netinet/ip.h>
+
+/*
+ * Internal of an ICMP Router Advertisement
+ */
+struct icmp_ra_addr
+{
+  u_int32_t ira_addr;
+  u_int32_t ira_preference;
+};
+
+struct icmp
+{
+  u_int8_t  icmp_type;	/* type of message, see below */
+  u_int8_t  icmp_code;	/* type sub code */
+  u_int16_t icmp_cksum;	/* ones complement checksum of struct */
+  union
+  {
+    u_char ih_pptr;		/* ICMP_PARAMPROB */
+    struct in_addr ih_gwaddr;	/* gateway address */
+    struct ih_idseq		/* echo datagram */
+    {
+      u_int16_t icd_id;
+      u_int16_t icd_seq;
+    } ih_idseq;
+    u_int32_t ih_void;
+
+    /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
+    struct ih_pmtu
+    {
+      u_int16_t ipm_void;
+      u_int16_t ipm_nextmtu;
+    } ih_pmtu;
+
+    struct ih_rtradv
+    {
+      u_int8_t irt_num_addrs;
+      u_int8_t irt_wpa;
+      u_int16_t irt_lifetime;
+    } ih_rtradv;
+  } icmp_hun;
+#define	icmp_pptr	icmp_hun.ih_pptr
+#define	icmp_gwaddr	icmp_hun.ih_gwaddr
+#define	icmp_id		icmp_hun.ih_idseq.icd_id
+#define	icmp_seq	icmp_hun.ih_idseq.icd_seq
+#define	icmp_void	icmp_hun.ih_void
+#define	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
+#define	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
+#define	icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
+#define	icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
+#define	icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
+  union
+  {
+    struct
+    {
+      u_int32_t its_otime;
+      u_int32_t its_rtime;
+      u_int32_t its_ttime;
+    } id_ts;
+    struct
+    {
+      struct ip idi_ip;
+      /* options and then 64 bits of data */
+    } id_ip;
+    struct icmp_ra_addr id_radv;
+    u_int32_t   id_mask;
+    u_int8_t    id_data[1];
+  } icmp_dun;
+#define	icmp_otime	icmp_dun.id_ts.its_otime
+#define	icmp_rtime	icmp_dun.id_ts.its_rtime
+#define	icmp_ttime	icmp_dun.id_ts.its_ttime
+#define	icmp_ip		icmp_dun.id_ip.idi_ip
+#define	icmp_radv	icmp_dun.id_radv
+#define	icmp_mask	icmp_dun.id_mask
+#define	icmp_data	icmp_dun.id_data
+};
+
+/*
+ * Lower bounds on packet lengths for various types.
+ * For the error advice packets must first insure that the
+ * packet is large enough to contain the returned ip header.
+ * Only then can we do the check to see if 64 bits of packet
+ * data have been returned, since we need to check the returned
+ * ip header length.
+ */
+#define	ICMP_MINLEN	8				/* abs minimum */
+#define	ICMP_TSLEN	(8 + 3 * sizeof (n_time))	/* timestamp */
+#define	ICMP_MASKLEN	12				/* address mask */
+#define	ICMP_ADVLENMIN	(8 + sizeof (struct ip) + 8)	/* min */
+#ifndef _IP_VHL
+#define	ICMP_ADVLEN(p)	(8 + ((p)->icmp_ip.ip_hl << 2) + 8)
+	/* N.B.: must separately check that ip_hl >= 5 */
+#else
+#define	ICMP_ADVLEN(p)	(8 + (IP_VHL_HL((p)->icmp_ip.ip_vhl) << 2) + 8)
+	/* N.B.: must separately check that header length >= 5 */
+#endif
+
+/* Definition of type and code fields. */
+/* defined above: ICMP_ECHOREPLY, ICMP_REDIRECT, ICMP_ECHO */
+#define	ICMP_UNREACH		3		/* dest unreachable, codes: */
+#define	ICMP_SOURCEQUENCH	4		/* packet lost, slow down */
+#define	ICMP_ROUTERADVERT	9		/* router advertisement */
+#define	ICMP_ROUTERSOLICIT	10		/* router solicitation */
+#define	ICMP_TIMXCEED		11		/* time exceeded, code: */
+#define	ICMP_PARAMPROB		12		/* ip header bad */
+#define	ICMP_TSTAMP		13		/* timestamp request */
+#define	ICMP_TSTAMPREPLY	14		/* timestamp reply */
+#define	ICMP_IREQ		15		/* information request */
+#define	ICMP_IREQREPLY		16		/* information reply */
+#define	ICMP_MASKREQ		17		/* address mask request */
+#define	ICMP_MASKREPLY		18		/* address mask reply */
+
+#define	ICMP_MAXTYPE		18
+
+/* UNREACH codes */
+#define	ICMP_UNREACH_NET	        0	/* bad net */
+#define	ICMP_UNREACH_HOST	        1	/* bad host */
+#define	ICMP_UNREACH_PROTOCOL	        2	/* bad protocol */
+#define	ICMP_UNREACH_PORT	        3	/* bad port */
+#define	ICMP_UNREACH_NEEDFRAG	        4	/* IP_DF caused drop */
+#define	ICMP_UNREACH_SRCFAIL	        5	/* src route failed */
+#define	ICMP_UNREACH_NET_UNKNOWN        6	/* unknown net */
+#define	ICMP_UNREACH_HOST_UNKNOWN       7	/* unknown host */
+#define	ICMP_UNREACH_ISOLATED	        8	/* src host isolated */
+#define	ICMP_UNREACH_NET_PROHIB	        9	/* net denied */
+#define	ICMP_UNREACH_HOST_PROHIB        10	/* host denied */
+#define	ICMP_UNREACH_TOSNET	        11	/* bad tos for net */
+#define	ICMP_UNREACH_TOSHOST	        12	/* bad tos for host */
+#define	ICMP_UNREACH_FILTER_PROHIB      13	/* admin prohib */
+#define	ICMP_UNREACH_HOST_PRECEDENCE    14	/* host prec vio. */
+#define	ICMP_UNREACH_PRECEDENCE_CUTOFF  15	/* prec cutoff */
+
+/* REDIRECT codes */
+#define	ICMP_REDIRECT_NET	0		/* for network */
+#define	ICMP_REDIRECT_HOST	1		/* for host */
+#define	ICMP_REDIRECT_TOSNET	2		/* for tos and net */
+#define	ICMP_REDIRECT_TOSHOST	3		/* for tos and host */
+
+/* TIMEXCEED codes */
+#define	ICMP_TIMXCEED_INTRANS	0		/* ttl==0 in transit */
+#define	ICMP_TIMXCEED_REASS	1		/* ttl==0 in reass */
+
+/* PARAMPROB code */
+#define	ICMP_PARAMPROB_OPTABSENT 1		/* req. opt. absent */
+
+#define	ICMP_INFOTYPE(type) \
+	((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || \
+	(type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || \
+	(type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || \
+	(type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || \
+	(type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)
+
+#endif /* __USE_BSD */
+
+__END_DECLS
+
+#endif /* netinet/ip_icmp.h */
diff --git a/include/netinet/tcp.h b/include/netinet/tcp.h
new file mode 100644
index 0000000..f6602ec
--- /dev/null
+++ b/include/netinet/tcp.h
@@ -0,0 +1,303 @@
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#ifndef _NETINET_TCP_H
+#define _NETINET_TCP_H	1
+
+#include <features.h>
+
+/*
+ * User-settable options (used with setsockopt).
+ */
+#define	TCP_NODELAY		 1  /* Don't delay send to coalesce packets  */
+#define	TCP_MAXSEG		 2  /* Set maximum segment size  */
+#define TCP_CORK		 3  /* Control sending of partial frames  */
+#define TCP_KEEPIDLE		 4  /* Start keeplives after this period */
+#define TCP_KEEPINTVL		 5  /* Interval between keepalives */
+#define TCP_KEEPCNT		 6  /* Number of keepalives before death */
+#define TCP_SYNCNT		 7  /* Number of SYN retransmits */
+#define TCP_LINGER2		 8  /* Life time of orphaned FIN-WAIT-2 state */
+#define TCP_DEFER_ACCEPT	 9  /* Wake up listener only when data arrive */
+#define TCP_WINDOW_CLAMP	 10 /* Bound advertised window */
+#define TCP_INFO		 11 /* Information about this connection. */
+#define	TCP_QUICKACK		 12 /* Bock/reenable quick ACKs.  */
+#define TCP_CONGESTION		 13 /* Congestion control algorithm.  */
+#define TCP_MD5SIG		 14 /* TCP MD5 Signature (RFC2385) */
+#define TCP_COOKIE_TRANSACTIONS	 15 /* TCP Cookie Transactions */
+#define TCP_THIN_LINEAR_TIMEOUTS 16 /* Use linear timeouts for thin streams*/
+#define TCP_THIN_DUPACK		 17 /* Fast retrans. after 1 dupack */
+#define TCP_USER_TIMEOUT	 18 /* How long for loss retry before timeout */
+#define TCP_REPAIR		 19 /* TCP sock is under repair right now */
+#define TCP_REPAIR_QUEUE	 20 /* Set TCP queue to repair */
+#define TCP_QUEUE_SEQ		 21 /* Set sequence number of repaired queue. */
+#define TCP_REPAIR_OPTIONS	 22 /* Repair TCP connection options */
+#define TCP_FASTOPEN		 23 /* Enable FastOpen on listeners */
+#define TCP_TIMESTAMP		 24 /* TCP time stamp */
+
+#ifdef __USE_MISC
+# include <sys/types.h>
+# include <sys/socket.h>
+
+typedef	u_int32_t tcp_seq;
+/*
+ * TCP header.
+ * Per RFC 793, September, 1981.
+ */
+struct tcphdr
+  {
+    __extension__ union
+    {
+      struct
+      {
+	u_int16_t th_sport;		/* source port */
+	u_int16_t th_dport;		/* destination port */
+	tcp_seq th_seq;		/* sequence number */
+	tcp_seq th_ack;		/* acknowledgement number */
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+	u_int8_t th_x2:4;		/* (unused) */
+	u_int8_t th_off:4;		/* data offset */
+# endif
+# if __BYTE_ORDER == __BIG_ENDIAN
+	u_int8_t th_off:4;		/* data offset */
+	u_int8_t th_x2:4;		/* (unused) */
+# endif
+	u_int8_t th_flags;
+# define TH_FIN	0x01
+# define TH_SYN	0x02
+# define TH_RST	0x04
+# define TH_PUSH	0x08
+# define TH_ACK	0x10
+# define TH_URG	0x20
+	u_int16_t th_win;		/* window */
+	u_int16_t th_sum;		/* checksum */
+	u_int16_t th_urp;		/* urgent pointer */
+      };
+      struct
+      {
+	u_int16_t source;
+	u_int16_t dest;
+	u_int32_t seq;
+	u_int32_t ack_seq;
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+	u_int16_t res1:4;
+	u_int16_t doff:4;
+	u_int16_t fin:1;
+	u_int16_t syn:1;
+	u_int16_t rst:1;
+	u_int16_t psh:1;
+	u_int16_t ack:1;
+	u_int16_t urg:1;
+	u_int16_t res2:2;
+# elif __BYTE_ORDER == __BIG_ENDIAN
+	u_int16_t doff:4;
+	u_int16_t res1:4;
+	u_int16_t res2:2;
+	u_int16_t urg:1;
+	u_int16_t ack:1;
+	u_int16_t psh:1;
+	u_int16_t rst:1;
+	u_int16_t syn:1;
+	u_int16_t fin:1;
+# else
+#  error "Adjust your <bits/endian.h> defines"
+# endif
+	u_int16_t window;
+	u_int16_t check;
+	u_int16_t urg_ptr;
+      };
+    };
+};
+
+enum
+{
+  TCP_ESTABLISHED = 1,
+  TCP_SYN_SENT,
+  TCP_SYN_RECV,
+  TCP_FIN_WAIT1,
+  TCP_FIN_WAIT2,
+  TCP_TIME_WAIT,
+  TCP_CLOSE,
+  TCP_CLOSE_WAIT,
+  TCP_LAST_ACK,
+  TCP_LISTEN,
+  TCP_CLOSING   /* now a valid state */
+};
+
+# define TCPOPT_EOL		0
+# define TCPOPT_NOP		1
+# define TCPOPT_MAXSEG		2
+# define TCPOLEN_MAXSEG		4
+# define TCPOPT_WINDOW		3
+# define TCPOLEN_WINDOW		3
+# define TCPOPT_SACK_PERMITTED	4		/* Experimental */
+# define TCPOLEN_SACK_PERMITTED	2
+# define TCPOPT_SACK		5		/* Experimental */
+# define TCPOPT_TIMESTAMP	8
+# define TCPOLEN_TIMESTAMP	10
+# define TCPOLEN_TSTAMP_APPA	(TCPOLEN_TIMESTAMP+2) /* appendix A */
+
+# define TCPOPT_TSTAMP_HDR	\
+    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)
+
+/*
+ * Default maximum segment size for TCP.
+ * With an IP MSS of 576, this is 536,
+ * but 512 is probably more convenient.
+ * This should be defined as MIN(512, IP_MSS - sizeof (struct tcpiphdr)).
+ */
+# define TCP_MSS	512
+
+# define TCP_MAXWIN	65535	/* largest value for (unscaled) window */
+
+# define TCP_MAX_WINSHIFT	14	/* maximum window shift */
+
+# define SOL_TCP		6	/* TCP level */
+
+
+# define TCPI_OPT_TIMESTAMPS	1
+# define TCPI_OPT_SACK		2
+# define TCPI_OPT_WSCALE	4
+# define TCPI_OPT_ECN		8  /* ECN was negociated at TCP session init */
+# define TCPI_OPT_ECN_SEEN	16 /* we received at least one packet with ECT */
+# define TCPI_OPT_SYN_DATA	32 /* SYN-ACK acked data in SYN sent or rcvd */
+
+/* Values for tcpi_state.  */
+enum tcp_ca_state
+{
+  TCP_CA_Open = 0,
+  TCP_CA_Disorder = 1,
+  TCP_CA_CWR = 2,
+  TCP_CA_Recovery = 3,
+  TCP_CA_Loss = 4
+};
+
+struct tcp_info
+{
+  u_int8_t	tcpi_state;
+  u_int8_t	tcpi_ca_state;
+  u_int8_t	tcpi_retransmits;
+  u_int8_t	tcpi_probes;
+  u_int8_t	tcpi_backoff;
+  u_int8_t	tcpi_options;
+  u_int8_t	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
+
+  u_int32_t	tcpi_rto;
+  u_int32_t	tcpi_ato;
+  u_int32_t	tcpi_snd_mss;
+  u_int32_t	tcpi_rcv_mss;
+
+  u_int32_t	tcpi_unacked;
+  u_int32_t	tcpi_sacked;
+  u_int32_t	tcpi_lost;
+  u_int32_t	tcpi_retrans;
+  u_int32_t	tcpi_fackets;
+
+  /* Times. */
+  u_int32_t	tcpi_last_data_sent;
+  u_int32_t	tcpi_last_ack_sent;	/* Not remembered, sorry.  */
+  u_int32_t	tcpi_last_data_recv;
+  u_int32_t	tcpi_last_ack_recv;
+
+  /* Metrics. */
+  u_int32_t	tcpi_pmtu;
+  u_int32_t	tcpi_rcv_ssthresh;
+  u_int32_t	tcpi_rtt;
+  u_int32_t	tcpi_rttvar;
+  u_int32_t	tcpi_snd_ssthresh;
+  u_int32_t	tcpi_snd_cwnd;
+  u_int32_t	tcpi_advmss;
+  u_int32_t	tcpi_reordering;
+
+  u_int32_t	tcpi_rcv_rtt;
+  u_int32_t	tcpi_rcv_space;
+
+  u_int32_t	tcpi_total_retrans;
+};
+
+
+/* For TCP_MD5SIG socket option.  */
+#define TCP_MD5SIG_MAXKEYLEN	80
+
+struct tcp_md5sig
+{
+  struct sockaddr_storage tcpm_addr;		/* Address associated.  */
+  u_int16_t	__tcpm_pad1;			/* Zero.  */
+  u_int16_t	tcpm_keylen;			/* Key length.  */
+  u_int32_t	__tcpm_pad2;			/* Zero.  */
+  u_int8_t	tcpm_key[TCP_MD5SIG_MAXKEYLEN];	/* Key (binary).  */
+};
+
+/* For socket repair options.  */
+struct tcp_repair_opt
+{
+  u_int32_t	opt_code;
+  u_int32_t	opt_val;
+};
+
+/* Queue to repair, for TCP_REPAIR_QUEUE.  */
+enum
+{
+  TCP_NO_QUEUE,
+  TCP_RECV_QUEUE,
+  TCP_SEND_QUEUE,
+  TCP_QUEUES_NR,
+};
+
+/* For cookie transactions socket options.  */
+#define TCP_COOKIE_MIN		8		/*  64-bits */
+#define TCP_COOKIE_MAX		16		/* 128-bits */
+#define TCP_COOKIE_PAIR_SIZE	(2*TCP_COOKIE_MAX)
+
+/* Flags for both getsockopt and setsockopt */
+#define TCP_COOKIE_IN_ALWAYS	(1 << 0)	/* Discard SYN without cookie */
+#define TCP_COOKIE_OUT_NEVER	(1 << 1)	/* Prohibit outgoing cookies,
+						 * supercedes everything. */
+
+/* Flags for getsockopt */
+#define TCP_S_DATA_IN		(1 << 2)	/* Was data received? */
+#define TCP_S_DATA_OUT		(1 << 3)	/* Was data sent? */
+
+#define TCP_MSS_DEFAULT		 536U	/* IPv4 (RFC1122, RFC2581) */
+#define TCP_MSS_DESIRED		1220U	/* IPv6 (tunneled), EDNS0 (RFC3226) */
+
+struct tcp_cookie_transactions
+{
+  u_int16_t	tcpct_flags;
+  u_int8_t	__tcpct_pad1;
+  u_int8_t	tcpct_cookie_desired;
+  u_int16_t	tcpct_s_data_desired;
+  u_int16_t	tcpct_used;
+  u_int8_t	tcpct_value[TCP_MSS_DEFAULT];
+};
+
+#endif /* Misc.  */
+
+#endif /* netinet/tcp.h */
diff --git a/include/netinet/udp.h b/include/netinet/udp.h
new file mode 100644
index 0000000..32159cd
--- /dev/null
+++ b/include/netinet/udp.h
@@ -0,0 +1,89 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Copyright (C) 1982, 1986 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __NETINET_UDP_H
+#define __NETINET_UDP_H    1
+
+#include <features.h>
+#include <sys/types.h>
+
+
+/* UDP header as specified by RFC 768, August 1980. */
+
+struct udphdr
+{
+  __extension__ union
+  {
+    struct
+    {
+      u_int16_t uh_sport;		/* source port */
+      u_int16_t uh_dport;		/* destination port */
+      u_int16_t uh_ulen;		/* udp length */
+      u_int16_t uh_sum;		/* udp checksum */
+    };
+    struct
+    {
+      u_int16_t source;
+      u_int16_t dest;
+      u_int16_t len;
+      u_int16_t check;
+    };
+  };
+};
+
+/* UDP socket options */
+#define UDP_CORK	1	/* Never send partially complete segments.  */
+#define UDP_ENCAP	100	/* Set the socket to accept
+				   encapsulated packets.  */
+
+/* UDP encapsulation types */
+#define UDP_ENCAP_ESPINUDP_NON_IKE 1	/* draft-ietf-ipsec-nat-t-ike-00/01 */
+#define UDP_ENCAP_ESPINUDP	2	/* draft-ietf-ipsec-udp-encaps-06 */
+#define UDP_ENCAP_L2TPINUDP	3	/* rfc2661 */
+
+#define SOL_UDP            17      /* sockopt level for UDP */
+
+#endif /* netinet/udp.h */
diff --git a/include/nfs/nfs.h b/include/nfs/nfs.h
new file mode 100644
index 0000000..c32b1d8
--- /dev/null
+++ b/include/nfs/nfs.h
@@ -0,0 +1,31 @@
+/* <nfs/nfs.h> -- ill-specified NFS-related definitions
+   Copyright (C) 1999-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NFS_NFS_H
+#define _NFS_NFS_H 1
+
+/* This file is empty for now.  Its contents do not seem to be
+   standardized in any way.  It exists solely for the sake of
+   <rpcsvc/bootparam_prot.h> which insists on including <nfs/nfs.h>.
+
+   For the time being, we just provide this file here to smooth building
+   the libc distribution (i.e. librpcsvc).  We do not install this file for
+   users, since we haven't really figured out what the right thing to go
+   here is.  */
+
+#endif /* nfs/nfs.h */
diff --git a/include/nl_types.h b/include/nl_types.h
new file mode 100644
index 0000000..e86bd89
--- /dev/null
+++ b/include/nl_types.h
@@ -0,0 +1,54 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NL_TYPES_H
+#define _NL_TYPES_H 1
+
+#include <features.h>
+
+/* The default message set used by the gencat program.  */
+#define NL_SETD 1
+
+/* Value for FLAG parameter of `catgets' to say we want XPG4 compliance.  */
+#define NL_CAT_LOCALE 1
+
+
+__BEGIN_DECLS
+
+/* Message catalog descriptor type.  */
+typedef void *nl_catd;
+
+/* Type used by `nl_langinfo'.  */
+typedef int nl_item;
+
+/* Open message catalog for later use, returning descriptor.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern nl_catd catopen (const char *__cat_name, int __flag) __nonnull ((1));
+
+/* Return translation with NUMBER in SET of CATALOG; if not found
+   return STRING.  */
+extern char *catgets (nl_catd __catalog, int __set, int __number,
+		      const char *__string) __THROW __nonnull ((1));
+
+/* Close message CATALOG.  */
+extern int catclose (nl_catd __catalog) __THROW __nonnull ((1));
+
+__END_DECLS
+
+#endif /* nl_types.h  */
diff --git a/include/nss.h b/include/nss.h
new file mode 100644
index 0000000..6896703
--- /dev/null
+++ b/include/nss.h
@@ -0,0 +1,63 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Define interface to NSS.  This is meant for the interface functions
+   and for implementors of new services.  */
+
+#ifndef _NSS_H
+#define _NSS_H	1
+
+#include <features.h>
+#include <stdint.h>
+
+
+__BEGIN_DECLS
+
+/* Possible results of lookup using a nss_* function.  */
+enum nss_status
+{
+  NSS_STATUS_TRYAGAIN = -2,
+  NSS_STATUS_UNAVAIL,
+  NSS_STATUS_NOTFOUND,
+  NSS_STATUS_SUCCESS,
+  NSS_STATUS_RETURN
+};
+
+
+/* Data structure used for the 'gethostbyname4_r' function.  */
+struct gaih_addrtuple
+  {
+    struct gaih_addrtuple *next;
+    char *name;
+    int family;
+    uint32_t addr[4];
+    uint32_t scopeid;
+  };
+
+
+/* Overwrite service selection for database DBNAME using specification
+   in STRING.
+   This function should only be used by system programs which have to
+   work around non-existing services (e.e., while booting).
+   Attention: Using this function repeatedly will slowly eat up the
+   whole memory since previous selection data cannot be freed.  */
+extern int __nss_configure_lookup (const char *__dbname,
+				   const char *__string) __THROW;
+
+__END_DECLS
+
+#endif /* nss.h */
diff --git a/include/obstack.h b/include/obstack.h
new file mode 100644
index 0000000..85472f9
--- /dev/null
+++ b/include/obstack.h
@@ -0,0 +1,505 @@
+/* obstack.h - object stack macros
+   Copyright (C) 1988-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Summary:
+
+   All the apparent functions defined here are macros. The idea
+   is that you would use these pre-tested macros to solve a
+   very specific set of problems, and they would run fast.
+   Caution: no side-effects in arguments please!! They may be
+   evaluated MANY times!!
+
+   These macros operate a stack of objects.  Each object starts life
+   small, and may grow to maturity.  (Consider building a word syllable
+   by syllable.)  An object can move while it is growing.  Once it has
+   been "finished" it never changes address again.  So the "top of the
+   stack" is typically an immature growing object, while the rest of the
+   stack is of mature, fixed size and fixed address objects.
+
+   These routines grab large chunks of memory, using a function you
+   supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,
+   by calling `obstack_chunk_free'.  You must define them and declare
+   them before using any obstack macros.
+
+   Each independent stack is represented by a `struct obstack'.
+   Each of the obstack macros expects a pointer to such a structure
+   as the first argument.
+
+   One motivation for this package is the problem of growing char strings
+   in symbol tables.  Unless you are "fascist pig with a read-only mind"
+   --Gosper's immortal quote from HAKMEM item 154, out of context--you
+   would not like to put any arbitrary upper limit on the length of your
+   symbols.
+
+   In practice this often means you will build many short symbols and a
+   few long symbols.  At the time you are reading a symbol you don't know
+   how long it is.  One traditional method is to read a symbol into a
+   buffer, realloc()ating the buffer every time you try to read a symbol
+   that is longer than the buffer.  This is beaut, but you still will
+   want to copy the symbol from the buffer to a more permanent
+   symbol-table entry say about half the time.
+
+   With obstacks, you can work differently.  Use one obstack for all symbol
+   names.  As you read a symbol, grow the name in the obstack gradually.
+   When the name is complete, finalize it.  Then, if the symbol exists already,
+   free the newly read name.
+
+   The way we do this is to take a large chunk, allocating memory from
+   low addresses.  When you want to build a symbol in the chunk you just
+   add chars above the current "high water mark" in the chunk.  When you
+   have finished adding chars, because you got to the end of the symbol,
+   you know how long the chars are, and you can create a new object.
+   Mostly the chars will not burst over the highest address of the chunk,
+   because you would typically expect a chunk to be (say) 100 times as
+   long as an average object.
+
+   In case that isn't clear, when we have enough chars to make up
+   the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)
+   so we just point to it where it lies.  No moving of chars is
+   needed and this is the second win: potentially long strings need
+   never be explicitly shuffled. Once an object is formed, it does not
+   change its address during its lifetime.
+
+   When the chars burst over a chunk boundary, we allocate a larger
+   chunk, and then copy the partly formed object from the end of the old
+   chunk to the beginning of the new larger chunk.  We then carry on
+   accreting characters to the end of the object as we normally would.
+
+   A special macro is provided to add a single char at a time to a
+   growing object.  This allows the use of register variables, which
+   break the ordinary 'growth' macro.
+
+   Summary:
+        We allocate large chunks.
+        We carve out one object at a time from the current chunk.
+        Once carved, an object never moves.
+        We are free to append data of any size to the currently
+          growing object.
+        Exactly one object is growing in an obstack at any one time.
+        You can run one obstack per control block.
+        You may have as many control blocks as you dare.
+        Because of the way we do it, you can `unwind' an obstack
+          back to a previous state. (You may remove objects much
+          as you would with a stack.)
+ */
+
+
+/* Don't do the contents of this file more than once.  */
+
+#ifndef _OBSTACK_H
+#define _OBSTACK_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* We need the type of a pointer subtraction.  If __PTRDIFF_TYPE__ is
+   defined, as with GNU C, use that; that way we don't pollute the
+   namespace with <stddef.h>'s symbols.  Otherwise, include <stddef.h>
+   and use ptrdiff_t.  */
+
+#ifdef __PTRDIFF_TYPE__
+# define PTR_INT_TYPE __PTRDIFF_TYPE__
+#else
+# include <stddef.h>
+# define PTR_INT_TYPE ptrdiff_t
+#endif
+
+/* If B is the base of an object addressed by P, return the result of
+   aligning P to the next multiple of A + 1.  B and P must be of type
+   char *.  A + 1 must be a power of 2.  */
+
+#define __BPTR_ALIGN(B, P, A) ((B) + (((P) -(B) + (A)) & ~(A)))
+
+/* Similiar to _BPTR_ALIGN (B, P, A), except optimize the common case
+   where pointers can be converted to integers, aligned as integers,
+   and converted back again.  If PTR_INT_TYPE is narrower than a
+   pointer (e.g., the AS/400), play it safe and compute the alignment
+   relative to B.  Otherwise, use the faster strategy of computing the
+   alignment relative to 0.  */
+
+#define __PTR_ALIGN(B, P, A)						      \
+  __BPTR_ALIGN (sizeof (PTR_INT_TYPE) < sizeof (void *) ? (B) : (char *) 0, \
+                P, A)
+
+#include <string.h>
+
+struct _obstack_chunk           /* Lives at front of each chunk. */
+{
+  char *limit;                  /* 1 past end of this chunk */
+  struct _obstack_chunk *prev;  /* address of prior chunk or NULL */
+  char contents[4];             /* objects begin here */
+};
+
+struct obstack          /* control current object in current chunk */
+{
+  long chunk_size;              /* preferred size to allocate chunks in */
+  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */
+  char *object_base;            /* address of object we are building */
+  char *next_free;              /* where to add next char to current object */
+  char *chunk_limit;            /* address of char after current chunk */
+  union
+  {
+    PTR_INT_TYPE tempint;
+    void *tempptr;
+  } temp;                       /* Temporary for some macros.  */
+  int alignment_mask;           /* Mask of alignment for each object. */
+  /* These prototypes vary based on `use_extra_arg', and we use
+     casts to the prototypeless function type in all assignments,
+     but having prototypes here quiets -Wstrict-prototypes.  */
+  struct _obstack_chunk *(*chunkfun) (void *, long);
+  void (*freefun) (void *, struct _obstack_chunk *);
+  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */
+  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */
+  unsigned maybe_empty_object : 1; /* There is a possibility that the current
+                                      chunk contains a zero-length object.  This
+                                      prevents freeing the chunk if we allocate
+                                      a bigger chunk to replace it. */
+  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed
+                                     handler on error, but retained for binary
+                                     compatibility.  */
+};
+
+/* Declare the external functions we use; they are in obstack.c.  */
+
+extern void _obstack_newchunk (struct obstack *, int);
+extern int _obstack_begin (struct obstack *, int, int,
+                           void *(*)(long), void (*)(void *));
+extern int _obstack_begin_1 (struct obstack *, int, int,
+                             void *(*)(void *, long),
+                             void (*)(void *, void *), void *);
+extern int _obstack_memory_used (struct obstack *);
+
+void obstack_free (struct obstack *__obstack, void *__glibc_block);
+
+
+/* Error handler called when `obstack_chunk_alloc' failed to allocate
+   more memory.  This can be set to a user defined function which
+   should either abort gracefully or use longjump - but shouldn't
+   return.  The default action is to print a message and abort.  */
+extern void (*obstack_alloc_failed_handler) (void);
+
+/* Exit value used when `print_and_abort' is used.  */
+extern int obstack_exit_failure;
+
+/* Pointer to beginning of object being allocated or to be allocated next.
+   Note that this might not be the final address of the object
+   because a new chunk might be needed to hold the final size.  */
+
+#define obstack_base(h) ((void *) (h)->object_base)
+
+/* Size for allocating ordinary chunks.  */
+
+#define obstack_chunk_size(h) ((h)->chunk_size)
+
+/* Pointer to next byte not yet allocated in current chunk.  */
+
+#define obstack_next_free(h)    ((h)->next_free)
+
+/* Mask specifying low bits that should be clear in address of an object.  */
+
+#define obstack_alignment_mask(h) ((h)->alignment_mask)
+
+/* To prevent prototype warnings provide complete argument list.  */
+#define obstack_init(h)							      \
+  _obstack_begin ((h), 0, 0,						      \
+                  (void *(*)(long))obstack_chunk_alloc,			      \
+                  (void (*)(void *))obstack_chunk_free)
+
+#define obstack_begin(h, size)						      \
+  _obstack_begin ((h), (size), 0,					      \
+                  (void *(*)(long))obstack_chunk_alloc,			      \
+                  (void (*)(void *))obstack_chunk_free)
+
+#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun)  \
+  _obstack_begin ((h), (size), (alignment),				      \
+                  (void *(*)(long))(chunkfun),				      \
+                  (void (*)(void *))(freefun))
+
+#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
+  _obstack_begin_1 ((h), (size), (alignment),				      \
+                    (void *(*)(void *, long))(chunkfun),		      \
+                    (void (*)(void *, void *))(freefun), (arg))
+
+#define obstack_chunkfun(h, newchunkfun) \
+  ((h)->chunkfun = (struct _obstack_chunk *(*)(void *, long))(newchunkfun))
+
+#define obstack_freefun(h, newfreefun) \
+  ((h)->freefun = (void (*)(void *, struct _obstack_chunk *))(newfreefun))
+
+#define obstack_1grow_fast(h, achar) (*((h)->next_free)++ = (achar))
+
+#define obstack_blank_fast(h, n) ((h)->next_free += (n))
+
+#define obstack_memory_used(h) _obstack_memory_used (h)
+
+#if defined __GNUC__
+/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and
+   does not implement __extension__.  But that compiler doesn't define
+   __GNUC_MINOR__.  */
+# if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)
+#  define __extension__
+# endif
+
+/* For GNU C, if not -traditional,
+   we can define these macros to compute all args only once
+   without using a global variable.
+   Also, we can avoid using the `temp' slot, to make faster code.  */
+
+# define obstack_object_size(OBSTACK)					      \
+  __extension__								      \
+    ({ struct obstack const *__o = (OBSTACK);				      \
+       (unsigned) (__o->next_free - __o->object_base); })
+
+# define obstack_room(OBSTACK)						      \
+  __extension__								      \
+    ({ struct obstack const *__o = (OBSTACK);				      \
+       (unsigned) (__o->chunk_limit - __o->next_free); })
+
+# define obstack_make_room(OBSTACK, length)				      \
+  __extension__								      \
+    ({ struct obstack *__o = (OBSTACK);					      \
+       int __len = (length);						      \
+       if (__o->chunk_limit - __o->next_free < __len)			      \
+         _obstack_newchunk (__o, __len);				      \
+       (void) 0; })
+
+# define obstack_empty_p(OBSTACK)					      \
+  __extension__								      \
+    ({ struct obstack const *__o = (OBSTACK);				      \
+       (__o->chunk->prev == 0						      \
+        && __o->next_free == __PTR_ALIGN ((char *) __o->chunk,		      \
+                                          __o->chunk->contents,		      \
+                                          __o->alignment_mask)); })
+
+# define obstack_grow(OBSTACK, where, length)				      \
+  __extension__								      \
+    ({ struct obstack *__o = (OBSTACK);					      \
+       int __len = (length);						      \
+       if (__o->next_free + __len > __o->chunk_limit)			      \
+         _obstack_newchunk (__o, __len);				      \
+       memcpy (__o->next_free, where, __len);				      \
+       __o->next_free += __len;						      \
+       (void) 0; })
+
+# define obstack_grow0(OBSTACK, where, length)				      \
+  __extension__								      \
+    ({ struct obstack *__o = (OBSTACK);					      \
+       int __len = (length);						      \
+       if (__o->next_free + __len + 1 > __o->chunk_limit)		      \
+         _obstack_newchunk (__o, __len + 1);				      \
+       memcpy (__o->next_free, where, __len);				      \
+       __o->next_free += __len;						      \
+       *(__o->next_free)++ = 0;						      \
+       (void) 0; })
+
+# define obstack_1grow(OBSTACK, datum)					      \
+  __extension__								      \
+    ({ struct obstack *__o = (OBSTACK);					      \
+       if (__o->next_free + 1 > __o->chunk_limit)			      \
+         _obstack_newchunk (__o, 1);					      \
+       obstack_1grow_fast (__o, datum);					      \
+       (void) 0; })
+
+/* These assume that the obstack alignment is good enough for pointers
+   or ints, and that the data added so far to the current object
+   shares that much alignment.  */
+
+# define obstack_ptr_grow(OBSTACK, datum)				      \
+  __extension__								      \
+    ({ struct obstack *__o = (OBSTACK);					      \
+       if (__o->next_free + sizeof (void *) > __o->chunk_limit)		      \
+         _obstack_newchunk (__o, sizeof (void *));			      \
+       obstack_ptr_grow_fast (__o, datum); })				      \
+
+# define obstack_int_grow(OBSTACK, datum)				      \
+  __extension__								      \
+    ({ struct obstack *__o = (OBSTACK);					      \
+       if (__o->next_free + sizeof (int) > __o->chunk_limit)		      \
+         _obstack_newchunk (__o, sizeof (int));				      \
+       obstack_int_grow_fast (__o, datum); })
+
+# define obstack_ptr_grow_fast(OBSTACK, aptr)				      \
+  __extension__								      \
+    ({ struct obstack *__o1 = (OBSTACK);				      \
+       *(const void **) __o1->next_free = (aptr);			      \
+       __o1->next_free += sizeof (const void *);			      \
+       (void) 0; })
+
+# define obstack_int_grow_fast(OBSTACK, aint)				      \
+  __extension__								      \
+    ({ struct obstack *__o1 = (OBSTACK);				      \
+       *(int *) __o1->next_free = (aint);				      \
+       __o1->next_free += sizeof (int);					      \
+       (void) 0; })
+
+# define obstack_blank(OBSTACK, length)					      \
+  __extension__								      \
+    ({ struct obstack *__o = (OBSTACK);					      \
+       int __len = (length);						      \
+       if (__o->chunk_limit - __o->next_free < __len)			      \
+         _obstack_newchunk (__o, __len);				      \
+       obstack_blank_fast (__o, __len);					      \
+       (void) 0; })
+
+# define obstack_alloc(OBSTACK, length)					      \
+  __extension__								      \
+    ({ struct obstack *__h = (OBSTACK);					      \
+       obstack_blank (__h, (length));					      \
+       obstack_finish (__h); })
+
+# define obstack_copy(OBSTACK, where, length)				      \
+  __extension__								      \
+    ({ struct obstack *__h = (OBSTACK);					      \
+       obstack_grow (__h, (where), (length));				      \
+       obstack_finish (__h); })
+
+# define obstack_copy0(OBSTACK, where, length)				      \
+  __extension__								      \
+    ({ struct obstack *__h = (OBSTACK);					      \
+       obstack_grow0 (__h, (where), (length));				      \
+       obstack_finish (__h); })
+
+/* The local variable is named __o1 to avoid a name conflict
+   when obstack_blank is called.  */
+# define obstack_finish(OBSTACK)					      \
+  __extension__								      \
+    ({ struct obstack *__o1 = (OBSTACK);				      \
+       void *__value = (void *) __o1->object_base;			      \
+       if (__o1->next_free == __value)					      \
+         __o1->maybe_empty_object = 1;					      \
+       __o1->next_free							      \
+         = __PTR_ALIGN (__o1->object_base, __o1->next_free,		      \
+                        __o1->alignment_mask);				      \
+       if (__o1->next_free - (char *) __o1->chunk			      \
+           > __o1->chunk_limit - (char *) __o1->chunk)			      \
+         __o1->next_free = __o1->chunk_limit;				      \
+       __o1->object_base = __o1->next_free;				      \
+       __value; })
+
+# define obstack_free(OBSTACK, OBJ)					      \
+  __extension__								      \
+    ({ struct obstack *__o = (OBSTACK);					      \
+       void *__obj = (OBJ);						      \
+       if (__obj > (void *) __o->chunk && __obj < (void *) __o->chunk_limit)  \
+         __o->next_free = __o->object_base = (char *) __obj;		      \
+       else (obstack_free) (__o, __obj); })
+
+#else /* not __GNUC__ */
+
+# define obstack_object_size(h) \
+  (unsigned) ((h)->next_free - (h)->object_base)
+
+# define obstack_room(h)						      \
+  (unsigned) ((h)->chunk_limit - (h)->next_free)
+
+# define obstack_empty_p(h) \
+  ((h)->chunk->prev == 0						      \
+   && (h)->next_free == __PTR_ALIGN ((char *) (h)->chunk,		      \
+                                     (h)->chunk->contents,		      \
+                                     (h)->alignment_mask))
+
+/* Note that the call to _obstack_newchunk is enclosed in (..., 0)
+   so that we can avoid having void expressions
+   in the arms of the conditional expression.
+   Casting the third operand to void was tried before,
+   but some compilers won't accept it.  */
+
+# define obstack_make_room(h, length)					      \
+  ((h)->temp.tempint = (length),					      \
+   (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		      \
+   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0))
+
+# define obstack_grow(h, where, length)					      \
+  ((h)->temp.tempint = (length),					      \
+   (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		      \
+   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		      \
+   memcpy ((h)->next_free, where, (h)->temp.tempint),			      \
+   (h)->next_free += (h)->temp.tempint)
+
+# define obstack_grow0(h, where, length)				      \
+  ((h)->temp.tempint = (length),					      \
+   (((h)->next_free + (h)->temp.tempint + 1 > (h)->chunk_limit)		      \
+   ? (_obstack_newchunk ((h), (h)->temp.tempint + 1), 0) : 0),		      \
+   memcpy ((h)->next_free, where, (h)->temp.tempint),			      \
+   (h)->next_free += (h)->temp.tempint,					      \
+   *((h)->next_free)++ = 0)
+
+# define obstack_1grow(h, datum)					      \
+  ((((h)->next_free + 1 > (h)->chunk_limit)				      \
+    ? (_obstack_newchunk ((h), 1), 0) : 0),				      \
+   obstack_1grow_fast (h, datum))
+
+# define obstack_ptr_grow(h, datum)					      \
+  ((((h)->next_free + sizeof (char *) > (h)->chunk_limit)		      \
+    ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		      \
+   obstack_ptr_grow_fast (h, datum))
+
+# define obstack_int_grow(h, datum)					      \
+  ((((h)->next_free + sizeof (int) > (h)->chunk_limit)			      \
+    ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			      \
+   obstack_int_grow_fast (h, datum))
+
+# define obstack_ptr_grow_fast(h, aptr)					      \
+  (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr))
+
+# define obstack_int_grow_fast(h, aint)					      \
+  (((int *) ((h)->next_free += sizeof (int)))[-1] = (aint))
+
+# define obstack_blank(h, length)					      \
+  ((h)->temp.tempint = (length),					      \
+   (((h)->chunk_limit - (h)->next_free < (h)->temp.tempint)		      \
+   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		      \
+   obstack_blank_fast (h, (h)->temp.tempint))
+
+# define obstack_alloc(h, length)					      \
+  (obstack_blank ((h), (length)), obstack_finish ((h)))
+
+# define obstack_copy(h, where, length)					      \
+  (obstack_grow ((h), (where), (length)), obstack_finish ((h)))
+
+# define obstack_copy0(h, where, length)				      \
+  (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))
+
+# define obstack_finish(h)						      \
+  (((h)->next_free == (h)->object_base					      \
+    ? (((h)->maybe_empty_object = 1), 0)				      \
+    : 0),								      \
+   (h)->temp.tempptr = (h)->object_base,				      \
+   (h)->next_free							      \
+     = __PTR_ALIGN ((h)->object_base, (h)->next_free,			      \
+                    (h)->alignment_mask),				      \
+   (((h)->next_free - (char *) (h)->chunk				      \
+     > (h)->chunk_limit - (char *) (h)->chunk)				      \
+   ? ((h)->next_free = (h)->chunk_limit) : 0),				      \
+   (h)->object_base = (h)->next_free,					      \
+   (h)->temp.tempptr)
+
+# define obstack_free(h, obj)						      \
+  ((h)->temp.tempint = (char *) (obj) - (char *) (h)->chunk,		      \
+   ((((h)->temp.tempint > 0						      \
+      && (h)->temp.tempint < (h)->chunk_limit - (char *) (h)->chunk))	      \
+   ? (((h)->next_free = (h)->object_base				      \
+                          = (h)->temp.tempint + (char *) (h)->chunk), 0)      \
+   : ((obstack_free) ((h), (h)->temp.tempint + (char *) (h)->chunk), 0)))
+#endif /* not __GNUC__ */
+
+#ifdef __cplusplus
+}       /* C++ */
+#endif
+#endif /* obstack.h */
diff --git a/include/paths.h b/include/paths.h
new file mode 100644
index 0000000..893b4c2
--- /dev/null
+++ b/include/paths.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)paths.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _PATHS_H_
+#define	_PATHS_H_
+
+/* Default search path. */
+#define	_PATH_DEFPATH	"/usr/bin:/bin"
+/* All standard utilities path. */
+#define	_PATH_STDPATH \
+	"/usr/bin:/bin:/usr/sbin:/sbin"
+
+#define	_PATH_BSHELL	"/bin/sh"
+#define	_PATH_CONSOLE	"/dev/console"
+#define	_PATH_CSHELL	"/bin/csh"
+#define	_PATH_DEVDB	"/var/run/dev.db"
+#define	_PATH_DEVNULL	"/dev/null"
+#define	_PATH_DRUM	"/dev/drum"
+#define	_PATH_GSHADOW	"/etc/gshadow"
+#define	_PATH_KMEM	"/dev/kmem"
+#define	_PATH_LASTLOG	"/var/log/lastlog"
+#define	_PATH_MAILDIR	"/var/mail"
+#define	_PATH_MAN	"/usr/share/man"
+#define	_PATH_MEM	"/dev/mem"
+#define	_PATH_MNTTAB	"/etc/fstab"
+#define	_PATH_MOUNTED	"/var/run/mtab"
+#define	_PATH_NOLOGIN	"/etc/nologin"
+#define	_PATH_PRESERVE	"/var/lib"
+#define	_PATH_RWHODIR	"/var/spool/rwho"
+#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
+#define	_PATH_SHADOW	"/etc/shadow"
+#define	_PATH_SHELLS	"/etc/shells"
+#define	_PATH_TTY	"/dev/tty"
+#define	_PATH_UNIX	"/vmunix"
+#define	_PATH_UTMP	"/var/run/utmp"
+#define	_PATH_UTMP_DB	"/var/run/utmp.db"
+#define	_PATH_VI	"/usr/bin/vi"
+#define	_PATH_WTMP	"/var/log/wtmp"
+
+/* Provide trailing slash, since mostly used for building pathnames. */
+#define	_PATH_DEV	"/dev/"
+#define	_PATH_TMP	"/tmp/"
+#define	_PATH_VARDB	"/var/db/"
+#define	_PATH_VARRUN	"/var/run/"
+#define	_PATH_VARTMP	"/var/tmp/"
+
+#endif /* !_PATHS_H_ */
diff --git a/include/poll.h b/include/poll.h
new file mode 100644
index 0000000..06fb41a
--- /dev/null
+++ b/include/poll.h
@@ -0,0 +1 @@
+#include <sys/poll.h>
diff --git a/include/printf.h b/include/printf.h
new file mode 100644
index 0000000..1e79cc1
--- /dev/null
+++ b/include/printf.h
@@ -0,0 +1,188 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_PRINTF_H
+
+#define	_PRINTF_H	1
+#include <features.h>
+
+__BEGIN_DECLS
+
+#define	__need_FILE
+#include <stdio.h>
+#define	__need_size_t
+#define __need_wchar_t
+#include <stddef.h>
+#include <stdarg.h>
+
+
+struct printf_info
+{
+  int prec;			/* Precision.  */
+  int width;			/* Width.  */
+  wchar_t spec;			/* Format letter.  */
+  unsigned int is_long_double:1;/* L flag.  */
+  unsigned int is_short:1;	/* h flag.  */
+  unsigned int is_long:1;	/* l flag.  */
+  unsigned int alt:1;		/* # flag.  */
+  unsigned int space:1;		/* Space flag.  */
+  unsigned int left:1;		/* - flag.  */
+  unsigned int showsign:1;	/* + flag.  */
+  unsigned int group:1;		/* ' flag.  */
+  unsigned int extra:1;		/* For special use.  */
+  unsigned int is_char:1;	/* hh flag.  */
+  unsigned int wide:1;		/* Nonzero for wide character streams.  */
+  unsigned int i18n:1;		/* I flag.  */
+  unsigned int __pad:4;		/* Unused so far.  */
+  unsigned short int user;	/* Bits for user-installed modifiers.  */
+  wchar_t pad;			/* Padding character.  */
+};
+
+
+/* Type of a printf specifier-handler function.
+   STREAM is the FILE on which to write output.
+   INFO gives information about the format specification.
+   ARGS is a vector of pointers to the argument data;
+   the number of pointers will be the number returned
+   by the associated arginfo function for the same INFO.
+
+   The function should return the number of characters written,
+   or -1 for errors.  */
+
+typedef int printf_function (FILE *__stream,
+			     const struct printf_info *__info,
+			     const void *const *__args);
+
+/* Type of a printf specifier-arginfo function.
+   INFO gives information about the format specification.
+   N, ARGTYPES, *SIZE has to contain the size of the parameter for
+   user-defined types, and return value are as for parse_printf_format
+   except that -1 should be returned if the handler cannot handle
+   this case.  This allows to partially overwrite the functionality
+   of existing format specifiers.  */
+
+typedef int printf_arginfo_size_function (const struct printf_info *__info,
+					  size_t __n, int *__argtypes,
+					  int *__size);
+
+/* Old version of 'printf_arginfo_function' without a SIZE parameter.  */
+
+typedef int printf_arginfo_function (const struct printf_info *__info,
+				     size_t __n, int *__argtypes);
+
+/* Type of a function to get a value of a user-defined from the
+   variable argument list.  */
+typedef void printf_va_arg_function (void *__mem, va_list *__ap);
+
+
+/* Register FUNC to be called to format SPEC specifiers; ARGINFO must be
+   specified to determine how many arguments a SPEC conversion requires and
+   what their types are.  */
+
+extern int register_printf_specifier (int __spec, printf_function __func,
+				      printf_arginfo_size_function __arginfo)
+  __THROW;
+
+
+/* Obsolete interface similar to register_printf_specifier.  It can only
+   handle basic data types because the ARGINFO callback does not return
+   information on the size of the user-defined type.  */
+
+extern int register_printf_function (int __spec, printf_function __func,
+				     printf_arginfo_function __arginfo)
+  __THROW __attribute_deprecated__;
+
+
+/* Register a new modifier character sequence.  If the call succeeds
+   it returns a positive value representing the bit set in the USER
+   field in 'struct printf_info'.  */
+
+extern int register_printf_modifier (const wchar_t *__str) __wur __THROW;
+
+
+/* Register variable argument handler for user type.  The return value
+   is to be used in ARGINFO functions to signal the use of the
+   type.  */
+extern int register_printf_type (printf_va_arg_function __fct) __wur __THROW;
+
+
+/* Parse FMT, and fill in N elements of ARGTYPES with the
+   types needed for the conversions FMT specifies.  Returns
+   the number of arguments required by FMT.
+
+   The ARGINFO function registered with a user-defined format is passed a
+   `struct printf_info' describing the format spec being parsed.  A width
+   or precision of INT_MIN means a `*' was used to indicate that the
+   width/precision will come from an arg.  The function should fill in the
+   array it is passed with the types of the arguments it wants, and return
+   the number of arguments it wants.  */
+
+extern size_t parse_printf_format (const char *__restrict __fmt, size_t __n,
+				   int *__restrict __argtypes) __THROW;
+
+
+/* Codes returned by `parse_printf_format' for basic types.
+
+   These values cover all the standard format specifications.
+   Users can reserve new values after PA_LAST for their own types
+   using 'register_printf_type'.  */
+
+enum
+{				/* C type: */
+  PA_INT,			/* int */
+  PA_CHAR,			/* int, cast to char */
+  PA_WCHAR,			/* wide char */
+  PA_STRING,			/* const char *, a '\0'-terminated string */
+  PA_WSTRING,			/* const wchar_t *, wide character string */
+  PA_POINTER,			/* void * */
+  PA_FLOAT,			/* float */
+  PA_DOUBLE,			/* double */
+  PA_LAST
+};
+
+/* Flag bits that can be set in a type returned by `parse_printf_format'.  */
+#define	PA_FLAG_MASK		0xff00
+#define	PA_FLAG_LONG_LONG	(1 << 8)
+#define	PA_FLAG_LONG_DOUBLE	PA_FLAG_LONG_LONG
+#define	PA_FLAG_LONG		(1 << 9)
+#define	PA_FLAG_SHORT		(1 << 10)
+#define	PA_FLAG_PTR		(1 << 11)
+
+
+
+/* Function which can be registered as `printf'-handlers.  */
+
+/* Print floating point value using using abbreviations for the orders
+   of magnitude used for numbers ('k' for kilo, 'm' for mega etc).  If
+   the format specifier is a uppercase character powers of 1000 are
+   used.  Otherwise powers of 1024.  */
+extern int printf_size (FILE *__restrict __fp,
+			const struct printf_info *__info,
+			const void *const *__restrict __args) __THROW;
+
+/* This is the appropriate argument information function for `printf_size'.  */
+extern int printf_size_info (const struct printf_info *__restrict
+			     __info, size_t __n, int *__restrict __argtypes)
+     __THROW;
+
+#ifdef __LDBL_COMPAT
+# include <bits/printf-ldbl.h>
+#endif
+
+__END_DECLS
+
+#endif /* printf.h  */
diff --git a/include/protocols/routed.h b/include/protocols/routed.h
new file mode 100644
index 0000000..befd865
--- /dev/null
+++ b/include/protocols/routed.h
@@ -0,0 +1,101 @@
+/*-
+ * Copyright (c) 1983, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)routed.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _PROTOCOLS_ROUTED_H
+#define	_PROTOCOLS_ROUTED_H 1
+
+#include <sys/socket.h>
+/*
+ * Routing Information Protocol
+ *
+ * Derived from Xerox NS Routing Information Protocol
+ * by changing 32-bit net numbers to sockaddr's and
+ * padding stuff to 32-bit boundaries.
+ */
+#define	RIPVERSION	1
+
+struct netinfo {
+	struct	sockaddr rip_dst;	/* destination net/host */
+	int	rip_metric;		/* cost of route */
+};
+
+struct rip {
+	u_char	rip_cmd;		/* request/response */
+	u_char	rip_vers;		/* protocol version # */
+	u_char	rip_res1[2];		/* pad to 32-bit boundary */
+	union {
+		struct	netinfo ru_nets[1];	/* variable length... */
+		char	ru_tracefile[1];	/* ditto ... */
+	} ripun;
+#define	rip_nets	ripun.ru_nets
+#define	rip_tracefile	ripun.ru_tracefile
+};
+
+/*
+ * Packet types.
+ */
+#define	RIPCMD_REQUEST		1	/* want info */
+#define	RIPCMD_RESPONSE		2	/* responding to request */
+#define	RIPCMD_TRACEON		3	/* turn tracing on */
+#define	RIPCMD_TRACEOFF		4	/* turn it off */
+
+#define	RIPCMD_MAX		5
+#ifdef RIPCMDS
+char *ripcmds[RIPCMD_MAX] =
+  { "#0", "REQUEST", "RESPONSE", "TRACEON", "TRACEOFF" };
+#endif
+
+#define	HOPCNT_INFINITY		16	/* per Xerox NS */
+#define	MAXPACKETSIZE		512	/* max broadcast size */
+
+/*
+ * Timer values used in managing the routing table.
+ * Complete tables are broadcast every SUPPLY_INTERVAL seconds.
+ * If changes occur between updates, dynamic updates containing only changes
+ * may be sent.  When these are sent, a timer is set for a random value
+ * between MIN_WAITTIME and MAX_WAITTIME, and no additional dynamic updates
+ * are sent until the timer expires.
+ *
+ * Every update of a routing entry forces an entry's timer to be reset.
+ * After EXPIRE_TIME without updates, the entry is marked invalid,
+ * but held onto until GARBAGE_TIME so that others may
+ * see it "be deleted".
+ */
+#define	TIMER_RATE		30	/* alarm clocks every 30 seconds */
+
+#define	SUPPLY_INTERVAL		30	/* time to supply tables */
+#define	MIN_WAITTIME		2	/* min. interval to broadcast changes */
+#define	MAX_WAITTIME		5	/* max. time to delay changes */
+
+#define	EXPIRE_TIME		180	/* time to mark entry invalid */
+#define	GARBAGE_TIME		240	/* time to garbage collect */
+
+#endif /* protocols/routed.h */
diff --git a/include/protocols/rwhod.h b/include/protocols/rwhod.h
new file mode 100644
index 0000000..446d6f9
--- /dev/null
+++ b/include/protocols/rwhod.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)rwhod.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _PROTOCOLS_RWHOD_H
+#define	_PROTOCOLS_RWHOD_H 1
+
+#include <sys/types.h>
+
+/*
+ * rwho protocol packet format.
+ */
+struct	outmp {
+	char	out_line[8];		/* tty name */
+	char	out_name[8];		/* user id */
+	int32_t	out_time;		/* time on */
+};
+
+struct	whod {
+	char	wd_vers;		/* protocol version # */
+	char	wd_type;		/* packet type, see below */
+	char	wd_pad[2];
+	int	wd_sendtime;		/* time stamp by sender */
+	int	wd_recvtime;		/* time stamp applied by receiver */
+	char	wd_hostname[32];	/* hosts's name */
+	int	wd_loadav[3];		/* load average as in uptime */
+	int	wd_boottime;		/* time system booted */
+	struct	whoent {
+		struct	outmp we_utmp;	/* active tty info */
+		int	we_idle;	/* tty idle time */
+	} wd_we[1024 / sizeof (struct whoent)];
+};
+
+#define	WHODVERSION	1
+#define	WHODTYPE_STATUS	1		/* host status */
+
+/* We used to define _PATH_RWHODIR here but it's now in <paths.h>.  */
+#include <paths.h>
+
+#endif /* protocols/rwhod.h */
diff --git a/include/protocols/talkd.h b/include/protocols/talkd.h
new file mode 100644
index 0000000..a8f33b1
--- /dev/null
+++ b/include/protocols/talkd.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)talkd.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _PROTOCOLS_TALKD_H
+#define	_PROTOCOLS_TALKD_H 1
+
+/*
+ * This describes the protocol used by the talk server and clients.
+ *
+ * The talk server acts a repository of invitations, responding to
+ * requests by clients wishing to rendezvous for the purpose of
+ * holding a conversation.  In normal operation, a client, the caller,
+ * initiates a rendezvous by sending a CTL_MSG to the server of
+ * type LOOK_UP.  This causes the server to search its invitation
+ * tables to check if an invitation currently exists for the caller
+ * (to speak to the callee specified in the message).  If the lookup
+ * fails, the caller then sends an ANNOUNCE message causing the server
+ * to broadcast an announcement on the callee's login ports requesting
+ * contact.  When the callee responds, the local server uses the
+ * recorded invitation to respond with the appropriate rendezvous
+ * address and the caller and callee client programs establish a
+ * stream connection through which the conversation takes place.
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+/*
+ * Client->server request message format.
+ */
+typedef struct {
+	u_char	vers;		/* protocol version */
+	u_char	type;		/* request type, see below */
+	u_char	answer;		/* not used */
+	u_char	pad;
+	u_int32_t id_num;	/* message id */
+	struct	osockaddr addr;		/* old (4.3) style */
+	struct	osockaddr ctl_addr;	/* old (4.3) style */
+	int32_t	pid;		/* caller's process id */
+#define	NAME_SIZE	12
+	char	l_name[NAME_SIZE];/* caller's name */
+	char	r_name[NAME_SIZE];/* callee's name */
+#define	TTY_SIZE	16
+	char	r_tty[TTY_SIZE];/* callee's tty name */
+} CTL_MSG;
+
+/*
+ * Server->client response message format.
+ */
+typedef struct {
+	u_char	vers;		/* protocol version */
+	u_char	type;		/* type of request message, see below */
+	u_char	answer;		/* response to request message, see below */
+	u_char	pad;
+	u_int32_t id_num;	/* message id */
+	struct	osockaddr addr;	/* address for establishing conversation */
+} CTL_RESPONSE;
+
+#define	TALK_VERSION	1		/* protocol version */
+
+/* message type values */
+#define LEAVE_INVITE	0	/* leave invitation with server */
+#define LOOK_UP		1	/* check for invitation by callee */
+#define DELETE		2	/* delete invitation by caller */
+#define ANNOUNCE	3	/* announce invitation by caller */
+
+/* answer values */
+#define SUCCESS		0	/* operation completed properly */
+#define NOT_HERE	1	/* callee not logged in */
+#define FAILED		2	/* operation failed for unexplained reason */
+#define MACHINE_UNKNOWN	3	/* caller's machine name unknown */
+#define PERMISSION_DENIED 4	/* callee's tty doesn't permit announce */
+#define UNKNOWN_REQUEST	5	/* request has invalid type value */
+#define	BADVERSION	6	/* request has invalid protocol version */
+#define	BADADDR		7	/* request has invalid addr value */
+#define	BADCTLADDR	8	/* request has invalid ctl_addr value */
+
+/*
+ * Operational parameters.
+ */
+#define MAX_LIFE	60	/* max time daemon saves invitations */
+/* RING_WAIT should be 10's of seconds less than MAX_LIFE */
+#define RING_WAIT	30	/* time to wait before resending invitation */
+
+#endif /* protocols/talkd.h */
diff --git a/include/protocols/timed.h b/include/protocols/timed.h
new file mode 100644
index 0000000..b5d4702
--- /dev/null
+++ b/include/protocols/timed.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)timed.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef	_PROTOCOLS_TIMED_H
+#define	_PROTOCOLS_TIMED_H 1
+
+#include <sys/types.h>
+#include <sys/time.h>
+
+/*
+ * Time Synchronization Protocol
+ */
+
+#define	TSPVERSION	1
+#define ANYADDR 	NULL
+#define MAXHOSTNAMELEN	64
+
+struct tsp {
+	u_char	tsp_type;
+	u_char	tsp_vers;
+	u_short	tsp_seq;
+	union {
+		struct timeval tspu_time;
+		char tspu_hopcnt;
+	} tsp_u;
+	char tsp_name[MAXHOSTNAMELEN];
+};
+
+#define	tsp_time	tsp_u.tspu_time
+#define	tsp_hopcnt	tsp_u.tspu_hopcnt
+
+/*
+ * Command types.
+ */
+#define	TSP_ANY			0	/* match any types */
+#define	TSP_ADJTIME		1	/* send adjtime */
+#define	TSP_ACK			2	/* generic acknowledgement */
+#define	TSP_MASTERREQ		3	/* ask for master's name */
+#define	TSP_MASTERACK		4	/* acknowledge master request */
+#define	TSP_SETTIME		5	/* send network time */
+#define	TSP_MASTERUP		6	/* inform slaves that master is up */
+#define	TSP_SLAVEUP		7	/* slave is up but not polled */
+#define	TSP_ELECTION		8	/* advance candidature for master */
+#define	TSP_ACCEPT		9	/* support candidature of master */
+#define	TSP_REFUSE		10	/* reject candidature of master */
+#define	TSP_CONFLICT		11	/* two or more masters present */
+#define	TSP_RESOLVE		12	/* masters' conflict resolution */
+#define	TSP_QUIT		13	/* reject candidature if master is up */
+#define	TSP_DATE		14	/* reset the time (date command) */
+#define	TSP_DATEREQ		15	/* remote request to reset the time */
+#define	TSP_DATEACK		16	/* acknowledge time setting  */
+#define	TSP_TRACEON		17	/* turn tracing on */
+#define	TSP_TRACEOFF		18	/* turn tracing off */
+#define	TSP_MSITE		19	/* find out master's site */
+#define	TSP_MSITEREQ		20	/* remote master's site request */
+#define	TSP_TEST		21	/* for testing election algo */
+#define	TSP_SETDATE		22	/* New from date command */
+#define	TSP_SETDATEREQ		23	/* New remote for above */
+#define	TSP_LOOP		24	/* loop detection packet */
+
+#define	TSPTYPENUMBER		25
+
+#ifdef TSPTYPES
+char *tsptype[TSPTYPENUMBER] =
+  { "ANY", "ADJTIME", "ACK", "MASTERREQ", "MASTERACK", "SETTIME", "MASTERUP",
+  "SLAVEUP", "ELECTION", "ACCEPT", "REFUSE", "CONFLICT", "RESOLVE", "QUIT",
+  "DATE", "DATEREQ", "DATEACK", "TRACEON", "TRACEOFF", "MSITE", "MSITEREQ",
+  "TEST", "SETDATE", "SETDATEREQ", "LOOP" };
+#endif
+
+#endif /* protocols/timed.h */
diff --git a/include/pthread.h b/include/pthread.h
new file mode 100644
index 0000000..1d4d3c7
--- /dev/null
+++ b/include/pthread.h
@@ -0,0 +1,7 @@
+#ifndef _PTHREAD_H
+#include <pthread/pthread.h>
+
+extern int __pthread_mutex_lock (pthread_mutex_t *__mutex);
+extern int __pthread_mutex_unlock (pthread_mutex_t *__mutex);
+
+#endif
diff --git a/include/pthread/pthread.h b/include/pthread/pthread.h
new file mode 100644
index 0000000..3aa6a93
--- /dev/null
+++ b/include/pthread/pthread.h
@@ -0,0 +1,835 @@
+/* Copyright (C) 2000, 2002, 2005, 2006, 2007, 2008, 2009, 2010
+     Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ *	POSIX Threads Extension: ???			<pthread.h>
+ */
+
+#ifndef _PTHREAD_H
+#define _PTHREAD_H	1
+
+#include <features.h>
+
+#include <sys/cdefs.h>
+#ifndef __extern_inline
+/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
+   inline semantics, unless -fgnu89-inline is used.  */
+# if !defined __cplusplus || __GNUC_PREREQ (4,3)
+#  if defined __GNUC_STDC_INLINE__ || defined __cplusplus
+#   define __extern_inline extern __inline __attribute__ ((__gnu_inline__))
+#   if __GNUC_PREREQ (4,3)
+#    define __extern_always_inline \
+   extern __always_inline __attribute__ ((__gnu_inline__, __artificial__))
+#   else
+#    define __extern_always_inline \
+   extern __always_inline __attribute__ ((__gnu_inline__))
+#   endif
+#  else
+#   define __extern_inline extern __inline
+#   define __extern_always_inline extern __always_inline
+#  endif
+# endif
+#endif
+
+#include <sched.h>
+#include <time.h>
+
+__BEGIN_DECLS
+
+#include <pthread/pthreadtypes.h>
+
+#include <bits/pthread.h>
+
+/* Possible values for the process shared attribute.  */
+#define PTHREAD_PROCESS_PRIVATE __PTHREAD_PROCESS_PRIVATE
+#define PTHREAD_PROCESS_SHARED __PTHREAD_PROCESS_SHARED
+
+
+/* Thread attributes.  */
+
+/* Possible values for the inheritsched attribute.  */
+#define PTHREAD_EXPLICIT_SCHED __PTHREAD_EXPLICIT_SCHED
+#define PTHREAD_INHERIT_SCHED __PTHREAD_INHERIT_SCHED
+
+/* Possible values for the `contentionscope' attribute.  */
+#define PTHREAD_SCOPE_SYSTEM __PTHREAD_SCOPE_SYSTEM
+#define PTHREAD_SCOPE_PROCESS __PTHREAD_SCOPE_PROCESS
+
+/* Possible values for the `detachstate' attribute.  */
+#define PTHREAD_CREATE_JOINABLE __PTHREAD_CREATE_JOINABLE
+#define PTHREAD_CREATE_DETACHED __PTHREAD_CREATE_DETACHED
+
+#include <bits/thread-attr.h>
+
+/* Initialize the thread attribute object in *ATTR to the default
+   values.  */
+extern int pthread_attr_init (pthread_attr_t *__attr) __THROW __nonnull ((1));
+
+/* Destroy the thread attribute object in *ATTR.  */
+extern int pthread_attr_destroy (pthread_attr_t *__attr)
+	__THROW __nonnull ((1));
+
+
+/* Return the value of the inheritsched attribute in *ATTR in
+   *INHERITSCHED.  */
+extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict __attr,
+					 int *__restrict __inheritsched)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the inheritsched attribute in *ATTR to
+   INHERITSCHED.  */
+extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
+					 int __inheritsched)
+	__THROW __nonnull ((1));
+
+
+/* Return the value of the schedparam attribute in *ATTR in *PARAM.  */
+extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
+				       struct sched_param *__restrict __param)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the schedparam attribute in *ATTR to PARAM.  */
+extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
+				       const struct sched_param *__restrict
+				       __param) __THROW __nonnull ((1, 2));
+
+
+/* Return the value of the schedpolicy attribute in *ATTR to *POLICY.  */
+extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict __attr,
+					int *__restrict __policy)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the schedpolicy attribute in *ATTR to POLICY.  */
+extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr,
+					int __policy)
+	__THROW __nonnull ((1));
+
+
+/* Return the value of the contentionscope attribute in *ATTR in
+   *CONTENTIONSCOPE.  */
+extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
+				  int *__restrict __contentionscope)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the contentionscope attribute in *ATTR to
+   CONTENTIONSCOPE.  */
+extern int pthread_attr_setscope (pthread_attr_t *__attr,
+				  int __contentionscope)
+	__THROW __nonnull ((1));
+
+
+/* Return the value of the stackaddr attribute in *ATTR in
+   *STACKADDR.  */
+extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict __attr,
+				      void **__restrict __stackaddr)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the stackaddr attribute in *ATTR to STACKADDR.  */
+extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
+				      void *__stackaddr)
+	__THROW __nonnull ((1));
+
+
+#ifdef __USE_XOPEN2K
+/* Return the value of the stackaddr and stacksize attributes in *ATTR
+   in *STACKADDR and *STACKSIZE respectively.  */
+extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
+				  void **__restrict __stackaddr,
+				  size_t *__restrict __stacksize)
+	__THROW __nonnull ((1, 2, 3));
+
+/* Set the value of the stackaddr and stacksize attributes in *ATTR to
+   STACKADDR and STACKSIZE respectively.  */
+extern int pthread_attr_setstack (pthread_attr_t *__attr,
+				  void *__stackaddr,
+				  size_t __stacksize)
+	__THROW __nonnull ((1));
+#endif
+
+
+/* Return the value of the detachstate attribute in *ATTR in
+   *DETACHSTATE.  */
+extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
+					int *__detachstate)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the detachstate attribute in *ATTR to
+   DETACHSTATE.  */
+extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
+					int __detachstate)
+	__THROW __nonnull ((1));
+
+
+/* Return the value of the guardsize attribute in *ATTR in
+   *GUARDSIZE.  */
+extern int pthread_attr_getguardsize (const pthread_attr_t *__restrict __attr,
+				      size_t *__restrict __guardsize)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the guardsize attribute in *ATTR to GUARDSIZE.  */
+extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
+				      size_t __guardsize)
+	__THROW __nonnull ((1));
+
+
+/* Return the value of the stacksize attribute in *ATTR in
+   *STACKSIZE.  */
+extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict __attr,
+				      size_t *__restrict __stacksize)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the stacksize attribute in *ATTR to STACKSIZE.  */
+extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
+				      size_t __stacksize)
+	__THROW __nonnull ((1));
+
+#ifdef __USE_GNU
+/* Initialize thread attribute *ATTR with attributes corresponding to the
+   already running thread THREAD.  It shall be called on an uninitialized ATTR
+   and destroyed with pthread_attr_destroy when no longer needed.  */
+extern int pthread_getattr_np (pthread_t __thr, pthread_attr_t *__attr)
+	__THROW __nonnull ((2));
+#endif
+
+
+/* Create a thread with attributes given by ATTR, executing
+   START_ROUTINE with argument ARG.  */
+extern int pthread_create (pthread_t *__restrict __threadp,
+			   __const pthread_attr_t *__restrict __attr,
+			   void *(*__start_routine)(void *),
+			   void *__restrict __arg) __THROWNL __nonnull ((1, 3));
+
+/* Terminate the current thread and make STATUS available to any
+   thread that might join us.  */
+extern void pthread_exit (void *__status) __attribute__ ((__noreturn__));
+
+/* Make calling thread wait for termination of thread THREAD.  Return
+   the exit status of the thread in *STATUS.  */
+extern int pthread_join (pthread_t __threadp, void **__status);
+
+/* Indicate that the storage for THREAD can be reclaimed when it
+   terminates.  */
+extern int pthread_detach (pthread_t __threadp);
+
+/* Compare thread IDs T1 and T2.  Return nonzero if they are equal, 0
+   if they are not.  */
+extern int pthread_equal (pthread_t __t1, pthread_t __t2);
+
+# ifdef __USE_EXTERN_INLINES
+
+__extern_inline int
+pthread_equal (pthread_t __t1, pthread_t __t2)
+{
+  return __pthread_equal (__t1, __t2);
+}
+
+# endif /* Use extern inlines.  */
+
+
+/* Return the thread ID of the calling thread.  */
+extern pthread_t pthread_self (void) __THROW;
+
+
+/* Mutex attributes.  */
+
+#define PTHREAD_PRIO_NONE_NP __PTHREAD_PRIO_NONE
+#define PTHREAD_PRIO_INHERIT_NP __PTHREAD_PRIO_INHERIT
+#define PTHREAD_PRIO_PROTECT_NP __PTHREAD_PRIO_PROTECT
+#ifdef __USE_UNIX98
+#define PTHREAD_PRIO_NONE PTHREAD_PRIO_NONE_NP
+#define PTHREAD_PRIO_INHERIT PTHREAD_PRIO_INHERIT_NP
+#define PTHREAD_PRIO_PROTECT PTHREAD_PRIO_PROTECT_NP
+#endif
+
+#define PTHREAD_MUTEX_TIMED_NP __PTHREAD_MUTEX_TIMED
+#define PTHREAD_MUTEX_ERRORCHECK_NP __PTHREAD_MUTEX_ERRORCHECK
+#define PTHREAD_MUTEX_RECURSIVE_NP __PTHREAD_MUTEX_RECURSIVE
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
+#define PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_TIMED_NP
+#define PTHREAD_MUTEX_ERRORCHECK PTHREAD_MUTEX_ERRORCHECK_NP
+#define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
+#define PTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL
+#endif
+#ifdef __USE_GNU
+/* For compatibility.  */
+#define PTHREAD_MUTEX_FAST_NP PTHREAD_MUTEX_TIMED_NP
+#endif
+
+#include <bits/mutex-attr.h>
+
+/* Initialize the mutex attribute object in *ATTR to the default
+   values.  */
+extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr)
+	__THROW __nonnull ((1));
+
+/* Destroy the mutex attribute structure in *ATTR.  */
+extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr)
+	__THROW __nonnull ((1));
+
+
+#ifdef __USE_UNIX98
+/* Return the value of the prioceiling attribute in *ATTR in
+   *PRIOCEILING.  */
+extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict __attr,
+					    int *__restrict __prioceiling)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the prioceiling attribute in *ATTR to
+   PRIOCEILING.  */
+extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr,
+					    int __prioceiling)
+	__THROW __nonnull ((1));
+
+
+/* Return the value of the protocol attribute in *ATTR in
+   *PROTOCOL.  */
+extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict __attr,
+					 int *__restrict __protocol)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the protocol attribute in *ATTR to PROTOCOL.  */
+extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr,
+					 int __protocol)
+	__THROW __nonnull ((1));
+#endif
+
+
+/* Return the value of the process shared attribute in *ATTR in
+   *PSHARED.  */
+extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict __attr,
+					int *__restrict __pshared)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the process shared attribute in *ATTR to
+   PSHARED.  */
+extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr,
+					int __pshared)
+	__THROW __nonnull ((1));
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
+/* Return the value of the type attribute in *ATTR in *TYPE.  */
+extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict __attr,
+				     int *__restrict __type)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the type attribute in *ATTR to TYPE.  */
+extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr,
+				     int __type)
+	__THROW __nonnull ((1));
+#endif
+
+
+/* Mutexes.  */
+
+#include <bits/mutex.h>
+
+#define PTHREAD_MUTEX_INITIALIZER __PTHREAD_MUTEX_INITIALIZER
+/* Static initializer for recursive mutexes.  */
+
+#ifdef __USE_GNU
+# define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \
+  __PTHREAD_ERRORCHECK_MUTEX_INITIALIZER
+# define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \
+  __PTHREAD_RECURSIVE_MUTEX_INITIALIZER
+#endif
+
+/* Create a mutex with attributes given by ATTR and store it in
+   *__MUTEX.  */
+extern int pthread_mutex_init (struct __pthread_mutex *__restrict __mutex,
+			       const pthread_mutexattr_t *__restrict __attr)
+	__THROW __nonnull ((1));
+
+/* Destroy the mutex __MUTEX.  */
+extern int pthread_mutex_destroy (struct __pthread_mutex *__mutex)
+	__THROW __nonnull ((1));
+
+/* Wait until lock for MUTEX becomes available and lock it.  */
+extern int pthread_mutex_lock (pthread_mutex_t *__mutex);
+
+/* Try to lock MUTEX.  */
+extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
+	__THROWNL __nonnull ((1));
+
+#ifdef __USE_XOPEN2K
+/* Try to lock MUTEX, block until *ABSTIME if it is already held.  */
+extern int pthread_mutex_timedlock (struct __pthread_mutex *__restrict __mutex,
+				    const struct timespec *__restrict __abstime)
+	__THROWNL __nonnull ((1, 2));
+#endif
+
+/* Unlock MUTEX.  */
+extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
+	__THROWNL __nonnull ((1));
+
+/* Transfer ownership of the mutex MUTEX to the thread TID.  The
+   caller must own the lock.  */
+extern int __pthread_mutex_transfer_np (struct __pthread_mutex *__mutex,
+					pthread_t __tid)
+	__THROWNL __nonnull ((1));
+
+
+#ifdef __USE_UNIX98
+/* Return the priority ceiling of mutex *MUTEX in *PRIOCEILING.  */
+extern int pthread_mutex_getprioceiling (const pthread_mutex_t *__restrict __mutex,
+					 int *__restrict __prioceiling)
+	__THROW __nonnull ((1, 2));
+
+/* After acquiring the mutex *MUTEX, set its priority ceiling to PRIO
+   and return the old priority ceiling in *OLDPRIO.  Before returning,
+   release the mutex.  */
+extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
+					 int __prio, int *__restrict __oldprio)
+	__THROW __nonnull ((1, 3));
+#endif
+
+
+
+/* Condition attributes.  */
+
+#include <bits/condition-attr.h>
+
+/* Initialize the condition attribute in *ATTR to the default
+   values.  */
+extern int pthread_condattr_init (pthread_condattr_t *__attr)
+	__THROW __nonnull ((1));
+
+/* Destroy the condition attribute structure in *ATTR.  */
+extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
+	__THROW __nonnull ((1));
+
+
+#ifdef __USE_XOPEN2K
+/* Return the value of the clock attribute in *ATTR in *CLOCK_ID.  */
+extern int pthread_condattr_getclock (const pthread_condattr_t *__restrict __attr,
+				      __clockid_t *__restrict __clock_id)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the clock attribute in *ATTR to CLOCK_ID.  */
+extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
+				      __clockid_t __clock_id)
+	__THROW __nonnull ((1));
+#endif
+
+
+/* Return the value of the process shared attribute in *ATTR in
+   *PSHARED.  */
+extern int pthread_condattr_getpshared (const pthread_condattr_t *__restrict __attr,
+					int *__restrict __pshared)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the process shared attribute in *ATTR to
+   PSHARED.  */
+extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
+					int __pshared)
+	__THROW __nonnull ((1));
+
+
+/* Condition variables.  */
+
+#include <bits/condition.h>
+
+#define PTHREAD_COND_INITIALIZER __PTHREAD_COND_INITIALIZER
+
+extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
+			      const pthread_condattr_t *__restrict __attr)
+	__THROW __nonnull ((1));
+
+extern int pthread_cond_destroy (pthread_cond_t *__cond)
+	__THROW __nonnull ((1));
+
+/* Unblock at least one of the threads that are blocked on condition
+   variable COND.  */
+extern int pthread_cond_signal (pthread_cond_t *__cond)
+	__THROWNL __nonnull ((1));
+
+/* Unblock all threads that are blocked on condition variable COND.  */
+extern int pthread_cond_broadcast (pthread_cond_t *__cond)
+	__THROWNL __nonnull ((1));
+
+/* Block on condition variable COND.  MUTEX should be held by the
+   calling thread.  On success, MUTEX will be held by the calling
+   thread.  */
+extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
+			      pthread_mutex_t *__restrict __mutex)
+	 __nonnull ((1, 2));
+
+/* Block on condition variable COND.  MUTEX should be held by the
+   calling thread. On success, MUTEX will be held by the calling
+   thread.  If the time specified by ABSTIME passes, ETIMEDOUT is
+   returned, and MUTEX will nevertheless be held.  */
+extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
+				   pthread_mutex_t *__restrict __mutex,
+				   __const struct timespec *__restrict __abstime)
+	 __nonnull ((1, 2, 3));
+
+
+/* Spin locks.  */
+
+#ifdef __USE_XOPEN2K
+
+# include <bits/spin-lock.h>
+
+#define PTHREAD_SPINLOCK_INITIALIZER __PTHREAD_SPIN_LOCK_INITIALIZER
+
+/* Destroy the spin lock object LOCK.  */
+extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
+	__nonnull ((1));
+
+/* Initialize the spin lock object LOCK.  PSHARED determines whether
+   the spin lock can be operated upon by multiple processes.  */
+extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
+	__nonnull ((1));
+
+/* Lock the spin lock object LOCK.  If the lock is held by another
+   thread spin until it becomes available.  */
+extern int pthread_spin_lock (pthread_spinlock_t *__lock)
+	__nonnull ((1));
+
+/* Lock the spin lock object LOCK.  Fail if the lock is held by
+   another thread.  */
+extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
+	__nonnull ((1));
+
+/* Unlock the spin lock object LOCK.  */
+extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
+	__nonnull ((1));
+
+# ifdef __USE_EXTERN_INLINES
+
+# include <bits/spin-lock-inline.h>
+
+__extern_inline int
+pthread_spin_destroy (pthread_spinlock_t *__lock)
+{
+  return __pthread_spin_destroy (__lock);
+}
+
+__extern_inline int
+pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
+{
+  return __pthread_spin_init (__lock, __pshared);
+}
+
+__extern_inline int
+pthread_spin_lock (pthread_spinlock_t *__lock)
+{
+  return __pthread_spin_lock (__lock);
+}
+
+__extern_inline int
+pthread_spin_trylock (pthread_spinlock_t *__lock)
+{
+  return __pthread_spin_trylock (__lock);
+}
+
+__extern_inline int
+pthread_spin_unlock (pthread_spinlock_t *__lock)
+{
+  return __pthread_spin_unlock (__lock);
+}
+
+# endif /* Use extern inlines.  */
+
+#endif /* XPG6.  */
+
+
+/* rwlock attributes.  */
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+
+#include <bits/rwlock-attr.h>
+
+/* Initialize rwlock attribute object in *ATTR to the default
+   values.  */
+extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
+	__THROW __nonnull ((1));
+
+/* Destroy the rwlock attribute object in *ATTR.  */
+extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
+	__THROW __nonnull ((1));
+
+
+/* Return the value of the process shared attribute in *ATTR in
+   *PSHARED.  */
+extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *__restrict __attr,
+					  int *__restrict __pshared)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the process shared atrribute in *ATTR to
+   PSHARED.  */
+extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
+					  int __pshared)
+	__THROW __nonnull ((1));
+
+
+/* rwlocks.  */
+
+#include <bits/rwlock.h>
+
+#define PTHREAD_RWLOCK_INITIALIZER __PTHREAD_RWLOCK_INITIALIZER
+/* Create a rwlock object with attributes given by ATTR and strore the
+   result in *RWLOCK.  */
+extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
+				const pthread_rwlockattr_t *__restrict __attr)
+	__THROW __nonnull ((1));
+
+/* Destroy the rwlock *RWLOCK.  */
+extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
+	__THROW __nonnull ((1));
+
+/* Acquire the rwlock *RWLOCK for reading.  */
+extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
+	__THROWNL __nonnull ((1));
+
+/* Acquire the rwlock *RWLOCK for reading.  */
+extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
+	__THROWNL __nonnull ((1));
+
+# ifdef __USE_XOPEN2K
+/* Acquire the rwlock *RWLOCK for reading blocking until *ABSTIME if
+   it is already held.  */
+extern int pthread_rwlock_timedrdlock (struct __pthread_rwlock *__restrict __rwlock,
+				       const struct timespec *__restrict __abstime)
+	__THROWNL __nonnull ((1, 2));
+# endif
+
+/* Acquire the rwlock *RWLOCK for writing.  */
+extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
+	__THROWNL __nonnull ((1));
+
+/* Try to acquire the rwlock *RWLOCK for writing.  */
+extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
+	__THROWNL __nonnull ((1));
+
+# ifdef __USE_XOPEN2K
+/* Acquire the rwlock *RWLOCK for writing blocking until *ABSTIME if
+   it is already held.  */
+extern int pthread_rwlock_timedwrlock (struct __pthread_rwlock *__restrict __rwlock,
+				       const struct timespec *__restrict __abstime)
+	__THROWNL __nonnull ((1, 2));
+# endif
+
+/* Release the lock held by the current thread on *RWLOCK.  */
+extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
+	__THROWNL __nonnull ((1));
+
+#endif /* __USE_UNIX98 || __USE_XOPEN2K */
+
+
+
+/* Cancelation.  */
+
+/* Register a cleanup handler.  */
+extern void pthread_cleanup_push (void (*__routine) (void *), void *__arg);
+
+/* Unregister a cleanup handler.  */
+extern void pthread_cleanup_pop (int __execute);
+
+#include <bits/cancelation.h>
+
+#define pthread_cleanup_push(rt, rtarg) __pthread_cleanup_push(rt, rtarg)
+#define pthread_cleanup_pop(execute) __pthread_cleanup_pop(execute)
+
+#define PTHREAD_CANCEL_DISABLE 0
+#define PTHREAD_CANCEL_ENABLE 1
+
+/* Return the calling thread's cancelation state in *OLDSTATE and set
+   its state to STATE.  */
+extern int pthread_setcancelstate (int __state, int *__oldstate);
+
+#define PTHREAD_CANCEL_DEFERRED 0
+#define PTHREAD_CANCEL_ASYNCHRONOUS 1
+
+/* Return the calling thread's cancelation type in *OLDTYPE and set
+   its type to TYPE.  */
+extern int pthread_setcanceltype (int __type, int *__oldtype);
+
+/* Value returned by pthread_join if the target thread was
+   canceled.  */
+#define PTHREAD_CANCELED ((void *) -1)
+
+/* Cancel THEAD.  */
+extern int pthread_cancel (pthread_t __thr);
+
+/* Add an explicit cancelation point.  */
+extern void pthread_testcancel (void);
+
+
+/* Barriers attributes.  */
+
+#ifdef __USE_XOPEN2K
+
+#include <bits/barrier-attr.h>
+
+/* Initialize barrier attribute object in *ATTR to the default
+   values.  */
+extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
+	__THROW __nonnull ((1));
+
+/* Destroy the barrier attribute object in *ATTR.  */
+extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
+	__THROW __nonnull ((1));
+
+
+/* Return the value of the process shared attribute in *ATTR in
+   *PSHARED.  */
+extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *__restrict __attr,
+					   int *__restrict __pshared)
+	__THROW __nonnull ((1, 2));
+
+/* Set the value of the process shared atrribute in *ATTR to
+   PSHARED.  */
+extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
+					   int __pshared)
+	__THROW __nonnull ((1));
+
+
+/* Barriers.  */
+
+#include <bits/barrier.h>
+
+/* Returned by pthread_barrier_wait to exactly one thread each time a
+   barrier is passed.  */
+#define PTHREAD_BARRIER_SERIAL_THREAD -1
+
+/* Initialize barrier BARRIER.  */
+extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
+				const pthread_barrierattr_t *__restrict __attr,
+				unsigned __count)
+	__THROW __nonnull ((1));
+
+/* Destroy barrier BARRIER.  */
+extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
+	__THROW __nonnull ((1));
+
+/* Wait on barrier BARRIER.  */
+extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
+	__THROWNL __nonnull ((1));
+
+#endif /* __USE_XOPEN2K */
+
+
+
+/* Thread specific data.  */
+
+#include <bits/thread-specific.h>
+
+/* Create a thread specific data key in KEY visible to all threads.
+   On thread destruction, DESTRUCTOR shall be called with the thread
+   specific data associate with KEY if it is not NULL.  */
+extern int pthread_key_create (pthread_key_t *__key,
+			       void (*__destructor) (void *))
+	__THROW __nonnull ((1));
+
+/* Delete the thread specific data key KEY.  The associated destructor
+   function is not called.  */
+extern int pthread_key_delete (pthread_key_t __key) __THROW;
+
+/* Return the caller thread's thread specific value of KEY.  */
+extern void *pthread_getspecific (pthread_key_t __key) __THROW;
+
+/* Set the caller thread's thread specific value of KEY to VALUE.  */
+extern int pthread_setspecific (pthread_key_t __key, const void *__value)
+	__THROW;
+
+
+/* Dynamic package initialization.  */
+
+#include <bits/once.h>
+
+#define PTHREAD_ONCE_INIT __PTHREAD_ONCE_INIT
+
+/* Call INIT_ROUTINE if this function has never been called with
+   *ONCE_CONTROL, otherwise do nothing.  */
+extern int pthread_once (pthread_once_t *__once_control,
+			 void (*__init_routine) (void)) __nonnull ((1, 2));
+
+
+/* Concurrency.  */
+
+#ifdef __USE_UNIX98
+/* Set the desired concurrency level to NEW_LEVEL.  */
+extern int pthread_setconcurrency (int __new_level) __THROW;
+
+/* Get the current concurrency level.  */
+extern int pthread_getconcurrency (void) __THROW;
+#endif
+
+
+/* Forking.  */
+
+/* Register the function PREPARE to be run before the process forks,
+   the function PARENT to be run after a fork in the parent and the
+   function CHILD to be run in the child after the fork.  If no
+   handling is desired then any of PREPARE, PARENT and CHILD may be
+   NULL.  The prepare handles will be called in the reverse order
+   which they were registered and the parent and child handlers in the
+   order in which they were registered.  */
+extern int pthread_atfork (void (*__prepare) (void), void (*__parent) (void),
+			   void (*__child) (void)) __THROW;
+
+
+/* Signals (should be in <signal.h>).  */
+
+/* Send signal SIGNO to thread THREAD.  */
+extern int pthread_kill (pthread_t __thr, int __signo) __THROW;
+
+
+/* Time.  */
+
+#ifdef __USE_XOPEN2K
+/* Return the thread cpu clock.  */
+extern int pthread_getcpuclockid (pthread_t __thr, __clockid_t *__clock)
+	__THROW __nonnull ((2));
+#endif
+
+
+/* Scheduling.  */
+
+/* Return thread THREAD's scheduling paramters.  */
+extern int pthread_getschedparam (pthread_t __thr, int *__restrict __policy,
+				  struct sched_param *__restrict __param)
+	__THROW __nonnull ((2, 3));
+
+/* Set thread THREAD's scheduling paramters.  */
+extern int pthread_setschedparam (pthread_t __thr, int __policy,
+				  const struct sched_param *__param)
+	__THROW __nonnull ((3));
+
+/* Set thread THREAD's scheduling priority.  */
+extern int pthread_setschedprio (pthread_t __thr, int __prio) __THROW;
+
+#ifdef __USE_GNU
+/* Yield the processor to another thread or process.
+   This function is similar to the POSIX `sched_yield' function but
+   might be differently implemented in the case of a m-on-n thread
+   implementation.  */
+extern int pthread_yield (void) __THROW;
+#endif
+
+
+/* Kernel-specific interfaces.  */
+
+#include <bits/pthread-np.h>
+
+
+__END_DECLS
+
+#endif /* pthread.h */
diff --git a/include/pthread/pthreadtypes.h b/include/pthread/pthreadtypes.h
new file mode 100644
index 0000000..33bd009
--- /dev/null
+++ b/include/pthread/pthreadtypes.h
@@ -0,0 +1,125 @@
+/* Copyright (C) 2000, 2002, 2005, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ *	POSIX Threads Extension: ???			<pthreadtypes.h>
+ */
+
+#ifndef _PTHREADTYPES_H
+#define _PTHREADTYPES_H	1
+
+#include <features.h>
+
+#include <bits/types.h>
+
+__BEGIN_DECLS
+
+#include <bits/pthread.h>
+typedef __pthread_t pthread_t;
+
+/* Possible values for the process shared attribute.  */
+enum __pthread_process_shared
+  {
+    __PTHREAD_PROCESS_PRIVATE = 0,
+    __PTHREAD_PROCESS_SHARED
+  };
+
+/* Possible values for the inheritsched attribute.  */
+enum __pthread_inheritsched
+  {
+    __PTHREAD_EXPLICIT_SCHED = 0,
+    __PTHREAD_INHERIT_SCHED
+  };
+
+/* Possible values for the `contentionscope' attribute.  */
+enum __pthread_contentionscope
+  {
+    __PTHREAD_SCOPE_SYSTEM = 0,
+    __PTHREAD_SCOPE_PROCESS
+  };
+
+/* Possible values for the `detachstate' attribute.  */
+enum __pthread_detachstate
+  {
+    __PTHREAD_CREATE_JOINABLE = 0,
+    __PTHREAD_CREATE_DETACHED
+  };
+
+#include <bits/thread-attr.h>
+typedef struct __pthread_attr pthread_attr_t;
+
+enum __pthread_mutex_protocol
+  {
+    __PTHREAD_PRIO_NONE= 0,
+    __PTHREAD_PRIO_INHERIT,
+    __PTHREAD_PRIO_PROTECT
+  };
+
+enum __pthread_mutex_type
+  {
+    __PTHREAD_MUTEX_TIMED,
+    __PTHREAD_MUTEX_ERRORCHECK,
+    __PTHREAD_MUTEX_RECURSIVE
+  };
+
+#include <bits/mutex-attr.h>
+typedef struct __pthread_mutexattr pthread_mutexattr_t;
+
+#include <bits/mutex.h>
+typedef struct __pthread_mutex pthread_mutex_t;
+
+#include <bits/condition-attr.h>
+typedef struct __pthread_condattr pthread_condattr_t;
+
+#include <bits/condition.h>
+typedef struct __pthread_cond pthread_cond_t;
+
+#ifdef __USE_XOPEN2K
+# include <bits/spin-lock.h>
+typedef __pthread_spinlock_t pthread_spinlock_t;
+#endif /* XPG6.  */
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+
+#include <bits/rwlock-attr.h>
+typedef struct __pthread_rwlockattr pthread_rwlockattr_t;
+
+#include <bits/rwlock.h>
+typedef struct __pthread_rwlock pthread_rwlock_t;
+
+#endif /* __USE_UNIX98 || __USE_XOPEN2K */
+
+#ifdef __USE_XOPEN2K
+
+#include <bits/barrier-attr.h>
+typedef struct __pthread_barrierattr pthread_barrierattr_t;
+
+#include <bits/barrier.h>
+typedef struct __pthread_barrier pthread_barrier_t;
+
+#endif /* __USE_XOPEN2K */
+
+#include <bits/thread-specific.h>
+typedef __pthread_key pthread_key_t;
+
+#include <bits/once.h>
+typedef struct __pthread_once pthread_once_t;
+
+__END_DECLS
+
+#endif /* pthreadtypes.h */
diff --git a/include/pty.h b/include/pty.h
new file mode 100644
index 0000000..6321c12
--- /dev/null
+++ b/include/pty.h
@@ -0,0 +1,45 @@
+/* Functions for pseudo TTY handling.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _PTY_H
+#define _PTY_H	1
+
+#include <features.h>
+
+#include <termios.h>
+#include <sys/ioctl.h>
+
+
+__BEGIN_DECLS
+
+/* Create pseudo tty master slave pair with NAME and set terminal
+   attributes according to TERMP and WINP and return handles for both
+   ends in AMASTER and ASLAVE.  */
+extern int openpty (int *__amaster, int *__aslave, char *__name,
+		    const struct termios *__termp,
+		    const struct winsize *__winp) __THROW;
+
+/* Create child process and establish the slave pseudo terminal as the
+   child's controlling terminal.  */
+extern int forkpty (int *__amaster, char *__name,
+		    const struct termios *__termp,
+		    const struct winsize *__winp) __THROW;
+
+__END_DECLS
+
+#endif	/* pty.h */
diff --git a/include/pwd.h b/include/pwd.h
new file mode 100644
index 0000000..626fcdd
--- /dev/null
+++ b/include/pwd.h
@@ -0,0 +1,185 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 9.2.2 User Database Access	<pwd.h>
+ */
+
+#ifndef	_PWD_H
+#define	_PWD_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K
+/* The Single Unix specification says that some more types are
+   available here.  */
+# ifndef __gid_t_defined
+typedef __gid_t gid_t;
+#  define __gid_t_defined
+# endif
+
+# ifndef __uid_t_defined
+typedef __uid_t uid_t;
+#  define __uid_t_defined
+# endif
+#endif
+
+/* The passwd structure.  */
+struct passwd
+{
+  char *pw_name;		/* Username.  */
+  char *pw_passwd;		/* Password.  */
+  __uid_t pw_uid;		/* User ID.  */
+  __gid_t pw_gid;		/* Group ID.  */
+  char *pw_gecos;		/* Real name.  */
+  char *pw_dir;			/* Home directory.  */
+  char *pw_shell;		/* Shell program.  */
+};
+
+
+#if defined __USE_SVID || defined __USE_GNU
+# define __need_FILE
+# include <stdio.h>
+#endif
+
+
+#if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN_EXTENDED
+/* Rewind the password-file stream.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void setpwent (void);
+
+/* Close the password-file stream.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void endpwent (void);
+
+/* Read an entry from the password-file stream, opening it if necessary.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct passwd *getpwent (void);
+#endif
+
+#ifdef	__USE_SVID
+/* Read an entry from STREAM.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct passwd *fgetpwent (FILE *__stream);
+
+/* Write the given entry onto the given stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int putpwent (const struct passwd *__restrict __p,
+		     FILE *__restrict __f);
+#endif
+
+/* Search for an entry with a matching user ID.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct passwd *getpwuid (__uid_t __uid);
+
+/* Search for an entry with a matching username.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct passwd *getpwnam (const char *__name);
+
+#if defined __USE_POSIX || defined __USE_MISC
+
+# ifdef __USE_MISC
+/* Reasonable value for the buffer sized used in the reentrant
+   functions below.  But better use `sysconf'.  */
+#  define NSS_BUFLEN_PASSWD	1024
+# endif
+
+/* Reentrant versions of some of the functions above.
+
+   PLEASE NOTE: the `getpwent_r' function is not (yet) standardized.
+   The interface may change in later versions of this library.  But
+   the interface is designed following the principals used for the
+   other reentrant functions so the chances are good this is what the
+   POSIX people would choose.  */
+
+# if defined __USE_SVID || defined __USE_MISC
+/* This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int getpwent_r (struct passwd *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct passwd **__restrict __result);
+# endif
+
+extern int getpwuid_r (__uid_t __uid,
+		       struct passwd *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct passwd **__restrict __result);
+
+extern int getpwnam_r (const char *__restrict __name,
+		       struct passwd *__restrict __resultbuf,
+		       char *__restrict __buffer, size_t __buflen,
+		       struct passwd **__restrict __result);
+
+
+# ifdef	__USE_SVID
+/* Read an entry from STREAM.  This function is not standardized and
+   probably never will.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fgetpwent_r (FILE *__restrict __stream,
+			struct passwd *__restrict __resultbuf,
+			char *__restrict __buffer, size_t __buflen,
+			struct passwd **__restrict __result);
+# endif
+
+#endif	/* POSIX or reentrant */
+
+#ifdef __USE_GNU
+/* Re-construct the password-file line for the given uid
+   in the given buffer.  This knows the format that the caller
+   will expect, but this need not be the format of the password file.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int getpw (__uid_t __uid, char *__buffer);
+#endif
+
+__END_DECLS
+
+#endif /* pwd.h  */
diff --git a/include/re_comp.h b/include/re_comp.h
new file mode 100644
index 0000000..7c6a724
--- /dev/null
+++ b/include/re_comp.h
@@ -0,0 +1,25 @@
+/*  Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _RE_COMP_H
+#define _RE_COMP_H	1
+
+/* This is only a wrapper around the <regex.h> file.  XPG4.2 mentions
+   this name.  */
+#include <regex.h>
+
+#endif /* re_comp.h */
diff --git a/include/regex.h b/include/regex.h
new file mode 100644
index 0000000..bb18d64
--- /dev/null
+++ b/include/regex.h
@@ -0,0 +1,581 @@
+/* Definitions for data structures and routines for the regular
+   expression library.
+   Copyright (C) 1985, 1989-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _REGEX_H
+#define _REGEX_H 1
+
+#include <sys/types.h>
+
+/* Allow the use in C++ code.  */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The following two types have to be signed and unsigned integer type
+   wide enough to hold a value of a pointer.  For most ANSI compilers
+   ptrdiff_t and size_t should be likely OK.  Still size of these two
+   types is 2 for Microsoft C.  Ugh... */
+typedef long int s_reg_t;
+typedef unsigned long int active_reg_t;
+
+/* The following bits are used to determine the regexp syntax we
+   recognize.  The set/not-set meanings are chosen so that Emacs syntax
+   remains the value 0.  The bits are given in alphabetical order, and
+   the definitions shifted by one from the previous bit; thus, when we
+   add or remove a bit, only one other definition need change.  */
+typedef unsigned long int reg_syntax_t;
+
+#ifdef __USE_GNU
+/* If this bit is not set, then \ inside a bracket expression is literal.
+   If set, then such a \ quotes the following character.  */
+# define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long int) 1)
+
+/* If this bit is not set, then + and ? are operators, and \+ and \? are
+     literals.
+   If set, then \+ and \? are operators and + and ? are literals.  */
+# define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
+
+/* If this bit is set, then character classes are supported.  They are:
+     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
+     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
+   If not set, then character classes are not supported.  */
+# define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
+
+/* If this bit is set, then ^ and $ are always anchors (outside bracket
+     expressions, of course).
+   If this bit is not set, then it depends:
+	^  is an anchor if it is at the beginning of a regular
+	   expression or after an open-group or an alternation operator;
+	$  is an anchor if it is at the end of a regular expression, or
+	   before a close-group or an alternation operator.
+
+   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
+   POSIX draft 11.2 says that * etc. in leading positions is undefined.
+   We already implemented a previous draft which made those constructs
+   invalid, though, so we haven't changed the code back.  */
+# define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
+
+/* If this bit is set, then special characters are always special
+     regardless of where they are in the pattern.
+   If this bit is not set, then special characters are special only in
+     some contexts; otherwise they are ordinary.  Specifically,
+     * + ? and intervals are only special when not after the beginning,
+     open-group, or alternation operator.  */
+# define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
+
+/* If this bit is set, then *, +, ?, and { cannot be first in an re or
+     immediately after an alternation or begin-group operator.  */
+# define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
+
+/* If this bit is set, then . matches newline.
+   If not set, then it doesn't.  */
+# define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
+
+/* If this bit is set, then . doesn't match NUL.
+   If not set, then it does.  */
+# define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
+
+/* If this bit is set, nonmatching lists [^...] do not match newline.
+   If not set, they do.  */
+# define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
+
+/* If this bit is set, either \{...\} or {...} defines an
+     interval, depending on RE_NO_BK_BRACES.
+   If not set, \{, \}, {, and } are literals.  */
+# define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
+
+/* If this bit is set, +, ? and | aren't recognized as operators.
+   If not set, they are.  */
+# define RE_LIMITED_OPS (RE_INTERVALS << 1)
+
+/* If this bit is set, newline is an alternation operator.
+   If not set, newline is literal.  */
+# define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
+
+/* If this bit is set, then `{...}' defines an interval, and \{ and \}
+     are literals.
+  If not set, then `\{...\}' defines an interval.  */
+# define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
+
+/* If this bit is set, (...) defines a group, and \( and \) are literals.
+   If not set, \(...\) defines a group, and ( and ) are literals.  */
+# define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
+
+/* If this bit is set, then \<digit> matches <digit>.
+   If not set, then \<digit> is a back-reference.  */
+# define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
+
+/* If this bit is set, then | is an alternation operator, and \| is literal.
+   If not set, then \| is an alternation operator, and | is literal.  */
+# define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
+
+/* If this bit is set, then an ending range point collating higher
+     than the starting range point, as in [z-a], is invalid.
+   If not set, then when ending range point collates higher than the
+     starting range point, the range is ignored.  */
+# define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
+
+/* If this bit is set, then an unmatched ) is ordinary.
+   If not set, then an unmatched ) is invalid.  */
+# define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
+
+/* If this bit is set, succeed as soon as we match the whole pattern,
+   without further backtracking.  */
+# define RE_NO_POSIX_BACKTRACKING (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)
+
+/* If this bit is set, do not process the GNU regex operators.
+   If not set, then the GNU regex operators are recognized. */
+# define RE_NO_GNU_OPS (RE_NO_POSIX_BACKTRACKING << 1)
+
+/* If this bit is set, turn on internal regex debugging.
+   If not set, and debugging was on, turn it off.
+   This only works if regex.c is compiled -DDEBUG.
+   We define this bit always, so that all that's needed to turn on
+   debugging is to recompile regex.c; the calling code can always have
+   this bit set, and it won't affect anything in the normal case. */
+# define RE_DEBUG (RE_NO_GNU_OPS << 1)
+
+/* If this bit is set, a syntactically invalid interval is treated as
+   a string of ordinary characters.  For example, the ERE 'a{1' is
+   treated as 'a\{1'.  */
+# define RE_INVALID_INTERVAL_ORD (RE_DEBUG << 1)
+
+/* If this bit is set, then ignore case when matching.
+   If not set, then case is significant.  */
+# define RE_ICASE (RE_INVALID_INTERVAL_ORD << 1)
+
+/* This bit is used internally like RE_CONTEXT_INDEP_ANCHORS but only
+   for ^, because it is difficult to scan the regex backwards to find
+   whether ^ should be special.  */
+# define RE_CARET_ANCHORS_HERE (RE_ICASE << 1)
+
+/* If this bit is set, then \{ cannot be first in an bre or
+   immediately after an alternation or begin-group operator.  */
+# define RE_CONTEXT_INVALID_DUP (RE_CARET_ANCHORS_HERE << 1)
+
+/* If this bit is set, then no_sub will be set to 1 during
+   re_compile_pattern.  */
+# define RE_NO_SUB (RE_CONTEXT_INVALID_DUP << 1)
+#endif
+
+/* This global variable defines the particular regexp syntax to use (for
+   some interfaces).  When a regexp is compiled, the syntax used is
+   stored in the pattern buffer, so changing this does not affect
+   already-compiled regexps.  */
+extern reg_syntax_t re_syntax_options;
+
+#ifdef __USE_GNU
+/* Define combinations of the above bits for the standard possibilities.
+   (The [[[ comments delimit what gets put into the Texinfo file, so
+   don't delete them!)  */
+/* [[[begin syntaxes]]] */
+#define RE_SYNTAX_EMACS 0
+
+#define RE_SYNTAX_AWK							\
+  (RE_BACKSLASH_ESCAPE_IN_LISTS   | RE_DOT_NOT_NULL			\
+   | RE_NO_BK_PARENS              | RE_NO_BK_REFS			\
+   | RE_NO_BK_VBAR                | RE_NO_EMPTY_RANGES			\
+   | RE_DOT_NEWLINE		  | RE_CONTEXT_INDEP_ANCHORS		\
+   | RE_CHAR_CLASSES							\
+   | RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)
+
+#define RE_SYNTAX_GNU_AWK						\
+  ((RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS		\
+    | RE_INVALID_INTERVAL_ORD)						\
+   & ~(RE_DOT_NOT_NULL | RE_CONTEXT_INDEP_OPS				\
+      | RE_CONTEXT_INVALID_OPS ))
+
+#define RE_SYNTAX_POSIX_AWK						\
+  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS		\
+   | RE_INTERVALS	    | RE_NO_GNU_OPS				\
+   | RE_INVALID_INTERVAL_ORD)
+
+#define RE_SYNTAX_GREP							\
+  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES				\
+   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS				\
+   | RE_NEWLINE_ALT)
+
+#define RE_SYNTAX_EGREP							\
+  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE			\
+   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS				\
+   | RE_NO_BK_VBAR)
+
+#define RE_SYNTAX_POSIX_EGREP						\
+  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES			\
+   | RE_INVALID_INTERVAL_ORD)
+
+/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
+#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
+
+#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
+
+/* Syntax bits common to both basic and extended POSIX regex syntax.  */
+#define _RE_SYNTAX_POSIX_COMMON						\
+  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\
+   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
+
+#define RE_SYNTAX_POSIX_BASIC						\
+  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM | RE_CONTEXT_INVALID_DUP)
+
+/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
+   RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
+   isn't minimal, since other operators, such as \`, aren't disabled.  */
+#define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
+  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
+
+#define RE_SYNTAX_POSIX_EXTENDED					\
+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INDEP_OPS   | RE_NO_BK_BRACES				\
+   | RE_NO_BK_PARENS        | RE_NO_BK_VBAR				\
+   | RE_CONTEXT_INVALID_OPS | RE_UNMATCHED_RIGHT_PAREN_ORD)
+
+/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INDEP_OPS is
+   removed and RE_NO_BK_REFS is added.  */
+#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
+   | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\
+   | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
+/* [[[end syntaxes]]] */
+
+/* Maximum number of duplicates an interval can allow.  Some systems
+   (erroneously) define this in other header files, but we want our
+   value, so remove any previous define.  */
+# ifdef RE_DUP_MAX
+#  undef RE_DUP_MAX
+# endif
+/* If sizeof(int) == 2, then ((1 << 15) - 1) overflows.  */
+# define RE_DUP_MAX (0x7fff)
+#endif
+
+
+/* POSIX `cflags' bits (i.e., information for `regcomp').  */
+
+/* If this bit is set, then use extended regular expression syntax.
+   If not set, then use basic regular expression syntax.  */
+#define REG_EXTENDED 1
+
+/* If this bit is set, then ignore case when matching.
+   If not set, then case is significant.  */
+#define REG_ICASE (REG_EXTENDED << 1)
+
+/* If this bit is set, then anchors do not match at newline
+     characters in the string.
+   If not set, then anchors do match at newlines.  */
+#define REG_NEWLINE (REG_ICASE << 1)
+
+/* If this bit is set, then report only success or fail in regexec.
+   If not set, then returns differ between not matching and errors.  */
+#define REG_NOSUB (REG_NEWLINE << 1)
+
+
+/* POSIX `eflags' bits (i.e., information for regexec).  */
+
+/* If this bit is set, then the beginning-of-line operator doesn't match
+     the beginning of the string (presumably because it's not the
+     beginning of a line).
+   If not set, then the beginning-of-line operator does match the
+     beginning of the string.  */
+#define REG_NOTBOL 1
+
+/* Like REG_NOTBOL, except for the end-of-line.  */
+#define REG_NOTEOL (1 << 1)
+
+/* Use PMATCH[0] to delimit the start and end of the search in the
+   buffer.  */
+#define REG_STARTEND (1 << 2)
+
+
+/* If any error codes are removed, changed, or added, update the
+   `re_error_msg' table in regex.c.  */
+typedef enum
+{
+#if defined _XOPEN_SOURCE || defined __USE_XOPEN2K
+  REG_ENOSYS = -1,	/* This will never happen for this implementation.  */
+#endif
+
+  REG_NOERROR = 0,	/* Success.  */
+  REG_NOMATCH,		/* Didn't find a match (for regexec).  */
+
+  /* POSIX regcomp return error codes.  (In the order listed in the
+     standard.)  */
+  REG_BADPAT,		/* Invalid pattern.  */
+  REG_ECOLLATE,		/* Inalid collating element.  */
+  REG_ECTYPE,		/* Invalid character class name.  */
+  REG_EESCAPE,		/* Trailing backslash.  */
+  REG_ESUBREG,		/* Invalid back reference.  */
+  REG_EBRACK,		/* Unmatched left bracket.  */
+  REG_EPAREN,		/* Parenthesis imbalance.  */
+  REG_EBRACE,		/* Unmatched \{.  */
+  REG_BADBR,		/* Invalid contents of \{\}.  */
+  REG_ERANGE,		/* Invalid range end.  */
+  REG_ESPACE,		/* Ran out of memory.  */
+  REG_BADRPT,		/* No preceding re for repetition op.  */
+
+  /* Error codes we've added.  */
+  REG_EEND,		/* Premature end.  */
+  REG_ESIZE,		/* Compiled pattern bigger than 2^16 bytes.  */
+  REG_ERPAREN		/* Unmatched ) or \); not returned from regcomp.  */
+} reg_errcode_t;
+
+/* This data structure represents a compiled pattern.  Before calling
+   the pattern compiler, the fields `buffer', `allocated', `fastmap',
+   and `translate' can be set.  After the pattern has been compiled,
+   the fields `re_nsub', `not_bol' and `not_eol' are available.  All
+   other fields are private to the regex routines.  */
+
+#ifndef RE_TRANSLATE_TYPE
+# define __RE_TRANSLATE_TYPE unsigned char *
+# ifdef __USE_GNU
+#  define RE_TRANSLATE_TYPE __RE_TRANSLATE_TYPE
+# endif
+#endif
+
+#ifdef __USE_GNU
+# define __REPB_PREFIX(name) name
+#else
+# define __REPB_PREFIX(name) __##name
+#endif
+
+struct re_pattern_buffer
+{
+  /* Space that holds the compiled pattern.  It is declared as
+     `unsigned char *' because its elements are sometimes used as
+     array indexes.  */
+  unsigned char *__REPB_PREFIX(buffer);
+
+  /* Number of bytes to which `buffer' points.  */
+  unsigned long int __REPB_PREFIX(allocated);
+
+  /* Number of bytes actually used in `buffer'.  */
+  unsigned long int __REPB_PREFIX(used);
+
+  /* Syntax setting with which the pattern was compiled.  */
+  reg_syntax_t __REPB_PREFIX(syntax);
+
+  /* Pointer to a fastmap, if any, otherwise zero.  re_search uses the
+     fastmap, if there is one, to skip over impossible starting points
+     for matches.  */
+  char *__REPB_PREFIX(fastmap);
+
+  /* Either a translate table to apply to all characters before
+     comparing them, or zero for no translation.  The translation is
+     applied to a pattern when it is compiled and to a string when it
+     is matched.  */
+  __RE_TRANSLATE_TYPE __REPB_PREFIX(translate);
+
+  /* Number of subexpressions found by the compiler.  */
+  size_t re_nsub;
+
+  /* Zero if this pattern cannot match the empty string, one else.
+     Well, in truth it's used only in `re_search_2', to see whether or
+     not we should use the fastmap, so we don't set this absolutely
+     perfectly; see `re_compile_fastmap' (the `duplicate' case).  */
+  unsigned __REPB_PREFIX(can_be_null) : 1;
+
+  /* If REGS_UNALLOCATED, allocate space in the `regs' structure
+     for `max (RE_NREGS, re_nsub + 1)' groups.
+     If REGS_REALLOCATE, reallocate space if necessary.
+     If REGS_FIXED, use what's there.  */
+#ifdef __USE_GNU
+# define REGS_UNALLOCATED 0
+# define REGS_REALLOCATE 1
+# define REGS_FIXED 2
+#endif
+  unsigned __REPB_PREFIX(regs_allocated) : 2;
+
+  /* Set to zero when `regex_compile' compiles a pattern; set to one
+     by `re_compile_fastmap' if it updates the fastmap.  */
+  unsigned __REPB_PREFIX(fastmap_accurate) : 1;
+
+  /* If set, `re_match_2' does not return information about
+     subexpressions.  */
+  unsigned __REPB_PREFIX(no_sub) : 1;
+
+  /* If set, a beginning-of-line anchor doesn't match at the beginning
+     of the string.  */
+  unsigned __REPB_PREFIX(not_bol) : 1;
+
+  /* Similarly for an end-of-line anchor.  */
+  unsigned __REPB_PREFIX(not_eol) : 1;
+
+  /* If true, an anchor at a newline matches.  */
+  unsigned __REPB_PREFIX(newline_anchor) : 1;
+};
+
+typedef struct re_pattern_buffer regex_t;
+
+/* Type for byte offsets within the string.  POSIX mandates this.  */
+typedef int regoff_t;
+
+
+#ifdef __USE_GNU
+/* This is the structure we store register match data in.  See
+   regex.texinfo for a full description of what registers match.  */
+struct re_registers
+{
+  unsigned num_regs;
+  regoff_t *start;
+  regoff_t *end;
+};
+
+
+/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
+   `re_match_2' returns information about at least this many registers
+   the first time a `regs' structure is passed.  */
+# ifndef RE_NREGS
+#  define RE_NREGS 30
+# endif
+#endif
+
+
+/* POSIX specification for registers.  Aside from the different names than
+   `re_registers', POSIX uses an array of structures, instead of a
+   structure of arrays.  */
+typedef struct
+{
+  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */
+  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */
+} regmatch_t;
+
+/* Declarations for routines.  */
+
+#ifdef __USE_GNU
+/* Sets the current default syntax to SYNTAX, and return the old syntax.
+   You can also simply assign to the `re_syntax_options' variable.  */
+extern reg_syntax_t re_set_syntax (reg_syntax_t __syntax);
+
+/* Compile the regular expression PATTERN, with length LENGTH
+   and syntax given by the global `re_syntax_options', into the buffer
+   BUFFER.  Return NULL if successful, and an error string if not.
+
+   To free the allocated storage, you must call `regfree' on BUFFER.
+   Note that the translate table must either have been initialised by
+   `regcomp', with a malloc'ed value, or set to NULL before calling
+   `regfree'.  */
+extern const char *re_compile_pattern (const char *__pattern, size_t __length,
+				       struct re_pattern_buffer *__buffer);
+
+
+/* Compile a fastmap for the compiled pattern in BUFFER; used to
+   accelerate searches.  Return 0 if successful and -2 if was an
+   internal error.  */
+extern int re_compile_fastmap (struct re_pattern_buffer *__buffer);
+
+
+/* Search in the string STRING (with length LENGTH) for the pattern
+   compiled into BUFFER.  Start searching at position START, for RANGE
+   characters.  Return the starting position of the match, -1 for no
+   match, or -2 for an internal error.  Also return register
+   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */
+extern int re_search (struct re_pattern_buffer *__buffer, const char *__string,
+		      int __length, int __start, int __range,
+		      struct re_registers *__regs);
+
+
+/* Like `re_search', but search in the concatenation of STRING1 and
+   STRING2.  Also, stop searching at index START + STOP.  */
+extern int re_search_2 (struct re_pattern_buffer *__buffer,
+			const char *__string1, int __length1,
+			const char *__string2, int __length2, int __start,
+			int __range, struct re_registers *__regs, int __stop);
+
+
+/* Like `re_search', but return how many characters in STRING the regexp
+   in BUFFER matched, starting at position START.  */
+extern int re_match (struct re_pattern_buffer *__buffer, const char *__string,
+		     int __length, int __start, struct re_registers *__regs);
+
+
+/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */
+extern int re_match_2 (struct re_pattern_buffer *__buffer,
+		       const char *__string1, int __length1,
+		       const char *__string2, int __length2, int __start,
+		       struct re_registers *__regs, int __stop);
+
+
+/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
+   ENDS.  Subsequent matches using BUFFER and REGS will use this memory
+   for recording register information.  STARTS and ENDS must be
+   allocated with malloc, and must each be at least `NUM_REGS * sizeof
+   (regoff_t)' bytes long.
+
+   If NUM_REGS == 0, then subsequent matches should allocate their own
+   register data.
+
+   Unless this function is called, the first search or match using
+   PATTERN_BUFFER will allocate its own register data, without
+   freeing the old data.  */
+extern void re_set_registers (struct re_pattern_buffer *__buffer,
+			      struct re_registers *__regs,
+			      unsigned int __num_regs,
+			      regoff_t *__starts, regoff_t *__ends);
+#endif	/* Use GNU */
+
+#if defined _REGEX_RE_COMP || (defined _LIBC && defined __USE_BSD)
+# ifndef _CRAY
+/* 4.2 bsd compatibility.  */
+extern char *re_comp (const char *);
+extern int re_exec (const char *);
+# endif
+#endif
+
+/* GCC 2.95 and later have "__restrict"; C99 compilers have
+   "restrict", and "configure" may have defined "restrict".  */
+#ifndef __restrict
+# if ! (2 < __GNUC__ || (2 == __GNUC__ && 95 <= __GNUC_MINOR__))
+#  if defined restrict || 199901L <= __STDC_VERSION__
+#   define __restrict restrict
+#  else
+#   define __restrict
+#  endif
+# endif
+#endif
+/* gcc 3.1 and up support the [restrict] syntax.  */
+#ifndef __restrict_arr
+# if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)) \
+     && !defined __GNUG__
+#  define __restrict_arr __restrict
+# else
+#  define __restrict_arr
+# endif
+#endif
+
+/* POSIX compatibility.  */
+extern int regcomp (regex_t *__restrict __preg,
+		    const char *__restrict __pattern,
+		    int __cflags);
+
+extern int regexec (const regex_t *__restrict __preg,
+		    const char *__restrict __string, size_t __nmatch,
+		    regmatch_t __pmatch[__restrict_arr],
+		    int __eflags);
+
+extern size_t regerror (int __errcode, const regex_t *__restrict __preg,
+			char *__restrict __errbuf, size_t __errbuf_size);
+
+extern void regfree (regex_t *__preg);
+
+
+#ifdef __cplusplus
+}
+#endif	/* C++ */
+
+#endif /* regex.h */
diff --git a/include/regexp.h b/include/regexp.h
new file mode 100644
index 0000000..2af2bdf
--- /dev/null
+++ b/include/regexp.h
@@ -0,0 +1,226 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _REGEXP_H
+#define _REGEXP_H	1
+
+/* The contents of this header file was first standardized in X/Open
+   System Interface and Headers Issue 2, originally coming from SysV.
+   In issue 4, version 2, it is marked as TO BE WITDRAWN, and it has
+   been withdrawn in SUSv3.
+
+   This code shouldn't be used in any newly written code.  It is
+   included only for compatibility reasons.  Use the POSIX definition
+   in <regex.h> for portable applications and a reasonable interface.  */
+
+#include <features.h>
+#include <alloca.h>
+#include <regex.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* The implementation provided here emulates the needed functionality
+   by mapping to the POSIX regular expression matcher.  The interface
+   for the here included function is weird (this really is a harmless
+   word).
+
+   The user has to provide six macros before this header file can be
+   included:
+
+   INIT		Declarations vor variables which can be used by the
+		other macros.
+
+   GETC()	Return the value of the next character in the regular
+		expression pattern.  Successive calls should return
+		successive characters.
+
+   PEEKC()	Return the value of the next character in the regular
+		expression pattern.  Immediately successive calls to
+		PEEKC() should return the same character which should
+		also be the next character returned by GETC().
+
+   UNGETC(c)	Cause `c' to be returned by the next call to GETC() and
+		PEEKC().
+
+   RETURN(ptr)	Used for normal exit of the `compile' function.  `ptr'
+		is a pointer to the character after the last character of
+		the compiled regular expression.
+
+   ERROR(val)	Used for abnormal return from `compile'.  `val' is the
+		error number.  The error codes are:
+		11	Range endpoint too large.
+		16	Bad number.
+		25	\digit out of range.
+		36	Illegal or missing delimiter.
+		41	No remembered search string.
+		42	\( \) imbalance.
+		43	Too many \(.
+		44	More tan two numbers given in \{ \}.
+		45	} expected after \.
+		46	First number exceeds second in \{ \}.
+		49	[ ] imbalance.
+		50	Regular expression overflow.
+
+  */
+
+__BEGIN_DECLS
+
+/* Interface variables.  They contain the results of the successful
+   calls to `setp' and `advance'.  */
+extern char *loc1;
+extern char *loc2;
+
+/* The use of this variable in the `advance' function is not
+   supported.  */
+extern char *locs;
+
+
+#ifndef __DO_NOT_DEFINE_COMPILE
+/* Get and compile the user supplied pattern up to end of line or
+   string or until EOF is seen, whatever happens first.  The result is
+   placed in the buffer starting at EXPBUF and delimited by ENDBUF.
+
+   This function cannot be defined in the libc itself since it depends
+   on the macros.  */
+char *
+compile (char *__restrict instring, char *__restrict expbuf,
+	 const char *__restrict endbuf, int eof)
+{
+  char *__input_buffer = NULL;
+  size_t __input_size = 0;
+  size_t __current_size = 0;
+  int __ch;
+  int __error;
+  INIT
+
+  /* Align the expression buffer according to the needs for an object
+     of type `regex_t'.  Then check for minimum size of the buffer for
+     the compiled regular expression.  */
+  regex_t *__expr_ptr;
+# if defined __GNUC__ && __GNUC__ >= 2
+  const size_t __req = __alignof__ (regex_t *);
+# else
+  /* How shall we find out?  We simply guess it and can change it is
+     this really proofs to be wrong.  */
+  const size_t __req = 8;
+# endif
+  expbuf += __req;
+  expbuf -= (expbuf - ((char *) 0)) % __req;
+  if (endbuf < expbuf + sizeof (regex_t))
+    {
+      ERROR (50);
+    }
+  __expr_ptr = (regex_t *) expbuf;
+  /* The remaining space in the buffer can be used for the compiled
+     pattern.  */
+  __expr_ptr->__REPB_PREFIX (buffer) = expbuf + sizeof (regex_t);
+  __expr_ptr->__REPB_PREFIX (allocated)
+    = endbuf - (char *) __expr_ptr->__REPB_PREFIX (buffer);
+
+  while ((__ch = (GETC ())) != eof)
+    {
+      if (__ch == '\0' || __ch == '\n')
+	{
+	  UNGETC (__ch);
+	  break;
+	}
+
+      if (__current_size + 1 >= __input_size)
+	{
+	  size_t __new_size = __input_size ? 2 * __input_size : 128;
+	  char *__new_room = (char *) alloca (__new_size);
+	  /* See whether we can use the old buffer.  */
+	  if (__new_room + __new_size == __input_buffer)
+	    {
+	      __input_size += __new_size;
+	      __input_buffer = (char *) memcpy (__new_room, __input_buffer,
+					       __current_size);
+	    }
+	  else if (__input_buffer + __input_size == __new_room)
+	    __input_size += __new_size;
+	  else
+	    {
+	      __input_size = __new_size;
+	      __input_buffer = (char *) memcpy (__new_room, __input_buffer,
+						__current_size);
+	    }
+	}
+      __input_buffer[__current_size++] = __ch;
+    }
+  if (__current_size)
+    __input_buffer[__current_size++] = '\0';
+  else
+    __input_buffer = "";
+
+  /* Now compile the pattern.  */
+  __error = regcomp (__expr_ptr, __input_buffer, REG_NEWLINE);
+  if (__error != 0)
+    /* Oh well, we have to translate POSIX error codes.  */
+    switch (__error)
+      {
+      case REG_BADPAT:
+      case REG_ECOLLATE:
+      case REG_ECTYPE:
+      case REG_EESCAPE:
+      case REG_BADRPT:
+      case REG_EEND:
+      case REG_ERPAREN:
+      default:
+	/* There is no matching error code.  */
+	RETURN (36);
+      case REG_ESUBREG:
+	RETURN (25);
+      case REG_EBRACK:
+	RETURN (49);
+      case REG_EPAREN:
+	RETURN (42);
+      case REG_EBRACE:
+	RETURN (44);
+      case REG_BADBR:
+	RETURN (46);
+      case REG_ERANGE:
+	RETURN (11);
+      case REG_ESPACE:
+      case REG_ESIZE:
+	ERROR (50);
+      }
+
+  /* Everything is ok.  */
+  RETURN ((char *) (__expr_ptr->__REPB_PREFIX (buffer)
+		    + __expr_ptr->__REPB_PREFIX (used)));
+}
+#endif
+
+
+/* Find the next match in STRING.  The compiled regular expression is
+   found in the buffer starting at EXPBUF.  `loc1' will return the
+   first character matched and `loc2' points to the next unmatched
+   character.  */
+extern int step (const char *__restrict __string,
+		 const char *__restrict __expbuf) __THROW;
+
+/* Match the beginning of STRING with the compiled regular expression
+   in EXPBUF.  If the match is successful `loc2' will contain the
+   position of the first unmatched character.  */
+extern int advance (const char *__restrict __string,
+		    const char *__restrict __expbuf) __THROW;
+
+
+__END_DECLS
+
+#endif /* regexp.h */
diff --git a/include/resolv.h b/include/resolv.h
new file mode 100644
index 0000000..53c3bba
--- /dev/null
+++ b/include/resolv.h
@@ -0,0 +1,389 @@
+/*
+ * Copyright (c) 1983, 1987, 1989
+ *    The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Portions Copyright (c) 1996-1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+ * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+ * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+/*
+ *	@(#)resolv.h	8.1 (Berkeley) 6/2/93
+ *	$BINDId: resolv.h,v 8.31 2000/03/30 20:16:50 vixie Exp $
+ */
+
+#ifndef _RESOLV_H_
+
+/* These headers are needed for types used in the `struct res_state'
+   declaration.  */
+#include <sys/types.h>
+#include <netinet/in.h>
+
+#ifndef __need_res_state
+# define _RESOLV_H_
+
+# include <sys/param.h>
+# include <sys/cdefs.h>
+# include <stdio.h>
+# include <arpa/nameser.h>
+#endif
+
+#ifndef __res_state_defined
+# define __res_state_defined
+
+typedef enum { res_goahead, res_nextns, res_modified, res_done, res_error }
+	res_sendhookact;
+
+typedef res_sendhookact (*res_send_qhook) (struct sockaddr_in * const *__ns,
+					   const u_char **__query,
+					   int *__querylen,
+					   u_char *__ans,
+					   int __anssiz,
+					   int *__resplen);
+
+typedef res_sendhookact (*res_send_rhook) (const struct sockaddr_in *__ns,
+					   const u_char *__query,
+					   int __querylen,
+					   u_char *__ans,
+					   int __anssiz,
+					   int *__resplen);
+
+/*
+ * Global defines and variables for resolver stub.
+ */
+# define MAXNS			3	/* max # name servers we'll track */
+# define MAXDFLSRCH		3	/* # default domain levels to try */
+# define MAXDNSRCH		6	/* max # domains in search path */
+# define LOCALDOMAINPARTS	2	/* min levels in name that is "local" */
+
+# define RES_TIMEOUT		5	/* min. seconds between retries */
+# define MAXRESOLVSORT		10	/* number of net to sort on */
+# define RES_MAXNDOTS		15	/* should reflect bit field size */
+# define RES_MAXRETRANS		30	/* only for resolv.conf/RES_OPTIONS */
+# define RES_MAXRETRY		5	/* only for resolv.conf/RES_OPTIONS */
+# define RES_DFLRETRY		2	/* Default #/tries. */
+# define RES_MAXTIME		65535	/* Infinity, in milliseconds. */
+
+struct __res_state {
+	int	retrans;		/* retransmition time interval */
+	int	retry;			/* number of times to retransmit */
+	u_long	options;		/* option flags - see below. */
+	int	nscount;		/* number of name servers */
+	struct sockaddr_in
+		nsaddr_list[MAXNS];	/* address of name server */
+# define nsaddr	nsaddr_list[0]		/* for backward compatibility */
+	u_short	id;			/* current message id */
+	/* 2 byte hole here.  */
+	char	*dnsrch[MAXDNSRCH+1];	/* components of domain to search */
+	char	defdname[256];		/* default domain (deprecated) */
+	u_long	pfcode;			/* RES_PRF_ flags - see below. */
+	unsigned ndots:4;		/* threshold for initial abs. query */
+	unsigned nsort:4;		/* number of elements in sort_list[] */
+	unsigned ipv6_unavail:1;	/* connecting to IPv6 server failed */
+	unsigned unused:23;
+	struct {
+		struct in_addr	addr;
+		u_int32_t	mask;
+	} sort_list[MAXRESOLVSORT];
+	/* 4 byte hole here on 64-bit architectures.  */
+	res_send_qhook qhook;		/* query hook */
+	res_send_rhook rhook;		/* response hook */
+	int	res_h_errno;		/* last one set for this context */
+	int	_vcsock;		/* PRIVATE: for res_send VC i/o */
+	u_int	_flags;			/* PRIVATE: see below */
+	/* 4 byte hole here on 64-bit architectures.  */
+	union {
+		char	pad[52];	/* On an i386 this means 512b total. */
+		struct {
+			u_int16_t		nscount;
+			u_int16_t		nsmap[MAXNS];
+			int			nssocks[MAXNS];
+			u_int16_t		nscount6;
+			u_int16_t		nsinit;
+			struct sockaddr_in6	*nsaddrs[MAXNS];
+#ifdef _LIBC
+			unsigned long long int	initstamp
+			  __attribute__((packed));
+#else
+			unsigned int		_initstamp[2];
+#endif
+		} _ext;
+	} _u;
+};
+
+typedef struct __res_state *res_state;
+# undef __need_res_state
+#endif
+
+#ifdef _RESOLV_H_
+/*
+ * Revision information.  This is the release date in YYYYMMDD format.
+ * It can change every day so the right thing to do with it is use it
+ * in preprocessor commands such as "#if (__RES > 19931104)".  Do not
+ * compare for equality; rather, use it to determine whether your resolver
+ * is new enough to contain a certain feature.
+ */
+
+#define	__RES	19991006
+
+/*
+ * Resolver configuration file.
+ * Normally not present, but may contain the address of the
+ * inital name server(s) to query and the domain search list.
+ */
+
+#ifndef _PATH_RESCONF
+#define _PATH_RESCONF        "/etc/resolv.conf"
+#endif
+
+struct res_sym {
+	int	number;		/* Identifying number, like T_MX */
+	char *	name;		/* Its symbolic name, like "MX" */
+	char *	humanname;	/* Its fun name, like "mail exchanger" */
+};
+
+/*
+ * Resolver flags (used to be discrete per-module statics ints).
+ */
+#define	RES_F_VC	0x00000001	/* socket is TCP */
+#define	RES_F_CONN	0x00000002	/* socket is connected */
+#define RES_F_EDNS0ERR	0x00000004	/* EDNS0 caused errors */
+
+/* res_findzonecut() options */
+#define	RES_EXHAUSTIVE	0x00000001	/* always do all queries */
+
+/*
+ * Resolver options (keep these in synch with res_debug.c, please)
+ */
+#define RES_INIT	0x00000001	/* address initialized */
+#define RES_DEBUG	0x00000002	/* print debug messages */
+#define RES_AAONLY	0x00000004	/* authoritative answers only (!IMPL)*/
+#define RES_USEVC	0x00000008	/* use virtual circuit */
+#define RES_PRIMARY	0x00000010	/* query primary server only (!IMPL) */
+#define RES_IGNTC	0x00000020	/* ignore trucation errors */
+#define RES_RECURSE	0x00000040	/* recursion desired */
+#define RES_DEFNAMES	0x00000080	/* use default domain name */
+#define RES_STAYOPEN	0x00000100	/* Keep TCP socket open */
+#define RES_DNSRCH	0x00000200	/* search up local domain tree */
+#define	RES_INSECURE1	0x00000400	/* type 1 security disabled */
+#define	RES_INSECURE2	0x00000800	/* type 2 security disabled */
+#define	RES_NOALIASES	0x00001000	/* shuts off HOSTALIASES feature */
+#define	RES_USE_INET6	0x00002000	/* use/map IPv6 in gethostbyname() */
+#define RES_ROTATE	0x00004000	/* rotate ns list after each query */
+#define	RES_NOCHECKNAME	0x00008000	/* do not check names for sanity (!IMPL) */
+#define	RES_KEEPTSIG	0x00010000	/* do not strip TSIG records */
+#define	RES_BLAST	0x00020000	/* blast all recursive servers */
+#define RES_USEBSTRING	0x00040000	/* IPv6 reverse lookup with byte
+					   strings */
+#define RES_NOIP6DOTINT	0x00080000	/* Do not use .ip6.int in IPv6
+					   reverse lookup */
+#define RES_USE_EDNS0	0x00100000	/* Use EDNS0.  */
+#define RES_SNGLKUP	0x00200000	/* one outstanding request at a time */
+#define RES_SNGLKUPREOP	0x00400000	/* -"-, but open new socket for each
+					   request */
+#define RES_USE_DNSSEC	0x00800000	/* use DNSSEC using OK bit in OPT */
+#define RES_NOTLDQUERY	0x01000000	/* Do not look up unqualified name
+					   as a TLD.  */
+
+#define RES_DEFAULT	(RES_RECURSE|RES_DEFNAMES|RES_DNSRCH|RES_NOIP6DOTINT)
+
+/*
+ * Resolver "pfcode" values.  Used by dig.
+ */
+#define RES_PRF_STATS	0x00000001
+#define RES_PRF_UPDATE	0x00000002
+#define RES_PRF_CLASS   0x00000004
+#define RES_PRF_CMD	0x00000008
+#define RES_PRF_QUES	0x00000010
+#define RES_PRF_ANS	0x00000020
+#define RES_PRF_AUTH	0x00000040
+#define RES_PRF_ADD	0x00000080
+#define RES_PRF_HEAD1	0x00000100
+#define RES_PRF_HEAD2	0x00000200
+#define RES_PRF_TTLID	0x00000400
+#define RES_PRF_HEADX	0x00000800
+#define RES_PRF_QUERY	0x00001000
+#define RES_PRF_REPLY	0x00002000
+#define RES_PRF_INIT	0x00004000
+/*			0x00008000	*/
+
+/* Things involving an internal (static) resolver context. */
+__BEGIN_DECLS
+extern struct __res_state *__res_state(void) __attribute__ ((__const__));
+__END_DECLS
+#define _res (*__res_state())
+
+#ifndef __BIND_NOSTATIC
+#define fp_nquery		__fp_nquery
+#define fp_query		__fp_query
+#define hostalias		__hostalias
+#define p_query			__p_query
+#define res_close		__res_close
+#define res_init		__res_init
+#define res_isourserver		__res_isourserver
+#define res_mkquery		__res_mkquery
+#define res_query		__res_query
+#define res_querydomain		__res_querydomain
+#define res_search		__res_search
+#define res_send		__res_send
+
+__BEGIN_DECLS
+void		fp_nquery (const u_char *, int, FILE *) __THROW;
+void		fp_query (const u_char *, FILE *) __THROW;
+const char *	hostalias (const char *) __THROW;
+void		p_query (const u_char *) __THROW;
+void		res_close (void) __THROW;
+int		res_init (void) __THROW;
+int		res_isourserver (const struct sockaddr_in *) __THROW;
+int		res_mkquery (int, const char *, int, int, const u_char *,
+			     int, const u_char *, u_char *, int) __THROW;
+int		res_query (const char *, int, int, u_char *, int) __THROW;
+int		res_querydomain (const char *, const char *, int, int,
+				 u_char *, int) __THROW;
+int		res_search (const char *, int, int, u_char *, int) __THROW;
+int		res_send (const u_char *, int, u_char *, int) __THROW;
+__END_DECLS
+#endif
+
+#define b64_ntop		__b64_ntop
+#define b64_pton		__b64_pton
+#define dn_comp			__dn_comp
+#define dn_count_labels		__dn_count_labels
+#define dn_expand		__dn_expand
+#define dn_skipname		__dn_skipname
+#define fp_resstat		__fp_resstat
+#define loc_aton		__loc_aton
+#define loc_ntoa		__loc_ntoa
+#define p_cdname		__p_cdname
+#define p_cdnname		__p_cdnname
+#define p_class			__p_class
+#define p_fqname		__p_fqname
+#define p_fqnname		__p_fqnname
+#define p_option		__p_option
+#define p_secstodate		__p_secstodate
+#define p_section		__p_section
+#define p_time			__p_time
+#define p_type			__p_type
+#define p_rcode			__p_rcode
+#define putlong			__putlong
+#define putshort		__putshort
+#define res_dnok		__res_dnok
+#define res_hnok		__res_hnok
+#define res_hostalias		__res_hostalias
+#define res_mailok		__res_mailok
+#define res_nameinquery		__res_nameinquery
+#define res_nclose		__res_nclose
+#define res_ninit		__res_ninit
+#define res_nmkquery		__res_nmkquery
+#define res_npquery		__res_npquery
+#define res_nquery		__res_nquery
+#define res_nquerydomain	__res_nquerydomain
+#define res_nsearch		__res_nsearch
+#define res_nsend		__res_nsend
+#define res_nisourserver	__res_nisourserver
+#define res_ownok		__res_ownok
+#define res_queriesmatch	__res_queriesmatch
+#define res_randomid		__res_randomid
+#define sym_ntop		__sym_ntop
+#define sym_ntos		__sym_ntos
+#define sym_ston		__sym_ston
+__BEGIN_DECLS
+int		res_hnok (const char *) __THROW;
+int		res_ownok (const char *) __THROW;
+int		res_mailok (const char *) __THROW;
+int		res_dnok (const char *) __THROW;
+int		sym_ston (const struct res_sym *, const char *, int *) __THROW;
+const char *	sym_ntos (const struct res_sym *, int, int *) __THROW;
+const char *	sym_ntop (const struct res_sym *, int, int *) __THROW;
+int		b64_ntop (u_char const *, size_t, char *, size_t) __THROW;
+int		b64_pton (char const *, u_char *, size_t) __THROW;
+int		loc_aton (const char *__ascii, u_char *__binary) __THROW;
+const char *	loc_ntoa (const u_char *__binary, char *__ascii) __THROW;
+int		dn_skipname (const u_char *, const u_char *) __THROW;
+void		putlong (u_int32_t, u_char *) __THROW;
+void		putshort (u_int16_t, u_char *) __THROW;
+const char *	p_class (int) __THROW;
+const char *	p_time (u_int32_t) __THROW;
+const char *	p_type (int) __THROW;
+const char *	p_rcode (int) __THROW;
+const u_char *	p_cdnname (const u_char *, const u_char *, int, FILE *)
+     __THROW;
+const u_char *	p_cdname (const u_char *, const u_char *, FILE *) __THROW;
+const u_char *	p_fqnname (const u_char *__cp, const u_char *__msg,
+			   int, char *, int) __THROW;
+const u_char *	p_fqname (const u_char *, const u_char *, FILE *) __THROW;
+const char *	p_option (u_long __option) __THROW;
+char *		p_secstodate (u_long) __THROW;
+int		dn_count_labels (const char *) __THROW;
+int		dn_comp (const char *, u_char *, int, u_char **, u_char **)
+     __THROW;
+int		dn_expand (const u_char *, const u_char *, const u_char *,
+			   char *, int) __THROW;
+u_int		res_randomid (void) __THROW;
+int		res_nameinquery (const char *, int, int,
+				 const u_char *, const u_char *) __THROW;
+int		res_queriesmatch (const u_char *, const u_char *,
+				  const u_char *, const u_char *) __THROW;
+const char *	p_section (int __section, int __opcode) __THROW;
+/* Things involving a resolver context. */
+int		res_ninit (res_state) __THROW;
+int		res_nisourserver (const res_state,
+				  const struct sockaddr_in *) __THROW;
+void		fp_resstat (const res_state, FILE *) __THROW;
+void		res_npquery (const res_state, const u_char *, int, FILE *)
+     __THROW;
+const char *	res_hostalias (const res_state, const char *, char *, size_t)
+     __THROW;
+int		res_nquery (res_state, const char *, int, int, u_char *, int)
+     __THROW;
+int		res_nsearch (res_state, const char *, int, int, u_char *, int)
+     __THROW;
+int		res_nquerydomain (res_state, const char *, const char *, int,
+				  int, u_char *, int) __THROW;
+int		res_nmkquery (res_state, int, const char *, int, int,
+			      const u_char *, int, const u_char *, u_char *,
+			      int) __THROW;
+int		res_nsend (res_state, const u_char *, int, u_char *, int)
+     __THROW;
+void		res_nclose (res_state) __THROW;
+__END_DECLS
+#endif
+
+#endif /* !_RESOLV_H_ */
diff --git a/include/rpc/auth.h b/include/rpc/auth.h
new file mode 100644
index 0000000..b25dcfc
--- /dev/null
+++ b/include/rpc/auth.h
@@ -0,0 +1,210 @@
+/*
+ * auth.h, Authentication interface.
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The data structures are completely opaque to the client.  The client
+ * is required to pass a AUTH * to routines that create rpc
+ * "sessions".
+ */
+
+#ifndef _RPC_AUTH_H
+
+#define _RPC_AUTH_H	1
+#include <features.h>
+#include <rpc/xdr.h>
+
+__BEGIN_DECLS
+
+#define MAX_AUTH_BYTES	400
+#define MAXNETNAMELEN	255	/* maximum length of network user's name */
+
+/*
+ * Status returned from authentication check
+ */
+enum auth_stat {
+	AUTH_OK=0,
+	/*
+	 * failed at remote end
+	 */
+	AUTH_BADCRED=1,			/* bogus credentials (seal broken) */
+	AUTH_REJECTEDCRED=2,		/* client should begin new session */
+	AUTH_BADVERF=3,			/* bogus verifier (seal broken) */
+	AUTH_REJECTEDVERF=4,		/* verifier expired or was replayed */
+	AUTH_TOOWEAK=5,			/* rejected due to security reasons */
+	/*
+	 * failed locally
+	*/
+	AUTH_INVALIDRESP=6,		/* bogus response verifier */
+	AUTH_FAILED=7			/* some unknown reason */
+};
+
+union des_block {
+	struct {
+		u_int32_t high;
+		u_int32_t low;
+	} key;
+	char c[8];
+};
+typedef union des_block des_block;
+extern bool_t xdr_des_block (XDR *__xdrs, des_block *__blkp) __THROW;
+
+/*
+ * Authentication info.  Opaque to client.
+ */
+struct opaque_auth {
+	enum_t	oa_flavor;		/* flavor of auth */
+	caddr_t	oa_base;		/* address of more auth stuff */
+	u_int	oa_length;		/* not to exceed MAX_AUTH_BYTES */
+};
+
+/*
+ * Auth handle, interface to client side authenticators.
+ */
+typedef struct AUTH AUTH;
+struct AUTH {
+  struct opaque_auth ah_cred;
+  struct opaque_auth ah_verf;
+  union des_block ah_key;
+  struct auth_ops {
+    void (*ah_nextverf) (AUTH *);
+    int  (*ah_marshal) (AUTH *, XDR *);		/* nextverf & serialize */
+    int  (*ah_validate) (AUTH *, struct opaque_auth *);
+						/* validate verifier */
+    int  (*ah_refresh) (AUTH *);		/* refresh credentials */
+    void (*ah_destroy) (AUTH *); 	    	/* destroy this structure */
+  } *ah_ops;
+  caddr_t ah_private;
+};
+
+
+/*
+ * Authentication ops.
+ * The ops and the auth handle provide the interface to the authenticators.
+ *
+ * AUTH	*auth;
+ * XDR	*xdrs;
+ * struct opaque_auth verf;
+ */
+#define AUTH_NEXTVERF(auth)		\
+		((*((auth)->ah_ops->ah_nextverf))(auth))
+#define auth_nextverf(auth)		\
+		((*((auth)->ah_ops->ah_nextverf))(auth))
+
+#define AUTH_MARSHALL(auth, xdrs)	\
+		((*((auth)->ah_ops->ah_marshal))(auth, xdrs))
+#define auth_marshall(auth, xdrs)	\
+		((*((auth)->ah_ops->ah_marshal))(auth, xdrs))
+
+#define AUTH_VALIDATE(auth, verfp)	\
+		((*((auth)->ah_ops->ah_validate))((auth), verfp))
+#define auth_validate(auth, verfp)	\
+		((*((auth)->ah_ops->ah_validate))((auth), verfp))
+
+#define AUTH_REFRESH(auth)		\
+		((*((auth)->ah_ops->ah_refresh))(auth))
+#define auth_refresh(auth)		\
+		((*((auth)->ah_ops->ah_refresh))(auth))
+
+#define AUTH_DESTROY(auth)		\
+		((*((auth)->ah_ops->ah_destroy))(auth))
+#define auth_destroy(auth)		\
+		((*((auth)->ah_ops->ah_destroy))(auth))
+
+
+extern struct opaque_auth _null_auth;
+
+
+/*
+ * These are the various implementations of client side authenticators.
+ */
+
+/*
+ * Unix style authentication
+ * AUTH *authunix_create(machname, uid, gid, len, aup_gids)
+ *	char *machname;
+ *	int uid;
+ *	int gid;
+ *	int len;
+ *	int *aup_gids;
+ */
+extern AUTH *authunix_create (char *__machname, __uid_t __uid, __gid_t __gid,
+			      int __len, __gid_t *__aup_gids);
+extern AUTH *authunix_create_default (void);
+extern AUTH *authnone_create (void) __THROW;
+extern AUTH *authdes_create (const char *__servername, u_int __window,
+			     struct sockaddr *__syncaddr, des_block *__ckey)
+     __THROW;
+extern AUTH *authdes_pk_create (const char *, netobj *, u_int,
+				struct sockaddr *, des_block *) __THROW;
+
+
+#define AUTH_NONE	0		/* no authentication */
+#define	AUTH_NULL	0		/* backward compatibility */
+#define	AUTH_SYS	1		/* unix style (uid, gids) */
+#define	AUTH_UNIX	AUTH_SYS
+#define	AUTH_SHORT	2		/* short hand unix style */
+#define AUTH_DES	3		/* des style (encrypted timestamps) */
+#define AUTH_DH		AUTH_DES	/* Diffie-Hellman (this is DES) */
+#define AUTH_KERB       4               /* kerberos style */
+
+/*
+ *  Netname manipulating functions
+ *
+ */
+extern int getnetname (char *) __THROW;
+extern int host2netname (char *, const char *, const char *) __THROW;
+extern int user2netname (char *, const uid_t, const char *) __THROW;
+extern int netname2user (const char *, uid_t *, gid_t *, int *, gid_t *)
+     __THROW;
+extern int netname2host (const char *, char *, const int) __THROW;
+
+/*
+ *
+ * These routines interface to the keyserv daemon
+ *
+ */
+extern int key_decryptsession (char *, des_block *);
+extern int key_decryptsession_pk (char *, netobj *, des_block *);
+extern int key_encryptsession (char *, des_block *);
+extern int key_encryptsession_pk (char *, netobj *, des_block *);
+extern int key_gendes (des_block *);
+extern int key_setsecret (char *);
+extern int key_secretkey_is_set (void);
+extern int key_get_conv (char *, des_block *);
+
+/*
+ * XDR an opaque authentication struct.
+ */
+extern bool_t xdr_opaque_auth (XDR *, struct opaque_auth *) __THROW;
+
+__END_DECLS
+
+#endif /* rpc/auth.h */
diff --git a/include/rpc/auth_des.h b/include/rpc/auth_des.h
new file mode 100644
index 0000000..19cdc16
--- /dev/null
+++ b/include/rpc/auth_des.h
@@ -0,0 +1,111 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _RPC_AUTH_DES_H
+#define _RPC_AUTH_DES_H	1
+
+#include <sys/cdefs.h>
+#include <rpc/auth.h>
+
+__BEGIN_DECLS
+
+/* There are two kinds of "names": fullnames and nicknames */
+enum authdes_namekind
+  {
+    ADN_FULLNAME,
+    ADN_NICKNAME
+  };
+
+/* A fullname contains the network name of the client,
+   a conversation key and the window */
+struct authdes_fullname
+  {
+    char *name;		/* network name of client, up to MAXNETNAMELEN */
+    des_block key;	/* conversation key */
+    uint32_t window;	/* associated window */
+  };
+
+/* A credential */
+struct authdes_cred
+  {
+    enum authdes_namekind adc_namekind;
+    struct authdes_fullname adc_fullname;
+    uint32_t adc_nickname;
+  };
+
+/* A timeval replacement for !32bit platforms */
+struct rpc_timeval
+  {
+    uint32_t tv_sec;            /* Seconds.  */
+    uint32_t tv_usec;           /* Microseconds.  */
+  };
+
+/* A des authentication verifier */
+struct authdes_verf
+  {
+    union
+      {
+	struct rpc_timeval adv_ctime;	/* clear time */
+	des_block adv_xtime;		/* crypt time */
+      }
+    adv_time_u;
+    uint32_t adv_int_u;
+  };
+
+/* des authentication verifier: client variety
+
+   adv_timestamp is the current time.
+   adv_winverf is the credential window + 1.
+   Both are encrypted using the conversation key. */
+#define adv_timestamp  adv_time_u.adv_ctime
+#define adv_xtimestamp adv_time_u.adv_xtime
+#define adv_winverf    adv_int_u
+
+/* des authentication verifier: server variety
+
+   adv_timeverf is the client's timestamp + client's window
+   adv_nickname is the server's nickname for the client.
+   adv_timeverf is encrypted using the conversation key. */
+#define adv_timeverf   adv_time_u.adv_ctime
+#define adv_xtimeverf  adv_time_u.adv_xtime
+#define adv_nickname   adv_int_u
+
+/* Map a des credential into a unix cred. */
+extern int authdes_getucred (const struct authdes_cred * __adc,
+			     uid_t * __uid, gid_t * __gid,
+			     short *__grouplen, gid_t * __groups) __THROW;
+
+/* Get the public key for NAME and place it in KEY.  NAME can only be
+   up to MAXNETNAMELEN bytes long and the destination buffer KEY should
+   have HEXKEYBYTES + 1 bytes long to fit all characters from the key.  */
+extern int getpublickey (const char *__name, char *__key) __THROW;
+
+/* Get the secret key for NAME and place it in KEY.  PASSWD is used to
+   decrypt the encrypted key stored in the database.  NAME can only be
+   up to MAXNETNAMELEN bytes long and the destination buffer KEY
+   should have HEXKEYBYTES + 1 bytes long to fit all characters from
+   the key.  */
+extern int getsecretkey (const char *__name, char *__key,
+			 const char *__passwd) __THROW;
+
+extern int rtime (struct sockaddr_in *__addrp, struct rpc_timeval *__timep,
+		  struct rpc_timeval *__timeout) __THROW;
+
+__END_DECLS
+
+
+#endif /* rpc/auth_des.h */
diff --git a/include/rpc/auth_unix.h b/include/rpc/auth_unix.h
new file mode 100644
index 0000000..2f4ee1d
--- /dev/null
+++ b/include/rpc/auth_unix.h
@@ -0,0 +1,86 @@
+/*
+ * auth_unix.h, Protocol for UNIX style authentication parameters for RPC
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * The system is very weak.  The client uses no encryption for  it
+ * credentials and only sends null verifiers.  The server sends backs
+ * null verifiers or optionally a verifier that suggests a new short hand
+ * for the credentials.
+ */
+
+#ifndef _RPC_AUTH_UNIX_H
+#define _RPC_AUTH_UNIX_H	1
+
+#include <features.h>
+#include <sys/types.h>
+#include <rpc/types.h>
+#include <rpc/auth.h>
+#include <rpc/xdr.h>
+
+__BEGIN_DECLS
+
+/* The machine name is part of a credential; it may not exceed 255 bytes */
+#define MAX_MACHINE_NAME 255
+
+/* gids compose part of a credential; there may not be more than 16 of them */
+#define NGRPS 16
+
+/*
+ * Unix style credentials.
+ */
+struct authunix_parms
+  {
+    u_long aup_time;
+    char *aup_machname;
+    __uid_t aup_uid;
+    __gid_t aup_gid;
+    u_int aup_len;
+    __gid_t *aup_gids;
+  };
+
+extern bool_t xdr_authunix_parms (XDR *__xdrs, struct authunix_parms *__p)
+     __THROW;
+
+/*
+ * If a response verifier has flavor AUTH_SHORT,
+ * then the body of the response verifier encapsulates the following structure;
+ * again it is serialized in the obvious fashion.
+ */
+struct short_hand_verf
+  {
+    struct opaque_auth new_cred;
+  };
+
+__END_DECLS
+
+#endif /* rpc/auth_unix.h */
diff --git a/include/rpc/clnt.h b/include/rpc/clnt.h
new file mode 100644
index 0000000..f4d4a94
--- /dev/null
+++ b/include/rpc/clnt.h
@@ -0,0 +1,418 @@
+/*
+ * clnt.h - Client side remote procedure call interface.
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPC_CLNT_H
+#define _RPC_CLNT_H	1
+
+#include <features.h>
+#include <sys/types.h>
+#include <rpc/types.h>
+#include <rpc/auth.h>
+#include <sys/un.h>
+
+__BEGIN_DECLS
+
+/*
+ * Rpc calls return an enum clnt_stat.  This should be looked at more,
+ * since each implementation is required to live with this (implementation
+ * independent) list of errors.
+ */
+enum clnt_stat {
+	RPC_SUCCESS=0,			/* call succeeded */
+	/*
+	 * local errors
+	 */
+	RPC_CANTENCODEARGS=1,		/* can't encode arguments */
+	RPC_CANTDECODERES=2,		/* can't decode results */
+	RPC_CANTSEND=3,			/* failure in sending call */
+	RPC_CANTRECV=4,			/* failure in receiving result */
+	RPC_TIMEDOUT=5,			/* call timed out */
+	/*
+	 * remote errors
+	 */
+	RPC_VERSMISMATCH=6,		/* rpc versions not compatible */
+	RPC_AUTHERROR=7,		/* authentication error */
+	RPC_PROGUNAVAIL=8,		/* program not available */
+	RPC_PROGVERSMISMATCH=9,		/* program version mismatched */
+	RPC_PROCUNAVAIL=10,		/* procedure unavailable */
+	RPC_CANTDECODEARGS=11,		/* decode arguments error */
+	RPC_SYSTEMERROR=12,		/* generic "other problem" */
+	RPC_NOBROADCAST = 21,		/* Broadcasting not supported */
+	/*
+	 * callrpc & clnt_create errors
+	 */
+	RPC_UNKNOWNHOST=13,		/* unknown host name */
+	RPC_UNKNOWNPROTO=17,		/* unknown protocol */
+	RPC_UNKNOWNADDR = 19,		/* Remote address unknown */
+
+	/*
+	 * rpcbind errors
+	 */
+	RPC_RPCBFAILURE=14,		/* portmapper failed in its call */
+#define RPC_PMAPFAILURE RPC_RPCBFAILURE
+	RPC_PROGNOTREGISTERED=15,	/* remote program is not registered */
+	RPC_N2AXLATEFAILURE = 22,	/* Name to addr translation failed */
+	/*
+	 * unspecified error
+	 */
+	RPC_FAILED=16,
+	RPC_INTR=18,
+	RPC_TLIERROR=20,
+	RPC_UDERROR=23,
+	/*
+	 * asynchronous errors
+	 */
+	RPC_INPROGRESS = 24,
+	RPC_STALERACHANDLE = 25
+};
+
+
+/*
+ * Error info.
+ */
+struct rpc_err {
+  enum clnt_stat re_status;
+  union {
+    int RE_errno;		/* related system error */
+    enum auth_stat RE_why;	/* why the auth error occurred */
+    struct {
+      u_long low;		/* lowest verion supported */
+      u_long high;		/* highest verion supported */
+    } RE_vers;
+    struct {			/* maybe meaningful if RPC_FAILED */
+      long s1;
+      long s2;
+    } RE_lb;			/* life boot & debugging only */
+  } ru;
+#define	re_errno	ru.RE_errno
+#define	re_why		ru.RE_why
+#define	re_vers		ru.RE_vers
+#define	re_lb		ru.RE_lb
+};
+
+
+/*
+ * Client rpc handle.
+ * Created by individual implementations, see e.g. rpc_udp.c.
+ * Client is responsible for initializing auth, see e.g. auth_none.c.
+ */
+typedef struct CLIENT CLIENT;
+struct CLIENT {
+  AUTH	*cl_auth;		 /* authenticator */
+  struct clnt_ops {
+    enum clnt_stat (*cl_call) (CLIENT *, u_long, xdrproc_t, caddr_t, xdrproc_t,
+			       caddr_t, struct timeval);
+				/* call remote procedure */
+    void (*cl_abort) (void);	/* abort a call */
+    void (*cl_geterr) (CLIENT *, struct rpc_err *);
+				/* get specific error code */
+    bool_t (*cl_freeres) (CLIENT *, xdrproc_t, caddr_t);
+				/* frees results */
+    void (*cl_destroy) (CLIENT *); /* destroy this structure */
+    bool_t (*cl_control) (CLIENT *, int, char *);
+				/* the ioctl() of rpc */
+  } *cl_ops;
+  caddr_t cl_private;		/* private stuff */
+};
+
+
+/*
+ * client side rpc interface ops
+ *
+ * Parameter types are:
+ *
+ */
+
+/*
+ * enum clnt_stat
+ * CLNT_CALL(rh, proc, xargs, argsp, xres, resp, timeout)
+ * 	CLIENT *rh;
+ *	u_long proc;
+ *	xdrproc_t xargs;
+ *	caddr_t argsp;
+ *	xdrproc_t xres;
+ *	caddr_t resp;
+ *	struct timeval timeout;
+ */
+#define	CLNT_CALL(rh, proc, xargs, argsp, xres, resp, secs)	\
+	((*(rh)->cl_ops->cl_call)(rh, proc, xargs, argsp, xres, resp, secs))
+#define	clnt_call(rh, proc, xargs, argsp, xres, resp, secs)	\
+	((*(rh)->cl_ops->cl_call)(rh, proc, xargs, argsp, xres, resp, secs))
+
+/*
+ * void
+ * CLNT_ABORT(rh);
+ * 	CLIENT *rh;
+ */
+#define	CLNT_ABORT(rh)	((*(rh)->cl_ops->cl_abort)(rh))
+#define	clnt_abort(rh)	((*(rh)->cl_ops->cl_abort)(rh))
+
+/*
+ * struct rpc_err
+ * CLNT_GETERR(rh);
+ * 	CLIENT *rh;
+ */
+#define	CLNT_GETERR(rh,errp)	((*(rh)->cl_ops->cl_geterr)(rh, errp))
+#define	clnt_geterr(rh,errp)	((*(rh)->cl_ops->cl_geterr)(rh, errp))
+
+
+/*
+ * bool_t
+ * CLNT_FREERES(rh, xres, resp);
+ * 	CLIENT *rh;
+ *	xdrproc_t xres;
+ *	caddr_t resp;
+ */
+#define	CLNT_FREERES(rh,xres,resp) ((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))
+#define	clnt_freeres(rh,xres,resp) ((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))
+
+/*
+ * bool_t
+ * CLNT_CONTROL(cl, request, info)
+ *      CLIENT *cl;
+ *      u_int request;
+ *      char *info;
+ */
+#define	CLNT_CONTROL(cl,rq,in) ((*(cl)->cl_ops->cl_control)(cl,rq,in))
+#define	clnt_control(cl,rq,in) ((*(cl)->cl_ops->cl_control)(cl,rq,in))
+
+/*
+ * control operations that apply to all transports
+ *
+ * Note: options marked XXX are no-ops in this implementation of RPC.
+ * The are present in TI-RPC but can't be implemented here since they
+ * depend on the presence of STREAMS/TLI, which we don't have.
+ */
+#define CLSET_TIMEOUT        1    /* set timeout (timeval) */
+#define CLGET_TIMEOUT        2    /* get timeout (timeval) */
+#define CLGET_SERVER_ADDR    3    /* get server's address (sockaddr) */
+#define CLGET_FD             6    /* get connections file descriptor */
+#define CLGET_SVC_ADDR       7    /* get server's address (netbuf)      XXX */
+#define CLSET_FD_CLOSE       8    /* close fd while clnt_destroy */
+#define CLSET_FD_NCLOSE      9    /* Do not close fd while clnt_destroy*/
+#define CLGET_XID            10   /* Get xid */
+#define CLSET_XID            11   /* Set xid */
+#define CLGET_VERS           12   /* Get version number */
+#define CLSET_VERS           13   /* Set version number */
+#define CLGET_PROG           14   /* Get program number */
+#define CLSET_PROG           15   /* Set program number */
+#define CLSET_SVC_ADDR       16   /* get server's address (netbuf)      XXX */
+#define CLSET_PUSH_TIMOD     17   /* push timod if not already present  XXX */
+#define CLSET_POP_TIMOD      18   /* pop timod                          XXX */
+/*
+ * Connectionless only control operations
+ */
+#define CLSET_RETRY_TIMEOUT	4	/* set retry timeout (timeval) */
+#define CLGET_RETRY_TIMEOUT	5	/* get retry timeout (timeval) */
+
+/*
+ * void
+ * CLNT_DESTROY(rh);
+ * 	CLIENT *rh;
+ */
+#define	CLNT_DESTROY(rh)	((*(rh)->cl_ops->cl_destroy)(rh))
+#define	clnt_destroy(rh)	((*(rh)->cl_ops->cl_destroy)(rh))
+
+
+/*
+ * RPCTEST is a test program which is accessible on every rpc
+ * transport/port.  It is used for testing, performance evaluation,
+ * and network administration.
+ */
+
+#define RPCTEST_PROGRAM		((u_long)1)
+#define RPCTEST_VERSION		((u_long)1)
+#define RPCTEST_NULL_PROC	((u_long)2)
+#define RPCTEST_NULL_BATCH_PROC	((u_long)3)
+
+/*
+ * By convention, procedure 0 takes null arguments and returns them
+ */
+
+#define NULLPROC ((u_long)0)
+
+/*
+ * Below are the client handle creation routines for the various
+ * implementations of client side rpc.  They can return NULL if a
+ * creation failure occurs.
+ */
+
+/*
+ * Memory based rpc (for speed check and testing)
+ * CLIENT *
+ * clntraw_create(prog, vers)
+ *	u_long prog;
+ *	u_long vers;
+ */
+extern CLIENT *clntraw_create (const u_long __prog, const u_long __vers)
+     __THROW;
+
+
+/*
+ * Generic client creation routine. Supported protocols are "udp", "tcp" and
+ * "unix"
+ * CLIENT *
+ * clnt_create(host, prog, vers, prot)
+ *	char *host; 	-- hostname
+ *	u_long prog;	-- program number
+ *	u_ong vers;	-- version number
+ *	char *prot;	-- protocol
+ */
+extern CLIENT *clnt_create (const char *__host, const u_long __prog,
+			    const u_long __vers, const char *__prot)
+     __THROW;
+
+
+/*
+ * TCP based rpc
+ * CLIENT *
+ * clnttcp_create(raddr, prog, vers, sockp, sendsz, recvsz)
+ *	struct sockaddr_in *raddr;
+ *	u_long prog;
+ *	u_long version;
+ *	register int *sockp;
+ *	u_int sendsz;
+ *	u_int recvsz;
+ */
+extern CLIENT *clnttcp_create (struct sockaddr_in *__raddr, u_long __prog,
+			       u_long __version, int *__sockp, u_int __sendsz,
+			       u_int __recvsz) __THROW;
+
+/*
+ * UDP based rpc.
+ * CLIENT *
+ * clntudp_create(raddr, program, version, wait, sockp)
+ *	struct sockaddr_in *raddr;
+ *	u_long program;
+ *	u_long version;
+ *	struct timeval wait_resend;
+ *	int *sockp;
+ *
+ * Same as above, but you specify max packet sizes.
+ * CLIENT *
+ * clntudp_bufcreate(raddr, program, version, wait, sockp, sendsz, recvsz)
+ *	struct sockaddr_in *raddr;
+ *	u_long program;
+ *	u_long version;
+ *	struct timeval wait_resend;
+ *	int *sockp;
+ *	u_int sendsz;
+ *	u_int recvsz;
+ */
+extern CLIENT *clntudp_create (struct sockaddr_in *__raddr, u_long __program,
+			       u_long __version, struct timeval __wait_resend,
+			       int *__sockp) __THROW;
+extern CLIENT *clntudp_bufcreate (struct sockaddr_in *__raddr,
+				  u_long __program, u_long __version,
+				  struct timeval __wait_resend, int *__sockp,
+				  u_int __sendsz, u_int __recvsz) __THROW;
+
+
+
+
+/*
+ * AF_UNIX based rpc
+ * CLIENT *
+ * clntunix_create(raddr, prog, vers, sockp, sendsz, recvsz)
+ *      struct sockaddr_un *raddr;
+ *      u_long prog;
+ *      u_long version;
+ *      register int *sockp;
+ *      u_int sendsz;
+ *      u_int recvsz;
+ */
+extern CLIENT *clntunix_create  (struct sockaddr_un *__raddr, u_long __program,
+				 u_long __version, int *__sockp,
+				 u_int __sendsz, u_int __recvsz) __THROW;
+
+
+extern int callrpc (const char *__host, const u_long __prognum,
+		    const u_long __versnum, const u_long __procnum,
+		    const xdrproc_t __inproc, const char *__in,
+		    const xdrproc_t __outproc, char *__out) __THROW;
+extern int _rpc_dtablesize (void) __THROW;
+
+/*
+ * Print why creation failed
+ */
+extern void clnt_pcreateerror (const char *__msg);	/* stderr */
+extern char *clnt_spcreateerror(const char *__msg) __THROW;	/* string */
+
+/*
+ * Like clnt_perror(), but is more verbose in its output
+ */
+extern void clnt_perrno (enum clnt_stat __num);		/* stderr */
+
+/*
+ * Print an English error message, given the client error code
+ */
+extern void clnt_perror (CLIENT *__clnt, const char *__msg);
+							/* stderr */
+extern char *clnt_sperror (CLIENT *__clnt, const char *__msg) __THROW;
+							/* string */
+
+/*
+ * If a creation fails, the following allows the user to figure out why.
+ */
+struct rpc_createerr {
+	enum clnt_stat cf_stat;
+	struct rpc_err cf_error; /* useful when cf_stat == RPC_PMAPFAILURE */
+};
+
+extern struct rpc_createerr rpc_createerr;
+
+
+
+/*
+ * Copy error message to buffer.
+ */
+extern char *clnt_sperrno (enum clnt_stat __num) __THROW;	/* string */
+
+/*
+ * get the port number on the host for the rpc program,version and proto
+ */
+extern int getrpcport (const char * __host, u_long __prognum,
+		       u_long __versnum, u_int __proto) __THROW;
+
+/*
+ * get the local host's IP address without consulting
+ * name service library functions
+ */
+extern void get_myaddress (struct sockaddr_in *) __THROW;
+
+#define UDPMSGSIZE	8800	/* rpc imposed limit on udp msg size */
+#define RPCSMALLMSGSIZE	400	/* a more reasonable packet size */
+
+__END_DECLS
+
+#endif /* rpc/clnt.h */
diff --git a/include/rpc/des_crypt.h b/include/rpc/des_crypt.h
new file mode 100644
index 0000000..77cca3c
--- /dev/null
+++ b/include/rpc/des_crypt.h
@@ -0,0 +1,96 @@
+/*
+ * @(#)des_crypt.h	2.1 88/08/11 4.0 RPCSRC
+ *
+ * des_crypt.h, des library routine interface
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DES_CRYPT_H__
+#define __DES_CRYPT_H__ 1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#define DES_MAXDATA 8192	/* max bytes encrypted in one call */
+#define DES_DIRMASK (1 << 0)
+#define DES_ENCRYPT (0*DES_DIRMASK)	/* Encrypt */
+#define DES_DECRYPT (1*DES_DIRMASK)	/* Decrypt */
+
+
+#define DES_DEVMASK (1 << 1)
+#define	DES_HW (0*DES_DEVMASK)	/* Use hardware device */
+#define DES_SW (1*DES_DEVMASK)	/* Use software device */
+
+
+#define DESERR_NONE 0	/* succeeded */
+#define DESERR_NOHWDEVICE 1	/* succeeded, but hw device not available */
+#define DESERR_HWERROR 2	/* failed, hardware/driver error */
+#define DESERR_BADPARAM 3	/* failed, bad parameter to call */
+
+#define DES_FAILED(err) \
+	((err) > DESERR_NOHWDEVICE)
+
+/*
+ * cbc_crypt()
+ * ecb_crypt()
+ *
+ * Encrypt (or decrypt) len bytes of a buffer buf.
+ * The length must be a multiple of eight.
+ * The key should have odd parity in the low bit of each byte.
+ * ivec is the input vector, and is updated to the new one (cbc only).
+ * The mode is created by oring together the appropriate parameters.
+ * DESERR_NOHWDEVICE is returned if DES_HW was specified but
+ * there was no hardware to do it on (the data will still be
+ * encrypted though, in software).
+ */
+
+
+/*
+ * Cipher Block Chaining mode
+ */
+extern int cbc_crypt (char *__key, char *__buf, unsigned __len,
+		      unsigned __mode, char *__ivec) __THROW;
+
+/*
+ * Electronic Code Book mode
+ */
+extern int ecb_crypt (char *__key, char *__buf, unsigned __len,
+		      unsigned __mode) __THROW;
+
+/*
+ * Set des parity for a key.
+ * DES parity is odd and in the low bit of each byte
+ */
+extern void des_setparity (char *__key) __THROW;
+
+__END_DECLS
+
+#endif
diff --git a/include/rpc/key_prot.h b/include/rpc/key_prot.h
new file mode 100644
index 0000000..74627e6
--- /dev/null
+++ b/include/rpc/key_prot.h
@@ -0,0 +1,343 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _KEY_PROT_H_RPCGEN
+#define _KEY_PROT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+/* Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Compiled from key_prot.x using rpcgen.
+ * DO NOT EDIT THIS FILE!
+ * This is NOT source code!
+ */
+#define PROOT 3
+#define HEXMODULUS "d4a0ba0250b6fd2ec626e7efd637df76c716e22d0944b88b"
+#define HEXKEYBYTES 48
+#define KEYSIZE 192
+#define KEYBYTES 24
+#define KEYCHECKSUMSIZE 16
+
+enum keystatus {
+	KEY_SUCCESS = 0,
+	KEY_NOSECRET = 1,
+	KEY_UNKNOWN = 2,
+	KEY_SYSTEMERR = 3,
+};
+typedef enum keystatus keystatus;
+#ifdef __cplusplus
+extern "C" bool_t xdr_keystatus(XDR *, keystatus*);
+#elif __STDC__
+extern  bool_t xdr_keystatus(XDR *, keystatus*);
+#else /* Old Style C */
+bool_t xdr_keystatus();
+#endif /* Old Style C */
+
+
+typedef char keybuf[HEXKEYBYTES];
+#ifdef __cplusplus
+extern "C" bool_t xdr_keybuf(XDR *, keybuf);
+#elif __STDC__
+extern  bool_t xdr_keybuf(XDR *, keybuf);
+#else /* Old Style C */
+bool_t xdr_keybuf();
+#endif /* Old Style C */
+
+
+typedef char *netnamestr;
+#ifdef __cplusplus
+extern "C" bool_t xdr_netnamestr(XDR *, netnamestr*);
+#elif __STDC__
+extern  bool_t xdr_netnamestr(XDR *, netnamestr*);
+#else /* Old Style C */
+bool_t xdr_netnamestr();
+#endif /* Old Style C */
+
+
+struct cryptkeyarg {
+	netnamestr remotename;
+	des_block deskey;
+};
+typedef struct cryptkeyarg cryptkeyarg;
+#ifdef __cplusplus
+extern "C" bool_t xdr_cryptkeyarg(XDR *, cryptkeyarg*);
+#elif __STDC__
+extern  bool_t xdr_cryptkeyarg(XDR *, cryptkeyarg*);
+#else /* Old Style C */
+bool_t xdr_cryptkeyarg();
+#endif /* Old Style C */
+
+
+struct cryptkeyarg2 {
+	netnamestr remotename;
+	netobj remotekey;
+	des_block deskey;
+};
+typedef struct cryptkeyarg2 cryptkeyarg2;
+#ifdef __cplusplus
+extern "C" bool_t xdr_cryptkeyarg2(XDR *, cryptkeyarg2*);
+#elif __STDC__
+extern  bool_t xdr_cryptkeyarg2(XDR *, cryptkeyarg2*);
+#else /* Old Style C */
+bool_t xdr_cryptkeyarg2();
+#endif /* Old Style C */
+
+
+struct cryptkeyres {
+	keystatus status;
+	union {
+		des_block deskey;
+	} cryptkeyres_u;
+};
+typedef struct cryptkeyres cryptkeyres;
+#ifdef __cplusplus
+extern "C" bool_t xdr_cryptkeyres(XDR *, cryptkeyres*);
+#elif __STDC__
+extern  bool_t xdr_cryptkeyres(XDR *, cryptkeyres*);
+#else /* Old Style C */
+bool_t xdr_cryptkeyres();
+#endif /* Old Style C */
+
+#define MAXGIDS 16
+
+struct unixcred {
+	u_int uid;
+	u_int gid;
+	struct {
+		u_int gids_len;
+		u_int *gids_val;
+	} gids;
+};
+typedef struct unixcred unixcred;
+#ifdef __cplusplus
+extern "C" bool_t xdr_unixcred(XDR *, unixcred*);
+#elif __STDC__
+extern  bool_t xdr_unixcred(XDR *, unixcred*);
+#else /* Old Style C */
+bool_t xdr_unixcred();
+#endif /* Old Style C */
+
+
+struct getcredres {
+	keystatus status;
+	union {
+		unixcred cred;
+	} getcredres_u;
+};
+typedef struct getcredres getcredres;
+#ifdef __cplusplus
+extern "C" bool_t xdr_getcredres(XDR *, getcredres*);
+#elif __STDC__
+extern  bool_t xdr_getcredres(XDR *, getcredres*);
+#else /* Old Style C */
+bool_t xdr_getcredres();
+#endif /* Old Style C */
+
+
+struct key_netstarg {
+	keybuf st_priv_key;
+	keybuf st_pub_key;
+	netnamestr st_netname;
+};
+typedef struct key_netstarg key_netstarg;
+#ifdef __cplusplus
+extern "C" bool_t xdr_key_netstarg(XDR *, key_netstarg*);
+#elif __STDC__
+extern  bool_t xdr_key_netstarg(XDR *, key_netstarg*);
+#else /* Old Style C */
+bool_t xdr_key_netstarg();
+#endif /* Old Style C */
+
+
+struct key_netstres {
+	keystatus status;
+	union {
+		key_netstarg knet;
+	} key_netstres_u;
+};
+typedef struct key_netstres key_netstres;
+#ifdef __cplusplus
+extern "C" bool_t xdr_key_netstres(XDR *, key_netstres*);
+#elif __STDC__
+extern  bool_t xdr_key_netstres(XDR *, key_netstres*);
+#else /* Old Style C */
+bool_t xdr_key_netstres();
+#endif /* Old Style C */
+
+
+#ifndef opaque
+#define opaque char
+#endif
+
+
+#define KEY_PROG ((u_long)100029)
+#define KEY_VERS ((u_long)1)
+
+#ifdef __cplusplus
+#define KEY_SET ((u_long)1)
+extern "C" keystatus * key_set_1(opaque *, CLIENT *);
+extern "C" keystatus * key_set_1_svc(opaque *, struct svc_req *);
+#define KEY_ENCRYPT ((u_long)2)
+extern "C" cryptkeyres * key_encrypt_1(cryptkeyarg *, CLIENT *);
+extern "C" cryptkeyres * key_encrypt_1_svc(cryptkeyarg *, struct svc_req *);
+#define KEY_DECRYPT ((u_long)3)
+extern "C" cryptkeyres * key_decrypt_1(cryptkeyarg *, CLIENT *);
+extern "C" cryptkeyres * key_decrypt_1_svc(cryptkeyarg *, struct svc_req *);
+#define KEY_GEN ((u_long)4)
+extern "C" des_block * key_gen_1(void *, CLIENT *);
+extern "C" des_block * key_gen_1_svc(void *, struct svc_req *);
+#define KEY_GETCRED ((u_long)5)
+extern "C" getcredres * key_getcred_1(netnamestr *, CLIENT *);
+extern "C" getcredres * key_getcred_1_svc(netnamestr *, struct svc_req *);
+
+#elif __STDC__
+#define KEY_SET ((u_long)1)
+extern  keystatus * key_set_1(opaque *, CLIENT *);
+extern  keystatus * key_set_1_svc(opaque *, struct svc_req *);
+#define KEY_ENCRYPT ((u_long)2)
+extern  cryptkeyres * key_encrypt_1(cryptkeyarg *, CLIENT *);
+extern  cryptkeyres * key_encrypt_1_svc(cryptkeyarg *, struct svc_req *);
+#define KEY_DECRYPT ((u_long)3)
+extern  cryptkeyres * key_decrypt_1(cryptkeyarg *, CLIENT *);
+extern  cryptkeyres * key_decrypt_1_svc(cryptkeyarg *, struct svc_req *);
+#define KEY_GEN ((u_long)4)
+extern  des_block * key_gen_1(void *, CLIENT *);
+extern  des_block * key_gen_1_svc(void *, struct svc_req *);
+#define KEY_GETCRED ((u_long)5)
+extern  getcredres * key_getcred_1(netnamestr *, CLIENT *);
+extern  getcredres * key_getcred_1_svc(netnamestr *, struct svc_req *);
+
+#else /* Old Style C */
+#define KEY_SET ((u_long)1)
+extern  keystatus * key_set_1();
+extern  keystatus * key_set_1_svc();
+#define KEY_ENCRYPT ((u_long)2)
+extern  cryptkeyres * key_encrypt_1();
+extern  cryptkeyres * key_encrypt_1_svc();
+#define KEY_DECRYPT ((u_long)3)
+extern  cryptkeyres * key_decrypt_1();
+extern  cryptkeyres * key_decrypt_1_svc();
+#define KEY_GEN ((u_long)4)
+extern  des_block * key_gen_1();
+extern  des_block * key_gen_1_svc();
+#define KEY_GETCRED ((u_long)5)
+extern  getcredres * key_getcred_1();
+extern  getcredres * key_getcred_1_svc();
+#endif /* Old Style C */
+#define KEY_VERS2 ((u_long)2)
+
+#ifdef __cplusplus
+extern "C" keystatus * key_set_2(opaque *, CLIENT *);
+extern "C" keystatus * key_set_2_svc(opaque *, struct svc_req *);
+extern "C" cryptkeyres * key_encrypt_2(cryptkeyarg *, CLIENT *);
+extern "C" cryptkeyres * key_encrypt_2_svc(cryptkeyarg *, struct svc_req *);
+extern "C" cryptkeyres * key_decrypt_2(cryptkeyarg *, CLIENT *);
+extern "C" cryptkeyres * key_decrypt_2_svc(cryptkeyarg *, struct svc_req *);
+extern "C" des_block * key_gen_2(void *, CLIENT *);
+extern "C" des_block * key_gen_2_svc(void *, struct svc_req *);
+extern "C" getcredres * key_getcred_2(netnamestr *, CLIENT *);
+extern "C" getcredres * key_getcred_2_svc(netnamestr *, struct svc_req *);
+#define KEY_ENCRYPT_PK ((u_long)6)
+extern "C" cryptkeyres * key_encrypt_pk_2(cryptkeyarg2 *, CLIENT *);
+extern "C" cryptkeyres * key_encrypt_pk_2_svc(cryptkeyarg2 *, struct svc_req *);
+#define KEY_DECRYPT_PK ((u_long)7)
+extern "C" cryptkeyres * key_decrypt_pk_2(cryptkeyarg2 *, CLIENT *);
+extern "C" cryptkeyres * key_decrypt_pk_2_svc(cryptkeyarg2 *, struct svc_req *);
+#define KEY_NET_PUT ((u_long)8)
+extern "C" keystatus * key_net_put_2(key_netstarg *, CLIENT *);
+extern "C" keystatus * key_net_put_2_svc(key_netstarg *, struct svc_req *);
+#define KEY_NET_GET ((u_long)9)
+extern "C" key_netstres * key_net_get_2(void *, CLIENT *);
+extern "C" key_netstres * key_net_get_2_svc(void *, struct svc_req *);
+#define KEY_GET_CONV ((u_long)10)
+extern "C" cryptkeyres * key_get_conv_2(opaque *, CLIENT *);
+extern "C" cryptkeyres * key_get_conv_2_svc(opaque *, struct svc_req *);
+
+#elif __STDC__
+extern  keystatus * key_set_2(opaque *, CLIENT *);
+extern  keystatus * key_set_2_svc(opaque *, struct svc_req *);
+extern  cryptkeyres * key_encrypt_2(cryptkeyarg *, CLIENT *);
+extern  cryptkeyres * key_encrypt_2_svc(cryptkeyarg *, struct svc_req *);
+extern  cryptkeyres * key_decrypt_2(cryptkeyarg *, CLIENT *);
+extern  cryptkeyres * key_decrypt_2_svc(cryptkeyarg *, struct svc_req *);
+extern  des_block * key_gen_2(void *, CLIENT *);
+extern  des_block * key_gen_2_svc(void *, struct svc_req *);
+extern  getcredres * key_getcred_2(netnamestr *, CLIENT *);
+extern  getcredres * key_getcred_2_svc(netnamestr *, struct svc_req *);
+#define KEY_ENCRYPT_PK ((u_long)6)
+extern  cryptkeyres * key_encrypt_pk_2(cryptkeyarg2 *, CLIENT *);
+extern  cryptkeyres * key_encrypt_pk_2_svc(cryptkeyarg2 *, struct svc_req *);
+#define KEY_DECRYPT_PK ((u_long)7)
+extern  cryptkeyres * key_decrypt_pk_2(cryptkeyarg2 *, CLIENT *);
+extern  cryptkeyres * key_decrypt_pk_2_svc(cryptkeyarg2 *, struct svc_req *);
+#define KEY_NET_PUT ((u_long)8)
+extern  keystatus * key_net_put_2(key_netstarg *, CLIENT *);
+extern  keystatus * key_net_put_2_svc(key_netstarg *, struct svc_req *);
+#define KEY_NET_GET ((u_long)9)
+extern  key_netstres * key_net_get_2(void *, CLIENT *);
+extern  key_netstres * key_net_get_2_svc(void *, struct svc_req *);
+#define KEY_GET_CONV ((u_long)10)
+extern  cryptkeyres * key_get_conv_2(opaque *, CLIENT *);
+extern  cryptkeyres * key_get_conv_2_svc(opaque *, struct svc_req *);
+
+#else /* Old Style C */
+extern  keystatus * key_set_2();
+extern  keystatus * key_set_2_svc();
+extern  cryptkeyres * key_encrypt_2();
+extern  cryptkeyres * key_encrypt_2_svc();
+extern  cryptkeyres * key_decrypt_2();
+extern  cryptkeyres * key_decrypt_2_svc();
+extern  des_block * key_gen_2();
+extern  des_block * key_gen_2_svc();
+extern  getcredres * key_getcred_2();
+extern  getcredres * key_getcred_2_svc();
+#define KEY_ENCRYPT_PK ((u_long)6)
+extern  cryptkeyres * key_encrypt_pk_2();
+extern  cryptkeyres * key_encrypt_pk_2_svc();
+#define KEY_DECRYPT_PK ((u_long)7)
+extern  cryptkeyres * key_decrypt_pk_2();
+extern  cryptkeyres * key_decrypt_pk_2_svc();
+#define KEY_NET_PUT ((u_long)8)
+extern  keystatus * key_net_put_2();
+extern  keystatus * key_net_put_2_svc();
+#define KEY_NET_GET ((u_long)9)
+extern  key_netstres * key_net_get_2();
+extern  key_netstres * key_net_get_2_svc();
+#define KEY_GET_CONV ((u_long)10)
+extern  cryptkeyres * key_get_conv_2();
+extern  cryptkeyres * key_get_conv_2_svc();
+#endif /* Old Style C */
+
+#endif /* !_KEY_PROT_H_RPCGEN */
diff --git a/include/rpc/netdb.h b/include/rpc/netdb.h
new file mode 100644
index 0000000..529a4ad
--- /dev/null
+++ b/include/rpc/netdb.h
@@ -0,0 +1,74 @@
+/* @(#)netdb.h	2.1 88/07/29 3.9 RPCSRC */
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Cleaned up for GNU C library roland@gnu.ai.mit.edu:
+   added multiple inclusion protection and use of <sys/cdefs.h>.
+   In GNU this file is #include'd by <netdb.h>.  */
+
+#ifndef _RPC_NETDB_H
+#define _RPC_NETDB_H	1
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+__BEGIN_DECLS
+
+struct rpcent
+{
+  char *r_name;		/* Name of server for this rpc program.  */
+  char **r_aliases;	/* Alias list.  */
+  int r_number;		/* RPC program number.  */
+};
+
+extern void setrpcent (int __stayopen) __THROW;
+extern void endrpcent (void) __THROW;
+extern struct rpcent *getrpcbyname (const char *__name) __THROW;
+extern struct rpcent *getrpcbynumber (int __number) __THROW;
+extern struct rpcent *getrpcent (void) __THROW;
+
+#ifdef __USE_MISC
+extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
+			   char *__buffer, size_t __buflen,
+			   struct rpcent **__result) __THROW;
+
+extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
+			     char *__buffer, size_t __buflen,
+			     struct rpcent **__result) __THROW;
+
+extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
+			size_t __buflen, struct rpcent **__result) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* rpc/netdb.h */
diff --git a/include/rpc/pmap_clnt.h b/include/rpc/pmap_clnt.h
new file mode 100644
index 0000000..1cc94b8
--- /dev/null
+++ b/include/rpc/pmap_clnt.h
@@ -0,0 +1,95 @@
+/*
+ * pmap_clnt.h
+ * Supplies C routines to get to portmap services.
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPC_PMAP_CLNT_H
+#define _RPC_PMAP_CLNT_H	1
+
+#include <features.h>
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+#include <rpc/clnt.h>
+
+__BEGIN_DECLS
+
+typedef bool_t (*resultproc_t) (caddr_t __resp, struct sockaddr_in *__raddr);
+
+/*
+ * Usage:
+ *	success = pmap_set(program, version, protocol, port);
+ *	success = pmap_unset(program, version);
+ *	port = pmap_getport(address, program, version, protocol);
+ *	head = pmap_getmaps(address);
+ *	clnt_stat = pmap_rmtcall(address, program, version, procedure,
+ *		xdrargs, argsp, xdrres, resp, tout, port_ptr)
+ *		(works for udp only.)
+ * 	clnt_stat = clnt_broadcast(program, version, procedure,
+ *		xdrargs, argsp,	xdrres, resp, eachresult)
+ *		(like pmap_rmtcall, except the call is broadcasted to all
+ *		locally connected nets.  For each valid response received,
+ *		the procedure eachresult is called.  Its form is:
+ *	done = eachresult(resp, raddr)
+ *		bool_t done;
+ *		caddr_t resp;
+ *		struct sockaddr_in raddr;
+ *		where resp points to the results of the call and raddr is the
+ *		address if the responder to the broadcast.
+ */
+
+extern bool_t pmap_set (const u_long __program, const u_long __vers,
+			int __protocol, u_short __port) __THROW;
+extern bool_t pmap_unset (const u_long __program, const u_long __vers)
+     __THROW;
+extern struct pmaplist *pmap_getmaps (struct sockaddr_in *__address) __THROW;
+extern enum clnt_stat pmap_rmtcall (struct sockaddr_in *__addr,
+				    const u_long __prog,
+				    const u_long __vers,
+				    const u_long __proc,
+				    xdrproc_t __xdrargs,
+				    caddr_t __argsp, xdrproc_t __xdrres,
+				    caddr_t __resp, struct timeval __tout,
+				    u_long *__port_ptr) __THROW;
+extern enum clnt_stat clnt_broadcast (const u_long __prog,
+				      const u_long __vers,
+				      const u_long __proc, xdrproc_t __xargs,
+				      caddr_t __argsp, xdrproc_t __xresults,
+				      caddr_t __resultsp,
+				      resultproc_t __eachresult) __THROW;
+extern u_short pmap_getport (struct sockaddr_in *__address,
+			     const u_long __program,
+			     const u_long __version, u_int __protocol)
+     __THROW;
+
+__END_DECLS
+
+#endif /* rpc/pmap_clnt.h */
diff --git a/include/rpc/pmap_prot.h b/include/rpc/pmap_prot.h
new file mode 100644
index 0000000..e5fd7cb
--- /dev/null
+++ b/include/rpc/pmap_prot.h
@@ -0,0 +1,105 @@
+/*
+ * pmap_prot.h
+ * Protocol for the local binder service, or pmap.
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPC_PMAP_PROT_H
+#define _RPC_PMAP_PROT_H	1
+
+#include <features.h>
+
+#include <rpc/xdr.h>
+
+__BEGIN_DECLS
+
+/* The following procedures are supported by the protocol:
+ *
+ * PMAPPROC_NULL() returns ()
+ *	takes nothing, returns nothing
+ *
+ * PMAPPROC_SET(struct pmap) returns (bool_t)
+ *	TRUE is success, FALSE is failure.  Registers the tuple
+ *	[prog, vers, prot, port].
+ *
+ * PMAPPROC_UNSET(struct pmap) returns (bool_t)
+ *	TRUE is success, FALSE is failure.  Un-registers pair
+ *	[prog, vers].  prot and port are ignored.
+ *
+ * PMAPPROC_GETPORT(struct pmap) returns (long unsigned).
+ *	0 is failure.  Otherwise returns the port number where the pair
+ *	[prog, vers] is registered.  It may lie!
+ *
+ * PMAPPROC_DUMP() RETURNS (struct pmaplist *)
+ *
+ * PMAPPROC_CALLIT(unsigned, unsigned, unsigned, string<>)
+ *	RETURNS (port, string<>);
+ * usage: encapsulatedresults = PMAPPROC_CALLIT(prog, vers, proc, encapsulatedargs);
+ *	Calls the procedure on the local machine.  If it is not registered,
+ *	this procedure is quite; ie it does not return error information!!!
+ *	This procedure only is supported on rpc/udp and calls via
+ *	rpc/udp.  This routine only passes null authentication parameters.
+ *	This file has no interface to xdr routines for PMAPPROC_CALLIT.
+ *
+ * The service supports remote procedure calls on udp/ip or tcp/ip socket 111.
+ */
+
+#define PMAPPORT		((u_short)111)
+#define PMAPPROG		((u_long)100000)
+#define PMAPVERS		((u_long)2)
+#define PMAPVERS_PROTO		((u_long)2)
+#define PMAPVERS_ORIG		((u_long)1)
+#define PMAPPROC_NULL		((u_long)0)
+#define PMAPPROC_SET		((u_long)1)
+#define PMAPPROC_UNSET		((u_long)2)
+#define PMAPPROC_GETPORT	((u_long)3)
+#define PMAPPROC_DUMP		((u_long)4)
+#define PMAPPROC_CALLIT		((u_long)5)
+
+struct pmap {
+	long unsigned pm_prog;
+	long unsigned pm_vers;
+	long unsigned pm_prot;
+	long unsigned pm_port;
+};
+
+extern bool_t xdr_pmap (XDR *__xdrs, struct pmap *__regs) __THROW;
+
+struct pmaplist {
+	struct pmap	pml_map;
+	struct pmaplist *pml_next;
+};
+
+extern bool_t xdr_pmaplist (XDR *__xdrs, struct pmaplist **__rp) __THROW;
+
+__END_DECLS
+
+#endif /* rpc/pmap_prot.h */
diff --git a/include/rpc/pmap_rmt.h b/include/rpc/pmap_rmt.h
new file mode 100644
index 0000000..f868014
--- /dev/null
+++ b/include/rpc/pmap_rmt.h
@@ -0,0 +1,65 @@
+/*
+ * Structures and XDR routines for parameters to and replies from
+ * the portmapper remote-call-service.
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPC_PMAP_RMT_H
+#define _RPC_PMAP_RMT_H	1
+
+#include <features.h>
+#include <sys/types.h>
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+
+__BEGIN_DECLS
+
+struct rmtcallargs {
+	u_long prog, vers, proc, arglen;
+	caddr_t args_ptr;
+	xdrproc_t xdr_args;
+};
+
+extern bool_t xdr_rmtcall_args (XDR *__xdrs, struct rmtcallargs *__crp)
+     __THROW;
+
+struct rmtcallres {
+	u_long *port_ptr;
+	u_long resultslen;
+	caddr_t results_ptr;
+	xdrproc_t xdr_results;
+};
+
+extern bool_t xdr_rmtcallres (XDR *__xdrs, struct rmtcallres *__crp) __THROW;
+
+__END_DECLS
+
+#endif /* rpc/pmap_rmt.h */
diff --git a/include/rpc/rpc.h b/include/rpc/rpc.h
new file mode 100644
index 0000000..173a4e3
--- /dev/null
+++ b/include/rpc/rpc.h
@@ -0,0 +1,94 @@
+/*
+ * rpc.h, Just includes the billions of rpc header files necessary to
+ * do remote procedure calling.
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPC_RPC_H
+#define _RPC_RPC_H 1
+
+#include <rpc/types.h>		/* some typedefs */
+#include <netinet/in.h>
+
+/* external data representation interfaces */
+#include <rpc/xdr.h>		/* generic (de)serializer */
+
+/* Client side only authentication */
+#include <rpc/auth.h>		/* generic authenticator (client side) */
+
+/* Client side (mostly) remote procedure call */
+#include <rpc/clnt.h>		/* generic rpc stuff */
+
+/* semi-private protocol headers */
+#include <rpc/rpc_msg.h>	/* protocol for rpc messages */
+#include <rpc/auth_unix.h>	/* protocol for unix style cred */
+#include <rpc/auth_des.h>	/* protocol for des style cred */
+
+/* Server side only remote procedure callee */
+#include <rpc/svc.h>		/* service manager and multiplexer */
+#include <rpc/svc_auth.h>	/* service side authenticator */
+
+/*
+ * COMMENT OUT THE NEXT INCLUDE IF RUNNING ON SUN OS OR ON A VERSION
+ * OF UNIX BASED ON NFSSRC.  These systems will already have the structures
+ * defined by <rpc/netdb.h> included in <netdb.h>.
+ */
+/* routines for parsing /etc/rpc */
+#include <rpc/netdb.h>		/* structures and routines to parse /etc/rpc */
+
+__BEGIN_DECLS
+
+/* Global variables, protected for multi-threaded applications.  */
+extern fd_set *__rpc_thread_svc_fdset (void) __attribute__ ((__const__));
+#define svc_fdset (*__rpc_thread_svc_fdset ())
+
+extern struct rpc_createerr *__rpc_thread_createerr (void)
+     __attribute__ ((__const__));
+#define get_rpc_createerr() (*__rpc_thread_createerr ())
+/* The people who "engineered" RPC should bee punished for naming the
+   data structure and the variable the same.  We cannot always define the
+   macro 'rpc_createerr' because this would prevent people from defining
+   object of type 'struct rpc_createerr'.  So we leave it up to the user
+   to select transparent replacement also of this variable.  */
+#ifdef _RPC_MT_VARS
+# define rpc_createerr (*__rpc_thread_createerr ())
+#endif
+
+extern struct pollfd **__rpc_thread_svc_pollfd (void)
+     __attribute__ ((__const__));
+#define svc_pollfd (*__rpc_thread_svc_pollfd ())
+
+extern int *__rpc_thread_svc_max_pollfd (void) __attribute__ ((__const__));
+#define svc_max_pollfd (*__rpc_thread_svc_max_pollfd ())
+
+__END_DECLS
+
+#endif /* rpc/rpc.h */
diff --git a/include/rpc/rpc_des.h b/include/rpc/rpc_des.h
new file mode 100644
index 0000000..4b3c426
--- /dev/null
+++ b/include/rpc/rpc_des.h
@@ -0,0 +1,71 @@
+/*
+ * Generic DES driver interface
+ * Keep this file hardware independent!
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _DES_H
+#define _DES_H
+
+#include <sys/types.h>
+
+#define DES_MAXLEN	65536	/* maximum # of bytes to encrypt  */
+#define DES_QUICKLEN	16	/* maximum # of bytes to encrypt quickly */
+
+enum desdir
+  {
+    ENCRYPT, DECRYPT
+  };
+enum desmode
+  {
+    CBC, ECB
+  };
+
+/*
+ * parameters to ioctl call
+ */
+struct desparams
+  {
+    u_char des_key[8];		/* key (with low bit parity) */
+    enum desdir des_dir;	/* direction */
+    enum desmode des_mode;	/* mode */
+    u_char des_ivec[8];		/* input vector */
+    unsigned des_len;		/* number of bytes to crypt */
+    union
+      {
+	u_char UDES_data[DES_QUICKLEN];
+	u_char *UDES_buf;
+      }
+    UDES;
+#define des_data UDES.UDES_data	/* direct data here if quick */
+#define des_buf	UDES.UDES_buf	/* otherwise, pointer to data */
+  };
+
+#endif
diff --git a/include/rpc/rpc_msg.h b/include/rpc/rpc_msg.h
new file mode 100644
index 0000000..273b187
--- /dev/null
+++ b/include/rpc/rpc_msg.h
@@ -0,0 +1,198 @@
+/*
+ * rpc_msg.h
+ * rpc message definition
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPC_MSG_H
+#define _RPC_MSG_H 1
+
+#include <sys/cdefs.h>
+
+#include <rpc/xdr.h>
+#include <rpc/clnt.h>
+
+#define RPC_MSG_VERSION		((u_long) 2)
+#define RPC_SERVICE_PORT	((u_short) 2048)
+
+__BEGIN_DECLS
+
+/*
+ * Bottom up definition of an rpc message.
+ * NOTE: call and reply use the same overall struct but
+ * different parts of unions within it.
+ */
+
+enum msg_type {
+	CALL=0,
+	REPLY=1
+};
+
+enum reply_stat {
+	MSG_ACCEPTED=0,
+	MSG_DENIED=1
+};
+
+enum accept_stat {
+	SUCCESS=0,
+	PROG_UNAVAIL=1,
+	PROG_MISMATCH=2,
+	PROC_UNAVAIL=3,
+	GARBAGE_ARGS=4,
+	SYSTEM_ERR=5
+};
+
+enum reject_stat {
+	RPC_MISMATCH=0,
+	AUTH_ERROR=1
+};
+
+/*
+ * Reply part of an rpc exchange
+ */
+
+/*
+ * Reply to an rpc request that was accepted by the server.
+ * Note: there could be an error even though the request was
+ * accepted.
+ */
+struct accepted_reply {
+	struct opaque_auth	ar_verf;
+	enum accept_stat	ar_stat;
+	union {
+		struct {
+			u_long	low;
+			u_long	high;
+		} AR_versions;
+		struct {
+			caddr_t	where;
+			xdrproc_t proc;
+		} AR_results;
+		/* and many other null cases */
+	} ru;
+#define	ar_results	ru.AR_results
+#define	ar_vers		ru.AR_versions
+};
+
+/*
+ * Reply to an rpc request that was rejected by the server.
+ */
+struct rejected_reply {
+	enum reject_stat rj_stat;
+	union {
+		struct {
+			u_long low;
+			u_long high;
+		} RJ_versions;
+		enum auth_stat RJ_why;  /* why authentication did not work */
+	} ru;
+#define	rj_vers	ru.RJ_versions
+#define	rj_why	ru.RJ_why
+};
+
+/*
+ * Body of a reply to an rpc request.
+ */
+struct reply_body {
+	enum reply_stat rp_stat;
+	union {
+		struct accepted_reply RP_ar;
+		struct rejected_reply RP_dr;
+	} ru;
+#define	rp_acpt	ru.RP_ar
+#define	rp_rjct	ru.RP_dr
+};
+
+/*
+ * Body of an rpc request call.
+ */
+struct call_body {
+	u_long cb_rpcvers;	/* must be equal to two */
+	u_long cb_prog;
+	u_long cb_vers;
+	u_long cb_proc;
+	struct opaque_auth cb_cred;
+	struct opaque_auth cb_verf; /* protocol specific - provided by client */
+};
+
+/*
+ * The rpc message
+ */
+struct rpc_msg {
+	u_long			rm_xid;
+	enum msg_type		rm_direction;
+	union {
+		struct call_body RM_cmb;
+		struct reply_body RM_rmb;
+	} ru;
+#define	rm_call		ru.RM_cmb
+#define	rm_reply	ru.RM_rmb
+};
+#define	acpted_rply	ru.RM_rmb.ru.RP_ar
+#define	rjcted_rply	ru.RM_rmb.ru.RP_dr
+
+
+/*
+ * XDR routine to handle a rpc message.
+ * xdr_callmsg(xdrs, cmsg)
+ * 	XDR *xdrs;
+ * 	struct rpc_msg *cmsg;
+ */
+extern bool_t	xdr_callmsg (XDR *__xdrs, struct rpc_msg *__cmsg) __THROW;
+
+/*
+ * XDR routine to pre-serialize the static part of a rpc message.
+ * xdr_callhdr(xdrs, cmsg)
+ * 	XDR *xdrs;
+ * 	struct rpc_msg *cmsg;
+ */
+extern bool_t	xdr_callhdr (XDR *__xdrs, struct rpc_msg *__cmsg) __THROW;
+
+/*
+ * XDR routine to handle a rpc reply.
+ * xdr_replymsg(xdrs, rmsg)
+ * 	XDR *xdrs;
+ * 	struct rpc_msg *rmsg;
+ */
+extern bool_t	xdr_replymsg (XDR *__xdrs, struct rpc_msg *__rmsg) __THROW;
+
+/*
+ * Fills in the error part of a reply message.
+ * _seterr_reply(msg, error)
+ * 	struct rpc_msg *msg;
+ * 	struct rpc_err *error;
+ */
+extern void	_seterr_reply (struct rpc_msg *__msg, struct rpc_err *__error)
+     __THROW;
+
+__END_DECLS
+
+#endif /* rpc/rpc_msg.h */
diff --git a/include/rpc/svc.h b/include/rpc/svc.h
new file mode 100644
index 0000000..ed5989b
--- /dev/null
+++ b/include/rpc/svc.h
@@ -0,0 +1,336 @@
+/*
+ * svc.h, Server-side remote procedure call interface.
+ *
+ * Copyright (C) 2012-2014 Free Software Foundation, Inc.
+ * This file is part of the GNU C Library.
+ *
+ * The GNU C Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * The GNU C Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the GNU C Library; if not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPC_SVC_H
+#define _RPC_SVC_H 1
+
+#include <features.h>
+#include <rpc/rpc_msg.h>
+
+__BEGIN_DECLS
+
+/*
+ * This interface must manage two items concerning remote procedure calling:
+ *
+ * 1) An arbitrary number of transport connections upon which rpc requests
+ * are received.  The two most notable transports are TCP and UDP;  they are
+ * created and registered by routines in svc_tcp.c and svc_udp.c, respectively;
+ * they in turn call xprt_register and xprt_unregister.
+ *
+ * 2) An arbitrary number of locally registered services.  Services are
+ * described by the following four data: program number, version number,
+ * "service dispatch" function, a transport handle, and a boolean that
+ * indicates whether or not the exported program should be registered with a
+ * local binder service;  if true the program's number and version and the
+ * port number from the transport handle are registered with the binder.
+ * These data are registered with the rpc svc system via svc_register.
+ *
+ * A service's dispatch function is called whenever an rpc request comes in
+ * on a transport.  The request's program and version numbers must match
+ * those of the registered service.  The dispatch function is passed two
+ * parameters, struct svc_req * and SVCXPRT *, defined below.
+ */
+
+enum xprt_stat {
+	XPRT_DIED,
+	XPRT_MOREREQS,
+	XPRT_IDLE
+};
+
+/*
+ * Server side transport handle
+ */
+typedef struct SVCXPRT SVCXPRT;
+struct SVCXPRT {
+  int xp_sock;
+  u_short xp_port;		/* associated port number */
+  const struct xp_ops {
+    bool_t	(*xp_recv) (SVCXPRT *__xprt, struct rpc_msg *__msg);
+				/* receive incoming requests */
+    enum xprt_stat (*xp_stat) (SVCXPRT *__xprt);
+				/* get transport status */
+    bool_t	(*xp_getargs) (SVCXPRT *__xprt, xdrproc_t __xdr_args,
+			       caddr_t __args_ptr); /* get arguments */
+    bool_t	(*xp_reply) (SVCXPRT *__xprt, struct rpc_msg *__msg);
+				/* send reply */
+    bool_t	(*xp_freeargs) (SVCXPRT *__xprt, xdrproc_t __xdr_args,
+				caddr_t __args_ptr);
+				/* free mem allocated for args */
+    void	(*xp_destroy) (SVCXPRT *__xprt);
+				/* destroy this struct */
+  } *xp_ops;
+  int		xp_addrlen;	 /* length of remote address */
+  struct sockaddr_in xp_raddr;	 /* remote address */
+  struct opaque_auth xp_verf;	 /* raw response verifier */
+  caddr_t		xp_p1;		 /* private */
+  caddr_t		xp_p2;		 /* private */
+  char		xp_pad [256];	/* padding, internal use */
+};
+
+/*
+ *  Approved way of getting address of caller
+ */
+#define svc_getcaller(x) (&(x)->xp_raddr)
+
+/*
+ * Operations defined on an SVCXPRT handle
+ *
+ * SVCXPRT		*xprt;
+ * struct rpc_msg	*msg;
+ * xdrproc_t		 xargs;
+ * caddr_t		 argsp;
+ */
+#define SVC_RECV(xprt, msg)				\
+	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))
+#define svc_recv(xprt, msg)				\
+	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))
+
+#define SVC_STAT(xprt)					\
+	(*(xprt)->xp_ops->xp_stat)(xprt)
+#define svc_stat(xprt)					\
+	(*(xprt)->xp_ops->xp_stat)(xprt)
+
+#define SVC_GETARGS(xprt, xargs, argsp)			\
+	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))
+#define svc_getargs(xprt, xargs, argsp)			\
+	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))
+
+#define SVC_REPLY(xprt, msg)				\
+	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))
+#define svc_reply(xprt, msg)				\
+	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))
+
+#define SVC_FREEARGS(xprt, xargs, argsp)		\
+	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))
+#define svc_freeargs(xprt, xargs, argsp)		\
+	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))
+
+#define SVC_DESTROY(xprt)				\
+	(*(xprt)->xp_ops->xp_destroy)(xprt)
+#define svc_destroy(xprt)				\
+	(*(xprt)->xp_ops->xp_destroy)(xprt)
+
+
+/*
+ * Service request
+ */
+struct svc_req {
+  rpcprog_t rq_prog;            /* service program number */
+  rpcvers_t rq_vers;            /* service protocol version */
+  rpcproc_t rq_proc;            /* the desired procedure */
+  struct opaque_auth rq_cred;   /* raw creds from the wire */
+  caddr_t rq_clntcred;          /* read only cooked cred */
+  SVCXPRT *rq_xprt;             /* associated transport */
+};
+
+#ifndef __DISPATCH_FN_T
+#define __DISPATCH_FN_T
+typedef void (*__dispatch_fn_t) (struct svc_req*, SVCXPRT*);
+#endif
+
+/*
+ * Service registration
+ *
+ * svc_register(xprt, prog, vers, dispatch, protocol)
+ *	SVCXPRT *xprt;
+ *	rpcprog_t prog;
+ *	rpcvers_t vers;
+ *	void (*dispatch)(struct svc_req*, SVCXPRT*);
+ *	rpcprot_t protocol;  like TCP or UDP, zero means do not register
+ */
+extern bool_t svc_register (SVCXPRT *__xprt, rpcprog_t __prog,
+			    rpcvers_t __vers, __dispatch_fn_t __dispatch,
+			    rpcprot_t __protocol) __THROW;
+
+/*
+ * Service un-registration
+ *
+ * svc_unregister(prog, vers)
+ *	rpcprog_t prog;
+ *	rpcvers_t vers;
+ */
+extern void svc_unregister (rpcprog_t __prog, rpcvers_t __vers) __THROW;
+
+/*
+ * Transport registration.
+ *
+ * xprt_register(xprt)
+ *	SVCXPRT *xprt;
+ */
+extern void xprt_register (SVCXPRT *__xprt) __THROW;
+
+/*
+ * Transport un-register
+ *
+ * xprt_unregister(xprt)
+ *	SVCXPRT *xprt;
+ */
+extern void xprt_unregister (SVCXPRT *__xprt) __THROW;
+
+
+/*
+ * When the service routine is called, it must first check to see if it
+ * knows about the procedure;  if not, it should call svcerr_noproc
+ * and return.  If so, it should deserialize its arguments via
+ * SVC_GETARGS (defined above).  If the deserialization does not work,
+ * svcerr_decode should be called followed by a return.  Successful
+ * decoding of the arguments should be followed the execution of the
+ * procedure's code and a call to svc_sendreply.
+ *
+ * Also, if the service refuses to execute the procedure due to too-
+ * weak authentication parameters, svcerr_weakauth should be called.
+ * Note: do not confuse access-control failure with weak authentication!
+ *
+ * NB: In pure implementations of rpc, the caller always waits for a reply
+ * msg.  This message is sent when svc_sendreply is called.
+ * Therefore pure service implementations should always call
+ * svc_sendreply even if the function logically returns void;  use
+ * xdr.h - xdr_void for the xdr routine.  HOWEVER, tcp based rpc allows
+ * for the abuse of pure rpc via batched calling or pipelining.  In the
+ * case of a batched call, svc_sendreply should NOT be called since
+ * this would send a return message, which is what batching tries to avoid.
+ * It is the service/protocol writer's responsibility to know which calls are
+ * batched and which are not.  Warning: responding to batch calls may
+ * deadlock the caller and server processes!
+ */
+
+extern bool_t	svc_sendreply (SVCXPRT *__xprt, xdrproc_t __xdr_results,
+			       caddr_t __xdr_location) __THROW;
+
+extern void	svcerr_decode (SVCXPRT *__xprt) __THROW;
+
+extern void	svcerr_weakauth (SVCXPRT *__xprt) __THROW;
+
+extern void	svcerr_noproc (SVCXPRT *__xprt) __THROW;
+
+extern void	svcerr_progvers (SVCXPRT *__xprt, rpcvers_t __low_vers,
+				 rpcvers_t __high_vers) __THROW;
+
+extern void	svcerr_auth (SVCXPRT *__xprt, enum auth_stat __why) __THROW;
+
+extern void	svcerr_noprog (SVCXPRT *__xprt) __THROW;
+
+extern void	svcerr_systemerr (SVCXPRT *__xprt) __THROW;
+
+/*
+ * Lowest level dispatching -OR- who owns this process anyway.
+ * Somebody has to wait for incoming requests and then call the correct
+ * service routine.  The routine svc_run does infinite waiting; i.e.,
+ * svc_run never returns.
+ * Since another (coexistent) package may wish to selectively wait for
+ * incoming calls or other events outside of the rpc architecture, the
+ * routine svc_getreq is provided.  It must be passed readfds, the
+ * "in-place" results of a select system call (see select, section 2).
+ */
+
+/*
+ * Global keeper of rpc service descriptors in use
+ * dynamic; must be inspected before each call to select
+ */
+
+extern struct pollfd *svc_pollfd;
+extern int svc_max_pollfd;
+extern fd_set svc_fdset;
+#define svc_fds svc_fdset.fds_bits[0]	/* compatibility */
+
+/*
+ * a small program implemented by the svc_rpc implementation itself;
+ * also see clnt.h for protocol numbers.
+ */
+extern void svc_getreq (int __rdfds) __THROW;
+extern void svc_getreq_common (const int __fd) __THROW;
+extern void svc_getreqset (fd_set *__readfds) __THROW;
+extern void svc_getreq_poll (struct pollfd *, const int) __THROW;
+extern void svc_exit (void) __THROW;
+extern void svc_run (void) __THROW;
+
+/*
+ * Socket to use on svcxxx_create call to get default socket
+ */
+#define	RPC_ANYSOCK	-1
+
+/*
+ * These are the existing service side transport implementations
+ */
+
+/*
+ * Memory based rpc for testing and timing.
+ */
+extern SVCXPRT *svcraw_create (void) __THROW;
+
+/*
+ * Udp based rpc.
+ */
+extern SVCXPRT *svcudp_create (int __sock) __THROW;
+extern SVCXPRT *svcudp_bufcreate (int __sock, u_int __sendsz, u_int __recvsz)
+     __THROW;
+
+/*
+ * Tcp based rpc.
+ */
+extern SVCXPRT *svctcp_create (int __sock, u_int __sendsize, u_int __recvsize)
+     __THROW;
+
+/*
+ * FD based rpc.
+ */
+extern SVCXPRT *svcfd_create (int __sock, u_int __sendsize, u_int __recvsize)
+     __THROW;
+
+/*
+ * Unix based rpc.
+ */
+extern SVCXPRT *svcunix_create (int __sock, u_int __sendsize, u_int __recvsize,
+				char *__path) __THROW;
+
+
+__END_DECLS
+
+#endif /* rpc/svc.h */
diff --git a/include/rpc/svc_auth.h b/include/rpc/svc_auth.h
new file mode 100644
index 0000000..4ba2741
--- /dev/null
+++ b/include/rpc/svc_auth.h
@@ -0,0 +1,50 @@
+/*
+ * svc_auth.h, Service side of rpc authentication.
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPC_SVC_AUTH_H
+#define _RPC_SVC_AUTH_H	1
+
+#include <features.h>
+#include <rpc/svc.h>
+
+__BEGIN_DECLS
+
+/*
+ * Server side authenticator
+ */
+extern enum auth_stat _authenticate (struct svc_req *__rqst,
+				     struct rpc_msg *__msg) __THROW;
+
+__END_DECLS
+
+#endif /* rpc/svc_auth.h */
diff --git a/include/rpc/types.h b/include/rpc/types.h
new file mode 100644
index 0000000..beded52
--- /dev/null
+++ b/include/rpc/types.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/* fixincludes should not add extern "C" to this file */
+/*
+ * Rpc additions to <sys/types.h>
+ */
+#ifndef _RPC_TYPES_H
+#define _RPC_TYPES_H 1
+
+typedef int bool_t;
+typedef int enum_t;
+/* This needs to be changed to uint32_t in the future */
+typedef unsigned long rpcprog_t;
+typedef unsigned long rpcvers_t;
+typedef unsigned long rpcproc_t;
+typedef unsigned long rpcprot_t;
+typedef unsigned long rpcport_t;
+
+#define        __dontcare__    -1
+
+#ifndef FALSE
+#      define  FALSE   (0)
+#endif
+
+#ifndef TRUE
+#      define  TRUE    (1)
+#endif
+
+#ifndef NULL
+#      define  NULL 0
+#endif
+
+#include <stdlib.h>		/* For malloc decl.  */
+#define mem_alloc(bsize)	malloc(bsize)
+/*
+ * XXX: This must not use the second argument, or code in xdr_array.c needs
+ * to be modified.
+ */
+#define mem_free(ptr, bsize)	free(ptr)
+
+#ifndef makedev /* ie, we haven't already included it */
+#include <sys/types.h>
+#endif
+
+#if defined __APPLE_CC__ || defined __FreeBSD__
+# define __u_char_defined
+# define __daddr_t_defined
+#endif
+
+#ifndef __u_char_defined
+typedef __u_char u_char;
+typedef __u_short u_short;
+typedef __u_int u_int;
+typedef __u_long u_long;
+typedef __quad_t quad_t;
+typedef __u_quad_t u_quad_t;
+typedef __fsid_t fsid_t;
+# define __u_char_defined
+#endif
+#ifndef __daddr_t_defined
+typedef __daddr_t daddr_t;
+typedef __caddr_t caddr_t;
+# define __daddr_t_defined
+#endif
+
+#include <sys/time.h>
+#include <sys/param.h>
+
+#include <netinet/in.h>
+
+#ifndef INADDR_LOOPBACK
+#define       INADDR_LOOPBACK         (u_long)0x7F000001
+#endif
+#ifndef MAXHOSTNAMELEN
+#define        MAXHOSTNAMELEN  64
+#endif
+
+#endif /* rpc/types.h */
diff --git a/include/rpc/xdr.h b/include/rpc/xdr.h
new file mode 100644
index 0000000..d80d8f7
--- /dev/null
+++ b/include/rpc/xdr.h
@@ -0,0 +1,377 @@
+/*
+ * xdr.h, External Data Representation Serialization Routines.
+ *
+ * Copyright (c) 2010, 2012, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPC_XDR_H
+#define _RPC_XDR_H 1
+
+#include <features.h>
+#include <sys/types.h>
+#include <rpc/types.h>
+
+/* We need FILE.  */
+#include <stdio.h>
+
+__BEGIN_DECLS
+
+/*
+ * XDR provides a conventional way for converting between C data
+ * types and an external bit-string representation.  Library supplied
+ * routines provide for the conversion on built-in C data types.  These
+ * routines and utility routines defined here are used to help implement
+ * a type encode/decode routine for each user-defined type.
+ *
+ * Each data type provides a single procedure which takes two arguments:
+ *
+ *      bool_t
+ *      xdrproc(xdrs, argresp)
+ *              XDR *xdrs;
+ *              <type> *argresp;
+ *
+ * xdrs is an instance of a XDR handle, to which or from which the data
+ * type is to be converted.  argresp is a pointer to the structure to be
+ * converted.  The XDR handle contains an operation field which indicates
+ * which of the operations (ENCODE, DECODE * or FREE) is to be performed.
+ *
+ * XDR_DECODE may allocate space if the pointer argresp is null.  This
+ * data can be freed with the XDR_FREE operation.
+ *
+ * We write only one procedure per data type to make it easy
+ * to keep the encode and decode procedures for a data type consistent.
+ * In many cases the same code performs all operations on a user defined type,
+ * because all the hard work is done in the component type routines.
+ * decode as a series of calls on the nested data types.
+ */
+
+/*
+ * Xdr operations.  XDR_ENCODE causes the type to be encoded into the
+ * stream.  XDR_DECODE causes the type to be extracted from the stream.
+ * XDR_FREE can be used to release the space allocated by an XDR_DECODE
+ * request.
+ */
+enum xdr_op {
+  XDR_ENCODE = 0,
+  XDR_DECODE = 1,
+  XDR_FREE = 2
+};
+
+/*
+ * This is the number of bytes per unit of external data.
+ */
+#define BYTES_PER_XDR_UNIT	(4)
+/*
+ * This only works if the above is a power of 2.  But it's defined to be
+ * 4 by the appropriate RFCs.  So it will work.  And it's normally quicker
+ * than the old routine.
+ */
+#if 1
+#define RNDUP(x)  (((x) + BYTES_PER_XDR_UNIT - 1) & ~(BYTES_PER_XDR_UNIT - 1))
+#else /* this is the old routine */
+#define RNDUP(x)  ((((x) + BYTES_PER_XDR_UNIT - 1) / BYTES_PER_XDR_UNIT) \
+		    * BYTES_PER_XDR_UNIT)
+#endif
+
+/*
+ * The XDR handle.
+ * Contains operation which is being applied to the stream,
+ * an operations vector for the particular implementation (e.g. see xdr_mem.c),
+ * and two private fields for the use of the particular implementation.
+ */
+typedef struct XDR XDR;
+struct XDR
+  {
+    enum xdr_op x_op;		/* operation; fast additional param */
+    struct xdr_ops
+      {
+	bool_t (*x_getlong) (XDR *__xdrs, long *__lp);
+	/* get a long from underlying stream */
+	bool_t (*x_putlong) (XDR *__xdrs, const long *__lp);
+	/* put a long to " */
+	bool_t (*x_getbytes) (XDR *__xdrs, caddr_t __addr, u_int __len);
+	/* get some bytes from " */
+	bool_t (*x_putbytes) (XDR *__xdrs, const char *__addr, u_int __len);
+	/* put some bytes to " */
+	u_int (*x_getpostn) (const XDR *__xdrs);
+	/* returns bytes off from beginning */
+	bool_t (*x_setpostn) (XDR *__xdrs, u_int __pos);
+	/* lets you reposition the stream */
+	int32_t *(*x_inline) (XDR *__xdrs, u_int __len);
+	/* buf quick ptr to buffered data */
+	void (*x_destroy) (XDR *__xdrs);
+	/* free privates of this xdr_stream */
+	bool_t (*x_getint32) (XDR *__xdrs, int32_t *__ip);
+	/* get a int from underlying stream */
+	bool_t (*x_putint32) (XDR *__xdrs, const int32_t *__ip);
+	/* put a int to " */
+      }
+     *x_ops;
+    caddr_t x_public;		/* users' data */
+    caddr_t x_private;		/* pointer to private data */
+    caddr_t x_base;		/* private used for position info */
+    u_int x_handy;		/* extra private word */
+  };
+
+/*
+ * A xdrproc_t exists for each data type which is to be encoded or decoded.
+ *
+ * The second argument to the xdrproc_t is a pointer to an opaque pointer.
+ * The opaque pointer generally points to a structure of the data type
+ * to be decoded.  If this pointer is 0, then the type routines should
+ * allocate dynamic storage of the appropriate size and return it.
+ * bool_t       (*xdrproc_t)(XDR *, caddr_t *);
+ */
+typedef bool_t (*xdrproc_t) (XDR *, void *,...);
+
+
+/*
+ * Operations defined on a XDR handle
+ *
+ * XDR          *xdrs;
+ * int32_t      *int32p;
+ * long         *longp;
+ * caddr_t       addr;
+ * u_int         len;
+ * u_int         pos;
+ */
+#define XDR_GETINT32(xdrs, int32p)                      \
+	(*(xdrs)->x_ops->x_getint32)(xdrs, int32p)
+#define xdr_getint32(xdrs, int32p)                      \
+	(*(xdrs)->x_ops->x_getint32)(xdrs, int32p)
+
+#define XDR_PUTINT32(xdrs, int32p)                      \
+	(*(xdrs)->x_ops->x_putint32)(xdrs, int32p)
+#define xdr_putint32(xdrs, int32p)                      \
+	(*(xdrs)->x_ops->x_putint32)(xdrs, int32p)
+
+#define XDR_GETLONG(xdrs, longp)			\
+	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
+#define xdr_getlong(xdrs, longp)			\
+	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
+
+#define XDR_PUTLONG(xdrs, longp)			\
+	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
+#define xdr_putlong(xdrs, longp)			\
+	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
+
+#define XDR_GETBYTES(xdrs, addr, len)			\
+	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
+#define xdr_getbytes(xdrs, addr, len)			\
+	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
+
+#define XDR_PUTBYTES(xdrs, addr, len)			\
+	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
+#define xdr_putbytes(xdrs, addr, len)			\
+	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
+
+#define XDR_GETPOS(xdrs)				\
+	(*(xdrs)->x_ops->x_getpostn)(xdrs)
+#define xdr_getpos(xdrs)				\
+	(*(xdrs)->x_ops->x_getpostn)(xdrs)
+
+#define XDR_SETPOS(xdrs, pos)				\
+	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
+#define xdr_setpos(xdrs, pos)				\
+	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
+
+#define	XDR_INLINE(xdrs, len)				\
+	(*(xdrs)->x_ops->x_inline)(xdrs, len)
+#define	xdr_inline(xdrs, len)				\
+	(*(xdrs)->x_ops->x_inline)(xdrs, len)
+
+#define	XDR_DESTROY(xdrs)					\
+	do {							\
+		if ((xdrs)->x_ops->x_destroy)			\
+			(*(xdrs)->x_ops->x_destroy)(xdrs);	\
+	} while (0)
+#define	xdr_destroy(xdrs)					\
+	do {							\
+		if ((xdrs)->x_ops->x_destroy)			\
+			(*(xdrs)->x_ops->x_destroy)(xdrs);	\
+	} while (0)
+
+/*
+ * Support struct for discriminated unions.
+ * You create an array of xdrdiscrim structures, terminated with
+ * an entry with a null procedure pointer.  The xdr_union routine gets
+ * the discriminant value and then searches the array of structures
+ * for a matching value.  If a match is found the associated xdr routine
+ * is called to handle that part of the union.  If there is
+ * no match, then a default routine may be called.
+ * If there is no match and no default routine it is an error.
+ */
+#define NULL_xdrproc_t ((xdrproc_t)0)
+struct xdr_discrim
+{
+  int value;
+  xdrproc_t proc;
+};
+
+/*
+ * Inline routines for fast encode/decode of primitive data types.
+ * Caveat emptor: these use single memory cycles to get the
+ * data from the underlying buffer, and will fail to operate
+ * properly if the data is not aligned.  The standard way to use these
+ * is to say:
+ *      if ((buf = XDR_INLINE(xdrs, count)) == NULL)
+ *              return (FALSE);
+ *      <<< macro calls >>>
+ * where ``count'' is the number of bytes of data occupied
+ * by the primitive data types.
+ *
+ * N.B. and frozen for all time: each data type here uses 4 bytes
+ * of external representation.
+ */
+
+#define IXDR_GET_INT32(buf)           ((int32_t)ntohl((uint32_t)*(buf)++))
+#define IXDR_PUT_INT32(buf, v)        (*(buf)++ = (int32_t)htonl((uint32_t)(v)))
+#define IXDR_GET_U_INT32(buf)         ((uint32_t)IXDR_GET_INT32(buf))
+#define IXDR_PUT_U_INT32(buf, v)      IXDR_PUT_INT32(buf, (int32_t)(v))
+
+/* WARNING: The IXDR_*_LONG defines are removed by Sun for new platforms
+ * and shouldn't be used any longer. Code which use this defines or longs
+ * in the RPC code will not work on 64bit Solaris platforms !
+ */
+#define IXDR_GET_LONG(buf) ((long)IXDR_GET_U_INT32(buf))
+#define IXDR_PUT_LONG(buf, v) ((long)IXDR_PUT_INT32(buf, (long)(v)))
+#define IXDR_GET_U_LONG(buf)	      ((u_long)IXDR_GET_LONG(buf))
+#define IXDR_PUT_U_LONG(buf, v)	      IXDR_PUT_LONG(buf, (long)(v))
+
+
+#define IXDR_GET_BOOL(buf)            ((bool_t)IXDR_GET_LONG(buf))
+#define IXDR_GET_ENUM(buf, t)         ((t)IXDR_GET_LONG(buf))
+#define IXDR_GET_SHORT(buf)           ((short)IXDR_GET_LONG(buf))
+#define IXDR_GET_U_SHORT(buf)         ((u_short)IXDR_GET_LONG(buf))
+
+#define IXDR_PUT_BOOL(buf, v)         IXDR_PUT_LONG(buf, (long)(v))
+#define IXDR_PUT_ENUM(buf, v)         IXDR_PUT_LONG(buf, (long)(v))
+#define IXDR_PUT_SHORT(buf, v)        IXDR_PUT_LONG(buf, (long)(v))
+#define IXDR_PUT_U_SHORT(buf, v)      IXDR_PUT_LONG(buf, (long)(v))
+
+/*
+ * These are the "generic" xdr routines.
+ * None of these can have const applied because it's not possible to
+ * know whether the call is a read or a write to the passed parameter
+ * also, the XDR structure is always updated by some of these calls.
+ */
+extern bool_t xdr_void (void) __THROW;
+extern bool_t xdr_short (XDR *__xdrs, short *__sp) __THROW;
+extern bool_t xdr_u_short (XDR *__xdrs, u_short *__usp) __THROW;
+extern bool_t xdr_int (XDR *__xdrs, int *__ip) __THROW;
+extern bool_t xdr_u_int (XDR *__xdrs, u_int *__up) __THROW;
+extern bool_t xdr_long (XDR *__xdrs, long *__lp) __THROW;
+extern bool_t xdr_u_long (XDR *__xdrs, u_long *__ulp) __THROW;
+extern bool_t xdr_hyper (XDR *__xdrs, quad_t *__llp) __THROW;
+extern bool_t xdr_u_hyper (XDR *__xdrs, u_quad_t *__ullp) __THROW;
+extern bool_t xdr_longlong_t (XDR *__xdrs, quad_t *__llp) __THROW;
+extern bool_t xdr_u_longlong_t (XDR *__xdrs, u_quad_t *__ullp) __THROW;
+extern bool_t xdr_int8_t (XDR *__xdrs, int8_t *__ip) __THROW;
+extern bool_t xdr_uint8_t (XDR *__xdrs, uint8_t *__up) __THROW;
+extern bool_t xdr_int16_t (XDR *__xdrs, int16_t *__ip) __THROW;
+extern bool_t xdr_uint16_t (XDR *__xdrs, uint16_t *__up) __THROW;
+extern bool_t xdr_int32_t (XDR *__xdrs, int32_t *__ip) __THROW;
+extern bool_t xdr_uint32_t (XDR *__xdrs, uint32_t *__up) __THROW;
+extern bool_t xdr_int64_t (XDR *__xdrs, int64_t *__ip) __THROW;
+extern bool_t xdr_uint64_t (XDR *__xdrs, uint64_t *__up) __THROW;
+extern bool_t xdr_quad_t (XDR *__xdrs, quad_t *__ip) __THROW;
+extern bool_t xdr_u_quad_t (XDR *__xdrs, u_quad_t *__up) __THROW;
+extern bool_t xdr_bool (XDR *__xdrs, bool_t *__bp) __THROW;
+extern bool_t xdr_enum (XDR *__xdrs, enum_t *__ep) __THROW;
+extern bool_t xdr_array (XDR * _xdrs, caddr_t *__addrp, u_int *__sizep,
+			 u_int __maxsize, u_int __elsize, xdrproc_t __elproc)
+     __THROW;
+extern bool_t xdr_bytes (XDR *__xdrs, char **__cpp, u_int *__sizep,
+			 u_int __maxsize) __THROW;
+extern bool_t xdr_opaque (XDR *__xdrs, caddr_t __cp, u_int __cnt) __THROW;
+extern bool_t xdr_string (XDR *__xdrs, char **__cpp, u_int __maxsize) __THROW;
+extern bool_t xdr_union (XDR *__xdrs, enum_t *__dscmp, char *__unp,
+			 const struct xdr_discrim *__choices,
+			 xdrproc_t __dfault) __THROW;
+extern bool_t xdr_char (XDR *__xdrs, char *__cp) __THROW;
+extern bool_t xdr_u_char (XDR *__xdrs, u_char *__cp) __THROW;
+extern bool_t xdr_vector (XDR *__xdrs, char *__basep, u_int __nelem,
+			  u_int __elemsize, xdrproc_t __xdr_elem) __THROW;
+extern bool_t xdr_float (XDR *__xdrs, float *__fp) __THROW;
+extern bool_t xdr_double (XDR *__xdrs, double *__dp) __THROW;
+extern bool_t xdr_reference (XDR *__xdrs, caddr_t *__xpp, u_int __size,
+			     xdrproc_t __proc) __THROW;
+extern bool_t xdr_pointer (XDR *__xdrs, char **__objpp,
+			   u_int __obj_size, xdrproc_t __xdr_obj) __THROW;
+extern bool_t xdr_wrapstring (XDR *__xdrs, char **__cpp) __THROW;
+extern u_long xdr_sizeof (xdrproc_t, void *) __THROW;
+
+/*
+ * Common opaque bytes objects used by many rpc protocols;
+ * declared here due to commonality.
+ */
+#define MAX_NETOBJ_SZ 1024
+struct netobj
+{
+  u_int n_len;
+  char *n_bytes;
+};
+typedef struct netobj netobj;
+extern bool_t xdr_netobj (XDR *__xdrs, struct netobj *__np) __THROW;
+
+/*
+ * These are the public routines for the various implementations of
+ * xdr streams.
+ */
+
+/* XDR using memory buffers */
+extern void xdrmem_create (XDR *__xdrs, const caddr_t __addr,
+			   u_int __size, enum xdr_op __xop) __THROW;
+
+/* XDR using stdio library */
+extern void xdrstdio_create (XDR *__xdrs, FILE *__file, enum xdr_op __xop)
+     __THROW;
+
+/* XDR pseudo records for tcp */
+extern void xdrrec_create (XDR *__xdrs, u_int __sendsize,
+			   u_int __recvsize, caddr_t __tcp_handle,
+			   int (*__readit) (char *, char *, int),
+			   int (*__writeit) (char *, char *, int)) __THROW;
+
+/* make end of xdr record */
+extern bool_t xdrrec_endofrecord (XDR *__xdrs, bool_t __sendnow) __THROW;
+
+/* move to beginning of next record */
+extern bool_t xdrrec_skiprecord (XDR *__xdrs) __THROW;
+
+/* true if no more input */
+extern bool_t xdrrec_eof (XDR *__xdrs) __THROW;
+
+/* free memory buffers for xdr */
+extern void xdr_free (xdrproc_t __proc, char *__objp) __THROW;
+
+__END_DECLS
+
+#endif /* rpc/xdr.h */
diff --git a/include/rpcsvc/bootparam.h b/include/rpcsvc/bootparam.h
new file mode 100644
index 0000000..20e8441
--- /dev/null
+++ b/include/rpcsvc/bootparam.h
@@ -0,0 +1,23 @@
+/* Copyright (C) 1999-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _RPCSVC_BOOTPARAM_H
+#define _RPCSVC_BOOTPARAM_H
+
+#include <rpcsvc/bootparam_prot.h>
+
+#endif  /* _RPCSVC_BOOTPARAM_H */
diff --git a/include/rpcsvc/bootparam_prot.h b/include/rpcsvc/bootparam_prot.h
new file mode 100644
index 0000000..fbed446
--- /dev/null
+++ b/include/rpcsvc/bootparam_prot.h
@@ -0,0 +1,124 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _BOOTPARAM_PROT_H_RPCGEN
+#define _BOOTPARAM_PROT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rpc/types.h>
+#include <sys/time.h>
+#include <sys/errno.h>
+#include <nfs/nfs.h>
+#define MAX_MACHINE_NAME 255
+#define MAX_PATH_LEN 1024
+#define MAX_FILEID 32
+#define IP_ADDR_TYPE 1
+
+typedef char *bp_machine_name_t;
+
+typedef char *bp_path_t;
+
+typedef char *bp_fileid_t;
+
+struct ip_addr_t {
+	char net;
+	char host;
+	char lh;
+	char impno;
+};
+typedef struct ip_addr_t ip_addr_t;
+
+struct bp_address {
+	int address_type;
+	union {
+		ip_addr_t ip_addr;
+	} bp_address_u;
+};
+typedef struct bp_address bp_address;
+
+struct bp_whoami_arg {
+	bp_address client_address;
+};
+typedef struct bp_whoami_arg bp_whoami_arg;
+
+struct bp_whoami_res {
+	bp_machine_name_t client_name;
+	bp_machine_name_t domain_name;
+	bp_address router_address;
+};
+typedef struct bp_whoami_res bp_whoami_res;
+
+struct bp_getfile_arg {
+	bp_machine_name_t client_name;
+	bp_fileid_t file_id;
+};
+typedef struct bp_getfile_arg bp_getfile_arg;
+
+struct bp_getfile_res {
+	bp_machine_name_t server_name;
+	bp_address server_address;
+	bp_path_t server_path;
+};
+typedef struct bp_getfile_res bp_getfile_res;
+
+#define BOOTPARAMPROG 100026
+#define BOOTPARAMVERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define BOOTPARAMPROC_WHOAMI 1
+extern  bp_whoami_res * bootparamproc_whoami_1(bp_whoami_arg *, CLIENT *);
+extern  bp_whoami_res * bootparamproc_whoami_1_svc(bp_whoami_arg *, struct svc_req *);
+#define BOOTPARAMPROC_GETFILE 2
+extern  bp_getfile_res * bootparamproc_getfile_1(bp_getfile_arg *, CLIENT *);
+extern  bp_getfile_res * bootparamproc_getfile_1_svc(bp_getfile_arg *, struct svc_req *);
+extern int bootparamprog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define BOOTPARAMPROC_WHOAMI 1
+extern  bp_whoami_res * bootparamproc_whoami_1();
+extern  bp_whoami_res * bootparamproc_whoami_1_svc();
+#define BOOTPARAMPROC_GETFILE 2
+extern  bp_getfile_res * bootparamproc_getfile_1();
+extern  bp_getfile_res * bootparamproc_getfile_1_svc();
+extern int bootparamprog_1_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_bp_machine_name_t (XDR *, bp_machine_name_t*);
+extern  bool_t xdr_bp_path_t (XDR *, bp_path_t*);
+extern  bool_t xdr_bp_fileid_t (XDR *, bp_fileid_t*);
+extern  bool_t xdr_ip_addr_t (XDR *, ip_addr_t*);
+extern  bool_t xdr_bp_address (XDR *, bp_address*);
+extern  bool_t xdr_bp_whoami_arg (XDR *, bp_whoami_arg*);
+extern  bool_t xdr_bp_whoami_res (XDR *, bp_whoami_res*);
+extern  bool_t xdr_bp_getfile_arg (XDR *, bp_getfile_arg*);
+extern  bool_t xdr_bp_getfile_res (XDR *, bp_getfile_res*);
+
+#else /* K&R C */
+extern bool_t xdr_bp_machine_name_t ();
+extern bool_t xdr_bp_path_t ();
+extern bool_t xdr_bp_fileid_t ();
+extern bool_t xdr_ip_addr_t ();
+extern bool_t xdr_bp_address ();
+extern bool_t xdr_bp_whoami_arg ();
+extern bool_t xdr_bp_whoami_res ();
+extern bool_t xdr_bp_getfile_arg ();
+extern bool_t xdr_bp_getfile_res ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_BOOTPARAM_PROT_H_RPCGEN */
diff --git a/include/rpcsvc/bootparam_prot.x b/include/rpcsvc/bootparam_prot.x
new file mode 100644
index 0000000..117e428
--- /dev/null
+++ b/include/rpcsvc/bootparam_prot.x
@@ -0,0 +1,97 @@
+/* @(#)bootparam_prot.x	2.1 88/08/01 4.0 RPCSRC */
+
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * RPC for bootparms service.
+ * There are two procedures:
+ *   WHOAMI takes a net address and returns a client name and also a
+ *	likely net address for routing
+ *   GETFILE takes a client name and file identifier and returns the
+ *	server name, server net address and pathname for the file.
+ *   file identifiers typically include root, swap, pub and dump
+ */
+
+#ifdef RPC_HDR
+%#include <rpc/types.h>
+%#include <sys/time.h>
+%#include <sys/errno.h>
+%#include <nfs/nfs.h>
+#endif
+
+const MAX_MACHINE_NAME  = 255;
+const MAX_PATH_LEN	= 1024;
+const MAX_FILEID	= 32;
+const IP_ADDR_TYPE	= 1;
+
+typedef	string	bp_machine_name_t<MAX_MACHINE_NAME>;
+typedef	string	bp_path_t<MAX_PATH_LEN>;
+typedef	string	bp_fileid_t<MAX_FILEID>;
+
+struct	ip_addr_t {
+	char	net;
+	char	host;
+	char	lh;
+	char	impno;
+};
+
+union bp_address switch (int address_type) {
+	case IP_ADDR_TYPE:
+		ip_addr_t	ip_addr;
+};
+
+struct bp_whoami_arg {
+	bp_address		client_address;
+};
+
+struct bp_whoami_res {
+	bp_machine_name_t	client_name;
+	bp_machine_name_t	domain_name;
+	bp_address		router_address;
+};
+
+struct bp_getfile_arg {
+	bp_machine_name_t	client_name;
+	bp_fileid_t		file_id;
+};
+
+struct bp_getfile_res {
+	bp_machine_name_t	server_name;
+	bp_address		server_address;
+	bp_path_t		server_path;
+};
+
+program BOOTPARAMPROG {
+	version BOOTPARAMVERS {
+		bp_whoami_res	BOOTPARAMPROC_WHOAMI(bp_whoami_arg) = 1;
+		bp_getfile_res	BOOTPARAMPROC_GETFILE(bp_getfile_arg) = 2;
+	} = 1;
+} = 100026;
diff --git a/include/rpcsvc/key_prot.h b/include/rpcsvc/key_prot.h
new file mode 100644
index 0000000..4fbdbf4
--- /dev/null
+++ b/include/rpcsvc/key_prot.h
@@ -0,0 +1,236 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _KEY_PROT_H_RPCGEN
+#define _KEY_PROT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if 0
+#pragma ident "@(#)key_prot.x	1.7	94/04/29 SMI"
+#endif
+
+/* Copyright (c)  1990, 1991 Sun Microsystems, Inc. */
+
+/*
+ * Compiled from key_prot.x using rpcgen.
+ * DO NOT EDIT THIS FILE!
+ * This is NOT source code!
+ */
+#define PROOT 3
+#define HEXMODULUS "d4a0ba0250b6fd2ec626e7efd637df76c716e22d0944b88b"
+#define HEXKEYBYTES 48
+#define KEYSIZE 192
+#define KEYBYTES 24
+#define KEYCHECKSUMSIZE 16
+
+enum keystatus {
+	KEY_SUCCESS = 0,
+	KEY_NOSECRET = 1,
+	KEY_UNKNOWN = 2,
+	KEY_SYSTEMERR = 3,
+};
+typedef enum keystatus keystatus;
+
+typedef char keybuf[HEXKEYBYTES];
+
+typedef char *netnamestr;
+
+struct cryptkeyarg {
+	netnamestr remotename;
+	des_block deskey;
+};
+typedef struct cryptkeyarg cryptkeyarg;
+
+struct cryptkeyarg2 {
+	netnamestr remotename;
+	netobj remotekey;
+	des_block deskey;
+};
+typedef struct cryptkeyarg2 cryptkeyarg2;
+
+struct cryptkeyres {
+	keystatus status;
+	union {
+		des_block deskey;
+	} cryptkeyres_u;
+};
+typedef struct cryptkeyres cryptkeyres;
+#define MAXGIDS 16
+
+struct unixcred {
+	u_int uid;
+	u_int gid;
+	struct {
+		u_int gids_len;
+		u_int *gids_val;
+	} gids;
+};
+typedef struct unixcred unixcred;
+
+struct getcredres {
+	keystatus status;
+	union {
+		unixcred cred;
+	} getcredres_u;
+};
+typedef struct getcredres getcredres;
+
+struct key_netstarg {
+	keybuf st_priv_key;
+	keybuf st_pub_key;
+	netnamestr st_netname;
+};
+typedef struct key_netstarg key_netstarg;
+
+struct key_netstres {
+	keystatus status;
+	union {
+		key_netstarg knet;
+	} key_netstres_u;
+};
+typedef struct key_netstres key_netstres;
+
+#ifndef opaque
+#define opaque char
+#endif
+
+
+#define KEY_PROG 100029
+#define KEY_VERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define KEY_SET 1
+extern  keystatus * key_set_1(char *, CLIENT *);
+extern  keystatus * key_set_1_svc(char *, struct svc_req *);
+#define KEY_ENCRYPT 2
+extern  cryptkeyres * key_encrypt_1(cryptkeyarg *, CLIENT *);
+extern  cryptkeyres * key_encrypt_1_svc(cryptkeyarg *, struct svc_req *);
+#define KEY_DECRYPT 3
+extern  cryptkeyres * key_decrypt_1(cryptkeyarg *, CLIENT *);
+extern  cryptkeyres * key_decrypt_1_svc(cryptkeyarg *, struct svc_req *);
+#define KEY_GEN 4
+extern  des_block * key_gen_1(void *, CLIENT *);
+extern  des_block * key_gen_1_svc(void *, struct svc_req *);
+#define KEY_GETCRED 5
+extern  getcredres * key_getcred_1(netnamestr *, CLIENT *);
+extern  getcredres * key_getcred_1_svc(netnamestr *, struct svc_req *);
+extern int key_prog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define KEY_SET 1
+extern  keystatus * key_set_1();
+extern  keystatus * key_set_1_svc();
+#define KEY_ENCRYPT 2
+extern  cryptkeyres * key_encrypt_1();
+extern  cryptkeyres * key_encrypt_1_svc();
+#define KEY_DECRYPT 3
+extern  cryptkeyres * key_decrypt_1();
+extern  cryptkeyres * key_decrypt_1_svc();
+#define KEY_GEN 4
+extern  des_block * key_gen_1();
+extern  des_block * key_gen_1_svc();
+#define KEY_GETCRED 5
+extern  getcredres * key_getcred_1();
+extern  getcredres * key_getcred_1_svc();
+extern int key_prog_1_freeresult ();
+#endif /* K&R C */
+#define KEY_VERS2 2
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  keystatus * key_set_2(char *, CLIENT *);
+extern  keystatus * key_set_2_svc(char *, struct svc_req *);
+extern  cryptkeyres * key_encrypt_2(cryptkeyarg *, CLIENT *);
+extern  cryptkeyres * key_encrypt_2_svc(cryptkeyarg *, struct svc_req *);
+extern  cryptkeyres * key_decrypt_2(cryptkeyarg *, CLIENT *);
+extern  cryptkeyres * key_decrypt_2_svc(cryptkeyarg *, struct svc_req *);
+extern  des_block * key_gen_2(void *, CLIENT *);
+extern  des_block * key_gen_2_svc(void *, struct svc_req *);
+extern  getcredres * key_getcred_2(netnamestr *, CLIENT *);
+extern  getcredres * key_getcred_2_svc(netnamestr *, struct svc_req *);
+#define KEY_ENCRYPT_PK 6
+extern  cryptkeyres * key_encrypt_pk_2(cryptkeyarg2 *, CLIENT *);
+extern  cryptkeyres * key_encrypt_pk_2_svc(cryptkeyarg2 *, struct svc_req *);
+#define KEY_DECRYPT_PK 7
+extern  cryptkeyres * key_decrypt_pk_2(cryptkeyarg2 *, CLIENT *);
+extern  cryptkeyres * key_decrypt_pk_2_svc(cryptkeyarg2 *, struct svc_req *);
+#define KEY_NET_PUT 8
+extern  keystatus * key_net_put_2(key_netstarg *, CLIENT *);
+extern  keystatus * key_net_put_2_svc(key_netstarg *, struct svc_req *);
+#define KEY_NET_GET 9
+extern  key_netstres * key_net_get_2(void *, CLIENT *);
+extern  key_netstres * key_net_get_2_svc(void *, struct svc_req *);
+#define KEY_GET_CONV 10
+extern  cryptkeyres * key_get_conv_2(char *, CLIENT *);
+extern  cryptkeyres * key_get_conv_2_svc(char *, struct svc_req *);
+extern int key_prog_2_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  keystatus * key_set_2();
+extern  keystatus * key_set_2_svc();
+extern  cryptkeyres * key_encrypt_2();
+extern  cryptkeyres * key_encrypt_2_svc();
+extern  cryptkeyres * key_decrypt_2();
+extern  cryptkeyres * key_decrypt_2_svc();
+extern  des_block * key_gen_2();
+extern  des_block * key_gen_2_svc();
+extern  getcredres * key_getcred_2();
+extern  getcredres * key_getcred_2_svc();
+#define KEY_ENCRYPT_PK 6
+extern  cryptkeyres * key_encrypt_pk_2();
+extern  cryptkeyres * key_encrypt_pk_2_svc();
+#define KEY_DECRYPT_PK 7
+extern  cryptkeyres * key_decrypt_pk_2();
+extern  cryptkeyres * key_decrypt_pk_2_svc();
+#define KEY_NET_PUT 8
+extern  keystatus * key_net_put_2();
+extern  keystatus * key_net_put_2_svc();
+#define KEY_NET_GET 9
+extern  key_netstres * key_net_get_2();
+extern  key_netstres * key_net_get_2_svc();
+#define KEY_GET_CONV 10
+extern  cryptkeyres * key_get_conv_2();
+extern  cryptkeyres * key_get_conv_2_svc();
+extern int key_prog_2_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_keystatus (XDR *, keystatus*);
+extern  bool_t xdr_keybuf (XDR *, keybuf);
+extern  bool_t xdr_netnamestr (XDR *, netnamestr*);
+extern  bool_t xdr_cryptkeyarg (XDR *, cryptkeyarg*);
+extern  bool_t xdr_cryptkeyarg2 (XDR *, cryptkeyarg2*);
+extern  bool_t xdr_cryptkeyres (XDR *, cryptkeyres*);
+extern  bool_t xdr_unixcred (XDR *, unixcred*);
+extern  bool_t xdr_getcredres (XDR *, getcredres*);
+extern  bool_t xdr_key_netstarg (XDR *, key_netstarg*);
+extern  bool_t xdr_key_netstres (XDR *, key_netstres*);
+
+#else /* K&R C */
+extern bool_t xdr_keystatus ();
+extern bool_t xdr_keybuf ();
+extern bool_t xdr_netnamestr ();
+extern bool_t xdr_cryptkeyarg ();
+extern bool_t xdr_cryptkeyarg2 ();
+extern bool_t xdr_cryptkeyres ();
+extern bool_t xdr_unixcred ();
+extern bool_t xdr_getcredres ();
+extern bool_t xdr_key_netstarg ();
+extern bool_t xdr_key_netstres ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_KEY_PROT_H_RPCGEN */
diff --git a/include/rpcsvc/key_prot.x b/include/rpcsvc/key_prot.x
new file mode 100644
index 0000000..9baf943
--- /dev/null
+++ b/include/rpcsvc/key_prot.x
@@ -0,0 +1,283 @@
+/*
+ * Key server protocol definition
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The keyserver is a public key storage/encryption/decryption service
+ * The encryption method used is based on the Diffie-Hellman exponential
+ * key exchange technology.
+ *
+ * The key server is local to each machine, akin to the portmapper.
+ * Under TI-RPC, communication with the keyserver is through the
+ * loopback transport.
+ *
+ * NOTE: This .x file generates the USER level headers for the keyserver.
+ * the KERNEL level headers are created by hand as they kernel has special
+ * requirements.
+ */
+
+%#if 0
+%#pragma ident	"@(#)key_prot.x	1.7	94/04/29 SMI"
+%#endif
+%
+%/* Copyright (c)  1990, 1991 Sun Microsystems, Inc. */
+%
+%/*
+% * Compiled from key_prot.x using rpcgen.
+% * DO NOT EDIT THIS FILE!
+% * This is NOT source code!
+% */
+
+/*
+ * PROOT and MODULUS define the way the Diffie-Hellman key is generated.
+ *
+ * MODULUS should be chosen as a prime of the form: MODULUS == 2*p + 1,
+ * where p is also prime.
+ *
+ * PROOT satisfies the following two conditions:
+ * (1) (PROOT ** 2) % MODULUS != 1
+ * (2) (PROOT ** p) % MODULUS != 1
+ *
+ */
+
+const PROOT = 3;
+const HEXMODULUS = "d4a0ba0250b6fd2ec626e7efd637df76c716e22d0944b88b";
+
+const HEXKEYBYTES = 48;		/* HEXKEYBYTES == strlen(HEXMODULUS) */
+const KEYSIZE = 192;		/* KEYSIZE == bit length of key */
+const KEYBYTES = 24;		/* byte length of key */
+
+/*
+ * The first 16 hex digits of the encrypted secret key are used as
+ * a checksum in the database.
+ */
+const KEYCHECKSUMSIZE = 16;
+
+/*
+ * status of operation
+ */
+enum keystatus {
+	KEY_SUCCESS,	/* no problems */
+	KEY_NOSECRET,	/* no secret key stored */
+	KEY_UNKNOWN,	/* unknown netname */
+	KEY_SYSTEMERR 	/* system error (out of memory, encryption failure) */
+};
+
+typedef opaque keybuf[HEXKEYBYTES];	/* store key in hex */
+
+typedef string netnamestr<MAXNETNAMELEN>;
+
+/*
+ * Argument to ENCRYPT or DECRYPT
+ */
+struct cryptkeyarg {
+	netnamestr remotename;
+	des_block deskey;
+};
+
+/*
+ * Argument to ENCRYPT_PK or DECRYPT_PK
+ */
+struct cryptkeyarg2 {
+	netnamestr remotename;
+	netobj	remotekey;	/* Contains a length up to 1024 bytes */
+	des_block deskey;
+};
+
+
+/*
+ * Result of ENCRYPT, DECRYPT, ENCRYPT_PK, and DECRYPT_PK
+ */
+union cryptkeyres switch (keystatus status) {
+case KEY_SUCCESS:
+	des_block deskey;
+default:
+	void;
+};
+
+const MAXGIDS  = 16;	/* max number of gids in gid list */
+
+/*
+ * Unix credential
+ */
+struct unixcred {
+	u_int uid;
+	u_int gid;
+	u_int gids<MAXGIDS>;
+};
+
+/*
+ * Result returned from GETCRED
+ */
+union getcredres switch (keystatus status) {
+case KEY_SUCCESS:
+	unixcred cred;
+default:
+	void;
+};
+/*
+ * key_netstarg;
+ */
+
+struct key_netstarg {
+	keybuf st_priv_key;
+	keybuf st_pub_key;
+	netnamestr st_netname;
+};
+
+union key_netstres switch (keystatus status){
+case KEY_SUCCESS:
+	key_netstarg knet;
+default:
+	void;
+};
+
+#ifdef RPC_HDR
+%
+%#ifndef opaque
+%#define opaque char
+%#endif
+%
+#endif
+program KEY_PROG {
+	version KEY_VERS {
+
+		/*
+		 * This is my secret key.
+	 	 * Store it for me.
+		 */
+		keystatus
+		KEY_SET(keybuf) = 1;
+
+		/*
+		 * I want to talk to X.
+		 * Encrypt a conversation key for me.
+	 	 */
+		cryptkeyres
+		KEY_ENCRYPT(cryptkeyarg) = 2;
+
+		/*
+		 * X just sent me a message.
+		 * Decrypt the conversation key for me.
+		 */
+		cryptkeyres
+		KEY_DECRYPT(cryptkeyarg) = 3;
+
+		/*
+		 * Generate a secure conversation key for me
+		 */
+		des_block
+		KEY_GEN(void) = 4;
+
+		/*
+		 * Get me the uid, gid and group-access-list associated
+		 * with this netname (for kernel which cannot use NIS)
+		 */
+		getcredres
+		KEY_GETCRED(netnamestr) = 5;
+	} = 1;
+	version KEY_VERS2 {
+
+		/*
+		 * #######
+		 * Procedures 1-5 are identical to version 1
+		 * #######
+		 */
+
+		/*
+		 * This is my secret key.
+	 	 * Store it for me.
+		 */
+		keystatus
+		KEY_SET(keybuf) = 1;
+
+		/*
+		 * I want to talk to X.
+		 * Encrypt a conversation key for me.
+	 	 */
+		cryptkeyres
+		KEY_ENCRYPT(cryptkeyarg) = 2;
+
+		/*
+		 * X just sent me a message.
+		 * Decrypt the conversation key for me.
+		 */
+		cryptkeyres
+		KEY_DECRYPT(cryptkeyarg) = 3;
+
+		/*
+		 * Generate a secure conversation key for me
+		 */
+		des_block
+		KEY_GEN(void) = 4;
+
+		/*
+		 * Get me the uid, gid and group-access-list associated
+		 * with this netname (for kernel which cannot use NIS)
+		 */
+		getcredres
+		KEY_GETCRED(netnamestr) = 5;
+
+		/*
+		 * I want to talk to X. and I know X's public key
+		 * Encrypt a conversation key for me.
+	 	 */
+		cryptkeyres
+		KEY_ENCRYPT_PK(cryptkeyarg2) = 6;
+
+		/*
+		 * X just sent me a message. and I know X's public key
+		 * Decrypt the conversation key for me.
+		 */
+		cryptkeyres
+		KEY_DECRYPT_PK(cryptkeyarg2) = 7;
+
+		/*
+		 * Store my public key, netname and private key.
+		 */
+		keystatus
+		KEY_NET_PUT(key_netstarg) = 8;
+
+		/*
+		 * Retrieve my public key, netname and private key.
+		 */
+ 		key_netstres
+		KEY_NET_GET(void) = 9;
+
+		/*
+		 * Return me the conversation key that is constructed
+		 * from my secret key and this publickey.
+		 */
+
+		cryptkeyres
+		KEY_GET_CONV(keybuf) = 10;
+
+
+	} = 2;
+} = 100029;
diff --git a/include/rpcsvc/klm_prot.h b/include/rpcsvc/klm_prot.h
new file mode 100644
index 0000000..6ec281e
--- /dev/null
+++ b/include/rpcsvc/klm_prot.h
@@ -0,0 +1,136 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _KLM_PROT_H_RPCGEN
+#define _KLM_PROT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LM_MAXSTRLEN 1024
+
+enum klm_stats {
+	klm_granted = 0,
+	klm_denied = 1,
+	klm_denied_nolocks = 2,
+	klm_working = 3,
+};
+typedef enum klm_stats klm_stats;
+
+struct klm_lock {
+	char *server_name;
+	netobj fh;
+	int pid;
+	u_int l_offset;
+	u_int l_len;
+};
+typedef struct klm_lock klm_lock;
+
+struct klm_holder {
+	bool_t exclusive;
+	int svid;
+	u_int l_offset;
+	u_int l_len;
+};
+typedef struct klm_holder klm_holder;
+
+struct klm_stat {
+	klm_stats stat;
+};
+typedef struct klm_stat klm_stat;
+
+struct klm_testrply {
+	klm_stats stat;
+	union {
+		struct klm_holder holder;
+	} klm_testrply_u;
+};
+typedef struct klm_testrply klm_testrply;
+
+struct klm_lockargs {
+	bool_t block;
+	bool_t exclusive;
+	struct klm_lock alock;
+};
+typedef struct klm_lockargs klm_lockargs;
+
+struct klm_testargs {
+	bool_t exclusive;
+	struct klm_lock alock;
+};
+typedef struct klm_testargs klm_testargs;
+
+struct klm_unlockargs {
+	struct klm_lock alock;
+};
+typedef struct klm_unlockargs klm_unlockargs;
+
+#define KLM_PROG 100020
+#define KLM_VERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define KLM_TEST 1
+extern  klm_testrply * klm_test_1(struct klm_testargs *, CLIENT *);
+extern  klm_testrply * klm_test_1_svc(struct klm_testargs *, struct svc_req *);
+#define KLM_LOCK 2
+extern  klm_stat * klm_lock_1(struct klm_lockargs *, CLIENT *);
+extern  klm_stat * klm_lock_1_svc(struct klm_lockargs *, struct svc_req *);
+#define KLM_CANCEL 3
+extern  klm_stat * klm_cancel_1(struct klm_lockargs *, CLIENT *);
+extern  klm_stat * klm_cancel_1_svc(struct klm_lockargs *, struct svc_req *);
+#define KLM_UNLOCK 4
+extern  klm_stat * klm_unlock_1(struct klm_unlockargs *, CLIENT *);
+extern  klm_stat * klm_unlock_1_svc(struct klm_unlockargs *, struct svc_req *);
+extern int klm_prog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define KLM_TEST 1
+extern  klm_testrply * klm_test_1();
+extern  klm_testrply * klm_test_1_svc();
+#define KLM_LOCK 2
+extern  klm_stat * klm_lock_1();
+extern  klm_stat * klm_lock_1_svc();
+#define KLM_CANCEL 3
+extern  klm_stat * klm_cancel_1();
+extern  klm_stat * klm_cancel_1_svc();
+#define KLM_UNLOCK 4
+extern  klm_stat * klm_unlock_1();
+extern  klm_stat * klm_unlock_1_svc();
+extern int klm_prog_1_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_klm_stats (XDR *, klm_stats*);
+extern  bool_t xdr_klm_lock (XDR *, klm_lock*);
+extern  bool_t xdr_klm_holder (XDR *, klm_holder*);
+extern  bool_t xdr_klm_stat (XDR *, klm_stat*);
+extern  bool_t xdr_klm_testrply (XDR *, klm_testrply*);
+extern  bool_t xdr_klm_lockargs (XDR *, klm_lockargs*);
+extern  bool_t xdr_klm_testargs (XDR *, klm_testargs*);
+extern  bool_t xdr_klm_unlockargs (XDR *, klm_unlockargs*);
+
+#else /* K&R C */
+extern bool_t xdr_klm_stats ();
+extern bool_t xdr_klm_lock ();
+extern bool_t xdr_klm_holder ();
+extern bool_t xdr_klm_stat ();
+extern bool_t xdr_klm_testrply ();
+extern bool_t xdr_klm_lockargs ();
+extern bool_t xdr_klm_testargs ();
+extern bool_t xdr_klm_unlockargs ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_KLM_PROT_H_RPCGEN */
diff --git a/include/rpcsvc/klm_prot.x b/include/rpcsvc/klm_prot.x
new file mode 100644
index 0000000..aee5b1a
--- /dev/null
+++ b/include/rpcsvc/klm_prot.x
@@ -0,0 +1,130 @@
+/* @(#)klm_prot.x	2.1 88/08/01 4.0 RPCSRC */
+
+/*
+ * Kernel/lock manager protocol definition
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * protocol used between the UNIX kernel (the "client") and the
+ * local lock manager.  The local lock manager is a deamon running
+ * above the kernel.
+ */
+
+const	LM_MAXSTRLEN = 1024;
+
+/*
+ * lock manager status returns
+ */
+enum klm_stats {
+	klm_granted = 0,	/* lock is granted */
+	klm_denied = 1,		/* lock is denied */
+	klm_denied_nolocks = 2, /* no lock entry available */
+	klm_working = 3		/* lock is being processed */
+};
+
+/*
+ * lock manager lock identifier
+ */
+struct klm_lock {
+	string server_name<LM_MAXSTRLEN>;
+	netobj fh;		/* a counted file handle */
+	int pid;		/* holder of the lock */
+	unsigned l_offset;	/* beginning offset of the lock */
+	unsigned l_len;		/* byte length of the lock;
+				 * zero means through end of file */
+};
+
+/*
+ * lock holder identifier
+ */
+struct klm_holder {
+	bool exclusive;		/* FALSE if shared lock */
+	int svid;		/* holder of the lock (pid) */
+	unsigned l_offset;	/* beginning offset of the lock */
+	unsigned l_len;		/* byte length of the lock;
+				 * zero means through end of file */
+};
+
+/*
+ * reply to KLM_LOCK / KLM_UNLOCK / KLM_CANCEL
+ */
+struct klm_stat {
+	klm_stats stat;
+};
+
+/*
+ * reply to a KLM_TEST call
+ */
+union klm_testrply switch (klm_stats stat) {
+	case klm_denied:
+		struct klm_holder holder;
+	default: /* All other cases return no arguments */
+		void;
+};
+
+
+/*
+ * arguments to KLM_LOCK
+ */
+struct klm_lockargs {
+	bool block;
+	bool exclusive;
+	struct klm_lock alock;
+};
+
+/*
+ * arguments to KLM_TEST
+ */
+struct klm_testargs {
+	bool exclusive;
+	struct klm_lock alock;
+};
+
+/*
+ * arguments to KLM_UNLOCK
+ */
+struct klm_unlockargs {
+	struct klm_lock alock;
+};
+
+program KLM_PROG {
+	version KLM_VERS {
+
+		klm_testrply	KLM_TEST (struct klm_testargs) =	1;
+
+		klm_stat	KLM_LOCK (struct klm_lockargs) =	2;
+
+		klm_stat	KLM_CANCEL (struct klm_lockargs) =	3;
+		/* klm_granted=> the cancel request fails due to lock is already granted */
+		/* klm_denied=> the cancel request successfully aborts
+lock request  */
+
+		klm_stat	KLM_UNLOCK (struct klm_unlockargs) =	4;
+	} = 1;
+} = 100020;
diff --git a/include/rpcsvc/mount.h b/include/rpcsvc/mount.h
new file mode 100644
index 0000000..de22f29
--- /dev/null
+++ b/include/rpcsvc/mount.h
@@ -0,0 +1,144 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _MOUNT_H_RPCGEN
+#define _MOUNT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MNTPATHLEN 1024
+#define MNTNAMLEN 255
+#define FHSIZE 32
+
+typedef char fhandle[FHSIZE];
+
+struct fhstatus {
+	u_int fhs_status;
+	union {
+		fhandle fhs_fhandle;
+	} fhstatus_u;
+};
+typedef struct fhstatus fhstatus;
+
+typedef char *dirpath;
+
+typedef char *name;
+
+typedef struct mountbody *mountlist;
+
+struct mountbody {
+	name ml_hostname;
+	dirpath ml_directory;
+	mountlist ml_next;
+};
+typedef struct mountbody mountbody;
+
+typedef struct groupnode *groups;
+
+struct groupnode {
+	name gr_name;
+	groups gr_next;
+};
+typedef struct groupnode groupnode;
+
+typedef struct exportnode *exports;
+
+struct exportnode {
+	dirpath ex_dir;
+	groups ex_groups;
+	exports ex_next;
+};
+typedef struct exportnode exportnode;
+
+#define MOUNTPROG 100005
+#define MOUNTVERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define MOUNTPROC_NULL 0
+extern  void * mountproc_null_1(void *, CLIENT *);
+extern  void * mountproc_null_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_MNT 1
+extern  fhstatus * mountproc_mnt_1(dirpath *, CLIENT *);
+extern  fhstatus * mountproc_mnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_DUMP 2
+extern  mountlist * mountproc_dump_1(void *, CLIENT *);
+extern  mountlist * mountproc_dump_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_UMNT 3
+extern  void * mountproc_umnt_1(dirpath *, CLIENT *);
+extern  void * mountproc_umnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_UMNTALL 4
+extern  void * mountproc_umntall_1(void *, CLIENT *);
+extern  void * mountproc_umntall_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORT 5
+extern  exports * mountproc_export_1(void *, CLIENT *);
+extern  exports * mountproc_export_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORTALL 6
+extern  exports * mountproc_exportall_1(void *, CLIENT *);
+extern  exports * mountproc_exportall_1_svc(void *, struct svc_req *);
+extern int mountprog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define MOUNTPROC_NULL 0
+extern  void * mountproc_null_1();
+extern  void * mountproc_null_1_svc();
+#define MOUNTPROC_MNT 1
+extern  fhstatus * mountproc_mnt_1();
+extern  fhstatus * mountproc_mnt_1_svc();
+#define MOUNTPROC_DUMP 2
+extern  mountlist * mountproc_dump_1();
+extern  mountlist * mountproc_dump_1_svc();
+#define MOUNTPROC_UMNT 3
+extern  void * mountproc_umnt_1();
+extern  void * mountproc_umnt_1_svc();
+#define MOUNTPROC_UMNTALL 4
+extern  void * mountproc_umntall_1();
+extern  void * mountproc_umntall_1_svc();
+#define MOUNTPROC_EXPORT 5
+extern  exports * mountproc_export_1();
+extern  exports * mountproc_export_1_svc();
+#define MOUNTPROC_EXPORTALL 6
+extern  exports * mountproc_exportall_1();
+extern  exports * mountproc_exportall_1_svc();
+extern int mountprog_1_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_fhandle (XDR *, fhandle);
+extern  bool_t xdr_fhstatus (XDR *, fhstatus*);
+extern  bool_t xdr_dirpath (XDR *, dirpath*);
+extern  bool_t xdr_name (XDR *, name*);
+extern  bool_t xdr_mountlist (XDR *, mountlist*);
+extern  bool_t xdr_mountbody (XDR *, mountbody*);
+extern  bool_t xdr_groups (XDR *, groups*);
+extern  bool_t xdr_groupnode (XDR *, groupnode*);
+extern  bool_t xdr_exports (XDR *, exports*);
+extern  bool_t xdr_exportnode (XDR *, exportnode*);
+
+#else /* K&R C */
+extern bool_t xdr_fhandle ();
+extern bool_t xdr_fhstatus ();
+extern bool_t xdr_dirpath ();
+extern bool_t xdr_name ();
+extern bool_t xdr_mountlist ();
+extern bool_t xdr_mountbody ();
+extern bool_t xdr_groups ();
+extern bool_t xdr_groupnode ();
+extern bool_t xdr_exports ();
+extern bool_t xdr_exportnode ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_MOUNT_H_RPCGEN */
diff --git a/include/rpcsvc/mount.x b/include/rpcsvc/mount.x
new file mode 100644
index 0000000..ed3b339
--- /dev/null
+++ b/include/rpcsvc/mount.x
@@ -0,0 +1,161 @@
+/* @(#)mount.x	2.1 88/08/01 4.0 RPCSRC */
+
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Protocol description for the mount program
+ */
+
+
+const MNTPATHLEN = 1024;	/* maximum bytes in a pathname argument */
+const MNTNAMLEN = 255;		/* maximum bytes in a name argument */
+const FHSIZE = 32;		/* size in bytes of a file handle */
+
+/*
+ * The fhandle is the file handle that the server passes to the client.
+ * All file operations are done using the file handles to refer to a file
+ * or a directory. The file handle can contain whatever information the
+ * server needs to distinguish an individual file.
+ */
+typedef opaque fhandle[FHSIZE];
+
+/*
+ * If a status of zero is returned, the call completed successfully, and
+ * a file handle for the directory follows. A non-zero status indicates
+ * some sort of error. The status corresponds with UNIX error numbers.
+ */
+union fhstatus switch (unsigned fhs_status) {
+case 0:
+	fhandle fhs_fhandle;
+default:
+	void;
+};
+
+/*
+ * The type dirpath is the pathname of a directory
+ */
+typedef string dirpath<MNTPATHLEN>;
+
+/*
+ * The type name is used for arbitrary names (hostnames, groupnames)
+ */
+typedef string name<MNTNAMLEN>;
+
+/*
+ * A list of who has what mounted
+ */
+typedef struct mountbody *mountlist;
+struct mountbody {
+	name ml_hostname;
+	dirpath ml_directory;
+	mountlist ml_next;
+};
+
+/*
+ * A list of netgroups
+ */
+typedef struct groupnode *groups;
+struct groupnode {
+	name gr_name;
+	groups gr_next;
+};
+
+/*
+ * A list of what is exported and to whom
+ */
+typedef struct exportnode *exports;
+struct exportnode {
+	dirpath ex_dir;
+	groups ex_groups;
+	exports ex_next;
+};
+
+program MOUNTPROG {
+	/*
+	 * Version one of the mount protocol communicates with version two
+	 * of the NFS protocol. The only connecting point is the fhandle
+	 * structure, which is the same for both protocols.
+	 */
+	version MOUNTVERS {
+		/*
+		 * Does no work. It is made available in all RPC services
+		 * to allow server response testing and timing
+		 */
+		void
+		MOUNTPROC_NULL(void) = 0;
+
+		/*
+		 * If fhs_status is 0, then fhs_fhandle contains the
+		 * file handle for the directory. This file handle may
+		 * be used in the NFS protocol. This procedure also adds
+		 * a new entry to the mount list for this client mounting
+		 * the directory.
+		 * Unix authentication required.
+		 */
+		fhstatus
+		MOUNTPROC_MNT(dirpath) = 1;
+
+		/*
+		 * Returns the list of remotely mounted filesystems. The
+		 * mountlist contains one entry for each hostname and
+		 * directory pair.
+		 */
+		mountlist
+		MOUNTPROC_DUMP(void) = 2;
+
+		/*
+		 * Removes the mount list entry for the directory
+		 * Unix authentication required.
+		 */
+		void
+		MOUNTPROC_UMNT(dirpath) = 3;
+
+		/*
+		 * Removes all of the mount list entries for this client
+		 * Unix authentication required.
+		 */
+		void
+		MOUNTPROC_UMNTALL(void) = 4;
+
+		/*
+		 * Returns a list of all the exported filesystems, and which
+		 * machines are allowed to import it.
+		 */
+		exports
+		MOUNTPROC_EXPORT(void)  = 5;
+
+		/*
+		 * Identical to MOUNTPROC_EXPORT above
+		 */
+		exports
+		MOUNTPROC_EXPORTALL(void) = 6;
+	} = 1;
+} = 100005;
diff --git a/include/rpcsvc/nfs_prot.h b/include/rpcsvc/nfs_prot.h
new file mode 100644
index 0000000..6cf626a
--- /dev/null
+++ b/include/rpcsvc/nfs_prot.h
@@ -0,0 +1,450 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _NFS_PROT_H_RPCGEN
+#define _NFS_PROT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NFS_PORT 2049
+#define NFS_MAXDATA 8192
+#define NFS_MAXPATHLEN 1024
+#define NFS_MAXNAMLEN 255
+#define NFS_FHSIZE 32
+#define NFS_COOKIESIZE 4
+#define NFS_FIFO_DEV -1
+#define NFSMODE_FMT 0170000
+#define NFSMODE_DIR 0040000
+#define NFSMODE_CHR 0020000
+#define NFSMODE_BLK 0060000
+#define NFSMODE_REG 0100000
+#define NFSMODE_LNK 0120000
+#define NFSMODE_SOCK 0140000
+#define NFSMODE_FIFO 0010000
+
+enum nfsstat {
+	NFS_OK = 0,
+	NFSERR_PERM = 1,
+	NFSERR_NOENT = 2,
+	NFSERR_IO = 5,
+	NFSERR_NXIO = 6,
+	NFSERR_ACCES = 13,
+	NFSERR_EXIST = 17,
+	NFSERR_NODEV = 19,
+	NFSERR_NOTDIR = 20,
+	NFSERR_ISDIR = 21,
+	NFSERR_FBIG = 27,
+	NFSERR_NOSPC = 28,
+	NFSERR_ROFS = 30,
+	NFSERR_NAMETOOLONG = 63,
+	NFSERR_NOTEMPTY = 66,
+	NFSERR_DQUOT = 69,
+	NFSERR_STALE = 70,
+	NFSERR_WFLUSH = 99,
+};
+typedef enum nfsstat nfsstat;
+
+enum ftype {
+	NFNON = 0,
+	NFREG = 1,
+	NFDIR = 2,
+	NFBLK = 3,
+	NFCHR = 4,
+	NFLNK = 5,
+	NFSOCK = 6,
+	NFBAD = 7,
+	NFFIFO = 8,
+};
+typedef enum ftype ftype;
+
+struct nfs_fh {
+	char data[NFS_FHSIZE];
+};
+typedef struct nfs_fh nfs_fh;
+
+struct nfstime {
+	u_int seconds;
+	u_int useconds;
+};
+typedef struct nfstime nfstime;
+
+struct fattr {
+	ftype type;
+	u_int mode;
+	u_int nlink;
+	u_int uid;
+	u_int gid;
+	u_int size;
+	u_int blocksize;
+	u_int rdev;
+	u_int blocks;
+	u_int fsid;
+	u_int fileid;
+	nfstime atime;
+	nfstime mtime;
+	nfstime ctime;
+};
+typedef struct fattr fattr;
+
+struct sattr {
+	u_int mode;
+	u_int uid;
+	u_int gid;
+	u_int size;
+	nfstime atime;
+	nfstime mtime;
+};
+typedef struct sattr sattr;
+
+typedef char *filename;
+
+typedef char *nfspath;
+
+struct attrstat {
+	nfsstat status;
+	union {
+		fattr attributes;
+	} attrstat_u;
+};
+typedef struct attrstat attrstat;
+
+struct sattrargs {
+	nfs_fh file;
+	sattr attributes;
+};
+typedef struct sattrargs sattrargs;
+
+struct diropargs {
+	nfs_fh dir;
+	filename name;
+};
+typedef struct diropargs diropargs;
+
+struct diropokres {
+	nfs_fh file;
+	fattr attributes;
+};
+typedef struct diropokres diropokres;
+
+struct diropres {
+	nfsstat status;
+	union {
+		diropokres diropres;
+	} diropres_u;
+};
+typedef struct diropres diropres;
+
+struct readlinkres {
+	nfsstat status;
+	union {
+		nfspath data;
+	} readlinkres_u;
+};
+typedef struct readlinkres readlinkres;
+
+struct readargs {
+	nfs_fh file;
+	u_int offset;
+	u_int count;
+	u_int totalcount;
+};
+typedef struct readargs readargs;
+
+struct readokres {
+	fattr attributes;
+	struct {
+		u_int data_len;
+		char *data_val;
+	} data;
+};
+typedef struct readokres readokres;
+
+struct readres {
+	nfsstat status;
+	union {
+		readokres reply;
+	} readres_u;
+};
+typedef struct readres readres;
+
+struct writeargs {
+	nfs_fh file;
+	u_int beginoffset;
+	u_int offset;
+	u_int totalcount;
+	struct {
+		u_int data_len;
+		char *data_val;
+	} data;
+};
+typedef struct writeargs writeargs;
+
+struct createargs {
+	diropargs where;
+	sattr attributes;
+};
+typedef struct createargs createargs;
+
+struct renameargs {
+	diropargs from;
+	diropargs to;
+};
+typedef struct renameargs renameargs;
+
+struct linkargs {
+	nfs_fh from;
+	diropargs to;
+};
+typedef struct linkargs linkargs;
+
+struct symlinkargs {
+	diropargs from;
+	nfspath to;
+	sattr attributes;
+};
+typedef struct symlinkargs symlinkargs;
+
+typedef char nfscookie[NFS_COOKIESIZE];
+
+struct readdirargs {
+	nfs_fh dir;
+	nfscookie cookie;
+	u_int count;
+};
+typedef struct readdirargs readdirargs;
+
+struct entry {
+	u_int fileid;
+	filename name;
+	nfscookie cookie;
+	struct entry *nextentry;
+};
+typedef struct entry entry;
+
+struct dirlist {
+	entry *entries;
+	bool_t eof;
+};
+typedef struct dirlist dirlist;
+
+struct readdirres {
+	nfsstat status;
+	union {
+		dirlist reply;
+	} readdirres_u;
+};
+typedef struct readdirres readdirres;
+
+struct statfsokres {
+	u_int tsize;
+	u_int bsize;
+	u_int blocks;
+	u_int bfree;
+	u_int bavail;
+};
+typedef struct statfsokres statfsokres;
+
+struct statfsres {
+	nfsstat status;
+	union {
+		statfsokres reply;
+	} statfsres_u;
+};
+typedef struct statfsres statfsres;
+
+#define NFS_PROGRAM 100003
+#define NFS_VERSION 2
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define NFSPROC_NULL 0
+extern  void * nfsproc_null_2(void *, CLIENT *);
+extern  void * nfsproc_null_2_svc(void *, struct svc_req *);
+#define NFSPROC_GETATTR 1
+extern  attrstat * nfsproc_getattr_2(nfs_fh *, CLIENT *);
+extern  attrstat * nfsproc_getattr_2_svc(nfs_fh *, struct svc_req *);
+#define NFSPROC_SETATTR 2
+extern  attrstat * nfsproc_setattr_2(sattrargs *, CLIENT *);
+extern  attrstat * nfsproc_setattr_2_svc(sattrargs *, struct svc_req *);
+#define NFSPROC_ROOT 3
+extern  void * nfsproc_root_2(void *, CLIENT *);
+extern  void * nfsproc_root_2_svc(void *, struct svc_req *);
+#define NFSPROC_LOOKUP 4
+extern  diropres * nfsproc_lookup_2(diropargs *, CLIENT *);
+extern  diropres * nfsproc_lookup_2_svc(diropargs *, struct svc_req *);
+#define NFSPROC_READLINK 5
+extern  readlinkres * nfsproc_readlink_2(nfs_fh *, CLIENT *);
+extern  readlinkres * nfsproc_readlink_2_svc(nfs_fh *, struct svc_req *);
+#define NFSPROC_READ 6
+extern  readres * nfsproc_read_2(readargs *, CLIENT *);
+extern  readres * nfsproc_read_2_svc(readargs *, struct svc_req *);
+#define NFSPROC_WRITECACHE 7
+extern  void * nfsproc_writecache_2(void *, CLIENT *);
+extern  void * nfsproc_writecache_2_svc(void *, struct svc_req *);
+#define NFSPROC_WRITE 8
+extern  attrstat * nfsproc_write_2(writeargs *, CLIENT *);
+extern  attrstat * nfsproc_write_2_svc(writeargs *, struct svc_req *);
+#define NFSPROC_CREATE 9
+extern  diropres * nfsproc_create_2(createargs *, CLIENT *);
+extern  diropres * nfsproc_create_2_svc(createargs *, struct svc_req *);
+#define NFSPROC_REMOVE 10
+extern  nfsstat * nfsproc_remove_2(diropargs *, CLIENT *);
+extern  nfsstat * nfsproc_remove_2_svc(diropargs *, struct svc_req *);
+#define NFSPROC_RENAME 11
+extern  nfsstat * nfsproc_rename_2(renameargs *, CLIENT *);
+extern  nfsstat * nfsproc_rename_2_svc(renameargs *, struct svc_req *);
+#define NFSPROC_LINK 12
+extern  nfsstat * nfsproc_link_2(linkargs *, CLIENT *);
+extern  nfsstat * nfsproc_link_2_svc(linkargs *, struct svc_req *);
+#define NFSPROC_SYMLINK 13
+extern  nfsstat * nfsproc_symlink_2(symlinkargs *, CLIENT *);
+extern  nfsstat * nfsproc_symlink_2_svc(symlinkargs *, struct svc_req *);
+#define NFSPROC_MKDIR 14
+extern  diropres * nfsproc_mkdir_2(createargs *, CLIENT *);
+extern  diropres * nfsproc_mkdir_2_svc(createargs *, struct svc_req *);
+#define NFSPROC_RMDIR 15
+extern  nfsstat * nfsproc_rmdir_2(diropargs *, CLIENT *);
+extern  nfsstat * nfsproc_rmdir_2_svc(diropargs *, struct svc_req *);
+#define NFSPROC_READDIR 16
+extern  readdirres * nfsproc_readdir_2(readdirargs *, CLIENT *);
+extern  readdirres * nfsproc_readdir_2_svc(readdirargs *, struct svc_req *);
+#define NFSPROC_STATFS 17
+extern  statfsres * nfsproc_statfs_2(nfs_fh *, CLIENT *);
+extern  statfsres * nfsproc_statfs_2_svc(nfs_fh *, struct svc_req *);
+extern int nfs_program_2_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define NFSPROC_NULL 0
+extern  void * nfsproc_null_2();
+extern  void * nfsproc_null_2_svc();
+#define NFSPROC_GETATTR 1
+extern  attrstat * nfsproc_getattr_2();
+extern  attrstat * nfsproc_getattr_2_svc();
+#define NFSPROC_SETATTR 2
+extern  attrstat * nfsproc_setattr_2();
+extern  attrstat * nfsproc_setattr_2_svc();
+#define NFSPROC_ROOT 3
+extern  void * nfsproc_root_2();
+extern  void * nfsproc_root_2_svc();
+#define NFSPROC_LOOKUP 4
+extern  diropres * nfsproc_lookup_2();
+extern  diropres * nfsproc_lookup_2_svc();
+#define NFSPROC_READLINK 5
+extern  readlinkres * nfsproc_readlink_2();
+extern  readlinkres * nfsproc_readlink_2_svc();
+#define NFSPROC_READ 6
+extern  readres * nfsproc_read_2();
+extern  readres * nfsproc_read_2_svc();
+#define NFSPROC_WRITECACHE 7
+extern  void * nfsproc_writecache_2();
+extern  void * nfsproc_writecache_2_svc();
+#define NFSPROC_WRITE 8
+extern  attrstat * nfsproc_write_2();
+extern  attrstat * nfsproc_write_2_svc();
+#define NFSPROC_CREATE 9
+extern  diropres * nfsproc_create_2();
+extern  diropres * nfsproc_create_2_svc();
+#define NFSPROC_REMOVE 10
+extern  nfsstat * nfsproc_remove_2();
+extern  nfsstat * nfsproc_remove_2_svc();
+#define NFSPROC_RENAME 11
+extern  nfsstat * nfsproc_rename_2();
+extern  nfsstat * nfsproc_rename_2_svc();
+#define NFSPROC_LINK 12
+extern  nfsstat * nfsproc_link_2();
+extern  nfsstat * nfsproc_link_2_svc();
+#define NFSPROC_SYMLINK 13
+extern  nfsstat * nfsproc_symlink_2();
+extern  nfsstat * nfsproc_symlink_2_svc();
+#define NFSPROC_MKDIR 14
+extern  diropres * nfsproc_mkdir_2();
+extern  diropres * nfsproc_mkdir_2_svc();
+#define NFSPROC_RMDIR 15
+extern  nfsstat * nfsproc_rmdir_2();
+extern  nfsstat * nfsproc_rmdir_2_svc();
+#define NFSPROC_READDIR 16
+extern  readdirres * nfsproc_readdir_2();
+extern  readdirres * nfsproc_readdir_2_svc();
+#define NFSPROC_STATFS 17
+extern  statfsres * nfsproc_statfs_2();
+extern  statfsres * nfsproc_statfs_2_svc();
+extern int nfs_program_2_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_nfsstat (XDR *, nfsstat*);
+extern  bool_t xdr_ftype (XDR *, ftype*);
+extern  bool_t xdr_nfs_fh (XDR *, nfs_fh*);
+extern  bool_t xdr_nfstime (XDR *, nfstime*);
+extern  bool_t xdr_fattr (XDR *, fattr*);
+extern  bool_t xdr_sattr (XDR *, sattr*);
+extern  bool_t xdr_filename (XDR *, filename*);
+extern  bool_t xdr_nfspath (XDR *, nfspath*);
+extern  bool_t xdr_attrstat (XDR *, attrstat*);
+extern  bool_t xdr_sattrargs (XDR *, sattrargs*);
+extern  bool_t xdr_diropargs (XDR *, diropargs*);
+extern  bool_t xdr_diropokres (XDR *, diropokres*);
+extern  bool_t xdr_diropres (XDR *, diropres*);
+extern  bool_t xdr_readlinkres (XDR *, readlinkres*);
+extern  bool_t xdr_readargs (XDR *, readargs*);
+extern  bool_t xdr_readokres (XDR *, readokres*);
+extern  bool_t xdr_readres (XDR *, readres*);
+extern  bool_t xdr_writeargs (XDR *, writeargs*);
+extern  bool_t xdr_createargs (XDR *, createargs*);
+extern  bool_t xdr_renameargs (XDR *, renameargs*);
+extern  bool_t xdr_linkargs (XDR *, linkargs*);
+extern  bool_t xdr_symlinkargs (XDR *, symlinkargs*);
+extern  bool_t xdr_nfscookie (XDR *, nfscookie);
+extern  bool_t xdr_readdirargs (XDR *, readdirargs*);
+extern  bool_t xdr_entry (XDR *, entry*);
+extern  bool_t xdr_dirlist (XDR *, dirlist*);
+extern  bool_t xdr_readdirres (XDR *, readdirres*);
+extern  bool_t xdr_statfsokres (XDR *, statfsokres*);
+extern  bool_t xdr_statfsres (XDR *, statfsres*);
+
+#else /* K&R C */
+extern bool_t xdr_nfsstat ();
+extern bool_t xdr_ftype ();
+extern bool_t xdr_nfs_fh ();
+extern bool_t xdr_nfstime ();
+extern bool_t xdr_fattr ();
+extern bool_t xdr_sattr ();
+extern bool_t xdr_filename ();
+extern bool_t xdr_nfspath ();
+extern bool_t xdr_attrstat ();
+extern bool_t xdr_sattrargs ();
+extern bool_t xdr_diropargs ();
+extern bool_t xdr_diropokres ();
+extern bool_t xdr_diropres ();
+extern bool_t xdr_readlinkres ();
+extern bool_t xdr_readargs ();
+extern bool_t xdr_readokres ();
+extern bool_t xdr_readres ();
+extern bool_t xdr_writeargs ();
+extern bool_t xdr_createargs ();
+extern bool_t xdr_renameargs ();
+extern bool_t xdr_linkargs ();
+extern bool_t xdr_symlinkargs ();
+extern bool_t xdr_nfscookie ();
+extern bool_t xdr_readdirargs ();
+extern bool_t xdr_entry ();
+extern bool_t xdr_dirlist ();
+extern bool_t xdr_readdirres ();
+extern bool_t xdr_statfsokres ();
+extern bool_t xdr_statfsres ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_NFS_PROT_H_RPCGEN */
diff --git a/include/rpcsvc/nfs_prot.x b/include/rpcsvc/nfs_prot.x
new file mode 100644
index 0000000..ad992e2
--- /dev/null
+++ b/include/rpcsvc/nfs_prot.x
@@ -0,0 +1,352 @@
+/* @(#)nfs_prot.x	2.1 88/08/01 4.0 RPCSRC */
+
+/*
+ * nfs_prot.x 1.2 87/10/12
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+const NFS_PORT          = 2049;
+const NFS_MAXDATA       = 8192;
+const NFS_MAXPATHLEN    = 1024;
+const NFS_MAXNAMLEN	= 255;
+const NFS_FHSIZE	= 32;
+const NFS_COOKIESIZE	= 4;
+const NFS_FIFO_DEV	= -1;	/* size kludge for named pipes */
+
+/*
+ * File types
+ */
+const NFSMODE_FMT  = 0170000;	/* type of file */
+const NFSMODE_DIR  = 0040000;	/* directory */
+const NFSMODE_CHR  = 0020000;	/* character special */
+const NFSMODE_BLK  = 0060000;	/* block special */
+const NFSMODE_REG  = 0100000;	/* regular */
+const NFSMODE_LNK  = 0120000;	/* symbolic link */
+const NFSMODE_SOCK = 0140000;	/* socket */
+const NFSMODE_FIFO = 0010000;	/* fifo */
+
+/*
+ * Error status
+ */
+enum nfsstat {
+	NFS_OK= 0,		/* no error */
+	NFSERR_PERM=1,		/* Not owner */
+	NFSERR_NOENT=2,		/* No such file or directory */
+	NFSERR_IO=5,		/* I/O error */
+	NFSERR_NXIO=6,		/* No such device or address */
+	NFSERR_ACCES=13,	/* Permission denied */
+	NFSERR_EXIST=17,	/* File exists */
+	NFSERR_NODEV=19,	/* No such device */
+	NFSERR_NOTDIR=20,	/* Not a directory*/
+	NFSERR_ISDIR=21,	/* Is a directory */
+	NFSERR_FBIG=27,		/* File too large */
+	NFSERR_NOSPC=28,	/* No space left on device */
+	NFSERR_ROFS=30,		/* Read-only file system */
+	NFSERR_NAMETOOLONG=63,	/* File name too long */
+	NFSERR_NOTEMPTY=66,	/* Directory not empty */
+	NFSERR_DQUOT=69,	/* Disc quota exceeded */
+	NFSERR_STALE=70,	/* Stale NFS file handle */
+	NFSERR_WFLUSH=99	/* write cache flushed */
+};
+
+/*
+ * File types
+ */
+enum ftype {
+	NFNON = 0,	/* non-file */
+	NFREG = 1,	/* regular file */
+	NFDIR = 2,	/* directory */
+	NFBLK = 3,	/* block special */
+	NFCHR = 4,	/* character special */
+	NFLNK = 5,	/* symbolic link */
+	NFSOCK = 6,	/* unix domain sockets */
+	NFBAD = 7,	/* unused */
+	NFFIFO = 8 	/* named pipe */
+};
+
+/*
+ * File access handle
+ */
+struct nfs_fh {
+	opaque data[NFS_FHSIZE];
+};
+
+/*
+ * Timeval
+ */
+struct nfstime {
+	unsigned seconds;
+	unsigned useconds;
+};
+
+
+/*
+ * File attributes
+ */
+struct fattr {
+	ftype type;		/* file type */
+	unsigned mode;		/* protection mode bits */
+	unsigned nlink;		/* # hard links */
+	unsigned uid;		/* owner user id */
+	unsigned gid;		/* owner group id */
+	unsigned size;		/* file size in bytes */
+	unsigned blocksize;	/* preferred block size */
+	unsigned rdev;		/* special device # */
+	unsigned blocks;	/* Kb of disk used by file */
+	unsigned fsid;		/* device # */
+	unsigned fileid;	/* inode # */
+	nfstime	atime;		/* time of last access */
+	nfstime	mtime;		/* time of last modification */
+	nfstime	ctime;		/* time of last change */
+};
+
+/*
+ * File attributes which can be set
+ */
+struct sattr {
+	unsigned mode;	/* protection mode bits */
+	unsigned uid;	/* owner user id */
+	unsigned gid;	/* owner group id */
+	unsigned size;	/* file size in bytes */
+	nfstime	atime;	/* time of last access */
+	nfstime	mtime;	/* time of last modification */
+};
+
+
+typedef string filename<NFS_MAXNAMLEN>;
+typedef string nfspath<NFS_MAXPATHLEN>;
+
+/*
+ * Reply status with file attributes
+ */
+union attrstat switch (nfsstat status) {
+case NFS_OK:
+	fattr attributes;
+default:
+	void;
+};
+
+struct sattrargs {
+	nfs_fh file;
+	sattr attributes;
+};
+
+/*
+ * Arguments for directory operations
+ */
+struct diropargs {
+	nfs_fh	dir;	/* directory file handle */
+	filename name;		/* name (up to NFS_MAXNAMLEN bytes) */
+};
+
+struct diropokres {
+	nfs_fh file;
+	fattr attributes;
+};
+
+/*
+ * Results from directory operation
+ */
+union diropres switch (nfsstat status) {
+case NFS_OK:
+	diropokres diropres;
+default:
+	void;
+};
+
+union readlinkres switch (nfsstat status) {
+case NFS_OK:
+	nfspath data;
+default:
+	void;
+};
+
+/*
+ * Arguments to remote read
+ */
+struct readargs {
+	nfs_fh file;		/* handle for file */
+	unsigned offset;	/* byte offset in file */
+	unsigned count;		/* immediate read count */
+	unsigned totalcount;	/* total read count (from this offset)*/
+};
+
+/*
+ * Status OK portion of remote read reply
+ */
+struct readokres {
+	fattr	attributes;	/* attributes, need for pagin*/
+	opaque data<NFS_MAXDATA>;
+};
+
+union readres switch (nfsstat status) {
+case NFS_OK:
+	readokres reply;
+default:
+	void;
+};
+
+/*
+ * Arguments to remote write
+ */
+struct writeargs {
+	nfs_fh	file;		/* handle for file */
+	unsigned beginoffset;	/* beginning byte offset in file */
+	unsigned offset;	/* current byte offset in file */
+	unsigned totalcount;	/* total write count (to this offset)*/
+	opaque data<NFS_MAXDATA>;
+};
+
+struct createargs {
+	diropargs where;
+	sattr attributes;
+};
+
+struct renameargs {
+	diropargs from;
+	diropargs to;
+};
+
+struct linkargs {
+	nfs_fh from;
+	diropargs to;
+};
+
+struct symlinkargs {
+	diropargs from;
+	nfspath to;
+	sattr attributes;
+};
+
+
+typedef opaque nfscookie[NFS_COOKIESIZE];
+
+/*
+ * Arguments to readdir
+ */
+struct readdirargs {
+	nfs_fh dir;		/* directory handle */
+	nfscookie cookie;
+	unsigned count;		/* number of directory bytes to read */
+};
+
+struct entry {
+	unsigned fileid;
+	filename name;
+	nfscookie cookie;
+	entry *nextentry;
+};
+
+struct dirlist {
+	entry *entries;
+	bool eof;
+};
+
+union readdirres switch (nfsstat status) {
+case NFS_OK:
+	dirlist reply;
+default:
+	void;
+};
+
+struct statfsokres {
+	unsigned tsize;	/* preferred transfer size in bytes */
+	unsigned bsize;	/* fundamental file system block size */
+	unsigned blocks;	/* total blocks in file system */
+	unsigned bfree;	/* free blocks in fs */
+	unsigned bavail;	/* free blocks avail to non-superuser */
+};
+
+union statfsres switch (nfsstat status) {
+case NFS_OK:
+	statfsokres reply;
+default:
+	void;
+};
+
+/*
+ * Remote file service routines
+ */
+program NFS_PROGRAM {
+	version NFS_VERSION {
+		void
+		NFSPROC_NULL(void) = 0;
+
+		attrstat
+		NFSPROC_GETATTR(nfs_fh) =	1;
+
+		attrstat
+		NFSPROC_SETATTR(sattrargs) = 2;
+
+		void
+		NFSPROC_ROOT(void) = 3;
+
+		diropres
+		NFSPROC_LOOKUP(diropargs) = 4;
+
+		readlinkres
+		NFSPROC_READLINK(nfs_fh) = 5;
+
+		readres
+		NFSPROC_READ(readargs) = 6;
+
+		void
+		NFSPROC_WRITECACHE(void) = 7;
+
+		attrstat
+		NFSPROC_WRITE(writeargs) = 8;
+
+		diropres
+		NFSPROC_CREATE(createargs) = 9;
+
+		nfsstat
+		NFSPROC_REMOVE(diropargs) = 10;
+
+		nfsstat
+		NFSPROC_RENAME(renameargs) = 11;
+
+		nfsstat
+		NFSPROC_LINK(linkargs) = 12;
+
+		nfsstat
+		NFSPROC_SYMLINK(symlinkargs) = 13;
+
+		diropres
+		NFSPROC_MKDIR(createargs) = 14;
+
+		nfsstat
+		NFSPROC_RMDIR(diropargs) = 15;
+
+		readdirres
+		NFSPROC_READDIR(readdirargs) = 16;
+
+		statfsres
+		NFSPROC_STATFS(nfs_fh) = 17;
+	} = 2;
+} = 100003;
diff --git a/include/rpcsvc/nis.h b/include/rpcsvc/nis.h
new file mode 100644
index 0000000..933c4d9
--- /dev/null
+++ b/include/rpcsvc/nis.h
@@ -0,0 +1,616 @@
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _RPCSVC_NIS_H
+#define _RPCSVC_NIS_H 1
+
+#include <features.h>
+#include <rpc/rpc.h>
+#include <rpcsvc/nis_tags.h>
+
+__BEGIN_DECLS
+
+/*
+ *	nis.h
+ *
+ *	This file is the main include file for NIS clients. It contains
+ *	both the client library function defines and the various data
+ *	structures used by the NIS service. It includes the file nis_tags.h
+ *	which defines the tag values. This allows the tags to change without
+ *	having to change the nis.x file.
+ *
+ *	NOTE : THIS FILE IS NOT GENERATED WITH RPCGEN ! SO YOU HAVE TO
+ *             ADD ALL THE CHANGES ON nis_*.x FILES HERE AGAIN !
+ *
+ *      I have removed all the Solaris internal structs and variables,
+ *      because they are not supported, Sun changed them between various
+ *      releases and they shouldn't be used in user programs.
+ *                                              <kukuk@suse.de>
+ */
+
+
+#ifndef __nis_object_h
+#define __nis_object_h
+
+#define NIS_MAXSTRINGLEN 255
+#define NIS_MAXNAMELEN 1024
+#define NIS_MAXATTRNAME 32
+#define NIS_MAXATTRVAL 2048
+#define NIS_MAXCOLUMNS 64
+#define NIS_MAXATTR 16
+#define NIS_MAXPATH 1024
+#define NIS_MAXREPLICAS 128
+#define NIS_MAXLINKS 16
+#define NIS_PK_NONE 0
+#define NIS_PK_DH 1
+#define NIS_PK_RSA 2
+#define NIS_PK_KERB 3
+#define NIS_PK_DHEXT 4
+
+struct nis_attr {
+	char *zattr_ndx;
+	struct {
+		u_int zattr_val_len;
+		char *zattr_val_val;
+	} zattr_val;
+};
+typedef struct nis_attr nis_attr;
+
+typedef char *nis_name;
+
+enum zotypes {
+	BOGUS_OBJ = 0,
+	NO_OBJ = 1,
+	DIRECTORY_OBJ = 2,
+	GROUP_OBJ = 3,
+	TABLE_OBJ = 4,
+	ENTRY_OBJ = 5,
+	LINK_OBJ = 6,
+	PRIVATE_OBJ = 7,
+	NIS_BOGUS_OBJ = 0,
+	NIS_NO_OBJ = 1,
+	NIS_DIRECTORY_OBJ = 2,
+	NIS_GROUP_OBJ = 3,
+	NIS_TABLE_OBJ = 4,
+	NIS_ENTRY_OBJ = 5,
+	NIS_LINK_OBJ = 6,
+	NIS_PRIVATE_OBJ = 7
+};
+typedef enum zotypes zotypes;
+
+enum nstype {
+	UNKNOWN = 0,
+	NIS = 1,
+	SUNYP = 2,
+	IVY = 3,
+	DNS = 4,
+	X500 = 5,
+	DNANS = 6,
+	XCHS = 7,
+	CDS = 8,
+};
+typedef enum nstype nstype;
+
+struct oar_mask {
+	uint32_t oa_rights;
+	zotypes oa_otype;
+};
+typedef struct oar_mask oar_mask;
+
+struct endpoint {
+	char *uaddr;
+	char *family;
+	char *proto;
+};
+typedef struct endpoint endpoint;
+
+struct nis_server {
+	nis_name name;
+	struct {
+		u_int ep_len;
+		endpoint *ep_val;
+	} ep;
+	uint32_t key_type;
+	netobj pkey;
+};
+typedef struct nis_server nis_server;
+
+struct directory_obj {
+	nis_name do_name;
+	nstype do_type;
+	struct {
+		u_int do_servers_len;
+		nis_server *do_servers_val;
+	} do_servers;
+	uint32_t do_ttl;
+	struct {
+		u_int do_armask_len;
+		oar_mask *do_armask_val;
+	} do_armask;
+};
+typedef struct directory_obj directory_obj;
+
+#define EN_BINARY 1
+#define EN_CRYPT 2
+#define EN_XDR 4
+#define EN_MODIFIED 8
+#define EN_ASN1 64
+
+struct entry_col {
+	uint32_t ec_flags;
+	struct {
+		u_int ec_value_len;
+		char *ec_value_val;
+	} ec_value;
+};
+typedef struct entry_col entry_col;
+
+struct entry_obj {
+	char *en_type;
+	struct {
+		u_int en_cols_len;
+		entry_col *en_cols_val;
+	} en_cols;
+};
+typedef struct entry_obj entry_obj;
+
+struct group_obj {
+	uint32_t gr_flags;
+	struct {
+		u_int gr_members_len;
+		nis_name *gr_members_val;
+	} gr_members;
+};
+typedef struct group_obj group_obj;
+
+struct link_obj {
+	zotypes li_rtype;
+	struct {
+		u_int li_attrs_len;
+		nis_attr *li_attrs_val;
+	} li_attrs;
+	nis_name li_name;
+};
+typedef struct link_obj link_obj;
+
+#define TA_BINARY 1
+#define TA_CRYPT 2
+#define TA_XDR 4
+#define TA_SEARCHABLE 8
+#define TA_CASE 16
+#define TA_MODIFIED 32
+#define TA_ASN1 64
+
+struct table_col {
+	char *tc_name;
+	uint32_t tc_flags;
+	uint32_t tc_rights;
+};
+typedef struct table_col table_col;
+
+struct table_obj {
+	char *ta_type;
+	int ta_maxcol;
+	u_char ta_sep;
+	struct {
+		u_int ta_cols_len;
+		table_col *ta_cols_val;
+	} ta_cols;
+	char *ta_path;
+};
+typedef struct table_obj table_obj;
+
+struct objdata {
+	zotypes zo_type;
+	union {
+		struct directory_obj di_data;
+		struct group_obj gr_data;
+		struct table_obj ta_data;
+		struct entry_obj en_data;
+		struct link_obj li_data;
+		struct {
+			u_int po_data_len;
+			char *po_data_val;
+		} po_data;
+	} objdata_u;
+};
+typedef struct objdata objdata;
+
+struct nis_oid {
+	uint32_t ctime;
+	uint32_t mtime;
+};
+typedef struct nis_oid nis_oid;
+
+struct nis_object {
+	nis_oid zo_oid;
+	nis_name zo_name;
+	nis_name zo_owner;
+	nis_name zo_group;
+	nis_name zo_domain;
+	uint32_t zo_access;
+	uint32_t zo_ttl;
+	objdata zo_data;
+};
+typedef struct nis_object nis_object;
+
+#endif /* if __nis_object_h */
+
+enum nis_error {
+	NIS_SUCCESS = 0,
+	NIS_S_SUCCESS = 1,
+	NIS_NOTFOUND = 2,
+	NIS_S_NOTFOUND = 3,
+	NIS_CACHEEXPIRED = 4,
+	NIS_NAMEUNREACHABLE = 5,
+	NIS_UNKNOWNOBJ = 6,
+	NIS_TRYAGAIN = 7,
+	NIS_SYSTEMERROR = 8,
+	NIS_CHAINBROKEN = 9,
+	NIS_PERMISSION = 10,
+	NIS_NOTOWNER = 11,
+	NIS_NOT_ME = 12,
+	NIS_NOMEMORY = 13,
+	NIS_NAMEEXISTS = 14,
+	NIS_NOTMASTER = 15,
+	NIS_INVALIDOBJ = 16,
+	NIS_BADNAME = 17,
+	NIS_NOCALLBACK = 18,
+	NIS_CBRESULTS = 19,
+	NIS_NOSUCHNAME = 20,
+	NIS_NOTUNIQUE = 21,
+	NIS_IBMODERROR = 22,
+	NIS_NOSUCHTABLE = 23,
+	NIS_TYPEMISMATCH = 24,
+	NIS_LINKNAMEERROR = 25,
+	NIS_PARTIAL = 26,
+	NIS_TOOMANYATTRS = 27,
+	NIS_RPCERROR = 28,
+	NIS_BADATTRIBUTE = 29,
+	NIS_NOTSEARCHABLE = 30,
+	NIS_CBERROR = 31,
+	NIS_FOREIGNNS = 32,
+	NIS_BADOBJECT = 33,
+	NIS_NOTSAMEOBJ = 34,
+	NIS_MODFAIL = 35,
+	NIS_BADREQUEST = 36,
+	NIS_NOTEMPTY = 37,
+	NIS_COLDSTART_ERR = 38,
+	NIS_RESYNC = 39,
+	NIS_FAIL = 40,
+	NIS_UNAVAIL = 41,
+	NIS_RES2BIG = 42,
+	NIS_SRVAUTH = 43,
+	NIS_CLNTAUTH = 44,
+	NIS_NOFILESPACE = 45,
+	NIS_NOPROC = 46,
+	NIS_DUMPLATER = 47,
+};
+typedef enum nis_error nis_error;
+
+struct nis_result {
+	nis_error status;
+	struct {
+		u_int objects_len;
+		nis_object *objects_val;
+	} objects;
+	netobj cookie;
+	uint32_t zticks;
+	uint32_t dticks;
+	uint32_t aticks;
+	uint32_t cticks;
+};
+typedef struct nis_result nis_result;
+
+struct ns_request {
+	nis_name ns_name;
+	struct {
+		u_int ns_object_len;
+		nis_object *ns_object_val;
+	} ns_object;
+};
+typedef struct ns_request ns_request;
+
+struct ib_request {
+	nis_name ibr_name;
+	struct {
+		u_int ibr_srch_len;
+		nis_attr *ibr_srch_val;
+	} ibr_srch;
+	uint32_t ibr_flags;
+	struct {
+		u_int ibr_obj_len;
+		nis_object *ibr_obj_val;
+	} ibr_obj;
+	struct {
+		u_int ibr_cbhost_len;
+		nis_server *ibr_cbhost_val;
+	} ibr_cbhost;
+	u_int ibr_bufsize;
+	netobj ibr_cookie;
+};
+typedef struct ib_request ib_request;
+
+struct ping_args {
+	nis_name dir;
+	uint32_t stamp;
+};
+typedef struct ping_args ping_args;
+
+enum log_entry_t {
+	LOG_NOP = 0,
+	ADD_NAME = 1,
+	REM_NAME = 2,
+	MOD_NAME_OLD = 3,
+	MOD_NAME_NEW = 4,
+	ADD_IBASE = 5,
+	REM_IBASE = 6,
+	MOD_IBASE = 7,
+	UPD_STAMP = 8,
+};
+typedef enum log_entry_t log_entry_t;
+
+struct log_entry {
+	uint32_t le_time;
+	log_entry_t le_type;
+	nis_name le_princp;
+	nis_name le_name;
+	struct {
+		u_int le_attrs_len;
+		nis_attr *le_attrs_val;
+	} le_attrs;
+	nis_object le_object;
+};
+typedef struct log_entry log_entry;
+
+struct log_result {
+	nis_error lr_status;
+	netobj lr_cookie;
+	struct {
+		u_int lr_entries_len;
+		log_entry *lr_entries_val;
+	} lr_entries;
+};
+typedef struct log_result log_result;
+
+struct cp_result {
+	nis_error cp_status;
+	uint32_t cp_zticks;
+	uint32_t cp_dticks;
+};
+typedef struct cp_result cp_result;
+
+struct nis_tag {
+	uint32_t tag_type;
+	char *tag_val;
+};
+typedef struct nis_tag nis_tag;
+
+struct nis_taglist {
+	struct {
+		u_int tags_len;
+		nis_tag *tags_val;
+	} tags;
+};
+typedef struct nis_taglist nis_taglist;
+
+struct dump_args {
+	nis_name da_dir;
+	uint32_t da_time;
+	struct {
+		u_int da_cbhost_len;
+		nis_server *da_cbhost_val;
+	} da_cbhost;
+};
+typedef struct dump_args dump_args;
+
+struct fd_args {
+	nis_name dir_name;
+	nis_name requester;
+};
+typedef struct fd_args fd_args;
+
+struct fd_result {
+	nis_error status;
+	nis_name source;
+	struct {
+		u_int dir_data_len;
+		char *dir_data_val;
+	} dir_data;
+	struct {
+		u_int signature_len;
+		char *signature_val;
+	} signature;
+};
+typedef struct fd_result fd_result;
+
+/* Generic client creating flags */
+#define ZMH_VC		1
+#define ZMH_DG		2
+#define ZMH_AUTH	4
+
+/* Testing Access rights for objects */
+
+#define NIS_READ_ACC		1
+#define NIS_MODIFY_ACC		2
+#define NIS_CREATE_ACC		4
+#define NIS_DESTROY_ACC	8
+/* Test macros. a == access rights, m == desired rights. */
+#define NIS_WORLD(a, m)        (((a) & (m)) != 0)
+#define NIS_GROUP(a, m)        (((a) & ((m) << 8)) != 0)
+#define NIS_OWNER(a, m)        (((a) & ((m) << 16)) != 0)
+#define NIS_NOBODY(a, m)       (((a) & ((m) << 24)) != 0)
+/*
+ * EOL Alert - The following non-prefixed test macros are
+ * here for backward compatibility, and will be not be present
+ * in future releases - use the NIS_*() macros above.
+ */
+#define WORLD(a, m)	(((a) & (m)) != 0)
+#define GROUP(a, m)	(((a) & ((m) << 8)) != 0)
+#define OWNER(a, m)	(((a) & ((m) << 16)) != 0)
+#define NOBODY(a, m)	(((a) & ((m) << 24)) != 0)
+
+#define OATYPE(d, n) (((d)->do_armask.do_armask_val+n)->oa_otype)
+#define OARIGHTS(d, n) (((d)->do_armask.do_armask_val+n)->oa_rights)
+#define WORLD_DEFAULT (NIS_READ_ACC)
+#define GROUP_DEFAULT (NIS_READ_ACC << 8)
+#define OWNER_DEFAULT ((NIS_READ_ACC + NIS_MODIFY_ACC + NIS_CREATE_ACC +\
+			NIS_DESTROY_ACC) << 16)
+#define DEFAULT_RIGHTS (WORLD_DEFAULT | GROUP_DEFAULT | OWNER_DEFAULT)
+
+/* Result manipulation defines ... */
+#define NIS_RES_NUMOBJ(x)	((x)->objects.objects_len)
+#define NIS_RES_OBJECT(x)	((x)->objects.objects_val)
+#define NIS_RES_COOKIE(x)	((x)->cookie)
+#define NIS_RES_STATUS(x)	((x)->status)
+
+/* These defines make getting at the variant part of the object easier. */
+#define TA_data zo_data.objdata_u.ta_data
+#define EN_data zo_data.objdata_u.en_data
+#define DI_data zo_data.objdata_u.di_data
+#define LI_data zo_data.objdata_u.li_data
+#define GR_data zo_data.objdata_u.gr_data
+
+#define __type_of(o) ((o)->zo_data.zo_type)
+
+/* Declarations for the internal subroutines in nislib.c */
+enum name_pos {SAME_NAME, HIGHER_NAME, LOWER_NAME, NOT_SEQUENTIAL, BAD_NAME};
+typedef enum name_pos name_pos;
+
+/*
+ * Defines for getting at column data in entry objects. Because RPCGEN
+ * generates some rather wordy structures, we create some defines that
+ * collapse the needed keystrokes to access a particular value using
+ * these definitions they take an nis_object *, and an int and return
+ * a u_char * for Value, and an int for length.
+ */
+#define ENTRY_VAL(obj, col) (obj)->EN_data.en_cols.en_cols_val[col].ec_value.ec_value_val
+#define ENTRY_LEN(obj, col) (obj)->EN_data.en_cols.en_cols_val[col].ec_value.ec_value_len
+
+
+/* Prototypes, and extern declarations for the NIS library functions. */
+#include <rpcsvc/nislib.h>
+#endif
+
+/*
+ * nis_3.h
+ *
+ * This file contains definitions that are only of interest to the actual
+ * service daemon and client stubs. Normal users of NIS will not include
+ * this file.
+ *
+ * NOTE : This include file is automatically created by a combination
+ * of rpcgen and sed. DO NOT EDIT IT, change the nis.x file instead
+ * and then remake this file.
+ */
+#ifndef __nis_3_h
+#define __nis_3_h
+
+#define NIS_PROG 100300
+#define NIS_VERSION 3
+
+#define NIS_LOOKUP 1
+extern  nis_result * nis_lookup_3 (ns_request *, CLIENT *) __THROW;
+extern  nis_result * nis_lookup_3_svc (ns_request *, struct svc_req *) __THROW;
+#define NIS_ADD 2
+extern  nis_result * nis_add_3 (ns_request *, CLIENT *) __THROW;
+extern  nis_result * nis_add_3_svc (ns_request *, struct svc_req *) __THROW;
+#define NIS_MODIFY 3
+extern  nis_result * nis_modify_3 (ns_request *, CLIENT *) __THROW;
+extern  nis_result * nis_modify_3_svc (ns_request *, struct svc_req *) __THROW;
+#define NIS_REMOVE 4
+extern  nis_result * nis_remove_3 (ns_request *, CLIENT *) __THROW;
+extern  nis_result * nis_remove_3_svc (ns_request *, struct svc_req *) __THROW;
+#define NIS_IBLIST 5
+extern  nis_result * nis_iblist_3 (ib_request *, CLIENT *) __THROW;
+extern  nis_result * nis_iblist_3_svc (ib_request *, struct svc_req *) __THROW;
+#define NIS_IBADD 6
+extern  nis_result * nis_ibadd_3 (ib_request *, CLIENT *) __THROW;
+extern  nis_result * nis_ibadd_3_svc (ib_request *, struct svc_req *) __THROW;
+#define NIS_IBMODIFY 7
+extern  nis_result * nis_ibmodify_3 (ib_request *, CLIENT *) __THROW;
+extern  nis_result * nis_ibmodify_3_svc (ib_request *, struct svc_req *)
+     __THROW;
+#define NIS_IBREMOVE 8
+extern  nis_result * nis_ibremove_3 (ib_request *, CLIENT *) __THROW;
+extern  nis_result * nis_ibremove_3_svc (ib_request *, struct svc_req *)
+     __THROW;
+#define NIS_IBFIRST 9
+extern  nis_result * nis_ibfirst_3 (ib_request *, CLIENT *) __THROW;
+extern  nis_result * nis_ibfirst_3_svc (ib_request *, struct svc_req *)
+     __THROW;
+#define NIS_IBNEXT 10
+extern  nis_result * nis_ibnext_3 (ib_request *, CLIENT *) __THROW;
+extern  nis_result * nis_ibnext_3_svc (ib_request *, struct svc_req *) __THROW;
+#define NIS_FINDDIRECTORY 12
+extern  fd_result * nis_finddirectory_3 (fd_args *, CLIENT *) __THROW;
+extern  fd_result * nis_finddirectory_3_svc (fd_args *,
+					     struct svc_req *) __THROW;
+#define NIS_STATUS 14
+extern  nis_taglist * nis_status_3 (nis_taglist *, CLIENT *) __THROW;
+extern  nis_taglist * nis_status_3_svc (nis_taglist *, struct svc_req *)
+     __THROW;
+#define NIS_DUMPLOG 15
+extern  log_result * nis_dumplog_3 (dump_args *, CLIENT *) __THROW;
+extern  log_result * nis_dumplog_3_svc (dump_args *, struct svc_req *) __THROW;
+#define NIS_DUMP 16
+extern  log_result * nis_dump_3 (dump_args *, CLIENT *) __THROW;
+extern  log_result * nis_dump_3_svc (dump_args *, struct svc_req *) __THROW;
+#define NIS_CALLBACK 17
+extern  bool_t * nis_callback_3 (netobj *, CLIENT *) __THROW;
+extern  bool_t * nis_callback_3_svc (netobj *, struct svc_req *) __THROW;
+#define NIS_CPTIME 18
+extern  uint32_t * nis_cptime_3 (nis_name *, CLIENT *) __THROW;
+extern  uint32_t * nis_cptime_3_svc (nis_name *, struct svc_req *) __THROW;
+#define NIS_CHECKPOINT 19
+extern  cp_result * nis_checkpoint_3 (nis_name *, CLIENT *) __THROW;
+extern  cp_result * nis_checkpoint_3_svc (nis_name *, struct svc_req *)
+     __THROW;
+#define NIS_PING 20
+extern  void * nis_ping_3 (ping_args *, CLIENT *) __THROW;
+extern  void * nis_ping_3_svc (ping_args *, struct svc_req *) __THROW;
+#define NIS_SERVSTATE 21
+extern  nis_taglist * nis_servstate_3 (nis_taglist *, CLIENT *) __THROW;
+extern  nis_taglist * nis_servstate_3_svc (nis_taglist *,
+					   struct svc_req *) __THROW;
+#define NIS_MKDIR 22
+extern  nis_error * nis_mkdir_3 (nis_name *, CLIENT *) __THROW;
+extern  nis_error * nis_mkdir_3_svc (nis_name *, struct svc_req *) __THROW;
+#define NIS_RMDIR 23
+extern  nis_error * nis_rmdir_3 (nis_name *, CLIENT *) __THROW;
+extern  nis_error * nis_rmdir_3_svc (nis_name *, struct svc_req *) __THROW;
+#define NIS_UPDKEYS 24
+extern  nis_error * nis_updkeys_3 (nis_name *, CLIENT *) __THROW;
+extern  nis_error * nis_updkeys_3_svc (nis_name *, struct svc_req *) __THROW;
+
+__END_DECLS
+
+#endif /* ! _RPCSVC_NIS_H */
diff --git a/include/rpcsvc/nis.x b/include/rpcsvc/nis.x
new file mode 100644
index 0000000..e318af2
--- /dev/null
+++ b/include/rpcsvc/nis.x
@@ -0,0 +1,474 @@
+%/*
+% * Copyright (c) 2010, Oracle America, Inc.
+% *
+% * Redistribution and use in source and binary forms, with or without
+% * modification, are permitted provided that the following conditions are
+% * met:
+% *
+% *     * Redistributions of source code must retain the above copyright
+% *       notice, this list of conditions and the following disclaimer.
+% *     * Redistributions in binary form must reproduce the above
+% *       copyright notice, this list of conditions and the following
+% *       disclaimer in the documentation and/or other materials
+% *       provided with the distribution.
+% *     * Neither the name of the "Oracle America, Inc." nor the names of its
+% *       contributors may be used to endorse or promote products derived
+% *       from this software without specific prior written permission.
+% *
+% *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+% *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+% *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+% *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+% *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+% *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+% *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+% *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+% *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+% *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+% *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+% *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+% */
+
+#ifdef RPC_HDR
+%/*
+% *	nis.h
+% *
+% *	This file is the main include file for NIS clients. It contains
+% *	both the client library function defines and the various data
+% *	structures used by the NIS service. It includes the file nis_tags.h
+% *	which defines the tag values. This allows the tags to change without
+% *	having to change the nis.x file.
+% *
+% *	NOTE : DO NOT EDIT THIS FILE! It is automatically generated when
+% *	       rpcgen is run on the nis.x file. Note that there is a
+% *	       simple sed script to remove some unneeded lines. (See the
+% *	       Makefile target nis.h)
+% *
+% */
+%#include <rpcsvc/nis_tags.h>
+#endif
+
+/* This gets stuffed into the source files. */
+#if RPC_HDR
+%#include <rpc/xdr.h>
+#endif
+
+/* Include the RPC Language description of NIS objects */
+#include "nis_object.x"
+
+/* Errors  that can be returned by the service */
+enum nis_error {
+	NIS_SUCCESS = 0,	/* A-ok, let's rock n roll	*/
+	NIS_S_SUCCESS = 1,	/* Name found (maybe)		*/
+	NIS_NOTFOUND = 2,	/* Name definitely not found	*/
+	NIS_S_NOTFOUND = 3,	/* Name maybe not found		*/
+	NIS_CACHEEXPIRED = 4,	/* Name exists but cache out of date */
+	NIS_NAMEUNREACHABLE = 5, /* Can't get there from here */
+	NIS_UNKNOWNOBJ = 6,	/* Object type is bogus */
+	NIS_TRYAGAIN = 7,	/* I'm busy, call back */
+	NIS_SYSTEMERROR = 8,	/* Generic system error */
+	NIS_CHAINBROKEN = 9,	/* First/Next warning */
+	NIS_PERMISSION = 10,	/* Not enough permission to access */
+	NIS_NOTOWNER = 11,	/* You don't own it, sorry */
+	NIS_NOT_ME = 12,	/* I don't serve this name */
+	NIS_NOMEMORY = 13,	/* Outta VM! Help! */
+	NIS_NAMEEXISTS = 14,	/* Can't create over another name */
+	NIS_NOTMASTER = 15,	/* I'm justa secondaray, don't ask me */
+	NIS_INVALIDOBJ = 16,	/* Object is broken somehow */
+	NIS_BADNAME = 17,	/* Unparsable name */
+	NIS_NOCALLBACK = 18,	/* Couldn't talk to call back proc */
+	NIS_CBRESULTS = 19,	/* Results being called back to you */
+	NIS_NOSUCHNAME = 20,	/* Name unknown */
+	NIS_NOTUNIQUE = 21,	/* Value is not uniques (entry) */
+	NIS_IBMODERROR = 22,	/* Inf. Base. Modify error. */
+	NIS_NOSUCHTABLE = 23,	/* Name for table was wrong */
+	NIS_TYPEMISMATCH = 24,	/* Entry and table type mismatch */
+	NIS_LINKNAMEERROR = 25,	/* Link points to bogus name */
+	NIS_PARTIAL = 26,	/* Partial success, found table */
+	NIS_TOOMANYATTRS = 27,	/* Too many attributes */
+	NIS_RPCERROR = 28,	/* RPC error encountered */
+	NIS_BADATTRIBUTE = 29,	/* Bad or invalid attribute */
+	NIS_NOTSEARCHABLE = 30,	/* Non-searchable object searched */
+	NIS_CBERROR = 31,	/* Error during callback (svc crash) */
+	NIS_FOREIGNNS = 32,	/* Foreign Namespace */
+	NIS_BADOBJECT = 33,	/* Malformed object structure */
+	NIS_NOTSAMEOBJ = 34,	/* Object swapped during deletion */
+	NIS_MODFAIL = 35,	/* Failure during a Modify. */
+	NIS_BADREQUEST = 36,	/* Illegal query for table */
+	NIS_NOTEMPTY = 37,	/* Attempt to remove a non-empty tbl */
+	NIS_COLDSTART_ERR = 38, /* Error accesing the cold start file */
+	NIS_RESYNC = 39,	/* Transaction log too far out of date */
+	NIS_FAIL = 40,		/* NIS operation failed. */
+	NIS_UNAVAIL = 41,	/* NIS+ service is unavailable (client) */
+	NIS_RES2BIG = 42,	/* NIS+ result too big for datagram */
+	NIS_SRVAUTH = 43,	/* NIS+ server wasn't authenticated. */
+	NIS_CLNTAUTH = 44,	/* NIS+ Client wasn't authenticated. */
+	NIS_NOFILESPACE = 45,	/* NIS+ server ran out of disk space */
+	NIS_NOPROC = 46,	/* NIS+ server couldn't create new proc */
+	NIS_DUMPLATER = 47	/* NIS+ server already has dump child */
+};
+
+
+/*
+ * Structure definitions for the parameters and results of the actual
+ * NIS RPC calls.
+ *
+ * This is the standard result (in the protocol) of most of the nis
+ * requests.
+ */
+
+struct nis_result {
+	nis_error	status;		/* Status of the response */
+	nis_object	objects<>;	/* objects found	  */
+	netobj		cookie;		/* Cookie Data		  */
+	uint32_t	zticks;		/* server ticks		  */
+	uint32_t	dticks;		/* DBM ticks.		  */
+	uint32_t	aticks;		/* Cache (accel) ticks	  */
+	uint32_t	cticks;		/* Client ticks		  */
+};
+
+/*
+ * A Name Service request
+ * This request is used to access the name space, ns_name is the name
+ * of the object within the namespace and the object is it's value, for
+ * add/modify, a copy of the original for remove.
+ */
+
+struct ns_request {
+	nis_name	ns_name;	/* Name in the NIS name space	*/
+	nis_object	ns_object<1>;	/* Optional Object (add/remove)	*/
+};
+
+/*
+ * An information base request
+ * This request includes the NIS name of the table we wish to search, the
+ * search criteria in the form of attribute/value pairs and an optional
+ * callback program number. If the callback program number is provided
+ * the server will send back objects one at a time, otherwise it will
+ * return them all in the response.
+ */
+
+struct ib_request {
+	nis_name	ibr_name;	/* The name of the Table	*/
+	nis_attr	ibr_srch<>;	/* The search critereia		*/
+	uint32_t	ibr_flags;	/* Optional flags		*/
+	nis_object	ibr_obj<1>;	/* optional object (add/modify) */
+	nis_server	ibr_cbhost<1>;	/* Optional callback info	*/
+	u_int		ibr_bufsize;	/* Optional first/next bufsize	*/
+	netobj		ibr_cookie;	/* The first/next cookie	*/
+};
+
+/*
+ * This argument to the PING call notifies the replicas that something in
+ * a directory has changed and this is it's timestamp. The replica will use
+ * the timestamp to determine if its resync operation was successful.
+ */
+struct ping_args {
+	nis_name	dir;	/* Directory that had the change */
+	uint32_t	stamp;	/* timestamp of the transaction  */
+};
+
+/*
+ * These are the type of entries that are stored in the transaction log,
+ * note that modifications will appear as two entries, for names, they have
+ * a "OLD" entry followed by a "NEW" entry. For entries in tables, there
+ * is a remove followed by an add. It is done this way so that we can read
+ * the log backwards to back out transactions and forwards to propogate
+ * updated.
+ */
+enum log_entry_t {
+	LOG_NOP = 0,
+	ADD_NAME = 1,		/* Name Added to name space		  */
+	REM_NAME = 2,		/* Name removed from name space		  */
+	MOD_NAME_OLD = 3,	/* Name was modified in the name space	  */
+	MOD_NAME_NEW = 4,	/* Name was modified in the name space	  */
+	ADD_IBASE = 5,		/* Entry added to information base	  */
+	REM_IBASE = 6,		/* Entry removed from information base    */
+	MOD_IBASE = 7,		/* Entry was modified in information base */
+	UPD_STAMP = 8		/* Update timestamp (used as fenceposts)  */
+};
+
+/*
+ * This result is returned from the name service when it is requested to
+ * dump logged entries from its transaction log. Information base updates
+ * will have the name of the information base in the le_name field and
+ * a canonical set of attribute/value pairs to fully specify the entry's
+ * 'name'.
+ */
+struct log_entry {
+	uint32_t	le_time;	/* Time in seconds		*/
+	log_entry_t	le_type;	/* Type of log entry		*/
+	nis_name	le_princp;	/* Principal making the change	*/
+	nis_name	le_name;	/* Name of table/dir involved	*/
+	nis_attr	le_attrs<>;	/* List of AV pairs.		*/
+	nis_object	le_object;	/* Actual object value		*/
+};
+
+struct log_result {
+	nis_error	lr_status;	/* The status itself		*/
+	netobj		lr_cookie;	/* Used by the dump callback	*/
+	log_entry	lr_entries<>;	/* zero or more entries	*/
+};
+
+struct cp_result {
+	nis_error	cp_status;	/* Status of the checkpoint	*/
+	uint32_t	cp_zticks;	/* Service 'ticks'		*/
+	uint32_t	cp_dticks;	/* Database 'ticks'		*/
+};
+
+/*
+ * This structure defines a generic NIS tag list. The taglist contains
+ * zero or tags, each of which is a type and a value. (u_int).
+ * These are used to report statistics (see tag definitions below)
+ * and to set or reset state variables.
+ */
+struct nis_tag {
+	uint32_t	tag_type;	/* Statistic tag (may vary)	 */
+	string		tag_val<>;	/* Statistic value may also vary */
+};
+
+struct nis_taglist {
+	nis_tag tags<>;			/* List of tags */
+};
+
+struct dump_args {
+	nis_name	da_dir;		/* Directory to dump	*/
+	uint32_t	da_time;	/* From this timestamp	*/
+	nis_server	da_cbhost<1>;	/* Callback to use.	*/
+};
+
+struct fd_args {
+	nis_name	dir_name;  /* The directory we're looking for */
+	nis_name	requester; /* Host principal name for signature */
+};
+
+struct fd_result {
+	nis_error	status;		/* Status returned by function	*/
+	nis_name	source;		/* Source of this answer	*/
+	opaque		dir_data<>;	/* Directory Data (XDR'ed)	*/
+	opaque		signature<>;	/* Signature of the source	*/
+};
+
+%/*
+% * Structures used for server binding.
+% */
+struct nis_bound_endpoint {
+	endpoint ep;
+	int generation;
+	int rank;
+	uint32_t flags;
+	int hostnum;
+	int epnum;
+	nis_name uaddr;
+	endpoint cbep;
+};
+typedef struct nis_bound_endpoint nis_bound_endpoint;
+
+struct nis_bound_directory {
+	int generation;
+	int min_rank;           /* minimum rank of bound endpoints */
+	int optimal_rank;       /* best possible rank of all endpoints */
+	directory_obj dobj;
+	nis_bound_endpoint BEP<>;
+};
+typedef struct nis_bound_directory nis_bound_directory;
+%#define bep_len BEP.BEP_len
+%#define bep_val BEP.BEP_val
+
+struct nis_active_endpoint {
+	endpoint ep;
+	nis_name hostname;
+	int rank;
+	int uaddr_generation;
+	nis_name uaddr;
+	int cbep_generation;
+	endpoint cbep;
+};
+typedef struct nis_active_endpoint nis_active_endpoint;
+
+%/* defines for nis_bound_endpoint.flags */
+%#define NIS_BOUND 0x1
+%#define NIS_TRANSIENT_ERRORS 0x2
+
+program  NIS_PROG {
+
+	/* RPC Language description of the NIS+ protocol */
+	version NIS_VERSION {
+		/* The name service functions */
+		nis_result  NIS_LOOKUP(ns_request) = 1;
+		nis_result  NIS_ADD(ns_request) = 2;
+		nis_result  NIS_MODIFY(ns_request) = 3;
+		nis_result  NIS_REMOVE(ns_request) = 4;
+
+		/* The information base functions */
+		nis_result  NIS_IBLIST(ib_request) = 5;
+		nis_result  NIS_IBADD(ib_request) = 6;
+		nis_result  NIS_IBMODIFY(ib_request) = 7;
+		nis_result  NIS_IBREMOVE(ib_request) = 8;
+		nis_result  NIS_IBFIRST(ib_request) = 9;
+		nis_result  NIS_IBNEXT(ib_request) = 10;
+
+		/* NIS Administrative functions */
+		fd_result   NIS_FINDDIRECTORY(fd_args) = 12;
+
+		/* If fetch and optionally reset statistics */
+		nis_taglist  NIS_STATUS(nis_taglist) = 14;
+
+		/* Dump changes to directory since time in da_time */
+		log_result  NIS_DUMPLOG(dump_args) = 15;
+
+		/* Dump contents of directory named */
+		log_result  NIS_DUMP(dump_args) = 16;
+
+		/* Check status of callback thread */
+		bool	    NIS_CALLBACK(netobj) = 17;
+
+		/* Return last update time for named dir */
+		uint32_t    NIS_CPTIME(nis_name) = 18;
+
+		/* Checkpoint directory or table named */
+		cp_result   NIS_CHECKPOINT(nis_name) = 19;
+
+		/* Send 'status changed' ping to replicates */
+		void	    NIS_PING(ping_args) = 20;
+
+		/* Modify server behaviour (such as debugging) */
+		nis_taglist NIS_SERVSTATE(nis_taglist) = 21;
+
+		/* Create a Directory */
+		nis_error   NIS_MKDIR(nis_name) = 22;
+
+		/* Remove a Directory */
+		nis_error   NIS_RMDIR(nis_name) = 23;
+
+		/* Update public keys of a directory object */
+		nis_error   NIS_UPDKEYS(nis_name) = 24;
+	} = 3;
+} = 100300;
+
+/*
+ * Included below are the defines that become part of nis.h,
+ * they are technically not part of the protocol, but do define
+ * key aspects of the implementation and are therefore useful
+ * in building a conforming server or client.
+ */
+#if RPC_HDR
+%/*
+% * Generic "hash" datastructures, used by all types of hashed data.
+% */
+%struct nis_hash_data {
+%	nis_name		name;	   /* NIS name of hashed item      */
+%	int			keychain;  /* It's hash key (for pop)      */
+%	struct nis_hash_data	*next;	   /* Hash collision pointer       */
+%	struct nis_hash_data	*prv_item; /* A serial, doubly linked list */
+%	struct nis_hash_data	*nxt_item; /* of items in the hash table   */
+%};
+%typedef struct nis_hash_data NIS_HASH_ITEM;
+%
+%struct nis_hash_table {
+%	NIS_HASH_ITEM	*keys[64];	/* A hash table of items           */
+%	NIS_HASH_ITEM	*first;		/* The first "item" in serial list */
+%};
+%typedef struct nis_hash_table NIS_HASH_TABLE;
+%
+%/* Structure for storing dynamically allocated static data */
+%struct nis_sdata {
+%	void	*buf;	/* Memory allocation pointer	*/
+%	u_int	size;	/* Buffer size			*/
+%};
+%
+%/* Generic client creating flags */
+%#define ZMH_VC		1
+%#define ZMH_DG		2
+%#define ZMH_AUTH	4
+%
+%/* Testing Access rights for objects */
+%
+%#define NIS_READ_ACC		1
+%#define NIS_MODIFY_ACC		2
+%#define NIS_CREATE_ACC		4
+%#define NIS_DESTROY_ACC	8
+%/* Test macros. a == access rights, m == desired rights. */
+%#define NIS_WORLD(a, m)	(((a) & (m)) != 0)
+%#define NIS_GROUP(a, m)	(((a) & ((m) << 8)) != 0)
+%#define NIS_OWNER(a, m)	(((a) & ((m) << 16)) != 0)
+%#define NIS_NOBODY(a, m)	(((a) & ((m) << 24)) != 0)
+%/*
+% * EOL Alert - The following non-prefixed test macros are
+% * here for backward compatability, and will be not be present
+% * in future releases - use the NIS_*() macros above.
+% */
+%#define WORLD(a, m)	(((a) & (m)) != 0)
+%#define GROUP(a, m)	(((a) & ((m) << 8)) != 0)
+%#define OWNER(a, m)	(((a) & ((m) << 16)) != 0)
+%#define NOBODY(a, m)	(((a) & ((m) << 24)) != 0)
+%
+%#define OATYPE(d, n) (((d)->do_armask.do_armask_val+n)->oa_otype)
+%#define OARIGHTS(d, n) (((d)->do_armask.do_armask_val+n)->oa_rights)
+%#define WORLD_DEFAULT (NIS_READ_ACC)
+%#define GROUP_DEFAULT (NIS_READ_ACC << 8)
+%#define OWNER_DEFAULT ((NIS_READ_ACC +\
+			 NIS_MODIFY_ACC +\
+			 NIS_CREATE_ACC +\
+			 NIS_DESTROY_ACC) << 16)
+%#define DEFAULT_RIGHTS (WORLD_DEFAULT | GROUP_DEFAULT | OWNER_DEFAULT)
+%
+%/* Result manipulation defines ... */
+%#define NIS_RES_NUMOBJ(x)	((x)->objects.objects_len)
+%#define NIS_RES_OBJECT(x)	((x)->objects.objects_val)
+%#define NIS_RES_COOKIE(x)	((x)->cookie)
+%#define NIS_RES_STATUS(x)	((x)->status)
+%
+%/* These defines make getting at the variant part of the object easier. */
+%#define TA_data zo_data.objdata_u.ta_data
+%#define EN_data zo_data.objdata_u.en_data
+%#define DI_data zo_data.objdata_u.di_data
+%#define LI_data zo_data.objdata_u.li_data
+%#define GR_data zo_data.objdata_u.gr_data
+%
+%#define __type_of(o) ((o)->zo_data.zo_type)
+%
+%/* Declarations for the internal subroutines in nislib.c */
+%enum name_pos {SAME_NAME, HIGHER_NAME, LOWER_NAME, NOT_SEQUENTIAL, BAD_NAME};
+%typedef enum name_pos name_pos;
+%
+%/*
+% * Defines for getting at column data in entry objects. Because RPCGEN
+% * generates some rather wordy structures, we create some defines that
+% * collapse the needed keystrokes to access a particular value using
+% * these definitions they take an nis_object *, and an int and return
+% * a u_char * for Value, and an int for length.
+% */
+%#define ENTRY_VAL(obj, col) \
+%	(obj)->EN_data.en_cols.en_cols_val[col].ec_value.ec_value_val
+%#define ENTRY_LEN(obj, col) \
+%	(obj)->EN_data.en_cols.en_cols_val[col].ec_value.ec_value_len
+%
+%
+%
+%#ifdef __cplusplus
+%}
+%#endif
+%
+%/* Prototypes, and extern declarations for the NIS library functions. */
+%#include <rpcsvc/nislib.h>
+%#endif /* __NIS_RPCGEN_H */
+%/* EDIT_START */
+%
+%/*
+% * nis_3.h
+% *
+% * This file contains definitions that are only of interest to the actual
+% * service daemon and client stubs. Normal users of NIS will not include
+% * this file.
+% *
+% * NOTE : This include file is automatically created by a combination
+% * of rpcgen and sed. DO NOT EDIT IT, change the nis.x file instead
+% * and then remake this file.
+% */
+%#ifndef __nis_3_h
+%#define __nis_3_h
+%#ifdef __cplusplus
+%extern "C" {
+%#endif
+#endif
diff --git a/include/rpcsvc/nis_callback.h b/include/rpcsvc/nis_callback.h
new file mode 100644
index 0000000..6f05728
--- /dev/null
+++ b/include/rpcsvc/nis_callback.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _RPCSVC_NIS_CALLBACK_H
+#define _RPCSVC_NIS_CALLBACK_H 1
+
+#include <rpc/rpc.h>
+#include <rpcsvc/nis.h>
+
+__BEGIN_DECLS
+
+typedef nis_object *obj_p;
+
+struct cback_data {
+	struct {
+		u_int entries_len;
+		obj_p *entries_val;
+	} entries;
+};
+typedef struct cback_data cback_data;
+
+#define CB_PROG 100302
+#define CB_VERS 1
+
+#define CBPROC_RECEIVE 1
+extern  bool_t * cbproc_receive_1 (cback_data *, CLIENT *) __THROW;
+extern  bool_t * cbproc_receive_1_svc (cback_data *, struct svc_req *) __THROW;
+
+#define CBPROC_FINISH 2
+extern  void * cbproc_finish_1 (void *, CLIENT *) __THROW;
+extern  void * cbproc_finish_1_svc (void *, struct svc_req *) __THROW;
+
+#define CBPROC_ERROR 3
+extern  void * cbproc_error_1 (nis_error *, CLIENT *) __THROW;
+extern  void * cbproc_error_1_svc (nis_error *, struct svc_req *) __THROW;
+extern int cb_prog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t) __THROW;
+
+/* the xdr functions */
+
+extern  bool_t xdr_obj_p (XDR *, obj_p*) __THROW;
+extern  bool_t xdr_cback_data (XDR *, cback_data*) __THROW;
+
+__END_DECLS
+
+#endif /* !_RPCVSC_NIS_CALLBACK_H */
diff --git a/include/rpcsvc/nis_callback.x b/include/rpcsvc/nis_callback.x
new file mode 100644
index 0000000..0fdca9e
--- /dev/null
+++ b/include/rpcsvc/nis_callback.x
@@ -0,0 +1,63 @@
+%/*
+% * Copyright (c) 2010, Oracle America, Inc.
+% *
+% * Redistribution and use in source and binary forms, with or without
+% * modification, are permitted provided that the following conditions are
+% * met:
+% *
+% *     * Redistributions of source code must retain the above copyright
+% *       notice, this list of conditions and the following disclaimer.
+% *     * Redistributions in binary form must reproduce the above
+% *       copyright notice, this list of conditions and the following
+% *       disclaimer in the documentation and/or other materials
+% *       provided with the distribution.
+% *     * Neither the name of the "Oracle America, Inc." nor the names of its
+% *       contributors may be used to endorse or promote products derived
+% *       from this software without specific prior written permission.
+% *
+% *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+% *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+% *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+% *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+% *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+% *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+% *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+% *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+% *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+% *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+% *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+% *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+% */
+
+/*
+ *	nis_callback.x
+ */
+
+%#pragma ident	"@(#)nis_callback.x	1.7	94/05/03"
+
+/*
+ * "@(#)zns_cback.x 1.2 90/09/10"
+ *
+ * RPCL description of the Callback Service.
+ */
+
+#ifdef RPC_HDR
+%#include <rpcsvc/nis.h>
+#endif
+#ifdef RPC_XDR
+%#include "nis_clnt.h"
+#endif
+
+typedef nis_object	*obj_p;
+
+struct cback_data {
+	obj_p		entries<>;	/* List of objects */
+};
+
+program CB_PROG {
+	version CB_VERS {
+		bool	CBPROC_RECEIVE(cback_data) = 1;
+		void	CBPROC_FINISH(void) = 2;
+		void	CBPROC_ERROR(nis_error) = 3;
+	} = 1;
+} = 100302;
diff --git a/include/rpcsvc/nis_object.x b/include/rpcsvc/nis_object.x
new file mode 100644
index 0000000..774b38f
--- /dev/null
+++ b/include/rpcsvc/nis_object.x
@@ -0,0 +1,328 @@
+/*
+ *	nis_object.x
+ *
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+%#pragma ident	"@(#)nis_object.x	1.12	97/11/19"
+
+#if RPC_HDR
+%
+%#ifndef __nis_object_h
+%#define __nis_object_h
+%
+#endif
+/*
+ *	This file defines the format for a NIS object in RPC language.
+ * It is included by the main .x file and the database access protocol
+ * file. It is common because both of them need to deal with the same
+ * type of object. Generating the actual code though is a bit messy because
+ * the nis.x file and the nis_dba.x file will generate xdr routines to
+ * encode/decode objects when only one set is needed. Such is life when
+ * one is using rpcgen.
+ *
+ * Note, the protocol doesn't specify any limits on such things as
+ * maximum name length, number of attributes, etc. These are enforced
+ * by the database backend. When you hit them you will no. Also see
+ * the db_getlimits() function for fetching the limit values.
+ *
+ */
+
+/* Some manifest constants, chosen to maximize flexibility without
+ * plugging the wire full of data.
+ */
+const NIS_MAXSTRINGLEN = 255;
+const NIS_MAXNAMELEN   = 1024;
+const NIS_MAXATTRNAME  = 32;
+const NIS_MAXATTRVAL   = 2048;
+const NIS_MAXCOLUMNS   = 64;
+const NIS_MAXATTR      = 16;
+const NIS_MAXPATH      = 1024;
+const NIS_MAXREPLICAS  = 128;
+const NIS_MAXLINKS     = 16;
+
+const NIS_PK_NONE      = 0;	/* no public key (unix/sys auth) */
+const NIS_PK_DH	       = 1;	/* Public key is Diffie-Hellman type */
+const NIS_PK_RSA       = 2;	/* Public key if RSA type */
+const NIS_PK_KERB      = 3;	/* Use kerberos style authentication */
+const NIS_PK_DHEXT     = 4;	/* Extended Diffie-Hellman for RPC-GSS */
+
+/*
+ * The fundamental name type of NIS. The name may consist of two parts,
+ * the first being the fully qualified name, and the second being an
+ * optional set of attribute/value pairs.
+ */
+struct nis_attr {
+	string	zattr_ndx<>;	/* name of the index		*/
+	opaque	zattr_val<>;	/* Value for the attribute.	*/
+};
+
+typedef string nis_name<>;	/* The NIS name itself. */
+
+/* NIS object types are defined by the following enumeration. The numbers
+ * they use are based on the following scheme :
+ *		     0 - 1023 are reserved for Sun,
+ *		1024 - 2047 are defined to be private to a particular tree.
+ *		2048 - 4095 are defined to be user defined.
+ *		4096 - ...  are reserved for future use.
+ *
+ * EOL Alert - The non-prefixed names are present for backward
+ * compatability only, and will not exist in future releases. Use
+ * the NIS_* names for future compatability.
+ */
+
+enum zotypes {
+
+	BOGUS_OBJ	= 0,	/* Uninitialized object structure	*/
+	NO_OBJ		= 1,	/* NULL object (no data)		*/
+	DIRECTORY_OBJ	= 2,	/* Directory object describing domain	*/
+	GROUP_OBJ	= 3,	/* Group object (a list of names)	*/
+	TABLE_OBJ	= 4,	/* Table object (a database schema)	*/
+	ENTRY_OBJ	= 5,	/* Entry object (a database record)	*/
+	LINK_OBJ	= 6,	/* A name link.				*/
+	PRIVATE_OBJ	= 7,	/* Private object (all opaque data)	*/
+
+	NIS_BOGUS_OBJ	= 0,	/* Uninitialized object structure	*/
+	NIS_NO_OBJ	= 1,	/* NULL object (no data)		*/
+	NIS_DIRECTORY_OBJ = 2, /* Directory object describing domain	*/
+	NIS_GROUP_OBJ	= 3,	/* Group object (a list of names)	*/
+	NIS_TABLE_OBJ	= 4,	/* Table object (a database schema)	*/
+	NIS_ENTRY_OBJ	= 5,	/* Entry object (a database record)	*/
+	NIS_LINK_OBJ	= 6,	/* A name link.				*/
+	NIS_PRIVATE_OBJ  = 7 /* Private object (all opaque data) */
+};
+
+/*
+ * The types of Name services NIS knows about. They are enumerated
+ * here. The Binder code will use this type to determine if it has
+ * a set of library routines that will access the indicated name service.
+ */
+enum nstype {
+	UNKNOWN = 0,
+	NIS = 1,	/* Nis Plus Service		*/
+	SUNYP = 2,	/* Old NIS Service		*/
+	IVY = 3,	/* Nis Plus Plus Service	*/
+	DNS = 4,	/* Domain Name Service		*/
+	X500 = 5,	/* ISO/CCCIT X.500 Service	*/
+	DNANS = 6,	/* Digital DECNet Name Service	*/
+	XCHS = 7,	/* Xerox ClearingHouse Service	*/
+	CDS= 8
+};
+
+/*
+ * DIRECTORY - The name service object. These objects identify other name
+ * servers that are serving some portion of the name space. Each has a
+ * type associated with it. The resolver library will note whether or not
+ * is has the needed routines to access that type of service.
+ * The oarmask structure defines an access rights mask on a per object
+ * type basis for the name spaces. The only bits currently used are
+ * create and destroy. By enabling or disabling these access rights for
+ * a specific object type for a one of the accessor entities (owner,
+ * group, world) the administrator can control what types of objects
+ * may be freely added to the name space and which require the
+ * administrator's approval.
+ */
+struct oar_mask {
+	uint32_t	oa_rights;	/* Access rights mask	*/
+	zotypes		oa_otype;	/* Object type		*/
+};
+
+struct endpoint {
+	string		uaddr<>;
+	string		family<>;   /* Transport family (INET, OSI, etc) */
+	string		proto<>;    /* Protocol (TCP, UDP, CLNP,  etc)   */
+};
+
+/*
+ * Note: pkey is a netobj which is limited to 1024 bytes which limits the
+ * keysize to 8192 bits. This is consider to be a reasonable limit for
+ * the expected lifetime of this service.
+ */
+struct nis_server {
+	nis_name	name;		/* Principal name of the server  */
+	endpoint	ep<>;		/* Universal addr(s) for server  */
+	uint32_t	key_type;	/* Public key type		 */
+	netobj		pkey;		/* server's public key		 */
+};
+
+struct directory_obj {
+	nis_name   do_name;	 /* Name of the directory being served   */
+	nstype	   do_type;	 /* one of NIS, DNS, IVY, YP, or X.500	 */
+	nis_server do_servers<>; /* <0> == Primary name server		 */
+	uint32_t   do_ttl;	 /* Time To Live (for caches)		 */
+	oar_mask   do_armask<>;  /* Create/Destroy rights by object type */
+};
+
+/*
+ * ENTRY - This is one row of data from an information base.
+ * The type value is used by the client library to convert the entry to
+ * it's internal structure representation. The Table name is a back pointer
+ * to the table where the entry is stored. This allows the client library
+ * to determine where to send a request if the client wishes to change this
+ * entry but got to it through a LINK rather than directly.
+ * If the entry is a "standalone" entry then this field is void.
+ */
+const EN_BINARY   = 1;	/* Indicates value is binary data	*/
+const EN_CRYPT    = 2;	/* Indicates the value is encrypted	*/
+const EN_XDR      = 4;	/* Indicates the value is XDR encoded	*/
+const EN_MODIFIED = 8;	/* Indicates entry is modified.	*/
+const EN_ASN1     = 64;	/* Means contents use ASN.1 encoding    */
+
+struct entry_col {
+	uint32_t	ec_flags;	/* Flags for this value */
+	opaque		ec_value<>;	/* It's textual value	*/
+};
+
+struct entry_obj {
+	string	en_type<>;	/* Type of entry such as "passwd" */
+	entry_col en_cols<>;	/* Value for the entry		  */
+};
+
+/*
+ * GROUP - The group object contains a list of NIS principal names. Groups
+ * are used to authorize principals. Each object has a set of access rights
+ * for members of its group. Principal names in groups are in the form
+ * name.directory and recursive groups are expressed as @groupname.directory
+ */
+struct group_obj {
+	uint32_t	gr_flags;	/* Flags controlling group	*/
+	nis_name	gr_members<>;	/* List of names in group	*/
+};
+
+/*
+ * LINK - This is the LINK object. It is quite similar to a symbolic link
+ * in the UNIX filesystem. The attributes in the main object structure are
+ * relative to the LINK data and not what it points to (like the file system)
+ * "modify" privleges here indicate the right to modify what the link points
+ * at and not to modify that actual object pointed to by the link.
+ */
+struct link_obj {
+	zotypes	 li_rtype;	/* Real type of the object	*/
+	nis_attr li_attrs<>;	/* Attribute/Values for tables	*/
+	nis_name li_name;	/* The object's real NIS name	*/
+};
+
+/*
+ * TABLE - This is the table object. It implements a simple
+ * data base that applications and use for configuration or
+ * administration purposes. The role of the table is to group together
+ * a set of related entries. Tables are the simple database component
+ * of NIS. Like many databases, tables are logically divided into columns
+ * and rows. The columns are labeled with indexes and each ENTRY makes
+ * up a row. Rows may be addressed within the table by selecting one
+ * or more indexes, and values for those indexes. Each row which has
+ * a value for the given index that matches the desired value is returned.
+ * Within the definition of each column there is a flags variable, this
+ * variable contains flags which determine whether or not the column is
+ * searchable, contains binary data, and access rights for the entry objects
+ * column value.
+ */
+
+const TA_BINARY     = 1;	/* Means table data is binary		*/
+const TA_CRYPT      = 2;	/* Means value should be encrypted	*/
+const TA_XDR        = 4;	/* Means value is XDR encoded		*/
+const TA_SEARCHABLE = 8;	/* Means this column is searchable	*/
+const TA_CASE       = 16;	/* Means this column is Case Sensitive	*/
+const TA_MODIFIED   = 32;	/* Means this columns attrs are modified*/
+const TA_ASN1       = 64;	/* Means contents use ASN.1 encoding     */
+
+struct table_col {
+	string		tc_name<64>;	/* Column Name		   */
+	uint32_t	tc_flags;	/* control flags	   */
+	uint32_t	tc_rights;	/* Access rights mask	   */
+};
+
+struct table_obj {
+	string	  ta_type<64>;	 /* Table type such as "passwd"	*/
+	int	  ta_maxcol;	 /* Total number of columns	*/
+	u_char	  ta_sep;	 /* Separator character		*/
+	table_col ta_cols<>;	 /* The number of table indexes */
+	string	  ta_path<>;	 /* A search path for this table */
+};
+
+/*
+ * This union joins together all of the currently known objects.
+ */
+union objdata switch (zotypes zo_type) {
+	case NIS_DIRECTORY_OBJ :
+		struct directory_obj di_data;
+	case NIS_GROUP_OBJ :
+		struct group_obj gr_data;
+	case NIS_TABLE_OBJ :
+		struct table_obj ta_data;
+	case NIS_ENTRY_OBJ:
+		struct entry_obj en_data;
+	case NIS_LINK_OBJ :
+		struct link_obj li_data;
+	case NIS_PRIVATE_OBJ :
+		opaque	po_data<>;
+	case NIS_NO_OBJ :
+		void;
+	case NIS_BOGUS_OBJ :
+		void;
+	default :
+		void;
+};
+
+/*
+ * This is the basic NIS object data type. It consists of a generic part
+ * which all objects contain, and a specialized part which varies depending
+ * on the type of the object. All of the specialized sections have been
+ * described above. You might have wondered why they all start with an
+ * integer size, followed by the useful data. The answer is, when the
+ * server doesn't recognize the type returned it treats it as opaque data.
+ * And the definition for opaque data is {int size; char *data;}. In this
+ * way, servers and utility routines that do not understand a given type
+ * may still pass it around. One has to be careful in setting
+ * this variable accurately, it must take into account such things as
+ * XDR padding of structures etc. The best way to set it is to note one's
+ * position in the XDR encoding stream, encode the structure, look at the
+ * new position and calculate the size.
+ */
+struct nis_oid {
+	uint32_t ctime;		/* Time of objects creation	*/
+	uint32_t mtime;		/* Time of objects modification */
+};
+
+struct nis_object {
+	nis_oid	 zo_oid;	/* object identity verifier.		*/
+	nis_name zo_name;	/* The NIS name for this object		*/
+	nis_name zo_owner;	/* NIS name of object owner.		*/
+	nis_name zo_group;	/* NIS name of access group.		*/
+	nis_name zo_domain;	/* The administrator for the object	*/
+	uint32_t zo_access;	/* Access rights (owner, group, world)	*/
+	uint32_t zo_ttl;	/* Object's time to live in seconds.	*/
+	objdata	 zo_data;	/* Data structure for this type		*/
+};
+#if RPC_HDR
+%
+%#endif /* if __nis_object_h */
+%
+#endif
diff --git a/include/rpcsvc/nis_tags.h b/include/rpcsvc/nis_tags.h
new file mode 100644
index 0000000..c2dc7fd
--- /dev/null
+++ b/include/rpcsvc/nis_tags.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *	nis_tags.h
+ *
+ *	This file contains the tags and statistics definitions. It is
+ *	automatically included by nis.h
+ */
+
+#ifndef	_RPCSVC_NIS_TAGS_H
+#define	_RPCSVC_NIS_TAGS_H
+
+#if 0
+#pragma ident	"@(#)nis_tags.h	1.16	96/10/25"
+#endif
+/* from file: zns_tags.h	1.7 */
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+
+#define	NIS_DIR	"data"
+
+/* Lookup and List function flags */
+#define	FOLLOW_LINKS	(1<<0)	/* Follow link objects			*/
+#define	FOLLOW_PATH	(1<<1)	/* Follow the path in a table		*/
+#define	HARD_LOOKUP	(1<<2)	/* Block until successful		*/
+#define	ALL_RESULTS	(1<<3)	/* Retrieve all results			*/
+#define	NO_CACHE	(1<<4)	/* Do not return 'cached' results	*/
+#define	MASTER_ONLY	(1<<5)	/* Get value only from master server	*/
+#define	EXPAND_NAME	(1<<6)	/* Expand partitially qualified names	*/
+
+/* Semantic modification for table operations flags */
+#define	RETURN_RESULT	(1<<7)	/* Return resulting object to client    */
+#define	ADD_OVERWRITE	(1<<8)	/* Allow overwrites on ADD		*/
+#define	REM_MULTIPLE	(1<<9)	/* Allow wildcard deletes		*/
+#define	MOD_SAMEOBJ	(1<<10)	/* Check modified object before write	*/
+#define	ADD_RESERVED	(1<<11)	/* Spare ADD semantic			*/
+#define	REM_RESERVED	(1<<12)	/* Spare REM semantic			*/
+#define	MOD_EXCLUSIVE	(1<<13)	/* Modify no overwrite on modified keys */
+
+/* Lookup and List function flags (continued) */
+#define	SOFT_LOOKUP	(1<<14)	/* The "old default" return on failure  */
+
+/* Transport specific modifications to the operation */
+#define	USE_DGRAM	(1<<16) /* Use a datagram transport		*/
+#define	NO_AUTHINFO	(1<<17) /* Don't bother attaching auth info	*/
+
+/*
+ * Declarations for "standard" NIS+ tags
+ * State variable tags have values	0 - 2047
+ * Statistic tags have values		2048 - 65535
+ * User Tags have values		>2^16
+ */
+#define	TAG_DEBUG	1	/* set debug level		*/
+#define	TAG_STATS	2	/* Enable/disable statistics	*/
+#define	TAG_GCACHE	3	/* Flush the Group Cache	*/
+#define	TAG_GCACHE_ALL	TAG_GCACHE
+#define	TAG_DCACHE	4	/* Flush the directory cache	*/
+#define	TAG_DCACHE_ONE	TAG_DCACHE
+#define	TAG_OCACHE	5	/* Flush the Object Cache	*/
+#define	TAG_SECURE	6	/* Set the security level	*/
+#define	TAG_TCACHE_ONE	7	/* Flush the table cache	*/
+#define	TAG_DCACHE_ALL	8	/* Flush entire directory cache	*/
+#define	TAG_TCACHE_ALL	9	/* Flush entire table cache	*/
+#define	TAG_GCACHE_ONE	10	/* Flush one group object	*/
+#define	TAG_DCACHE_ONE_REFRESH 11 /* Flush and refresh one DO	*/
+#define	TAG_READONLY	12	/* Set read only mode		*/
+#define	TAG_READWRITE	14	/* Reset read-write mode	*/
+
+#define	TAG_OPSTATS	2048	/* NIS+ operations statistics   */
+#define	TAG_THREADS	2049	/* Child process/thread status  */
+#define	TAG_HEAP	2050	/* Heap usage statistics	*/
+#define	TAG_UPDATES	2051	/* Updates to this service	*/
+#define	TAG_VISIBLE	2052	/* First update that isn't replicated */
+#define	TAG_S_DCACHE	2053	/* Directory cache statistics	*/
+#define	TAG_S_OCACHE	2054	/* Object cache statistics	*/
+#define	TAG_S_GCACHE	2055	/* Group cache statistics	*/
+#define	TAG_S_STORAGE	2056	/* Group cache statistics	*/
+#define	TAG_UPTIME	2057	/* Time that server has been up */
+#define	TAG_DIRLIST	2058	/* Dir served by this server    */
+#define	TAG_NISCOMPAT	2059	/* Whether supports NIS compat mode */
+#define	TAG_DNSFORWARDING 2060	/* Whether DNS forwarding supported */
+#define	TAG_SECURITY_LEVEL 2061	/* Security level of the server	*/
+#define	TAG_ROOTSERVER	2062	/* Whether root server		*/
+
+/*
+ * Declarations for the Group object flags. Currently
+ * there are only 3.
+ */
+#define	IMPMEM_GROUPS  1	/* Implicit Membership allowed	*/
+#define	RECURS_GROUPS  2	/* Recursive Groups allowed	*/
+#define	NEGMEM_GROUPS  4	/* Negative Groups allowed	*/
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _RPCSVC_NIS_TAGS_H */
diff --git a/include/rpcsvc/nislib.h b/include/rpcsvc/nislib.h
new file mode 100644
index 0000000..3c6c33f
--- /dev/null
+++ b/include/rpcsvc/nislib.h
@@ -0,0 +1,286 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Thorsten Kukuk <kukuk@suse.de>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	__RPCSVC_NISLIB_H__
+#define	__RPCSVC_NISLIB_H__
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+typedef const char *const_nis_name;
+
+/* nis_names: These functions are used to locate and manipulate all NIS+
+ * objects except the NIS+ entry objects.
+ *
+ * nis_lookup (name, flags) resolves a NIS+ name and returns a copy of
+ *                          that object  from a NIS+ server.
+ *    const nis_name name: name of the object to be resolved
+ *    unsigned int flags: logically ORing zero or more flags (FOLLOW_LINKS,
+ *                          HARD_LOOKUP, [NO_CACHE], MASTER_ONLY, EXPAND_NAME)
+ *
+ * nis_add (name, obj) adds objects to the NIS+ namespace.
+ *    const nis_name name: fully qualified NIS+ name.
+ *    const nis_object *obj: object members zo_name and zo_domain will be
+ *                           constructed from name.
+ *
+ * nis_remove (name, obj) removes objects from the NIS+ namespace.
+ *    const nis_name name: fully qualified NIS+ name.
+ *    const nis_object *obj: if not NULL, it is assumed to point to a copy
+ *                           of the object being removed. In this case, if
+ *                           the object on the server does not have the same
+ *                           object identifier as the  object  being  passed,
+ *                           the operation will fail with the NIS_NOTSAMEOBJ
+ *                           error.
+ *
+ * nis_modify (name, obj) can change specific attributes of an object
+ *                        that already exists in the namespace.
+ */
+extern nis_result *nis_lookup (const_nis_name name, unsigned int flags)
+     __THROW;
+extern nis_result *nis_add (const_nis_name name, const nis_object *obj)
+     __THROW;
+extern nis_result *nis_remove (const_nis_name name,
+			       const nis_object *obj) __THROW;
+extern nis_result *nis_modify (const_nis_name name,
+			       const nis_object *obj) __THROW;
+
+/* nis_tables: These functions are used to search and modify NIS+ tables.
+ *
+ * nis_list (table_name, flags, callback(table_name, obj, userdata), userdata)
+ *           search a table in the NIS+ namespace.
+ *    const nis_name table_name: indexed name ([xx=yy],table.dir)
+ *    unsigned int flags: logically ORing one or more flags (FOLLOW_LINKS,
+ *                      [FOLLOW_PATH], HARD_LOOKUP, [ALL_RESULTS], [NO_CACHE],
+ *                      MASTER_ONLY, EXPAND_NAME, RETURN_RESULT)
+ *    callback(): callback is an optional pointer to a function that will
+ *                process the ENTRY type objects that are returned from the
+ *                search. If this pointer is NULL, then all entries that match
+ *                the search criteria are returned in the nis_result structure,
+ *                otherwise  this  function  will  be  called once for each
+ *                entry returned.
+ *    void *userdata: passed to callback function along with the returned
+ *                    entry object.
+ *
+ * nis_add_entry (table_name, obj, flags) will add the NIS+ object to the
+ *                                        NIS+ table_name.
+ *    const nis_name table_name
+ *    const nis_object *obj
+ *    unsigned int flags: 0, ADD_OVERWRITE, RETURN_RESULT
+ *
+ * nis_modify_entry (name, obj, flags) modifies an object identified by name.
+ *    const nis_name name: object identifier
+ *    const nis_object *obj: should point to an entry with the EN_MODIFIED
+ *                           flag set in each column that contains new
+ *                           information.
+ *    unsigned int flags: 0, MOD_SAMEOBJ, RETURN_RESULT
+ *
+ * nis_remove_entry (table_name, obj, flags) removes a set of entries
+ *                                 identified by table_name from the table.
+ *    const nis_name table_name: indexed NIS+ name
+ *    const nis_object *obj: if obj is non-null, it is presumed to point to
+ *                           a cached copy of the entry. When the removal is
+ *                           attempted, and the object that would be removed
+ *                           is not the same as the cached object pointed to
+ *                           by object then the operation will fail with an
+ *                           NIS_NOTSAMEOBJ error
+ *    unsigned int flags: 0, REM_MULTIPLE
+ *
+ * nis_first_entry (table_name) fetches entries from a table one at a time.
+ *    const nis_name table_name
+ *
+ * nis_next_entry (table_name, cookie) retrieves the "next" entry from a
+ *                                     table specified by table_name.
+ *    const nis_name table_name:
+ *    const netobj *cookie: The value of cookie from the nis_result structure
+ *                          form the previous call.
+ */
+extern nis_result *nis_list (const_nis_name __name, unsigned int __flags,
+			     int (*__callback)(const_nis_name __table_name,
+					       const nis_object *__obj,
+					       const void *__userdata),
+			     const void *__userdata) __THROW;
+extern nis_result *nis_add_entry (const_nis_name __table_name,
+				  const nis_object *__obj,
+				  unsigned int __flags) __THROW;
+extern nis_result *nis_modify_entry (const_nis_name __name,
+				     const nis_object *__obj,
+				     unsigned int __flags) __THROW;
+extern nis_result *nis_remove_entry (const_nis_name __table_name,
+				     const nis_object *__obj,
+				     unsigned int __flags) __THROW;
+extern nis_result *nis_first_entry (const_nis_name __table_name) __THROW;
+extern nis_result *nis_next_entry (const_nis_name __table_name,
+				   const netobj *__cookie) __THROW;
+/*
+** nis_server
+*/
+extern nis_error nis_mkdir (const_nis_name __dirname,
+			    const nis_server *__machine) __THROW;
+extern nis_error nis_rmdir (const_nis_name __dirname,
+			    const nis_server *__machine) __THROW;
+extern nis_error nis_servstate (const nis_server *__machine,
+				const nis_tag *__tags, int __numtags,
+				nis_tag **__result) __THROW;
+extern nis_error nis_stats (const nis_server *__machine,
+			    const nis_tag *__tags, int __numtags,
+			    nis_tag **__result) __THROW;
+extern void nis_freetags (nis_tag *__tags, int __numtags) __THROW;
+extern nis_server **nis_getservlist (const_nis_name __dirname) __THROW;
+extern void nis_freeservlist (nis_server **__machines) __THROW;
+
+/*
+** nis_subr
+*/
+extern nis_name nis_leaf_of (const_nis_name __name) __THROW;
+extern nis_name nis_leaf_of_r (const_nis_name __name, char *__buffer,
+			       size_t __buflen) __THROW;
+extern nis_name nis_name_of (const_nis_name __name) __THROW;
+extern nis_name nis_name_of_r (const_nis_name __name, char *__buffer,
+			       size_t __buflen) __THROW;
+extern nis_name nis_domain_of (const_nis_name __name) __THROW;
+extern nis_name nis_domain_of_r (const_nis_name __name, char *__buffer,
+				 size_t __buflen) __THROW;
+extern nis_name *nis_getnames (const_nis_name __name) __THROW;
+extern void nis_freenames (nis_name *__namelist) __THROW;
+extern name_pos nis_dir_cmp (const_nis_name __n1, const_nis_name __n2) __THROW;
+extern nis_object *nis_clone_object (const nis_object *__src,
+				     nis_object *__dest) __THROW;
+extern void nis_destroy_object (nis_object *__obj) __THROW;
+extern void nis_print_object (const nis_object *__obj) __THROW;
+
+/*
+** nis_local_names
+*/
+extern nis_name nis_local_group (void) __THROW;
+extern nis_name nis_local_directory (void) __THROW;
+extern nis_name nis_local_principal (void) __THROW;
+extern nis_name nis_local_host (void) __THROW;
+
+/*
+** nis_error
+*/
+extern const char *nis_sperrno (const nis_error __status) __THROW;
+extern void nis_perror (const nis_error __status, const char *__label) __THROW;
+extern void nis_lerror (const nis_error __status, const char *__label) __THROW;
+extern char *nis_sperror (const nis_error status, const char *__label) __THROW;
+extern char *nis_sperror_r (const nis_error __status, const char *__label,
+			    char *__buffer, size_t __buflen) __THROW;
+/*
+** nis_groups
+*/
+extern bool_t nis_ismember (const_nis_name __principal,
+			    const_nis_name __group) __THROW;
+extern nis_error nis_addmember (const_nis_name __member,
+				const_nis_name __group) __THROW;
+extern nis_error nis_removemember (const_nis_name __member,
+				   const_nis_name __group) __THROW;
+extern nis_error nis_creategroup (const_nis_name __group,
+				  unsigned int __flags) __THROW;
+extern nis_error nis_destroygroup (const_nis_name __group) __THROW;
+extern void nis_print_group_entry (const_nis_name __group) __THROW;
+extern nis_error nis_verifygroup (const_nis_name __group) __THROW;
+
+/*
+** nis_ping
+*/
+extern void nis_ping (const_nis_name __dirname, uint32_t __utime,
+		      const nis_object *__dirobj) __THROW;
+extern nis_result *nis_checkpoint (const_nis_name __dirname) __THROW;
+
+/*
+** nis_print (XXX INTERNAL FUNCTIONS, SHOULD NOT BE USED !!)
+*/
+extern void nis_print_result (const nis_result *__result) __THROW;
+extern void nis_print_rights (unsigned int __rights) __THROW;
+extern void nis_print_directory (const directory_obj *__dirobj) __THROW;
+extern void nis_print_group (const group_obj *__grpobj) __THROW;
+extern void nis_print_table (const table_obj *__tblobj) __THROW;
+extern void nis_print_link (const link_obj *__lnkobj) __THROW;
+extern void nis_print_entry (const entry_obj *__enobj) __THROW;
+
+/*
+** nis_file (XXX INTERNAL FUNCTIONS, SHOULD NOT BE USED !!)
+*/
+extern directory_obj *readColdStartFile (void) __THROW;
+extern bool_t writeColdStartFile (const directory_obj *__dirobj) __THROW;
+extern nis_object *nis_read_obj (const char *__obj) __THROW;
+extern bool_t nis_write_obj (const char *__file, const nis_object *__obj) __THROW;
+
+/*
+** nis_clone - (XXX INTERNAL FUNCTIONS, SHOULD NOT BE USED !!)
+*/
+extern directory_obj *nis_clone_directory (const directory_obj *__src,
+					   directory_obj *__dest) __THROW;
+extern nis_result *nis_clone_result (const nis_result *__src,
+				     nis_result *__dest) __THROW;
+
+/* nis_free - nis_freeresult */
+extern void nis_freeresult (nis_result *__result) __THROW;
+/* (XXX THE FOLLOWING ARE INTERNAL FUNCTIONS, SHOULD NOT BE USED !!) */
+extern void nis_free_request (ib_request *__req) __THROW;
+extern void nis_free_directory (directory_obj *__dirobj) __THROW;
+extern void nis_free_object (nis_object *__obj) __THROW;
+
+/* (XXX INTERNAL FUNCTIONS, SHOULD NOT BE USED !!) */
+extern nis_name __nis_default_owner (char *) __THROW;
+extern nis_name __nis_default_group (char *) __THROW;
+extern uint32_t __nis_default_ttl (char *) __THROW;
+extern unsigned int __nis_default_access (char *, unsigned int) __THROW;
+extern fd_result *__nis_finddirectory (directory_obj *, const_nis_name) __THROW;
+extern void __free_fdresult (fd_result *) __THROW;
+extern uint32_t __nis_hash (const void *__keyarg, size_t __len) __THROW;
+
+/* NIS+ cache locking */
+extern int __nis_lock_cache (void) __THROW;
+extern int __nis_unlock_cache (void) __THROW;
+
+/* (XXX INTERNAL FUNCTIONS, ONLY FOR rpc.nisd AND glibc !!) */
+#if defined (NIS_INTERNAL) || defined (_LIBC)
+
+struct dir_binding
+{
+  CLIENT *clnt;                  /* RPC CLIENT handle */
+  nis_server *server_val;        /* List of servers */
+  unsigned int server_len;       /* # of servers */
+  unsigned int server_used;      /* Which server we are bind in the moment ? */
+  unsigned int current_ep;       /* Which endpoint of the server are in use? */
+  unsigned int trys;             /* How many server have we tried ? */
+  unsigned int class;            /* From which class is server_val ? */
+  bool_t master_only;            /* Is only binded to the master */
+  bool_t use_auth;               /* Do we use AUTH ? */
+  bool_t use_udp;                /* Do we use UDP ? */
+  struct sockaddr_in addr;       /* Server's IP address */
+  int socket;                    /* Server's local socket */
+};
+typedef struct dir_binding dir_binding;
+
+extern nis_error __nisbind_create (dir_binding *, const nis_server *,
+				   unsigned int, unsigned int, unsigned int,
+				   unsigned int) __THROW;
+extern nis_error __nisbind_connect (dir_binding *) __THROW;
+extern nis_error __nisbind_next (dir_binding *) __THROW;
+extern void __nisbind_destroy (dir_binding *) __THROW;
+extern nis_error __nisfind_server (const_nis_name, int, directory_obj **,
+				   dir_binding *, unsigned int) __THROW;
+
+#endif
+
+__END_DECLS
+
+#endif	/* __RPCSVC_NISLIB_H__ */
diff --git a/include/rpcsvc/nlm_prot.h b/include/rpcsvc/nlm_prot.h
new file mode 100644
index 0000000..5420a6c
--- /dev/null
+++ b/include/rpcsvc/nlm_prot.h
@@ -0,0 +1,330 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _NLM_PROT_H_RPCGEN
+#define _NLM_PROT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LM_MAXSTRLEN 1024
+#define MAXNAMELEN LM_MAXSTRLEN+1
+
+enum nlm_stats {
+	nlm_granted = 0,
+	nlm_denied = 1,
+	nlm_denied_nolocks = 2,
+	nlm_blocked = 3,
+	nlm_denied_grace_period = 4,
+};
+typedef enum nlm_stats nlm_stats;
+
+struct nlm_holder {
+	bool_t exclusive;
+	int svid;
+	netobj oh;
+	u_int l_offset;
+	u_int l_len;
+};
+typedef struct nlm_holder nlm_holder;
+
+struct nlm_testrply {
+	nlm_stats stat;
+	union {
+		struct nlm_holder holder;
+	} nlm_testrply_u;
+};
+typedef struct nlm_testrply nlm_testrply;
+
+struct nlm_stat {
+	nlm_stats stat;
+};
+typedef struct nlm_stat nlm_stat;
+
+struct nlm_res {
+	netobj cookie;
+	nlm_stat stat;
+};
+typedef struct nlm_res nlm_res;
+
+struct nlm_testres {
+	netobj cookie;
+	nlm_testrply stat;
+};
+typedef struct nlm_testres nlm_testres;
+
+struct nlm_lock {
+	char *caller_name;
+	netobj fh;
+	netobj oh;
+	int svid;
+	u_int l_offset;
+	u_int l_len;
+};
+typedef struct nlm_lock nlm_lock;
+
+struct nlm_lockargs {
+	netobj cookie;
+	bool_t block;
+	bool_t exclusive;
+	struct nlm_lock alock;
+	bool_t reclaim;
+	int state;
+};
+typedef struct nlm_lockargs nlm_lockargs;
+
+struct nlm_cancargs {
+	netobj cookie;
+	bool_t block;
+	bool_t exclusive;
+	struct nlm_lock alock;
+};
+typedef struct nlm_cancargs nlm_cancargs;
+
+struct nlm_testargs {
+	netobj cookie;
+	bool_t exclusive;
+	struct nlm_lock alock;
+};
+typedef struct nlm_testargs nlm_testargs;
+
+struct nlm_unlockargs {
+	netobj cookie;
+	struct nlm_lock alock;
+};
+typedef struct nlm_unlockargs nlm_unlockargs;
+/*
+ * The following enums are actually bit encoded for efficient
+ * boolean algebra.... DON'T change them.....
+ */
+
+enum fsh_mode {
+	fsm_DN = 0,
+	fsm_DR = 1,
+	fsm_DW = 2,
+	fsm_DRW = 3,
+};
+typedef enum fsh_mode fsh_mode;
+
+enum fsh_access {
+	fsa_NONE = 0,
+	fsa_R = 1,
+	fsa_W = 2,
+	fsa_RW = 3,
+};
+typedef enum fsh_access fsh_access;
+
+struct nlm_share {
+	char *caller_name;
+	netobj fh;
+	netobj oh;
+	fsh_mode mode;
+	fsh_access access;
+};
+typedef struct nlm_share nlm_share;
+
+struct nlm_shareargs {
+	netobj cookie;
+	nlm_share share;
+	bool_t reclaim;
+};
+typedef struct nlm_shareargs nlm_shareargs;
+
+struct nlm_shareres {
+	netobj cookie;
+	nlm_stats stat;
+	int sequence;
+};
+typedef struct nlm_shareres nlm_shareres;
+
+struct nlm_notify {
+	char *name;
+	long state;
+};
+typedef struct nlm_notify nlm_notify;
+
+#define NLM_PROG 100021
+#define NLM_VERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define NLM_TEST 1
+extern  nlm_testres * nlm_test_1(struct nlm_testargs *, CLIENT *);
+extern  nlm_testres * nlm_test_1_svc(struct nlm_testargs *, struct svc_req *);
+#define NLM_LOCK 2
+extern  nlm_res * nlm_lock_1(struct nlm_lockargs *, CLIENT *);
+extern  nlm_res * nlm_lock_1_svc(struct nlm_lockargs *, struct svc_req *);
+#define NLM_CANCEL 3
+extern  nlm_res * nlm_cancel_1(struct nlm_cancargs *, CLIENT *);
+extern  nlm_res * nlm_cancel_1_svc(struct nlm_cancargs *, struct svc_req *);
+#define NLM_UNLOCK 4
+extern  nlm_res * nlm_unlock_1(struct nlm_unlockargs *, CLIENT *);
+extern  nlm_res * nlm_unlock_1_svc(struct nlm_unlockargs *, struct svc_req *);
+#define NLM_GRANTED 5
+extern  nlm_res * nlm_granted_1(struct nlm_testargs *, CLIENT *);
+extern  nlm_res * nlm_granted_1_svc(struct nlm_testargs *, struct svc_req *);
+#define NLM_TEST_MSG 6
+extern  void * nlm_test_msg_1(struct nlm_testargs *, CLIENT *);
+extern  void * nlm_test_msg_1_svc(struct nlm_testargs *, struct svc_req *);
+#define NLM_LOCK_MSG 7
+extern  void * nlm_lock_msg_1(struct nlm_lockargs *, CLIENT *);
+extern  void * nlm_lock_msg_1_svc(struct nlm_lockargs *, struct svc_req *);
+#define NLM_CANCEL_MSG 8
+extern  void * nlm_cancel_msg_1(struct nlm_cancargs *, CLIENT *);
+extern  void * nlm_cancel_msg_1_svc(struct nlm_cancargs *, struct svc_req *);
+#define NLM_UNLOCK_MSG 9
+extern  void * nlm_unlock_msg_1(struct nlm_unlockargs *, CLIENT *);
+extern  void * nlm_unlock_msg_1_svc(struct nlm_unlockargs *, struct svc_req *);
+#define NLM_GRANTED_MSG 10
+extern  void * nlm_granted_msg_1(struct nlm_testargs *, CLIENT *);
+extern  void * nlm_granted_msg_1_svc(struct nlm_testargs *, struct svc_req *);
+#define NLM_TEST_RES 11
+extern  void * nlm_test_res_1(nlm_testres *, CLIENT *);
+extern  void * nlm_test_res_1_svc(nlm_testres *, struct svc_req *);
+#define NLM_LOCK_RES 12
+extern  void * nlm_lock_res_1(nlm_res *, CLIENT *);
+extern  void * nlm_lock_res_1_svc(nlm_res *, struct svc_req *);
+#define NLM_CANCEL_RES 13
+extern  void * nlm_cancel_res_1(nlm_res *, CLIENT *);
+extern  void * nlm_cancel_res_1_svc(nlm_res *, struct svc_req *);
+#define NLM_UNLOCK_RES 14
+extern  void * nlm_unlock_res_1(nlm_res *, CLIENT *);
+extern  void * nlm_unlock_res_1_svc(nlm_res *, struct svc_req *);
+#define NLM_GRANTED_RES 15
+extern  void * nlm_granted_res_1(nlm_res *, CLIENT *);
+extern  void * nlm_granted_res_1_svc(nlm_res *, struct svc_req *);
+extern int nlm_prog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define NLM_TEST 1
+extern  nlm_testres * nlm_test_1();
+extern  nlm_testres * nlm_test_1_svc();
+#define NLM_LOCK 2
+extern  nlm_res * nlm_lock_1();
+extern  nlm_res * nlm_lock_1_svc();
+#define NLM_CANCEL 3
+extern  nlm_res * nlm_cancel_1();
+extern  nlm_res * nlm_cancel_1_svc();
+#define NLM_UNLOCK 4
+extern  nlm_res * nlm_unlock_1();
+extern  nlm_res * nlm_unlock_1_svc();
+#define NLM_GRANTED 5
+extern  nlm_res * nlm_granted_1();
+extern  nlm_res * nlm_granted_1_svc();
+#define NLM_TEST_MSG 6
+extern  void * nlm_test_msg_1();
+extern  void * nlm_test_msg_1_svc();
+#define NLM_LOCK_MSG 7
+extern  void * nlm_lock_msg_1();
+extern  void * nlm_lock_msg_1_svc();
+#define NLM_CANCEL_MSG 8
+extern  void * nlm_cancel_msg_1();
+extern  void * nlm_cancel_msg_1_svc();
+#define NLM_UNLOCK_MSG 9
+extern  void * nlm_unlock_msg_1();
+extern  void * nlm_unlock_msg_1_svc();
+#define NLM_GRANTED_MSG 10
+extern  void * nlm_granted_msg_1();
+extern  void * nlm_granted_msg_1_svc();
+#define NLM_TEST_RES 11
+extern  void * nlm_test_res_1();
+extern  void * nlm_test_res_1_svc();
+#define NLM_LOCK_RES 12
+extern  void * nlm_lock_res_1();
+extern  void * nlm_lock_res_1_svc();
+#define NLM_CANCEL_RES 13
+extern  void * nlm_cancel_res_1();
+extern  void * nlm_cancel_res_1_svc();
+#define NLM_UNLOCK_RES 14
+extern  void * nlm_unlock_res_1();
+extern  void * nlm_unlock_res_1_svc();
+#define NLM_GRANTED_RES 15
+extern  void * nlm_granted_res_1();
+extern  void * nlm_granted_res_1_svc();
+extern int nlm_prog_1_freeresult ();
+#endif /* K&R C */
+#define NLM_VERSX 3
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define NLM_SHARE 20
+extern  nlm_shareres * nlm_share_3(nlm_shareargs *, CLIENT *);
+extern  nlm_shareres * nlm_share_3_svc(nlm_shareargs *, struct svc_req *);
+#define NLM_UNSHARE 21
+extern  nlm_shareres * nlm_unshare_3(nlm_shareargs *, CLIENT *);
+extern  nlm_shareres * nlm_unshare_3_svc(nlm_shareargs *, struct svc_req *);
+#define NLM_NM_LOCK 22
+extern  nlm_res * nlm_nm_lock_3(nlm_lockargs *, CLIENT *);
+extern  nlm_res * nlm_nm_lock_3_svc(nlm_lockargs *, struct svc_req *);
+#define NLM_FREE_ALL 23
+extern  void * nlm_free_all_3(nlm_notify *, CLIENT *);
+extern  void * nlm_free_all_3_svc(nlm_notify *, struct svc_req *);
+extern int nlm_prog_3_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define NLM_SHARE 20
+extern  nlm_shareres * nlm_share_3();
+extern  nlm_shareres * nlm_share_3_svc();
+#define NLM_UNSHARE 21
+extern  nlm_shareres * nlm_unshare_3();
+extern  nlm_shareres * nlm_unshare_3_svc();
+#define NLM_NM_LOCK 22
+extern  nlm_res * nlm_nm_lock_3();
+extern  nlm_res * nlm_nm_lock_3_svc();
+#define NLM_FREE_ALL 23
+extern  void * nlm_free_all_3();
+extern  void * nlm_free_all_3_svc();
+extern int nlm_prog_3_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_nlm_stats (XDR *, nlm_stats*);
+extern  bool_t xdr_nlm_holder (XDR *, nlm_holder*);
+extern  bool_t xdr_nlm_testrply (XDR *, nlm_testrply*);
+extern  bool_t xdr_nlm_stat (XDR *, nlm_stat*);
+extern  bool_t xdr_nlm_res (XDR *, nlm_res*);
+extern  bool_t xdr_nlm_testres (XDR *, nlm_testres*);
+extern  bool_t xdr_nlm_lock (XDR *, nlm_lock*);
+extern  bool_t xdr_nlm_lockargs (XDR *, nlm_lockargs*);
+extern  bool_t xdr_nlm_cancargs (XDR *, nlm_cancargs*);
+extern  bool_t xdr_nlm_testargs (XDR *, nlm_testargs*);
+extern  bool_t xdr_nlm_unlockargs (XDR *, nlm_unlockargs*);
+extern  bool_t xdr_fsh_mode (XDR *, fsh_mode*);
+extern  bool_t xdr_fsh_access (XDR *, fsh_access*);
+extern  bool_t xdr_nlm_share (XDR *, nlm_share*);
+extern  bool_t xdr_nlm_shareargs (XDR *, nlm_shareargs*);
+extern  bool_t xdr_nlm_shareres (XDR *, nlm_shareres*);
+extern  bool_t xdr_nlm_notify (XDR *, nlm_notify*);
+
+#else /* K&R C */
+extern bool_t xdr_nlm_stats ();
+extern bool_t xdr_nlm_holder ();
+extern bool_t xdr_nlm_testrply ();
+extern bool_t xdr_nlm_stat ();
+extern bool_t xdr_nlm_res ();
+extern bool_t xdr_nlm_testres ();
+extern bool_t xdr_nlm_lock ();
+extern bool_t xdr_nlm_lockargs ();
+extern bool_t xdr_nlm_cancargs ();
+extern bool_t xdr_nlm_testargs ();
+extern bool_t xdr_nlm_unlockargs ();
+extern bool_t xdr_fsh_mode ();
+extern bool_t xdr_fsh_access ();
+extern bool_t xdr_nlm_share ();
+extern bool_t xdr_nlm_shareargs ();
+extern bool_t xdr_nlm_shareres ();
+extern bool_t xdr_nlm_notify ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_NLM_PROT_H_RPCGEN */
diff --git a/include/rpcsvc/nlm_prot.x b/include/rpcsvc/nlm_prot.x
new file mode 100644
index 0000000..81ff137
--- /dev/null
+++ b/include/rpcsvc/nlm_prot.x
@@ -0,0 +1,203 @@
+/* @(#)nlm_prot.x	2.1 88/08/01 4.0 RPCSRC */
+
+/*
+ * Network lock manager protocol definition
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * protocol used between local lock manager and remote lock manager
+ */
+
+#ifdef RPC_HDR
+%#define LM_MAXSTRLEN	1024
+%#define MAXNAMELEN	LM_MAXSTRLEN+1
+#endif
+
+/*
+ * status of a call to the lock manager
+ */
+enum nlm_stats {
+	nlm_granted = 0,
+	nlm_denied = 1,
+	nlm_denied_nolocks = 2,
+	nlm_blocked = 3,
+	nlm_denied_grace_period = 4
+};
+
+struct nlm_holder {
+	bool exclusive;
+	int svid;
+	netobj oh;
+	unsigned l_offset;
+	unsigned l_len;
+};
+
+union nlm_testrply switch (nlm_stats stat) {
+	case nlm_denied:
+		struct nlm_holder holder;
+	default:
+		void;
+};
+
+struct nlm_stat {
+	nlm_stats stat;
+};
+
+struct nlm_res {
+	netobj cookie;
+	nlm_stat stat;
+};
+
+struct nlm_testres {
+	netobj cookie;
+	nlm_testrply stat;
+};
+
+struct nlm_lock {
+	string caller_name<LM_MAXSTRLEN>;
+	netobj fh;		/* identify a file */
+	netobj oh;		/* identify owner of a lock */
+	int svid;		/* generated from pid for svid */
+	unsigned l_offset;
+	unsigned l_len;
+};
+
+struct nlm_lockargs {
+	netobj cookie;
+	bool block;
+	bool exclusive;
+	struct nlm_lock alock;
+	bool reclaim;		/* used for recovering locks */
+	int state;		/* specify local status monitor state */
+};
+
+struct nlm_cancargs {
+	netobj cookie;
+	bool block;
+	bool exclusive;
+	struct nlm_lock alock;
+};
+
+struct nlm_testargs {
+	netobj cookie;
+	bool exclusive;
+	struct nlm_lock alock;
+};
+
+struct nlm_unlockargs {
+	netobj cookie;
+	struct nlm_lock alock;
+};
+
+
+#ifdef RPC_HDR
+%/*
+% * The following enums are actually bit encoded for efficient
+% * boolean algebra.... DON'T change them.....
+% */
+#endif
+enum	fsh_mode {
+	fsm_DN  = 0,	/* deny none */
+	fsm_DR  = 1,	/* deny read */
+	fsm_DW  = 2,	/* deny write */
+	fsm_DRW = 3	/* deny read/write */
+};
+
+enum	fsh_access {
+	fsa_NONE = 0,	/* for completeness */
+	fsa_R    = 1,	/* read only */
+	fsa_W    = 2,	/* write only */
+	fsa_RW   = 3	/* read/write */
+};
+
+struct	nlm_share {
+	string caller_name<LM_MAXSTRLEN>;
+	netobj	fh;
+	netobj	oh;
+	fsh_mode	mode;
+	fsh_access	access;
+};
+
+struct	nlm_shareargs {
+	netobj	cookie;
+	nlm_share	share;
+	bool	reclaim;
+};
+
+struct	nlm_shareres {
+	netobj	cookie;
+	nlm_stats	stat;
+	int	sequence;
+};
+
+struct	nlm_notify {
+	string name<MAXNAMELEN>;
+	long state;
+};
+
+/*
+ * Over-the-wire protocol used between the network lock managers
+ */
+
+program NLM_PROG {
+	version NLM_VERS {
+
+		nlm_testres	NLM_TEST(struct nlm_testargs) =	1;
+
+		nlm_res		NLM_LOCK(struct nlm_lockargs) =	2;
+
+		nlm_res		NLM_CANCEL(struct nlm_cancargs) = 3;
+		nlm_res		NLM_UNLOCK(struct nlm_unlockargs) =	4;
+
+		/*
+		 * remote lock manager call-back to grant lock
+		 */
+		nlm_res		NLM_GRANTED(struct nlm_testargs)= 5;
+		/*
+		 * message passing style of requesting lock
+		 */
+		void		NLM_TEST_MSG(struct nlm_testargs) = 6;
+		void		NLM_LOCK_MSG(struct nlm_lockargs) = 7;
+		void		NLM_CANCEL_MSG(struct nlm_cancargs) =8;
+		void		NLM_UNLOCK_MSG(struct nlm_unlockargs) = 9;
+		void		NLM_GRANTED_MSG(struct nlm_testargs) = 10;
+		void		NLM_TEST_RES(nlm_testres) = 11;
+		void		NLM_LOCK_RES(nlm_res) = 12;
+		void		NLM_CANCEL_RES(nlm_res) = 13;
+		void		NLM_UNLOCK_RES(nlm_res) = 14;
+		void		NLM_GRANTED_RES(nlm_res) = 15;
+	} = 1;
+
+	version NLM_VERSX {
+		nlm_shareres	NLM_SHARE(nlm_shareargs) = 20;
+		nlm_shareres	NLM_UNSHARE(nlm_shareargs) = 21;
+		nlm_res		NLM_NM_LOCK(nlm_lockargs) = 22;
+		void		NLM_FREE_ALL(nlm_notify) = 23;
+	} = 3;
+
+} = 100021;
diff --git a/include/rpcsvc/rex.h b/include/rpcsvc/rex.h
new file mode 100644
index 0000000..3c80ce7
--- /dev/null
+++ b/include/rpcsvc/rex.h
@@ -0,0 +1,227 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _REX_H_RPCGEN
+#define _REX_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define STRINGSIZE 1024
+
+typedef char *rexstring;
+#define SIGINT 2
+#define REX_INTERACTIVE 1
+
+struct rex_start {
+	struct {
+		u_int rst_cmd_len;
+		rexstring *rst_cmd_val;
+	} rst_cmd;
+	rexstring rst_host;
+	rexstring rst_fsname;
+	rexstring rst_dirwithin;
+	struct {
+		u_int rst_env_len;
+		rexstring *rst_env_val;
+	} rst_env;
+	u_int rst_port0;
+	u_int rst_port1;
+	u_int rst_port2;
+	u_int rst_flags;
+};
+typedef struct rex_start rex_start;
+
+struct rex_result {
+	int rlt_stat;
+	rexstring rlt_message;
+};
+typedef struct rex_result rex_result;
+
+struct sgttyb {
+	u_int four;
+	char chars[4];
+	u_int flags;
+};
+typedef struct sgttyb sgttyb;
+#define B0 0
+#define B50 1
+#define B75 2
+#define B110 3
+#define B134 4
+#define B150 5
+#define B200 6
+#define B300 7
+#define B600 8
+#define B1200 9
+#define B1800 10
+#define B2400 11
+#define B4800 12
+#define B9600 13
+#define B19200 14
+#define B38400 15
+#define TANDEM 0x00000001
+#define CBREAK 0x00000002
+#define LCASE 0x00000004
+#define ECHO 0x00000008
+#define CRMOD 0x00000010
+#define RAW 0x00000020
+#define ODDP 0x00000040
+#define EVENP 0x00000080
+#define ANYP 0x000000c0
+#define NLDELAY 0x00000300
+#define NL0 0x00000000
+#define NL1 0x00000100
+#define NL2 0x00000200
+#define NL3 0x00000300
+#define TBDELAY 0x00000c00
+#define TAB0 0x00000000
+#define TAB1 0x00000400
+#define TAB2 0x00000800
+#define XTABS 0x00000c00
+#define CRDELAY 0x00003000
+#define CR0 0x00000000
+#define CR1 0x00001000
+#define CR2 0x00002000
+#define CR3 0x00003000
+#define VTDELAY 0x00004000
+#define FF0 0x00000000
+#define FF1 0x00004000
+#define BSDELAY 0x00008000
+#define BS0 0x00000000
+#define BS1 0x00008000
+#define CRTBS 0x00010000
+#define PRTERA 0x00020000
+#define CRTERA 0x00040000
+#define TILDE 0x00080000
+#define MDMBUF 0x00100000
+#define LITOUT 0x00200000
+#define TOSTOP 0x00400000
+#define FLUSHO 0x00800000
+#define NOHANG 0x01000000
+#define L001000 0x02000000
+#define CRTKIL 0x04000000
+#define PASS8 0x08000000
+#define CTLECH 0x10000000
+#define PENDIN 0x20000000
+#define DECCTQ 0x40000000
+#define NOFLSH 0x80000000
+
+struct tchars {
+	u_int six;
+	char chars[6];
+};
+typedef struct tchars tchars;
+
+struct ltchars {
+	u_int six;
+	char chars[6];
+	u_int mode;
+};
+typedef struct ltchars ltchars;
+
+struct rex_ttysize {
+	int ts_lines;
+	int ts_cols;
+};
+typedef struct rex_ttysize rex_ttysize;
+
+struct rex_ttymode {
+	sgttyb basic;
+	tchars more;
+	ltchars yetmore;
+	u_int andmore;
+};
+typedef struct rex_ttymode rex_ttymode;
+#define LCRTBS 0x0001
+#define LPRTERA 0x0002
+#define LCRTERA 0x0004
+#define LTILDE 0x0008
+#define LMDMBUF 0x0010
+#define LLITOUT 0x0020
+#define LTOSTOP 0x0040
+#define LFLUSHO 0x0080
+#define LNOHANG 0x0100
+#define LL001000 0x0200
+#define LCRTKIL 0x0400
+#define LPASS8 0x0800
+#define LCTLECH 0x1000
+#define LPENDIN 0x2000
+#define LDECCTQ 0x4000
+#define LNOFLSH 0x8000
+
+#define REXPROG 100017
+#define REXVERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define REXPROC_START 1
+extern  rex_result * rexproc_start_1(rex_start *, CLIENT *);
+extern  rex_result * rexproc_start_1_svc(rex_start *, struct svc_req *);
+#define REXPROC_WAIT 2
+extern  rex_result * rexproc_wait_1(void *, CLIENT *);
+extern  rex_result * rexproc_wait_1_svc(void *, struct svc_req *);
+#define REXPROC_MODES 3
+extern  void * rexproc_modes_1(rex_ttymode *, CLIENT *);
+extern  void * rexproc_modes_1_svc(rex_ttymode *, struct svc_req *);
+#define REXPROC_WINCH 4
+extern  void * rexproc_winch_1(rex_ttysize *, CLIENT *);
+extern  void * rexproc_winch_1_svc(rex_ttysize *, struct svc_req *);
+#define REXPROC_SIGNAL 5
+extern  void * rexproc_signal_1(int *, CLIENT *);
+extern  void * rexproc_signal_1_svc(int *, struct svc_req *);
+extern int rexprog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define REXPROC_START 1
+extern  rex_result * rexproc_start_1();
+extern  rex_result * rexproc_start_1_svc();
+#define REXPROC_WAIT 2
+extern  rex_result * rexproc_wait_1();
+extern  rex_result * rexproc_wait_1_svc();
+#define REXPROC_MODES 3
+extern  void * rexproc_modes_1();
+extern  void * rexproc_modes_1_svc();
+#define REXPROC_WINCH 4
+extern  void * rexproc_winch_1();
+extern  void * rexproc_winch_1_svc();
+#define REXPROC_SIGNAL 5
+extern  void * rexproc_signal_1();
+extern  void * rexproc_signal_1_svc();
+extern int rexprog_1_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rexstring (XDR *, rexstring*);
+extern  bool_t xdr_rex_start (XDR *, rex_start*);
+extern  bool_t xdr_rex_result (XDR *, rex_result*);
+extern  bool_t xdr_sgttyb (XDR *, sgttyb*);
+extern  bool_t xdr_tchars (XDR *, tchars*);
+extern  bool_t xdr_ltchars (XDR *, ltchars*);
+extern  bool_t xdr_rex_ttysize (XDR *, rex_ttysize*);
+extern  bool_t xdr_rex_ttymode (XDR *, rex_ttymode*);
+
+#else /* K&R C */
+extern bool_t xdr_rexstring ();
+extern bool_t xdr_rex_start ();
+extern bool_t xdr_rex_result ();
+extern bool_t xdr_sgttyb ();
+extern bool_t xdr_tchars ();
+extern bool_t xdr_ltchars ();
+extern bool_t xdr_rex_ttysize ();
+extern bool_t xdr_rex_ttymode ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_REX_H_RPCGEN */
diff --git a/include/rpcsvc/rex.x b/include/rpcsvc/rex.x
new file mode 100644
index 0000000..b5baf15
--- /dev/null
+++ b/include/rpcsvc/rex.x
@@ -0,0 +1,229 @@
+/* @(#)rex.x	2.1 88/08/01 4.0 RPCSRC */
+
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Remote execution (rex) protocol specification
+ */
+
+const STRINGSIZE = 1024;
+typedef string rexstring<1024>;
+
+/*
+ * values to pass to REXPROC_SIGNAL
+ */
+const SIGINT = 2;	/* interrupt */
+
+/*
+ * Values for rst_flags, below
+ */
+const REX_INTERACTIVE = 1;	/* interactive mode */
+
+struct rex_start {
+	rexstring rst_cmd<>;	/* list of command and args */
+	rexstring rst_host;	/* working directory host name */
+	rexstring rst_fsname;	/* working directory file system name */
+	rexstring rst_dirwithin;/* working directory within file system */
+	rexstring rst_env<>;	/* list of environment */
+	unsigned int rst_port0;	/* port for stdin */
+	unsigned int rst_port1;	/* port for stdout */
+	unsigned int rst_port2;	/* port for stderr */
+	unsigned int rst_flags;	/* options - see const above */
+};
+
+struct rex_result {
+   	int rlt_stat;		/* integer status code */
+	rexstring rlt_message;	/* string message for human consumption */
+};
+
+
+struct sgttyb {
+	unsigned four;	/* always equals 4 */
+	opaque chars[4];
+	/* chars[0] == input speed */
+	/* chars[1] == output speed */
+	/* chars[2] == kill character */
+	/* chars[3] == erase character */
+	unsigned flags;
+};
+/* values for speeds above (baud rates)  */
+const B0  = 0;
+const B50 = 1;
+const B75 = 2;
+const B110 = 3;
+const B134 = 4;
+const B150 = 5;
+const B200 = 6;
+const B300 = 7;
+const B600 = 8;
+const B1200 = 9;
+const B1800 = 10;
+const B2400 = 11;
+const B4800 = 12;
+const B9600 = 13;
+const B19200 = 14;
+const B38400 = 15;
+
+/* values for flags above */
+const TANDEM = 0x00000001; /* send stopc on out q full */
+const CBREAK = 0x00000002; /* half-cooked mode */
+const LCASE = 0x00000004; /* simulate lower case */
+const ECHO = 0x00000008; /* echo input */
+const CRMOD = 0x00000010; /* map \r to \r\n on output */
+const RAW = 0x00000020; /* no i/o processing */
+const ODDP = 0x00000040; /* get/send odd parity */
+const EVENP = 0x00000080; /* get/send even parity */
+const ANYP = 0x000000c0; /* get any parity/send none */
+const NLDELAY = 0x00000300; /* \n delay */
+const  NL0 = 0x00000000;
+const  NL1 = 0x00000100; /* tty 37 */
+const  NL2 = 0x00000200; /* vt05 */
+const  NL3 = 0x00000300;
+const TBDELAY = 0x00000c00; /* horizontal tab delay */
+const  TAB0 = 0x00000000;
+const  TAB1 = 0x00000400; /* tty 37 */
+const  TAB2 = 0x00000800;
+const XTABS = 0x00000c00; /* expand tabs on output */
+const CRDELAY = 0x00003000; /* \r delay */
+const  CR0 = 0x00000000;
+const  CR1 = 0x00001000; /* tn 300 */
+const  CR2 = 0x00002000; /* tty 37 */
+const  CR3 = 0x00003000; /* concept 100 */
+const VTDELAY = 0x00004000; /* vertical tab delay */
+const  FF0 = 0x00000000;
+const  FF1 = 0x00004000; /* tty 37 */
+const BSDELAY = 0x00008000; /* \b delay */
+const  BS0 = 0x00000000;
+const  BS1 = 0x00008000;
+const CRTBS = 0x00010000; /* do backspacing for crt */
+const PRTERA = 0x00020000; /* \ ... / erase */
+const CRTERA = 0x00040000; /* " \b " to wipe out char */
+const TILDE = 0x00080000; /* hazeltine tilde kludge */
+const MDMBUF = 0x00100000; /* start/stop output on carrier intr */
+const LITOUT = 0x00200000; /* literal output */
+const TOSTOP = 0x00400000; /* SIGTTOU on background output */
+const FLUSHO = 0x00800000; /* flush output to terminal */
+const NOHANG = 0x01000000; /* no SIGHUP on carrier drop */
+const L001000 = 0x02000000;
+const CRTKIL = 0x04000000; /* kill line with " \b " */
+const PASS8 = 0x08000000;
+const CTLECH = 0x10000000; /* echo control chars as ^X */
+const PENDIN = 0x20000000; /* tp->t_rawq needs reread */
+const DECCTQ = 0x40000000; /* only ^Q starts after ^S */
+const NOFLSH = 0x80000000; /* no output flush on signal */
+
+struct tchars {
+	unsigned six;	/* always equals 6 */
+	opaque chars[6];
+	/* chars[0] == interrupt char */
+	/* chars[1] == quit char */
+	/* chars[2] == start output char */
+	/* chars[3] == stop output char */
+	/* chars[4] == end-of-file char */
+	/* chars[5] == input delimiter (like nl) */
+};
+
+struct ltchars {
+	unsigned six;	/* always equals 6 */
+	opaque chars[6];
+	/* chars[0] == stop process signal */
+	/* chars[1] == delayed stop process signal */
+	/* chars[2] == reprint line */
+	/* chars[3] == flush output */
+	/* chars[4] == word erase */
+	/* chars[5] == literal next character */
+	unsigned mode;
+};
+
+struct rex_ttysize {
+	int ts_lines;
+	int ts_cols;
+};
+
+struct rex_ttymode {
+    sgttyb basic;    /* standard unix tty flags */
+    tchars more; /* interrupt, kill characters, etc. */
+    ltchars yetmore; /* special Berkeley characters */
+    unsigned andmore;     /* and Berkeley modes */
+};
+
+/* values for andmore above */
+const LCRTBS = 0x0001;	/* do backspacing for crt */
+const LPRTERA = 0x0002;	/* \ ... / erase */
+const LCRTERA = 0x0004;	/* " \b " to wipe out char */
+const LTILDE = 0x0008;	/* hazeltine tilde kludge */
+const LMDMBUF = 0x0010;	/* start/stop output on carrier intr */
+const LLITOUT = 0x0020;	/* literal output */
+const LTOSTOP = 0x0040;	/* SIGTTOU on background output */
+const LFLUSHO = 0x0080;	/* flush output to terminal */
+const LNOHANG = 0x0100;	/* no SIGHUP on carrier drop */
+const LL001000 = 0x0200;
+const LCRTKIL = 0x0400;	/* kill line with " \b " */
+const LPASS8 = 0x0800;
+const LCTLECH = 0x1000;	/* echo control chars as ^X */
+const LPENDIN = 0x2000;	/* needs reread */
+const LDECCTQ = 0x4000;	/* only ^Q starts after ^S */
+const LNOFLSH = 0x8000;	/* no output flush on signal */
+
+program REXPROG {
+	version REXVERS {
+
+		/*
+		 * Start remote execution
+		 */
+		rex_result
+		REXPROC_START(rex_start) = 1;
+
+		/*
+		 * Wait for remote execution to terminate
+		 */
+		rex_result
+		REXPROC_WAIT(void) = 2;
+
+		/*
+		 * Send tty modes
+		 */
+		void
+		REXPROC_MODES(rex_ttymode) = 3;
+
+		/*
+		 * Send window size change
+		 */
+		void
+		REXPROC_WINCH(rex_ttysize) = 4;
+
+		/*
+		 * Send other signal
+		 */
+		void
+		REXPROC_SIGNAL(int) = 5;
+	} = 1;
+} = 100017;
diff --git a/include/rpcsvc/rquota.h b/include/rpcsvc/rquota.h
new file mode 100644
index 0000000..b506460
--- /dev/null
+++ b/include/rpcsvc/rquota.h
@@ -0,0 +1,95 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _RQUOTA_H_RPCGEN
+#define _RQUOTA_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define RQ_PATHLEN 1024
+
+struct getquota_args {
+	char *gqa_pathp;
+	int gqa_uid;
+};
+typedef struct getquota_args getquota_args;
+
+struct rquota {
+	int rq_bsize;
+	bool_t rq_active;
+	u_int rq_bhardlimit;
+	u_int rq_bsoftlimit;
+	u_int rq_curblocks;
+	u_int rq_fhardlimit;
+	u_int rq_fsoftlimit;
+	u_int rq_curfiles;
+	u_int rq_btimeleft;
+	u_int rq_ftimeleft;
+};
+typedef struct rquota rquota;
+
+enum gqr_status {
+	Q_OK = 1,
+	Q_NOQUOTA = 2,
+	Q_EPERM = 3,
+};
+typedef enum gqr_status gqr_status;
+
+struct getquota_rslt {
+	gqr_status status;
+	union {
+		rquota gqr_rquota;
+	} getquota_rslt_u;
+};
+typedef struct getquota_rslt getquota_rslt;
+
+#define RQUOTAPROG 100011
+#define RQUOTAVERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define RQUOTAPROC_GETQUOTA 1
+extern  getquota_rslt * rquotaproc_getquota_1(getquota_args *, CLIENT *);
+extern  getquota_rslt * rquotaproc_getquota_1_svc(getquota_args *, struct svc_req *);
+#define RQUOTAPROC_GETACTIVEQUOTA 2
+extern  getquota_rslt * rquotaproc_getactivequota_1(getquota_args *, CLIENT *);
+extern  getquota_rslt * rquotaproc_getactivequota_1_svc(getquota_args *, struct svc_req *);
+extern int rquotaprog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define RQUOTAPROC_GETQUOTA 1
+extern  getquota_rslt * rquotaproc_getquota_1();
+extern  getquota_rslt * rquotaproc_getquota_1_svc();
+#define RQUOTAPROC_GETACTIVEQUOTA 2
+extern  getquota_rslt * rquotaproc_getactivequota_1();
+extern  getquota_rslt * rquotaproc_getactivequota_1_svc();
+extern int rquotaprog_1_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_getquota_args (XDR *, getquota_args*);
+extern  bool_t xdr_rquota (XDR *, rquota*);
+extern  bool_t xdr_gqr_status (XDR *, gqr_status*);
+extern  bool_t xdr_getquota_rslt (XDR *, getquota_rslt*);
+
+#else /* K&R C */
+extern bool_t xdr_getquota_args ();
+extern bool_t xdr_rquota ();
+extern bool_t xdr_gqr_status ();
+extern bool_t xdr_getquota_rslt ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_RQUOTA_H_RPCGEN */
diff --git a/include/rpcsvc/rquota.x b/include/rpcsvc/rquota.x
new file mode 100644
index 0000000..c457524
--- /dev/null
+++ b/include/rpcsvc/rquota.x
@@ -0,0 +1,61 @@
+/* @(#)rquota.x	2.1 88/08/01 4.0 RPCSRC */
+/* @(#)rquota.x 1.2 87/09/20 Copyr 1987 Sun Micro */
+
+/*
+ * Remote quota protocol
+ * Requires unix authentication
+ */
+
+const RQ_PATHLEN = 1024;
+
+struct getquota_args {
+	string gqa_pathp<RQ_PATHLEN>;  	/* path to filesystem of interest */
+	int gqa_uid;	        	/* inquire about quota for uid */
+};
+
+/*
+ * remote quota structure
+ */
+struct rquota {
+	int rq_bsize;			/* block size for block counts */
+	bool rq_active;  		/* indicates whether quota is active */
+	unsigned int rq_bhardlimit;	/* absolute limit on disk blks alloc */
+	unsigned int rq_bsoftlimit;	/* preferred limit on disk blks */
+	unsigned int rq_curblocks;	/* current block count */
+	unsigned int rq_fhardlimit;	/* absolute limit on allocated files */
+	unsigned int rq_fsoftlimit;	/* preferred file limit */
+	unsigned int rq_curfiles;	/* current # allocated files */
+	unsigned int rq_btimeleft;	/* time left for excessive disk use */
+	unsigned int rq_ftimeleft;	/* time left for excessive files */
+};
+
+enum gqr_status {
+	Q_OK = 1,		/* quota returned */
+	Q_NOQUOTA = 2,  	/* noquota for uid */
+	Q_EPERM = 3		/* no permission to access quota */
+};
+
+union getquota_rslt switch (gqr_status status) {
+case Q_OK:
+	rquota gqr_rquota;	/* valid if status == Q_OK */
+case Q_NOQUOTA:
+	void;
+case Q_EPERM:
+	void;
+};
+
+program RQUOTAPROG {
+	version RQUOTAVERS {
+		/*
+		 * Get all quotas
+		 */
+		getquota_rslt
+		RQUOTAPROC_GETQUOTA(getquota_args) = 1;
+
+		/*
+	 	 * Get active quotas only
+		 */
+		getquota_rslt
+		RQUOTAPROC_GETACTIVEQUOTA(getquota_args) = 2;
+	} = 1;
+} = 100011;
diff --git a/include/rpcsvc/rstat.h b/include/rpcsvc/rstat.h
new file mode 100644
index 0000000..abc0ba8
--- /dev/null
+++ b/include/rpcsvc/rstat.h
@@ -0,0 +1,162 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _RSTAT_H_RPCGEN
+#define _RSTAT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef FSCALE
+/*
+ * Scale factor for scaled integers used to count load averages.
+ */
+#define FSHIFT 8 /* bits to right of fixed binary point */
+#define FSCALE (1<<FSHIFT)
+
+#endif /* ndef FSCALE */
+#define CPUSTATES 4
+#define DK_NDRIVE 4
+
+struct rstat_timeval {
+	u_int tv_sec;
+	u_int tv_usec;
+};
+typedef struct rstat_timeval rstat_timeval;
+
+struct statstime {
+	int cp_time[CPUSTATES];
+	int dk_xfer[DK_NDRIVE];
+	u_int v_pgpgin;
+	u_int v_pgpgout;
+	u_int v_pswpin;
+	u_int v_pswpout;
+	u_int v_intr;
+	int if_ipackets;
+	int if_ierrors;
+	int if_oerrors;
+	int if_collisions;
+	u_int v_swtch;
+	int avenrun[3];
+	rstat_timeval boottime;
+	rstat_timeval curtime;
+	int if_opackets;
+};
+typedef struct statstime statstime;
+
+struct statsswtch {
+	int cp_time[CPUSTATES];
+	int dk_xfer[DK_NDRIVE];
+	u_int v_pgpgin;
+	u_int v_pgpgout;
+	u_int v_pswpin;
+	u_int v_pswpout;
+	u_int v_intr;
+	int if_ipackets;
+	int if_ierrors;
+	int if_oerrors;
+	int if_collisions;
+	u_int v_swtch;
+	u_int avenrun[3];
+	rstat_timeval boottime;
+	int if_opackets;
+};
+typedef struct statsswtch statsswtch;
+
+struct stats {
+	int cp_time[CPUSTATES];
+	int dk_xfer[DK_NDRIVE];
+	u_int v_pgpgin;
+	u_int v_pgpgout;
+	u_int v_pswpin;
+	u_int v_pswpout;
+	u_int v_intr;
+	int if_ipackets;
+	int if_ierrors;
+	int if_oerrors;
+	int if_collisions;
+	int if_opackets;
+};
+typedef struct stats stats;
+
+#define RSTATPROG 100001
+#define RSTATVERS_TIME 3
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define RSTATPROC_STATS 1
+extern  statstime * rstatproc_stats_3(void *, CLIENT *);
+extern  statstime * rstatproc_stats_3_svc(void *, struct svc_req *);
+#define RSTATPROC_HAVEDISK 2
+extern  u_int * rstatproc_havedisk_3(void *, CLIENT *);
+extern  u_int * rstatproc_havedisk_3_svc(void *, struct svc_req *);
+extern int rstatprog_3_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define RSTATPROC_STATS 1
+extern  statstime * rstatproc_stats_3();
+extern  statstime * rstatproc_stats_3_svc();
+#define RSTATPROC_HAVEDISK 2
+extern  u_int * rstatproc_havedisk_3();
+extern  u_int * rstatproc_havedisk_3_svc();
+extern int rstatprog_3_freeresult ();
+#endif /* K&R C */
+#define RSTATVERS_SWTCH 2
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  statsswtch * rstatproc_stats_2(void *, CLIENT *);
+extern  statsswtch * rstatproc_stats_2_svc(void *, struct svc_req *);
+extern  u_int * rstatproc_havedisk_2(void *, CLIENT *);
+extern  u_int * rstatproc_havedisk_2_svc(void *, struct svc_req *);
+extern int rstatprog_2_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  statsswtch * rstatproc_stats_2();
+extern  statsswtch * rstatproc_stats_2_svc();
+extern  u_int * rstatproc_havedisk_2();
+extern  u_int * rstatproc_havedisk_2_svc();
+extern int rstatprog_2_freeresult ();
+#endif /* K&R C */
+#define RSTATVERS_ORIG 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  stats * rstatproc_stats_1(void *, CLIENT *);
+extern  stats * rstatproc_stats_1_svc(void *, struct svc_req *);
+extern  u_int * rstatproc_havedisk_1(void *, CLIENT *);
+extern  u_int * rstatproc_havedisk_1_svc(void *, struct svc_req *);
+extern int rstatprog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  stats * rstatproc_stats_1();
+extern  stats * rstatproc_stats_1_svc();
+extern  u_int * rstatproc_havedisk_1();
+extern  u_int * rstatproc_havedisk_1_svc();
+extern int rstatprog_1_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rstat_timeval (XDR *, rstat_timeval*);
+extern  bool_t xdr_statstime (XDR *, statstime*);
+extern  bool_t xdr_statsswtch (XDR *, statsswtch*);
+extern  bool_t xdr_stats (XDR *, stats*);
+
+#else /* K&R C */
+extern bool_t xdr_rstat_timeval ();
+extern bool_t xdr_statstime ();
+extern bool_t xdr_statsswtch ();
+extern bool_t xdr_stats ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_RSTAT_H_RPCGEN */
diff --git a/include/rpcsvc/rstat.x b/include/rpcsvc/rstat.x
new file mode 100644
index 0000000..9b7b102
--- /dev/null
+++ b/include/rpcsvc/rstat.x
@@ -0,0 +1,145 @@
+/* @(#)rstat.x	2.2 88/08/01 4.0 RPCSRC */
+
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Gather statistics on remote machines
+ */
+
+#ifdef RPC_HDR
+
+%#ifndef FSCALE
+%/*
+% * Scale factor for scaled integers used to count load averages.
+% */
+%#define FSHIFT  8               /* bits to right of fixed binary point */
+%#define FSCALE  (1<<FSHIFT)
+%
+%#endif /* ndef FSCALE */
+
+#endif /* def RPC_HDR */
+
+const CPUSTATES = 4;
+const DK_NDRIVE = 4;
+
+/*
+ * GMT since 0:00, January 1, 1970
+ */
+struct rstat_timeval {
+	unsigned int tv_sec;	/* seconds */
+	unsigned int tv_usec;	/* and microseconds */
+};
+
+struct statstime {				/* RSTATVERS_TIME */
+	int cp_time[CPUSTATES];
+	int dk_xfer[DK_NDRIVE];
+	unsigned int v_pgpgin;	/* these are cumulative sum */
+	unsigned int v_pgpgout;
+	unsigned int v_pswpin;
+	unsigned int v_pswpout;
+	unsigned int v_intr;
+	int if_ipackets;
+	int if_ierrors;
+	int if_oerrors;
+	int if_collisions;
+	unsigned int v_swtch;
+	int avenrun[3];         /* scaled by FSCALE */
+	rstat_timeval boottime;
+	rstat_timeval curtime;
+	int if_opackets;
+};
+
+struct statsswtch {			/* RSTATVERS_SWTCH */
+	int cp_time[CPUSTATES];
+	int dk_xfer[DK_NDRIVE];
+	unsigned int v_pgpgin;	/* these are cumulative sum */
+	unsigned int v_pgpgout;
+	unsigned int v_pswpin;
+	unsigned int v_pswpout;
+	unsigned int v_intr;
+	int if_ipackets;
+	int if_ierrors;
+	int if_oerrors;
+	int if_collisions;
+	unsigned int v_swtch;
+	unsigned int avenrun[3];/* scaled by FSCALE */
+	rstat_timeval boottime;
+	int if_opackets;
+};
+
+struct stats {				/* RSTATVERS_ORIG */
+	int cp_time[CPUSTATES];
+	int dk_xfer[DK_NDRIVE];
+	unsigned int v_pgpgin;	/* these are cumulative sum */
+	unsigned int v_pgpgout;
+	unsigned int v_pswpin;
+	unsigned int v_pswpout;
+	unsigned int v_intr;
+	int if_ipackets;
+	int if_ierrors;
+	int if_oerrors;
+	int if_collisions;
+	int if_opackets;
+};
+
+
+program RSTATPROG {
+	/*
+	 * Newest version includes current time and context switching info
+	 */
+	version RSTATVERS_TIME {
+		statstime
+		RSTATPROC_STATS(void) = 1;
+
+		unsigned int
+		RSTATPROC_HAVEDISK(void) = 2;
+	} = 3;
+	/*
+	 * Does not have current time
+	 */
+	version RSTATVERS_SWTCH {
+		statsswtch
+		RSTATPROC_STATS(void) = 1;
+
+		unsigned int
+		RSTATPROC_HAVEDISK(void) = 2;
+	} = 2;
+	/*
+	 * Old version has no info about current time or context switching
+	 */
+	version RSTATVERS_ORIG {
+		stats
+		RSTATPROC_STATS(void) = 1;
+
+		unsigned int
+		RSTATPROC_HAVEDISK(void) = 2;
+	} = 1;
+} = 100001;
diff --git a/include/rpcsvc/rusers.h b/include/rpcsvc/rusers.h
new file mode 100644
index 0000000..dc2d3b0
--- /dev/null
+++ b/include/rpcsvc/rusers.h
@@ -0,0 +1,147 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _RUSERS_H_RPCGEN
+#define _RUSERS_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Find out about remote users
+ */
+#define RUSERS_MAXUSERLEN 32
+#define RUSERS_MAXLINELEN 32
+#define RUSERS_MAXHOSTLEN 257
+
+struct rusers_utmp {
+	char *ut_user;
+	char *ut_line;
+	char *ut_host;
+	int ut_type;
+	int ut_time;
+	u_int ut_idle;
+};
+typedef struct rusers_utmp rusers_utmp;
+
+typedef struct {
+	u_int utmp_array_len;
+	rusers_utmp *utmp_array_val;
+} utmp_array;
+
+/*
+ * Values for ut_type field above.
+ */
+#define RUSERS_EMPTY 0
+#define RUSERS_RUN_LVL 1
+#define RUSERS_BOOT_TIME 2
+#define RUSERS_OLD_TIME 3
+#define RUSERS_NEW_TIME 4
+#define RUSERS_INIT_PROCESS 5
+#define RUSERS_LOGIN_PROCESS 6
+#define RUSERS_USER_PROCESS 7
+#define RUSERS_DEAD_PROCESS 8
+#define RUSERS_ACCOUNTING 9
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rpc/xdr.h>
+
+/*
+ * The following structures are used by version 2 of the rusersd protocol.
+ * They were not developed with rpcgen, so they do not appear as RPCL.
+ */
+
+#define RUSERSVERS_IDLE 2
+#define RUSERSVERS 3 /* current version */
+#define MAXUSERS 100
+
+/*
+ * This is the structure used in version 2 of the rusersd RPC service.
+ * It corresponds to the utmp structure for BSD systems.
+ */
+struct ru_utmp {
+ char ut_line[8]; /* tty name */
+ char ut_name[8]; /* user id */
+ char ut_host[16]; /* host name, if remote */
+ long int ut_time; /* time on */
+};
+
+struct utmparr {
+ struct ru_utmp **uta_arr;
+ int uta_cnt;
+};
+typedef struct utmparr utmparr;
+
+extern bool_t xdr_utmparr (XDR *xdrs, struct utmparr *objp) __THROW;
+
+struct utmpidle {
+ struct ru_utmp ui_utmp;
+ unsigned int ui_idle;
+};
+
+struct utmpidlearr {
+ struct utmpidle **uia_arr;
+ int uia_cnt;
+};
+
+extern bool_t xdr_utmpidlearr (XDR *xdrs, struct utmpidlearr *objp) __THROW;
+
+#ifdef __cplusplus
+}
+#endif
+
+#define RUSERSPROG 100002
+#define RUSERSVERS_3 3
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define RUSERSPROC_NUM 1
+extern  int * rusersproc_num_3(void *, CLIENT *);
+extern  int * rusersproc_num_3_svc(void *, struct svc_req *);
+#define RUSERSPROC_NAMES 2
+extern  utmp_array * rusersproc_names_3(void *, CLIENT *);
+extern  utmp_array * rusersproc_names_3_svc(void *, struct svc_req *);
+#define RUSERSPROC_ALLNAMES 3
+extern  utmp_array * rusersproc_allnames_3(void *, CLIENT *);
+extern  utmp_array * rusersproc_allnames_3_svc(void *, struct svc_req *);
+extern int rusersprog_3_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define RUSERSPROC_NUM 1
+extern  int * rusersproc_num_3();
+extern  int * rusersproc_num_3_svc();
+#define RUSERSPROC_NAMES 2
+extern  utmp_array * rusersproc_names_3();
+extern  utmp_array * rusersproc_names_3_svc();
+#define RUSERSPROC_ALLNAMES 3
+extern  utmp_array * rusersproc_allnames_3();
+extern  utmp_array * rusersproc_allnames_3_svc();
+extern int rusersprog_3_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rusers_utmp (XDR *, rusers_utmp*);
+extern  bool_t xdr_utmp_array (XDR *, utmp_array*);
+
+#else /* K&R C */
+extern bool_t xdr_rusers_utmp ();
+extern bool_t xdr_utmp_array ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_RUSERS_H_RPCGEN */
diff --git a/include/rpcsvc/rusers.x b/include/rpcsvc/rusers.x
new file mode 100644
index 0000000..476ed74
--- /dev/null
+++ b/include/rpcsvc/rusers.x
@@ -0,0 +1,240 @@
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+%/*
+% * Find out about remote users
+% */
+
+const RUSERS_MAXUSERLEN = 32;
+const RUSERS_MAXLINELEN = 32;
+const RUSERS_MAXHOSTLEN = 257;
+
+struct rusers_utmp {
+	string ut_user<RUSERS_MAXUSERLEN>;	/* aka ut_name */
+	string ut_line<RUSERS_MAXLINELEN>;	/* device */
+	string ut_host<RUSERS_MAXHOSTLEN>;	/* host user logged on from */
+	int ut_type;				/* type of entry */
+	int ut_time;				/* time entry was made */
+	unsigned int ut_idle;			/* minutes idle */
+};
+
+typedef rusers_utmp utmp_array<>;
+
+#ifdef RPC_HDR
+%
+%/*
+% * Values for ut_type field above.
+% */
+#endif
+const	RUSERS_EMPTY = 0;
+const	RUSERS_RUN_LVL = 1;
+const	RUSERS_BOOT_TIME = 2;
+const	RUSERS_OLD_TIME = 3;
+const	RUSERS_NEW_TIME = 4;
+const	RUSERS_INIT_PROCESS = 5;
+const	RUSERS_LOGIN_PROCESS = 6;
+const	RUSERS_USER_PROCESS = 7;
+const	RUSERS_DEAD_PROCESS = 8;
+const	RUSERS_ACCOUNTING = 9;
+
+program RUSERSPROG {
+
+	version RUSERSVERS_3 {
+		int
+		RUSERSPROC_NUM(void) = 1;
+
+		utmp_array
+		RUSERSPROC_NAMES(void) = 2;
+
+		utmp_array
+		RUSERSPROC_ALLNAMES(void) = 3;
+	} = 3;
+
+} = 100002;
+
+#ifdef RPC_HDR
+%
+%
+%#ifdef	__cplusplus
+%extern "C" {
+%#endif
+%
+%#include <rpc/xdr.h>
+%
+%/*
+% * The following structures are used by version 2 of the rusersd protocol.
+% * They were not developed with rpcgen, so they do not appear as RPCL.
+% */
+%
+%#define	RUSERSVERS_IDLE 2
+%#define	RUSERSVERS 3		/* current version */
+%#define	MAXUSERS 100
+%
+%/*
+% * This is the structure used in version 2 of the rusersd RPC service.
+% * It corresponds to the utmp structure for BSD systems.
+% */
+%struct ru_utmp {
+%	char	ut_line[8];		/* tty name */
+%	char	ut_name[8];		/* user id */
+%	char	ut_host[16];		/* host name, if remote */
+%	long int ut_time;		/* time on */
+%};
+%
+%struct utmparr {
+%       struct ru_utmp **uta_arr;
+%       int uta_cnt;
+%};
+%typedef struct utmparr utmparr;
+%
+%extern bool_t xdr_utmparr (XDR *xdrs, struct utmparr *objp) __THROW;
+%
+%struct utmpidle {
+%	struct ru_utmp ui_utmp;
+%	unsigned int ui_idle;
+%};
+%
+%struct utmpidlearr {
+%	struct utmpidle **uia_arr;
+%	int uia_cnt;
+%};
+%
+%extern bool_t xdr_utmpidlearr (XDR *xdrs, struct utmpidlearr *objp) __THROW;
+%
+%#ifdef	__cplusplus
+%}
+%#endif
+#endif
+
+
+#ifdef	RPC_XDR
+%bool_t xdr_utmp (XDR *xdrs, struct ru_utmp *objp);
+%
+%bool_t
+%xdr_utmp(xdrs, objp)
+%	XDR *xdrs;
+%	struct ru_utmp *objp;
+%{
+%	/* Since the fields are char foo [xxx], we should not free them. */
+%	if (xdrs->x_op != XDR_FREE)
+%	{
+%		char *ptr;
+%		unsigned int size;
+%		ptr = objp->ut_line;
+%		size = sizeof (objp->ut_line);
+%		if (!xdr_bytes (xdrs, &ptr, &size, size)) {
+%			return (FALSE);
+%		}
+%		ptr = objp->ut_name;
+%		size = sizeof (objp->ut_name);
+%		if (!xdr_bytes (xdrs, &ptr, &size, size)) {
+%			return (FALSE);
+%		}
+%		ptr = objp->ut_host;
+%		size = sizeof (objp->ut_host);
+%		if (!xdr_bytes (xdrs, &ptr, &size, size)) {
+%			return (FALSE);
+%		}
+%	}
+%	if (!xdr_long(xdrs, &objp->ut_time)) {
+%		return (FALSE);
+%	}
+%	return (TRUE);
+%}
+%
+%bool_t xdr_utmpptr(XDR *xdrs, struct ru_utmp **objpp);
+%
+%bool_t
+%xdr_utmpptr(xdrs, objpp)
+%	XDR *xdrs;
+%	struct ru_utmp **objpp;
+%{
+%	if (!xdr_reference(xdrs, (char **) objpp, sizeof (struct ru_utmp),
+%			   (xdrproc_t) xdr_utmp)) {
+%		return (FALSE);
+%	}
+%	return (TRUE);
+%}
+%
+%bool_t
+%xdr_utmparr(xdrs, objp)
+%	XDR *xdrs;
+%	struct utmparr *objp;
+%{
+%	if (!xdr_array(xdrs, (char **)&objp->uta_arr, (u_int *)&objp->uta_cnt,
+%		       MAXUSERS, sizeof(struct ru_utmp *),
+%		       (xdrproc_t) xdr_utmpptr)) {
+%		return (FALSE);
+%	}
+%	return (TRUE);
+%}
+%
+%bool_t xdr_utmpidle(XDR *xdrs, struct utmpidle *objp);
+%
+%bool_t
+%xdr_utmpidle(xdrs, objp)
+%	XDR *xdrs;
+%	struct utmpidle *objp;
+%{
+%	if (!xdr_utmp(xdrs, &objp->ui_utmp)) {
+%		return (FALSE);
+%	}
+%	if (!xdr_u_int(xdrs, &objp->ui_idle)) {
+%		return (FALSE);
+%	}
+%	return (TRUE);
+%}
+%
+%bool_t xdr_utmpidleptr(XDR *xdrs, struct utmpidle **objp);
+%
+%bool_t
+%xdr_utmpidleptr(xdrs, objpp)
+%	XDR *xdrs;
+%	struct utmpidle **objpp;
+%{
+%	if (!xdr_reference(xdrs, (char **) objpp, sizeof (struct utmpidle),
+%			   (xdrproc_t) xdr_utmpidle)) {
+%		return (FALSE);
+%	}
+%	return (TRUE);
+%}
+%
+%bool_t
+%xdr_utmpidlearr(xdrs, objp)
+%	XDR *xdrs;
+%	struct utmpidlearr *objp;
+%{
+%	if (!xdr_array(xdrs, (char **)&objp->uia_arr, (u_int *)&objp->uia_cnt,
+%		       MAXUSERS, sizeof(struct utmpidle *),
+%		       (xdrproc_t) xdr_utmpidleptr)) {
+%		return (FALSE);
+%	}
+%	return (TRUE);
+%}
+#endif
diff --git a/include/rpcsvc/sm_inter.h b/include/rpcsvc/sm_inter.h
new file mode 100644
index 0000000..d4bc3e1
--- /dev/null
+++ b/include/rpcsvc/sm_inter.h
@@ -0,0 +1,135 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _SM_INTER_H_RPCGEN
+#define _SM_INTER_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SM_MAXSTRLEN 1024
+
+struct sm_name {
+	char *mon_name;
+};
+typedef struct sm_name sm_name;
+
+struct my_id {
+	char *my_name;
+	int my_prog;
+	int my_vers;
+	int my_proc;
+};
+typedef struct my_id my_id;
+
+struct mon_id {
+	char *mon_name;
+	struct my_id my_id;
+};
+typedef struct mon_id mon_id;
+
+struct mon {
+	struct mon_id mon_id;
+	char priv[16];
+};
+typedef struct mon mon;
+
+struct sm_stat {
+	int state;
+};
+typedef struct sm_stat sm_stat;
+
+enum res {
+	stat_succ = 0,
+	stat_fail = 1,
+};
+typedef enum res res;
+
+struct sm_stat_res {
+	res res_stat;
+	int state;
+};
+typedef struct sm_stat_res sm_stat_res;
+
+struct status {
+	char *mon_name;
+	int state;
+	char priv[16];
+};
+typedef struct status status;
+
+#define SM_PROG 100024
+#define SM_VERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define SM_STAT 1
+extern  struct sm_stat_res * sm_stat_1(struct sm_name *, CLIENT *);
+extern  struct sm_stat_res * sm_stat_1_svc(struct sm_name *, struct svc_req *);
+#define SM_MON 2
+extern  struct sm_stat_res * sm_mon_1(struct mon *, CLIENT *);
+extern  struct sm_stat_res * sm_mon_1_svc(struct mon *, struct svc_req *);
+#define SM_UNMON 3
+extern  struct sm_stat * sm_unmon_1(struct mon_id *, CLIENT *);
+extern  struct sm_stat * sm_unmon_1_svc(struct mon_id *, struct svc_req *);
+#define SM_UNMON_ALL 4
+extern  struct sm_stat * sm_unmon_all_1(struct my_id *, CLIENT *);
+extern  struct sm_stat * sm_unmon_all_1_svc(struct my_id *, struct svc_req *);
+#define SM_SIMU_CRASH 5
+extern  void * sm_simu_crash_1(void *, CLIENT *);
+extern  void * sm_simu_crash_1_svc(void *, struct svc_req *);
+extern int sm_prog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define SM_STAT 1
+extern  struct sm_stat_res * sm_stat_1();
+extern  struct sm_stat_res * sm_stat_1_svc();
+#define SM_MON 2
+extern  struct sm_stat_res * sm_mon_1();
+extern  struct sm_stat_res * sm_mon_1_svc();
+#define SM_UNMON 3
+extern  struct sm_stat * sm_unmon_1();
+extern  struct sm_stat * sm_unmon_1_svc();
+#define SM_UNMON_ALL 4
+extern  struct sm_stat * sm_unmon_all_1();
+extern  struct sm_stat * sm_unmon_all_1_svc();
+#define SM_SIMU_CRASH 5
+extern  void * sm_simu_crash_1();
+extern  void * sm_simu_crash_1_svc();
+extern int sm_prog_1_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_sm_name (XDR *, sm_name*);
+extern  bool_t xdr_my_id (XDR *, my_id*);
+extern  bool_t xdr_mon_id (XDR *, mon_id*);
+extern  bool_t xdr_mon (XDR *, mon*);
+extern  bool_t xdr_sm_stat (XDR *, sm_stat*);
+extern  bool_t xdr_res (XDR *, res*);
+extern  bool_t xdr_sm_stat_res (XDR *, sm_stat_res*);
+extern  bool_t xdr_status (XDR *, status*);
+
+#else /* K&R C */
+extern bool_t xdr_sm_name ();
+extern bool_t xdr_my_id ();
+extern bool_t xdr_mon_id ();
+extern bool_t xdr_mon ();
+extern bool_t xdr_sm_stat ();
+extern bool_t xdr_res ();
+extern bool_t xdr_sm_stat_res ();
+extern bool_t xdr_status ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_SM_INTER_H_RPCGEN */
diff --git a/include/rpcsvc/sm_inter.x b/include/rpcsvc/sm_inter.x
new file mode 100644
index 0000000..767f0e0
--- /dev/null
+++ b/include/rpcsvc/sm_inter.x
@@ -0,0 +1,110 @@
+/*
+ * Status monitor protocol specification
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+program SM_PROG {
+	version SM_VERS  {
+		/* res_stat = stat_succ if status monitor agrees to monitor */
+		/* res_stat = stat_fail if status monitor cannot monitor */
+		/* if res_stat == stat_succ, state = state number of site sm_name */
+		struct sm_stat_res			 SM_STAT(struct sm_name) = 1;
+
+		/* res_stat = stat_succ if status monitor agrees to monitor */
+		/* res_stat = stat_fail if status monitor cannot monitor */
+		/* stat consists of state number of local site */
+		struct sm_stat_res			 SM_MON(struct mon) = 2;
+
+		/* stat consists of state number of local site */
+		struct sm_stat				 SM_UNMON(struct mon_id) = 3;
+
+		/* stat consists of state number of local site */
+		struct sm_stat				 SM_UNMON_ALL(struct my_id) = 4;
+
+		void					 SM_SIMU_CRASH(void) = 5;
+
+	} = 1;
+} = 100024;
+
+const	SM_MAXSTRLEN = 1024;
+
+struct sm_name {
+	string mon_name<SM_MAXSTRLEN>;
+};
+
+struct my_id {
+	string	 my_name<SM_MAXSTRLEN>;		/* name of the site initiating the monitoring request*/
+	int	my_prog;			/* rpc program # of the requesting process */
+	int	my_vers;			/* rpc version # of the requesting process */
+	int	my_proc;			/* rpc procedure # of the requesting process */
+};
+
+struct mon_id {
+	string	mon_name<SM_MAXSTRLEN>;		/* name of the site to be monitored */
+	struct my_id my_id;
+};
+
+
+struct mon{
+	struct mon_id mon_id;
+	opaque priv[16]; 		/* private information to store at monitor for requesting process */
+};
+
+
+/*
+ * state # of status monitor monotonically increases each time
+ * status of the site changes:
+ * an even number (>= 0) indicates the site is down and
+ * an odd number (> 0) indicates the site is up;
+ */
+struct sm_stat {
+	int state;		/* state # of status monitor */
+};
+
+enum res {
+	stat_succ = 0,		/* status monitor agrees to monitor */
+	stat_fail = 1		/* status monitor cannot monitor */
+};
+
+struct sm_stat_res {
+	res res_stat;
+	int state;
+};
+
+/*
+ * structure of the status message sent back by the status monitor
+ * when monitor site status changes
+ */
+struct status {
+	string mon_name<SM_MAXSTRLEN>;
+	int state;
+	opaque priv[16];		/* stored private information */
+};
diff --git a/include/rpcsvc/spray.h b/include/rpcsvc/spray.h
new file mode 100644
index 0000000..b19e402
--- /dev/null
+++ b/include/rpcsvc/spray.h
@@ -0,0 +1,81 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _SPRAY_H_RPCGEN
+#define _SPRAY_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SPRAYMAX 8845
+
+struct spraytimeval {
+	u_int sec;
+	u_int usec;
+};
+typedef struct spraytimeval spraytimeval;
+
+struct spraycumul {
+	u_int counter;
+	spraytimeval clock;
+};
+typedef struct spraycumul spraycumul;
+
+typedef struct {
+	u_int sprayarr_len;
+	char *sprayarr_val;
+} sprayarr;
+
+#define SPRAYPROG 100012
+#define SPRAYVERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define SPRAYPROC_SPRAY 1
+extern  void * sprayproc_spray_1(sprayarr *, CLIENT *);
+extern  void * sprayproc_spray_1_svc(sprayarr *, struct svc_req *);
+#define SPRAYPROC_GET 2
+extern  spraycumul * sprayproc_get_1(void *, CLIENT *);
+extern  spraycumul * sprayproc_get_1_svc(void *, struct svc_req *);
+#define SPRAYPROC_CLEAR 3
+extern  void * sprayproc_clear_1(void *, CLIENT *);
+extern  void * sprayproc_clear_1_svc(void *, struct svc_req *);
+extern int sprayprog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define SPRAYPROC_SPRAY 1
+extern  void * sprayproc_spray_1();
+extern  void * sprayproc_spray_1_svc();
+#define SPRAYPROC_GET 2
+extern  spraycumul * sprayproc_get_1();
+extern  spraycumul * sprayproc_get_1_svc();
+#define SPRAYPROC_CLEAR 3
+extern  void * sprayproc_clear_1();
+extern  void * sprayproc_clear_1_svc();
+extern int sprayprog_1_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_spraytimeval (XDR *, spraytimeval*);
+extern  bool_t xdr_spraycumul (XDR *, spraycumul*);
+extern  bool_t xdr_sprayarr (XDR *, sprayarr*);
+
+#else /* K&R C */
+extern bool_t xdr_spraytimeval ();
+extern bool_t xdr_spraycumul ();
+extern bool_t xdr_sprayarr ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_SPRAY_H_RPCGEN */
diff --git a/include/rpcsvc/spray.x b/include/rpcsvc/spray.x
new file mode 100644
index 0000000..68b7c48
--- /dev/null
+++ b/include/rpcsvc/spray.x
@@ -0,0 +1,84 @@
+/* @(#)spray.x	2.1 88/08/01 4.0 RPCSRC */
+
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Spray a server with packets
+ * Useful for testing flakiness of network interfaces
+ */
+
+const SPRAYMAX = 8845;	/* max amount can spray */
+
+/*
+ * GMT since 0:00, 1 January 1970
+ */
+struct spraytimeval {
+	unsigned int sec;
+	unsigned int usec;
+};
+
+/*
+ * spray statistics
+ */
+struct spraycumul {
+	unsigned int counter;
+	spraytimeval clock;
+};
+
+/*
+ * spray data
+ */
+typedef opaque sprayarr<SPRAYMAX>;
+
+program SPRAYPROG {
+	version SPRAYVERS {
+		/*
+		 * Just throw away the data and increment the counter
+		 * This call never returns, so the client should always
+		 * time it out.
+		 */
+		void
+		SPRAYPROC_SPRAY(sprayarr) = 1;
+
+		/*
+		 * Get the value of the counter and elapsed time  since
+		 * last CLEAR.
+		 */
+		spraycumul
+		SPRAYPROC_GET(void) = 2;
+
+		/*
+		 * Clear the counter and reset the elapsed time
+		 */
+		void
+		SPRAYPROC_CLEAR(void) = 3;
+	} = 1;
+} = 100012;
diff --git a/include/rpcsvc/yp.h b/include/rpcsvc/yp.h
new file mode 100644
index 0000000..968b74c
--- /dev/null
+++ b/include/rpcsvc/yp.h
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RPCSVC_YP_H__
+#define __RPCSVC_YP_H__
+
+#include <features.h>
+#include <rpc/rpc.h>
+
+#define YPMAXRECORD 1024
+#define YPMAXDOMAIN 64
+#define YPMAXMAP 64
+#define YPMAXPEER 64
+
+enum ypstat {
+	YP_TRUE = 1,
+	YP_NOMORE = 2,
+	YP_FALSE = 0,
+	YP_NOMAP = -1,
+	YP_NODOM = -2,
+	YP_NOKEY = -3,
+	YP_BADOP = -4,
+	YP_BADDB = -5,
+	YP_YPERR = -6,
+	YP_BADARGS = -7,
+	YP_VERS = -8,
+};
+typedef enum ypstat ypstat;
+
+enum ypxfrstat {
+	YPXFR_SUCC = 1,
+	YPXFR_AGE = 2,
+	YPXFR_NOMAP = -1,
+	YPXFR_NODOM = -2,
+	YPXFR_RSRC = -3,
+	YPXFR_RPC = -4,
+	YPXFR_MADDR = -5,
+	YPXFR_YPERR = -6,
+	YPXFR_BADARGS = -7,
+	YPXFR_DBM = -8,
+	YPXFR_FILE = -9,
+	YPXFR_SKEW = -10,
+	YPXFR_CLEAR = -11,
+	YPXFR_FORCE = -12,
+	YPXFR_XFRERR = -13,
+	YPXFR_REFUSED = -14,
+};
+typedef enum ypxfrstat ypxfrstat;
+
+typedef char *domainname;
+typedef char *mapname;
+typedef char *peername;
+
+typedef struct {
+  u_int keydat_len;
+  char *keydat_val;
+} keydat;
+
+typedef struct {
+  u_int valdat_len;
+  char *valdat_val;
+} valdat;
+
+struct ypmap_parms {
+  domainname domain;
+  mapname map;
+  u_int ordernum;
+  peername peer;
+};
+typedef struct ypmap_parms ypmap_parms;
+
+struct ypreq_key {
+  domainname domain;
+  mapname map;
+  keydat key;
+};
+typedef struct ypreq_key ypreq_key;
+
+struct ypreq_nokey {
+  domainname domain;
+  mapname map;
+};
+typedef struct ypreq_nokey ypreq_nokey;
+
+struct ypreq_xfr {
+  ypmap_parms map_parms;
+  u_int transid;
+  u_int prog;
+  u_int port;
+};
+typedef struct ypreq_xfr ypreq_xfr;
+
+struct ypresp_val {
+  ypstat stat;
+  valdat val;
+};
+typedef struct ypresp_val ypresp_val;
+
+struct ypresp_key_val {
+  ypstat stat;
+#ifdef STUPID_SUN_BUG
+  /* This is the form as distributed by Sun.  But even the Sun NIS
+     servers expect the values in the other order.  So their
+     implementation somehow must change the order internally.  We
+     don't want to follow this bad example since the user should be
+     able to use rpcgen on this file.  */
+  keydat key;
+  valdat val;
+#else
+  valdat val;
+  keydat key;
+#endif
+};
+typedef struct ypresp_key_val ypresp_key_val;
+
+struct ypresp_master {
+  ypstat stat;
+  peername peer;
+};
+typedef struct ypresp_master ypresp_master;
+
+struct ypresp_order {
+  ypstat stat;
+  u_int ordernum;
+};
+typedef struct ypresp_order ypresp_order;
+
+struct ypresp_all {
+  bool_t more;
+  union {
+    ypresp_key_val val;
+  } ypresp_all_u;
+};
+typedef struct ypresp_all ypresp_all;
+
+struct ypresp_xfr {
+  u_int transid;
+  ypxfrstat xfrstat;
+};
+typedef struct ypresp_xfr ypresp_xfr;
+
+struct ypmaplist {
+  mapname map;
+  struct ypmaplist *next;
+};
+typedef struct ypmaplist ypmaplist;
+
+struct ypresp_maplist {
+  ypstat stat;
+  ypmaplist *maps;
+};
+typedef struct ypresp_maplist ypresp_maplist;
+
+enum yppush_status {
+  YPPUSH_SUCC = 1,
+  YPPUSH_AGE = 2,
+  YPPUSH_NOMAP = -1,
+  YPPUSH_NODOM = -2,
+  YPPUSH_RSRC = -3,
+  YPPUSH_RPC = -4,
+  YPPUSH_MADDR = -5,
+  YPPUSH_YPERR = -6,
+  YPPUSH_BADARGS = -7,
+  YPPUSH_DBM = -8,
+  YPPUSH_FILE = -9,
+  YPPUSH_SKEW = -10,
+  YPPUSH_CLEAR = -11,
+  YPPUSH_FORCE = -12,
+  YPPUSH_XFRERR = -13,
+  YPPUSH_REFUSED = -14,
+};
+typedef enum yppush_status yppush_status;
+
+struct yppushresp_xfr {
+  u_int transid;
+  yppush_status status;
+};
+typedef struct yppushresp_xfr yppushresp_xfr;
+
+enum ypbind_resptype {
+  YPBIND_SUCC_VAL = 1,
+  YPBIND_FAIL_VAL = 2,
+};
+typedef enum ypbind_resptype ypbind_resptype;
+
+struct ypbind_binding {
+  char ypbind_binding_addr[4];
+  char ypbind_binding_port[2];
+};
+typedef struct ypbind_binding ypbind_binding;
+
+struct ypbind_resp {
+  ypbind_resptype ypbind_status;
+  union {
+    u_int ypbind_error;
+    ypbind_binding ypbind_bindinfo;
+  } ypbind_resp_u;
+};
+typedef struct ypbind_resp ypbind_resp;
+
+#define YPBIND_ERR_ERR 1
+#define YPBIND_ERR_NOSERV 2
+#define YPBIND_ERR_RESC 3
+
+struct ypbind_setdom {
+  domainname ypsetdom_domain;
+  ypbind_binding ypsetdom_binding;
+  u_int ypsetdom_vers;
+};
+typedef struct ypbind_setdom ypbind_setdom;
+
+__BEGIN_DECLS
+
+#define YPPROG 100004
+#define YPVERS 2
+
+#define YPPROC_NULL 0
+extern  void *ypproc_null_2 (void *, CLIENT *);
+extern  void *ypproc_null_2_svc (void *, struct svc_req *);
+#define YPPROC_DOMAIN 1
+extern  bool_t *ypproc_domain_2 (domainname *, CLIENT *);
+extern  bool_t *ypproc_domain_2_svc (domainname *, struct svc_req *);
+#define YPPROC_DOMAIN_NONACK 2
+extern  bool_t *ypproc_domain_nonack_2 (domainname *, CLIENT *);
+extern  bool_t *ypproc_domain_nonack_2_svc (domainname *, struct svc_req *);
+#define YPPROC_MATCH 3
+extern  ypresp_val *ypproc_match_2 (ypreq_key *, CLIENT *);
+extern  ypresp_val *ypproc_match_2_svc (ypreq_key *, struct svc_req *);
+#define YPPROC_FIRST 4
+extern  ypresp_key_val *ypproc_first_2 (ypreq_key *, CLIENT *);
+extern  ypresp_key_val *ypproc_first_2_svc (ypreq_key *, struct svc_req *);
+#define YPPROC_NEXT 5
+extern  ypresp_key_val *ypproc_next_2 (ypreq_key *, CLIENT *);
+extern  ypresp_key_val *ypproc_next_2_svc (ypreq_key *, struct svc_req *);
+#define YPPROC_XFR 6
+extern  ypresp_xfr *ypproc_xfr_2 (ypreq_xfr *, CLIENT *);
+extern  ypresp_xfr *ypproc_xfr_2_svc (ypreq_xfr *, struct svc_req *);
+#define YPPROC_CLEAR 7
+extern  void *ypproc_clear_2 (void *, CLIENT *);
+extern  void *ypproc_clear_2_svc (void *, struct svc_req *);
+#define YPPROC_ALL 8
+extern  ypresp_all *ypproc_all_2 (ypreq_nokey *, CLIENT *);
+extern  ypresp_all *ypproc_all_2_svc (ypreq_nokey *, struct svc_req *);
+#define YPPROC_MASTER 9
+extern  ypresp_master *ypproc_master_2 (ypreq_nokey *, CLIENT *);
+extern  ypresp_master *ypproc_master_2_svc (ypreq_nokey *, struct svc_req *);
+#define YPPROC_ORDER 10
+extern  ypresp_order *ypproc_order_2 (ypreq_nokey *, CLIENT *);
+extern  ypresp_order *ypproc_order_2_svc (ypreq_nokey *, struct svc_req *);
+#define YPPROC_MAPLIST 11
+extern  ypresp_maplist *ypproc_maplist_2 (domainname *, CLIENT *);
+extern  ypresp_maplist *ypproc_maplist_2_svc (domainname *, struct svc_req *);
+extern int ypprog_2_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+
+#define YPPUSH_XFRRESPPROG (0x40000000)
+#define YPPUSH_XFRRESPVERS 1
+
+#define YPPUSHPROC_NULL 0
+extern  void *yppushproc_null_1 (void *, CLIENT *);
+extern  void *yppushproc_null_1_svc (void *, struct svc_req *);
+#define YPPUSHPROC_XFRRESP 1
+extern  void *yppushproc_xfrresp_1 (yppushresp_xfr *, CLIENT *);
+extern  void *yppushproc_xfrresp_1_svc (yppushresp_xfr *, struct svc_req *);
+extern int yppush_xfrrespprog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+
+#define YPBINDPROG 100007
+#define YPBINDVERS 2
+
+#define YPBINDPROC_NULL 0
+extern  void *ypbindproc_null_2 (void *, CLIENT *);
+extern  void *ypbindproc_null_2_svc (void *, struct svc_req *);
+#define YPBINDPROC_DOMAIN 1
+extern  ypbind_resp *ypbindproc_domain_2 (domainname *, CLIENT *);
+extern  ypbind_resp *ypbindproc_domain_2_svc (domainname *, struct svc_req *);
+#define YPBINDPROC_SETDOM 2
+extern  void *ypbindproc_setdom_2 (ypbind_setdom *, CLIENT *);
+extern  void *ypbindproc_setdom_2_svc (ypbind_setdom *, struct svc_req *);
+extern int ypbindprog_2_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+
+extern  bool_t xdr_ypstat (XDR *, ypstat*);
+extern  bool_t xdr_ypxfrstat (XDR *, ypxfrstat*);
+extern  bool_t xdr_domainname (XDR *, domainname*);
+extern  bool_t xdr_mapname (XDR *, mapname*);
+extern  bool_t xdr_peername (XDR *, peername*);
+extern  bool_t xdr_keydat (XDR *, keydat*);
+extern  bool_t xdr_valdat (XDR *, valdat*);
+extern  bool_t xdr_ypmap_parms (XDR *, ypmap_parms*);
+extern  bool_t xdr_ypreq_key (XDR *, ypreq_key*);
+extern  bool_t xdr_ypreq_nokey (XDR *, ypreq_nokey*);
+extern  bool_t xdr_ypreq_xfr (XDR *, ypreq_xfr*);
+extern  bool_t xdr_ypresp_val (XDR *, ypresp_val*);
+extern  bool_t xdr_ypresp_key_val (XDR *, ypresp_key_val*);
+extern  bool_t xdr_ypresp_master (XDR *, ypresp_master*);
+extern  bool_t xdr_ypresp_order (XDR *, ypresp_order*);
+extern  bool_t xdr_ypresp_all (XDR *, ypresp_all*);
+extern  bool_t xdr_ypresp_xfr (XDR *, ypresp_xfr*);
+extern  bool_t xdr_ypmaplist (XDR *, ypmaplist*);
+extern  bool_t xdr_ypresp_maplist (XDR *, ypresp_maplist*);
+extern  bool_t xdr_yppush_status (XDR *, yppush_status*);
+extern  bool_t xdr_yppushresp_xfr (XDR *, yppushresp_xfr*);
+extern  bool_t xdr_ypbind_resptype (XDR *, ypbind_resptype*);
+extern  bool_t xdr_ypbind_binding (XDR *, ypbind_binding*);
+extern  bool_t xdr_ypbind_resp (XDR *, ypbind_resp*);
+extern  bool_t xdr_ypbind_setdom (XDR *, ypbind_setdom*);
+
+__END_DECLS
+
+#endif /* !__RPCSVC_YP_H__ */
diff --git a/include/rpcsvc/yp.x b/include/rpcsvc/yp.x
new file mode 100644
index 0000000..269ae6f
--- /dev/null
+++ b/include/rpcsvc/yp.x
@@ -0,0 +1,311 @@
+/* @(#)yp.x	2.1 88/08/01 4.0 RPCSRC */
+
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Protocol description file for the Yellow Pages Service
+ */
+
+const YPMAXRECORD = 1024;
+const YPMAXDOMAIN = 64;
+const YPMAXMAP = 64;
+const YPMAXPEER = 64;
+
+
+enum ypstat {
+	YP_TRUE		=  1,
+	YP_NOMORE	=  2,
+	YP_FALSE	=  0,
+	YP_NOMAP	= -1,
+	YP_NODOM	= -2,
+	YP_NOKEY	= -3,
+	YP_BADOP	= -4,
+	YP_BADDB	= -5,
+	YP_YPERR	= -6,
+	YP_BADARGS	= -7,
+	YP_VERS		= -8
+};
+
+
+enum ypxfrstat {
+	YPXFR_SUCC	=  1,
+	YPXFR_AGE	=  2,
+	YPXFR_NOMAP	= -1,
+	YPXFR_NODOM	= -2,
+	YPXFR_RSRC	= -3,
+	YPXFR_RPC	= -4,
+	YPXFR_MADDR	= -5,
+	YPXFR_YPERR	= -6,
+	YPXFR_BADARGS	= -7,
+	YPXFR_DBM	= -8,
+	YPXFR_FILE	= -9,
+	YPXFR_SKEW	= -10,
+	YPXFR_CLEAR	= -11,
+	YPXFR_FORCE	= -12,
+	YPXFR_XFRERR	= -13,
+	YPXFR_REFUSED	= -14
+};
+
+
+typedef string domainname<YPMAXDOMAIN>;
+typedef string mapname<YPMAXMAP>;
+typedef string peername<YPMAXPEER>;
+typedef opaque keydat<YPMAXRECORD>;
+typedef opaque valdat<YPMAXRECORD>;
+
+
+struct ypmap_parms {
+	domainname domain;
+	mapname map;
+	unsigned int ordernum;
+	peername peer;
+};
+
+struct ypreq_key {
+	domainname domain;
+	mapname map;
+	keydat key;
+};
+
+struct ypreq_nokey {
+	domainname domain;
+	mapname map;
+};
+
+struct ypreq_xfr {
+	ypmap_parms map_parms;
+	unsigned int transid;
+	unsigned int prog;
+	unsigned int port;
+};
+
+
+struct ypresp_val {
+	ypstat stat;
+	valdat val;
+};
+
+struct ypresp_key_val {
+	ypstat stat;
+#ifdef STUPID_SUN_BUG
+	/* This is the form as distributed by Sun.  But even the Sun NIS
+	   servers expect the values in the other order.  So their
+	   implementation somehow must change the order internally.  We
+	   don't want to follow this bad example since the user should be
+	   able to use rpcgen on this file.  */
+	keydat key;
+	valdat val;
+#else
+	valdat val;
+	keydat key;
+#endif
+};
+
+
+struct ypresp_master {
+	ypstat stat;
+	peername peer;
+};
+
+struct ypresp_order {
+	ypstat stat;
+	unsigned int ordernum;
+};
+
+union ypresp_all switch (bool more) {
+case TRUE:
+	ypresp_key_val val;
+case FALSE:
+	void;
+};
+
+struct ypresp_xfr {
+	unsigned int transid;
+	ypxfrstat xfrstat;
+};
+
+struct ypmaplist {
+	mapname map;
+	ypmaplist *next;
+};
+
+struct ypresp_maplist {
+	ypstat stat;
+	ypmaplist *maps;
+};
+
+enum yppush_status {
+	YPPUSH_SUCC	=  1,	/* Success */
+	YPPUSH_AGE	=  2,	/* Master's version not newer */
+	YPPUSH_NOMAP	= -1,	/* Can't find server for map */
+	YPPUSH_NODOM	= -2,	/* Domain not supported */
+	YPPUSH_RSRC	= -3,	/* Local resource alloc failure */
+	YPPUSH_RPC	= -4,	/* RPC failure talking to server */
+	YPPUSH_MADDR	= -5,	/* Can't get master address */
+	YPPUSH_YPERR	= -6,	/* YP server/map db error */
+	YPPUSH_BADARGS	= -7,	/* Request arguments bad */
+	YPPUSH_DBM	= -8,	/* Local dbm operation failed */
+	YPPUSH_FILE	= -9,	/* Local file I/O operation failed */
+	YPPUSH_SKEW	= -10,	/* Map version skew during transfer */
+	YPPUSH_CLEAR	= -11,	/* Can't send "Clear" req to local ypserv */
+	YPPUSH_FORCE	= -12,	/* No local order number in map  use -f flag. */
+	YPPUSH_XFRERR	= -13,	/* ypxfr error */
+	YPPUSH_REFUSED	= -14	/* Transfer request refused by ypserv */
+};
+
+struct yppushresp_xfr {
+	unsigned transid;
+	yppush_status status;
+};
+
+/*
+ * Response structure and overall result status codes.  Success and failure
+ * represent two separate response message types.
+ */
+
+enum ypbind_resptype {
+	YPBIND_SUCC_VAL = 1,
+	YPBIND_FAIL_VAL = 2
+};
+
+struct ypbind_binding {
+    opaque ypbind_binding_addr[4]; /* In network order */
+    opaque ypbind_binding_port[2]; /* In network order */
+};
+
+union ypbind_resp switch (ypbind_resptype ypbind_status) {
+case YPBIND_FAIL_VAL:
+	unsigned ypbind_error;
+case YPBIND_SUCC_VAL:
+	ypbind_binding ypbind_bindinfo;
+};
+
+/* Detailed failure reason codes for response field ypbind_error*/
+
+const YPBIND_ERR_ERR    = 1;	/* Internal error */
+const YPBIND_ERR_NOSERV = 2;	/* No bound server for passed domain */
+const YPBIND_ERR_RESC   = 3;	/* System resource allocation failure */
+
+
+/*
+ * Request data structure for ypbind "Set domain" procedure.
+ */
+struct ypbind_setdom {
+	domainname ypsetdom_domain;
+	ypbind_binding ypsetdom_binding;
+	unsigned ypsetdom_vers;
+};
+
+
+/*
+ * YP access protocol
+ */
+program YPPROG {
+	version YPVERS {
+		void
+		YPPROC_NULL(void) = 0;
+
+		bool
+		YPPROC_DOMAIN(domainname) = 1;
+
+		bool
+		YPPROC_DOMAIN_NONACK(domainname) = 2;
+
+		ypresp_val
+		YPPROC_MATCH(ypreq_key) = 3;
+
+		ypresp_key_val
+		YPPROC_FIRST(ypreq_key) = 4;
+
+		ypresp_key_val
+		YPPROC_NEXT(ypreq_key) = 5;
+
+		ypresp_xfr
+		YPPROC_XFR(ypreq_xfr) = 6;
+
+		void
+		YPPROC_CLEAR(void) = 7;
+
+		ypresp_all
+		YPPROC_ALL(ypreq_nokey) = 8;
+
+		ypresp_master
+		YPPROC_MASTER(ypreq_nokey) = 9;
+
+		ypresp_order
+		YPPROC_ORDER(ypreq_nokey) = 10;
+
+		ypresp_maplist
+		YPPROC_MAPLIST(domainname) = 11;
+	} = 2;
+} = 100004;
+
+
+/*
+ * YPPUSHPROC_XFRRESP is the callback routine for result of YPPROC_XFR
+ */
+program YPPUSH_XFRRESPPROG {
+	version YPPUSH_XFRRESPVERS {
+		void
+		YPPUSHPROC_NULL(void) = 0;
+
+#ifdef STUPID_SUN_BUG
+		/* This is the form as distributed by Sun.  But even
+		   the Sun NIS servers expect the values in the other
+		   order.  So their implementation somehow must change
+		   the order internally.  We don't want to follow this
+		   bad example since the user should be able to use
+		   rpcgen on this file.  */
+		yppushresp_xfr
+		YPPUSHPROC_XFRRESP(void) = 1;
+#else
+		void
+		YPPUSHPROC_XFRRESP(yppushresp_xfr) = 1;
+#endif
+	} = 1;
+} = 0x40000000;	/* transient: could be anything up to 0x5fffffff */
+
+/*
+ * YP binding protocol
+ */
+program YPBINDPROG {
+	version YPBINDVERS {
+		void
+		YPBINDPROC_NULL(void) = 0;
+
+		ypbind_resp
+		YPBINDPROC_DOMAIN(domainname) = 1;
+
+		void
+		YPBINDPROC_SETDOM(ypbind_setdom) = 2;
+	} = 2;
+} = 100007;
diff --git a/include/rpcsvc/yp_prot.h b/include/rpcsvc/yp_prot.h
new file mode 100644
index 0000000..ae0db36
--- /dev/null
+++ b/include/rpcsvc/yp_prot.h
@@ -0,0 +1,366 @@
+/*
+ * This file contains symbols and structures defining the rpc protocol
+ * between the NIS clients and the NIS servers.  The servers
+ * are the NIS database servers, and the NIS binders.
+ */
+
+#ifndef _RPCSVC_YP_PROT_H
+#define _RPCSVC_YP_PROT_H
+
+#include <features.h>
+
+#include <rpc/rpc.h>
+#include <rpcsvc/ypclnt.h>
+
+__BEGIN_DECLS
+
+/*
+ * The following procedures are supported by the protocol:
+ *
+ * YPPROC_NULL() returns () takes nothing, returns nothing.  This indicates
+ * that the NIS server is alive.
+ *
+ * YPPROC_DOMAIN (char *) returns (bool_t) TRUE.  Indicates that the
+ * responding NIS server does serve the named domain; FALSE indicates no
+ * support.
+ *
+ * YPPROC_DOMAIN_NONACK (char *) returns (TRUE) if the NIS server does serve
+ * the named domain, otherwise does not return.  Used in the broadcast case.
+ *
+ * YPPROC_MATCH (struct ypreq_key) returns (struct ypresp_val).  Returns the
+ * right-hand value for a passed left-hand key, within a named map and
+ * domain.
+ *
+ * YPPROC_FIRST (struct ypreq_nokey) returns (struct ypresp_key_val).
+ * Returns the first key-value pair from a named domain and map.
+ *
+ * YPPROC_NEXT (struct ypreq_key) returns (struct ypresp_key_val).  Returns
+ * the key-value pair following a passed key-value pair within a named
+ * domain and map.
+ *
+ * YPPROC_XFR (struct ypreq_xfr) returns nothing.  Indicates to a server that
+ * a map should be updated.
+ *
+ * YPPROC_CLEAR	takes nothing, returns nothing.  Instructs a NIS server to
+ * close the current map, so that old versions of the disk file don't get
+ * held open.
+ *
+ * YPPROC_ALL (struct ypreq_nokey), returns
+ * 	union switch (bool_t more) {
+ *		TRUE:	(struct ypresp_key_val);
+ *		FALSE:	(struct) {};
+ *	}
+ *
+ * YPPROC_MASTER (struct ypreq_nokey), returns (ypresp_master)
+ *
+ * YPPROC_ORDER (struct ypreq_nokey), returns (ypresp_order)
+ *
+ * YPPROC_MAPLIST (char *), returns (struct ypmaplist *)
+ */
+
+/* Program and version symbols, magic numbers */
+
+#define YPPROG		100004
+#define YPVERS		2
+#define YPVERS_ORIG	1
+#define YPMAXRECORD	1024
+#define YPMAXDOMAIN	64 /* XXX orig. yp_prot.h defines 256 */
+#define YPMAXMAP	64
+#define YPMAXPEER	64 /* XXX orig. yp_prot.h defines 256 */
+
+/* byte size of a large NIS packet */
+#define YPMSGSZ		1600
+
+typedef struct {
+  u_int keydat_len;
+  char *keydat_val;
+} keydat_t;
+
+typedef struct {
+  u_int valdat_len;
+  char *valdat_val;
+} valdat_t;
+
+struct ypmap_parms {
+  char *domain;			/* Null string means not available */
+  char *map;			/* Null string means not available */
+  unsigned int ordernum;	/* 0 means not available */
+  char *owner;			/* Null string means not available */
+};
+
+/*
+ * Request parameter structures
+ */
+
+struct ypreq_key {
+  const char *domain;
+  const char *map;
+  keydat_t keydat;
+};
+
+struct ypreq_nokey {
+  char *domain;
+  char *map;
+};
+
+struct ypreq_xfr {
+  struct ypmap_parms map_parms;
+  u_int transid;
+  u_int proto;
+  u_int port;
+};
+
+#define ypxfr_domain map_parms.domain
+#define ypxfr_map map_parms.map
+#define ypxfr_ordernum map_parms.ordernum
+#define ypxfr_owner map_parms.owner
+
+/* Return status values */
+
+enum ypstat {
+  YP_TRUE = 1,		/* General purpose success code */
+#define YP_TRUE YP_TRUE
+  YP_NOMORE = 2,	/* No more entries in map */
+#define YP_NOMORE YP_NOMORE
+  YP_FALSE = 0,		/* General purpose failure code */
+#define YP_FALSE YP_FALSE
+  YP_NOMAP = -1,	/* No such map in domain */
+#define YP_NOMAP YP_NOMAP
+  YP_NODOM = -2,	/* Domain not supported */
+#define YP_NODOM YP_NODOM
+  YP_NOKEY = -3,	/* No such key in map */
+#define YP_NOKEY YP_NOKEY
+  YP_BADOP = -4,	/* Invalid operation */
+#define YP_BADOP YP_BADOP
+  YP_BADDB = -5,	/* Server data base is bad */
+#define YP_BADDB YP_BADDB
+  YP_YPERR = -6,	/* NIS server error */
+#define YP_YPERR YP_YPERR
+  YP_BADARGS = -7,	/* Request arguments bad */
+#define YP_BADARGS YP_BADARGS
+  YP_VERS = -8,		/* NIS server version mismatch - server can't supply
+			   requested service. */
+#define YP_VERS YP_VERS
+};
+
+/*
+ * Response parameter structures
+ */
+
+typedef enum ypstat ypstat;
+
+struct ypresp_val {
+  ypstat status;
+  valdat_t valdat;
+};
+
+struct ypresp_key_val {
+  ypstat status;
+#ifdef STUPID_SUN_BUG
+  /* This is the form as distributed by Sun.  But even the Sun NIS
+     servers expect the values in the other order.  So their
+     implementation somehow must change the order internally.  We
+     don't want to follow this bad example since the user should be
+     able to use rpcgen on this file.  */
+  keydat_t keydat;
+  valdat_t valdat;
+#else
+  valdat_t valdat;
+  keydat_t keydat;
+#endif
+};
+
+struct ypresp_master {
+  ypstat status;
+  char *master;
+};
+
+struct ypresp_order {
+  ypstat status;
+  u_int ordernum;
+};
+
+struct ypmaplist {
+  char *map;
+#define ypml_name map
+  struct ypmaplist *next;
+#define ypml_next next
+};
+
+struct ypresp_maplist {
+  ypstat status;
+  struct ypmaplist *list;
+};
+
+/*
+ * Procedure symbols.  YPPROC_NULL, YPPROC_DOMAIN, and YPPROC_DOMAIN_NONACK
+ * must keep the same values (0, 1, and 2) that they had in the first version
+ * of the protocol.
+ */
+
+#define YPPROC_NULL	0
+#define YPPROC_DOMAIN	1
+#define YPPROC_DOMAIN_NONACK 2
+#define YPPROC_MATCH	3
+#define YPPROC_FIRST	4
+#define YPPROC_NEXT	5
+#define YPPROC_XFR	6
+#define YPPROC_CLEAR	7
+#define YPPROC_ALL	8
+#define YPPROC_MASTER	9
+#define YPPROC_ORDER	10
+#define YPPROC_MAPLIST	11
+#define	YPPROC_NEWXFR	12
+
+/*
+ *		Protocol between clients and NIS binder servers
+ */
+
+/*
+ * The following procedures are supported by the protocol:
+ *
+ * YPBINDPROC_NULL() returns ()
+ * 	takes nothing, returns nothing
+ *
+ * YPBINDPROC_DOMAIN takes (char *) returns (struct ypbind_resp)
+ *
+ * YPBINDPROC_SETDOM takes (struct ypbind_setdom) returns nothing
+ */
+
+/* Program and version symbols, magic numbers */
+
+#define YPBINDPROG		100007
+#define YPBINDVERS		2
+#define YPBINDVERS_ORIG		1
+
+/* Procedure symbols */
+
+#define YPBINDPROC_NULL		0
+#define YPBINDPROC_DOMAIN	1
+#define YPBINDPROC_SETDOM	2
+/*
+ * Response structure and overall result status codes.  Success and failure
+ * represent two separate response message types.
+ */
+
+enum ypbind_resptype {YPBIND_SUCC_VAL = 1, YPBIND_FAIL_VAL = 2};
+
+struct ypbind_binding {
+  struct in_addr ypbind_binding_addr;	        /* In network order */
+  unsigned short int ypbind_binding_port;	/* In network order */
+};
+
+struct ypbind_resp {
+  enum ypbind_resptype ypbind_status;
+  union {
+    u_int ypbind_error;
+    struct ypbind_binding ypbind_bindinfo;
+  } ypbind_respbody;
+};
+
+
+/* Detailed failure reason codes for response field ypbind_error*/
+
+#define YPBIND_ERR_ERR 1		/* Internal error */
+#define YPBIND_ERR_NOSERV 2		/* No bound server for passed domain */
+#define YPBIND_ERR_RESC 3		/* System resource allocation failure */
+
+/*
+ * Request data structure for ypbind "Set domain" procedure.
+ */
+struct ypbind_setdom {
+  char *ypsetdom_domain;
+  struct ypbind_binding ypsetdom_binding;
+  u_int ypsetdom_vers;
+};
+#define ypsetdom_addr ypsetdom_binding.ypbind_binding_addr
+#define ypsetdom_port ypsetdom_binding.ypbind_binding_port
+
+/*
+ *		Protocol between clients (ypxfr, only) and yppush
+ *		yppush speaks a protocol in the transient range, which
+ *		is supplied to ypxfr as a command-line parameter when it
+ *		is activated by ypserv.
+ */
+#define YPPUSHVERS		1
+#define YPPUSHVERS_ORIG		1
+
+/* Procedure symbols */
+
+#define YPPUSHPROC_NULL		0
+#define YPPUSHPROC_XFRRESP	1
+
+/* Status values for yppushresp_xfr.status */
+
+enum yppush_status {
+  YPPUSH_SUCC = 1,		/* Success */
+#define YPPUSH_SUCC	YPPUSH_SUCC
+  YPPUSH_AGE = 2,		/* Master's version not newer */
+#define YPPUSH_AGE	YPPUSH_AGE
+  YPPUSH_NOMAP = -1,		/* Can't find server for map */
+#define YPPUSH_NOMAP 	YPPUSH_NOMAP
+  YPPUSH_NODOM = -2,		/* Domain not supported */
+#define YPPUSH_NODOM 	YPPUSH_NODOM
+  YPPUSH_RSRC = -3,		/* Local resouce alloc failure */
+#define YPPUSH_RSRC 	YPPUSH_RSRC
+  YPPUSH_RPC = -4,		/* RPC failure talking to server */
+#define YPPUSH_RPC 	YPPUSH_RPC
+  YPPUSH_MADDR = -5,		/* Can't get master address */
+#define YPPUSH_MADDR	YPPUSH_MADDR
+  YPPUSH_YPERR = -6,		/* NIS server/map db error */
+#define YPPUSH_YPERR 	YPPUSH_YPERR
+  YPPUSH_BADARGS = -7,		/* Request arguments bad */
+#define YPPUSH_BADARGS 	YPPUSH_BADARGS
+  YPPUSH_DBM = -8,		/* Local dbm operation failed */
+#define YPPUSH_DBM	YPPUSH_DBM
+  YPPUSH_FILE = -9,		/* Local file I/O operation failed */
+#define YPPUSH_FILE	YPPUSH_FILE
+  YPPUSH_SKEW = -10,		/* Map version skew during transfer */
+#define YPPUSH_SKEW	YPPUSH_SKEW
+  YPPUSH_CLEAR = -11,		/* Can't send "Clear" req to local ypserv */
+#define YPPUSH_CLEAR	YPPUSH_CLEAR
+  YPPUSH_FORCE = -12,		/* No local order number in map - use -f flag*/
+#define YPPUSH_FORCE	YPPUSH_FORCE
+  YPPUSH_XFRERR = -13,		/* ypxfr error */
+#define YPPUSH_XFRERR	YPPUSH_XFRERR
+  YPPUSH_REFUSED = -14,		/* Transfer request refused by ypserv */
+#define YPPUSH_REFUSED	YPPUSH_REFUSED
+  YPPUSH_NOALIAS = -15		/* Alias not found for map or domain */
+#define	YPPUSH_NOALIAS	YPPUSH_NOALIAS
+};
+typedef enum yppush_status yppush_status;
+
+struct yppushresp_xfr {
+  u_int transid;
+  yppush_status status;
+};
+
+struct ypresp_all {
+  bool_t more;
+  union {
+    struct ypresp_key_val val;
+  } ypresp_all_u;
+};
+
+extern bool_t xdr_ypreq_key (XDR *__xdrs, struct ypreq_key * __objp);
+extern bool_t xdr_ypreq_nokey (XDR *__xdrs, struct ypreq_nokey * __objp);
+extern bool_t xdr_ypreq_xfr (XDR *__xdrs, struct ypreq_xfr * __objp);
+extern bool_t xdr_ypresp_val (XDR *__xdrs, struct ypresp_val * __objp);
+extern bool_t xdr_ypresp_key_val (XDR *__xdrs, struct ypresp_key_val * __objp);
+extern bool_t xdr_ypbind_resp (XDR *__xdrs, struct ypbind_resp * __objp);
+extern bool_t xdr_ypbind_setdom (XDR *__xdrs, struct ypbind_setdom * __objp);
+extern bool_t xdr_ypmap_parms (XDR *__xdrs, struct ypmap_parms * __objp);
+extern bool_t xdr_yppushresp_xfr (XDR *__xdrs, struct yppushresp_xfr * __objp);
+extern bool_t xdr_ypresp_order (XDR *__xdrs, struct ypresp_order  * __objp);
+extern bool_t xdr_ypresp_master (XDR *__xdrs, struct ypresp_master * __objp);
+extern bool_t xdr_ypall (XDR *__xdrs, struct ypall_callback * __objp);
+extern bool_t xdr_ypresp_maplist (XDR *__xdrs, struct ypresp_maplist * __objp);
+extern bool_t xdr_ypbind_binding (XDR *__xdrs, struct ypbind_binding * __objp);
+extern bool_t xdr_ypbind_resptype (XDR *__xdrs, enum ypbind_resptype * __objp);
+extern bool_t xdr_ypstat (XDR *__xdrs, enum ypbind_resptype * __objp);
+extern bool_t xdr_ypresp_all (XDR *__xdrs, struct ypresp_all  * __objp);
+extern bool_t xdr_domainname (XDR *__xdrs, char ** __objp);
+
+__END_DECLS
+
+#endif	/* _RPCSVC_YP_PROT_H */
diff --git a/include/rpcsvc/ypclnt.h b/include/rpcsvc/ypclnt.h
new file mode 100644
index 0000000..3217299
--- /dev/null
+++ b/include/rpcsvc/ypclnt.h
@@ -0,0 +1,88 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Thorsten Kukuk <kukuk@suse.de>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#ifndef	__RPCSVC_YPCLNT_H__
+#define	__RPCSVC_YPCLNT_H__
+
+#include <features.h>
+
+/* Some defines */
+#define YPERR_SUCCESS	0		/* There is no error */
+#define	YPERR_BADARGS	1		/* Args to function are bad */
+#define	YPERR_RPC 	2		/* RPC failure */
+#define	YPERR_DOMAIN	3		/* Can't bind to a server with this domain */
+#define	YPERR_MAP	4		/* No such map in server's domain */
+#define	YPERR_KEY	5		/* No such key in map */
+#define	YPERR_YPERR	6		/* Internal yp server or client error */
+#define	YPERR_RESRC	7		/* Local resource allocation failure */
+#define	YPERR_NOMORE	8		/* No more records in map database */
+#define	YPERR_PMAP	9		/* Can't communicate with portmapper */
+#define	YPERR_YPBIND	10		/* Can't communicate with ypbind */
+#define	YPERR_YPSERV	11		/* Can't communicate with ypserv */
+#define	YPERR_NODOM	12		/* Local domain name not set */
+#define	YPERR_BADDB	13		/* yp data base is bad */
+#define	YPERR_VERS	14		/* YP version mismatch */
+#define	YPERR_ACCESS	15		/* Access violation */
+#define	YPERR_BUSY	16		/* Database is busy */
+
+/* Types of update operations */
+#define	YPOP_CHANGE	1		/* Change, do not add */
+#define	YPOP_INSERT	2		/* Add, do not change */
+#define	YPOP_DELETE	3		/* Delete this entry */
+#define	YPOP_STORE	4		/* Add, or change */
+
+__BEGIN_DECLS
+
+/* struct ypall_callback * is the arg which must be passed to yp_all.  */
+struct ypall_callback
+  {
+    int (*foreach) (int __status, char *__key, int __keylen,
+		    char *__val, int __vallen, char *__data);
+    char *data;
+  };
+
+/* External NIS client function references.  */
+extern int yp_bind (const char *) __THROW;
+extern void yp_unbind (const char *) __THROW;
+extern int yp_get_default_domain (char **) __THROW;
+extern int yp_match (const char *, const char *, const char *,
+		     const int, char **, int *) __THROW;
+extern int yp_first (const char *, const char *, char **,
+		     int *, char **, int *) __THROW;
+extern int yp_next (const char *, const char *, const char *,
+		    const int, char **, int *, char **, int *) __THROW;
+extern int yp_master (const char *, const char *, char **) __THROW;
+extern int yp_order (const char *, const char *, unsigned int *) __THROW;
+extern int yp_all (const char *, const char *,
+		   const struct ypall_callback *) __THROW;
+extern const char *yperr_string (const int) __THROW;
+extern const char *ypbinderr_string (const int) __THROW;
+extern int ypprot_err (const int) __THROW;
+extern int yp_update (char *, char *, unsigned int,  char *,
+		      int, char *, int) __THROW;
+#if 0
+extern int yp_maplist (const char *, struct ypmaplist **) __THROW;
+#endif
+
+/* This functions exists only under BSD and Linux systems.  */
+extern int __yp_check (char **) __THROW;
+
+__END_DECLS
+
+#endif	/* __RPCSVC_YPCLNT_H__ */
diff --git a/include/rpcsvc/yppasswd.h b/include/rpcsvc/yppasswd.h
new file mode 100644
index 0000000..adbe9b3
--- /dev/null
+++ b/include/rpcsvc/yppasswd.h
@@ -0,0 +1,66 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _YPPASSWD_H_RPCGEN
+#define _YPPASSWD_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+struct passwd {
+	char *pw_name;
+	char *pw_passwd;
+	int pw_uid;
+	int pw_gid;
+	char *pw_gecos;
+	char *pw_dir;
+	char *pw_shell;
+};
+typedef struct passwd passwd;
+
+struct yppasswd {
+	char *oldpass;
+	passwd newpw;
+};
+typedef struct yppasswd yppasswd;
+
+#define YPPASSWDPROG 100009
+#define YPPASSWDVERS 1
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define YPPASSWDPROC_UPDATE 1
+extern  int * yppasswdproc_update_1(yppasswd *, CLIENT *);
+extern  int * yppasswdproc_update_1_svc(yppasswd *, struct svc_req *);
+extern int yppasswdprog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define YPPASSWDPROC_UPDATE 1
+extern  int * yppasswdproc_update_1();
+extern  int * yppasswdproc_update_1_svc();
+extern int yppasswdprog_1_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_passwd (XDR *, passwd*);
+extern  bool_t xdr_yppasswd (XDR *, yppasswd*);
+
+#else /* K&R C */
+extern bool_t xdr_passwd ();
+extern bool_t xdr_yppasswd ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_YPPASSWD_H_RPCGEN */
diff --git a/include/rpcsvc/yppasswd.x b/include/rpcsvc/yppasswd.x
new file mode 100644
index 0000000..34e3efe
--- /dev/null
+++ b/include/rpcsvc/yppasswd.x
@@ -0,0 +1,61 @@
+/* @(#)yppasswd.x	2.1 88/08/01 4.0 RPCSRC */
+
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * YP password update protocol
+ * Requires unix authentication
+ */
+program YPPASSWDPROG {
+	version YPPASSWDVERS {
+		/*
+		 * Update my passwd entry
+		 */
+		int
+		YPPASSWDPROC_UPDATE(yppasswd) = 1;
+	} = 1;
+} = 100009;
+
+
+struct passwd {
+	string pw_name<>;	/* username */
+	string pw_passwd<>;	/* encrypted password */
+	int pw_uid;		/* user id */
+	int pw_gid;		/* group id */
+	string pw_gecos<>;	/* in real life name */
+	string pw_dir<>;	/* home directory */
+	string pw_shell<>;	/* default shell */
+};
+
+struct yppasswd {
+	string oldpass<>;	/* unencrypted old password */
+	passwd newpw;		/* new passwd entry */
+};
diff --git a/include/rpcsvc/ypupd.h b/include/rpcsvc/ypupd.h
new file mode 100644
index 0000000..d07fd4d
--- /dev/null
+++ b/include/rpcsvc/ypupd.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2010, Oracle America, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials
+ *       provided with the distribution.
+ *     * Neither the name of the "Oracle America, Inc." nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/* from @(#)ypupdate_prot.x	1.3 91/03/11 TIRPC 1.0 */
+
+#ifndef __RPCSVC_YPUPD_H__
+#define __RPCSVC_YPUPD_H__
+
+#include <features.h>
+
+#include <rpc/rpc.h>
+
+#define MAXMAPNAMELEN 255
+#define MAXYPDATALEN 1023
+#define MAXERRMSGLEN 255
+
+__BEGIN_DECLS
+
+typedef struct {
+	u_int yp_buf_len;
+	char *yp_buf_val;
+} yp_buf;
+
+extern  bool_t xdr_yp_buf (XDR *, yp_buf*);
+
+struct ypupdate_args {
+	char *mapname;
+	yp_buf key;
+	yp_buf datum;
+};
+typedef struct ypupdate_args ypupdate_args;
+
+extern  bool_t xdr_ypupdate_args (XDR *, ypupdate_args*);
+
+struct ypdelete_args {
+	char *mapname;
+	yp_buf key;
+};
+typedef struct ypdelete_args ypdelete_args;
+
+extern  bool_t xdr_ypdelete_args (XDR *, ypdelete_args*);
+
+#define YPU_PROG 100028
+#define YPU_VERS 1
+
+#define YPU_CHANGE 1
+extern  u_int * ypu_change_1 (ypupdate_args *, CLIENT *);
+extern  u_int * ypu_change_1_svc (ypupdate_args *, struct svc_req *);
+#define YPU_INSERT 2
+extern  u_int * ypu_insert_1 (ypupdate_args *, CLIENT *);
+extern  u_int * ypu_insert_1_svc (ypupdate_args *, struct svc_req *);
+#define YPU_DELETE 3
+extern  u_int * ypu_delete_1 (ypdelete_args *, CLIENT *);
+extern  u_int * ypu_delete_1_svc (ypdelete_args *, struct svc_req *);
+#define YPU_STORE 4
+extern  u_int * ypu_store_1 (ypupdate_args *, CLIENT *);
+extern  u_int * ypu_store_1_svc (ypupdate_args *, struct svc_req *);
+
+__END_DECLS
+
+#endif /* !__RPCSVC_YPUPD_H__ */
diff --git a/include/sched.h b/include/sched.h
new file mode 100644
index 0000000..f7da255
--- /dev/null
+++ b/include/sched.h
@@ -0,0 +1,126 @@
+/* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SCHED_H
+#define	_SCHED_H	1
+
+#include <features.h>
+
+/* Get type definitions.  */
+#include <bits/types.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+#define __need_time_t
+#define __need_timespec
+#include <time.h>
+
+#ifndef __pid_t_defined
+typedef __pid_t pid_t;
+# define __pid_t_defined
+#endif
+
+
+/* Get system specific constant and data structure definitions.  */
+#include <bits/sched.h>
+/* Define the real names for the elements of `struct sched_param'.  */
+#define sched_priority	__sched_priority
+
+
+__BEGIN_DECLS
+
+/* Set scheduling parameters for a process.  */
+extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
+     __THROW;
+
+/* Retrieve scheduling parameters for a particular process.  */
+extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __THROW;
+
+/* Set scheduling algorithm and/or parameters for a process.  */
+extern int sched_setscheduler (__pid_t __pid, int __policy,
+			       const struct sched_param *__param) __THROW;
+
+/* Retrieve scheduling algorithm for a particular purpose.  */
+extern int sched_getscheduler (__pid_t __pid) __THROW;
+
+/* Yield the processor.  */
+extern int sched_yield (void) __THROW;
+
+/* Get maximum priority value for a scheduler.  */
+extern int sched_get_priority_max (int __algorithm) __THROW;
+
+/* Get minimum priority value for a scheduler.  */
+extern int sched_get_priority_min (int __algorithm) __THROW;
+
+/* Get the SCHED_RR interval for the named process.  */
+extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __THROW;
+
+
+#ifdef __USE_GNU
+/* Access macros for `cpu_set'.  */
+# define CPU_SETSIZE __CPU_SETSIZE
+# define CPU_SET(cpu, cpusetp)	 __CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)
+# define CPU_CLR(cpu, cpusetp)	 __CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)
+# define CPU_ISSET(cpu, cpusetp) __CPU_ISSET_S (cpu, sizeof (cpu_set_t), \
+						cpusetp)
+# define CPU_ZERO(cpusetp)	 __CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)
+# define CPU_COUNT(cpusetp)	 __CPU_COUNT_S (sizeof (cpu_set_t), cpusetp)
+
+# define CPU_SET_S(cpu, setsize, cpusetp)   __CPU_SET_S (cpu, setsize, cpusetp)
+# define CPU_CLR_S(cpu, setsize, cpusetp)   __CPU_CLR_S (cpu, setsize, cpusetp)
+# define CPU_ISSET_S(cpu, setsize, cpusetp) __CPU_ISSET_S (cpu, setsize, \
+							   cpusetp)
+# define CPU_ZERO_S(setsize, cpusetp)	    __CPU_ZERO_S (setsize, cpusetp)
+# define CPU_COUNT_S(setsize, cpusetp)	    __CPU_COUNT_S (setsize, cpusetp)
+
+# define CPU_EQUAL(cpusetp1, cpusetp2) \
+  __CPU_EQUAL_S (sizeof (cpu_set_t), cpusetp1, cpusetp2)
+# define CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+  __CPU_EQUAL_S (setsize, cpusetp1, cpusetp2)
+
+# define CPU_AND(destset, srcset1, srcset2) \
+  __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &)
+# define CPU_OR(destset, srcset1, srcset2) \
+  __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)
+# define CPU_XOR(destset, srcset1, srcset2) \
+  __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)
+# define CPU_AND_S(setsize, destset, srcset1, srcset2) \
+  __CPU_OP_S (setsize, destset, srcset1, srcset2, &)
+# define CPU_OR_S(setsize, destset, srcset1, srcset2) \
+  __CPU_OP_S (setsize, destset, srcset1, srcset2, |)
+# define CPU_XOR_S(setsize, destset, srcset1, srcset2) \
+  __CPU_OP_S (setsize, destset, srcset1, srcset2, ^)
+
+# define CPU_ALLOC_SIZE(count) __CPU_ALLOC_SIZE (count)
+# define CPU_ALLOC(count) __CPU_ALLOC (count)
+# define CPU_FREE(cpuset) __CPU_FREE (cpuset)
+
+
+/* Set the CPU affinity for a task */
+extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
+			      const cpu_set_t *__cpuset) __THROW;
+
+/* Get the CPU affinity for a task */
+extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
+			      cpu_set_t *__cpuset) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* sched.h */
diff --git a/include/search.h b/include/search.h
new file mode 100644
index 0000000..e09790c
--- /dev/null
+++ b/include/search.h
@@ -0,0 +1,174 @@
+/* Declarations for System V style searching functions.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SEARCH_H
+#define	_SEARCH_H 1
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+__BEGIN_DECLS
+
+#if defined __USE_SVID || defined __USE_XOPEN_EXTENDED
+/* Prototype structure for a linked-list data structure.
+   This is the type used by the `insque' and `remque' functions.  */
+
+# ifdef __USE_GNU
+struct qelem
+  {
+    struct qelem *q_forw;
+    struct qelem *q_back;
+    char q_data[1];
+  };
+# endif
+
+
+/* Insert ELEM into a doubly-linked list, after PREV.  */
+extern void insque (void *__elem, void *__prev) __THROW;
+
+/* Unlink ELEM from the doubly-linked list that it is in.  */
+extern void remque (void *__elem) __THROW;
+#endif
+
+
+/* For use with hsearch(3).  */
+#ifndef __COMPAR_FN_T
+# define __COMPAR_FN_T
+typedef int (*__compar_fn_t) (const void *, const void *);
+
+# ifdef	__USE_GNU
+typedef __compar_fn_t comparison_fn_t;
+# endif
+#endif
+
+/* Action which shall be performed in the call the hsearch.  */
+typedef enum
+  {
+    FIND,
+    ENTER
+  }
+ACTION;
+
+typedef struct entry
+  {
+    char *key;
+    void *data;
+  }
+ENTRY;
+
+/* Opaque type for internal use.  */
+struct _ENTRY;
+
+/* Family of hash table handling functions.  The functions also
+   have reentrant counterparts ending with _r.  The non-reentrant
+   functions all work on a signle internal hashing table.  */
+
+/* Search for entry matching ITEM.key in internal hash table.  If
+   ACTION is `FIND' return found entry or signal error by returning
+   NULL.  If ACTION is `ENTER' replace existing data (if any) with
+   ITEM.data.  */
+extern ENTRY *hsearch (ENTRY __item, ACTION __action) __THROW;
+
+/* Create a new hashing table which will at most contain NEL elements.  */
+extern int hcreate (size_t __nel) __THROW;
+
+/* Destroy current internal hashing table.  */
+extern void hdestroy (void) __THROW;
+
+#ifdef __USE_GNU
+/* Data type for reentrant functions.  */
+struct hsearch_data
+  {
+    struct _ENTRY *table;
+    unsigned int size;
+    unsigned int filled;
+  };
+
+/* Reentrant versions which can handle multiple hashing tables at the
+   same time.  */
+extern int hsearch_r (ENTRY __item, ACTION __action, ENTRY **__retval,
+		      struct hsearch_data *__htab) __THROW;
+extern int hcreate_r (size_t __nel, struct hsearch_data *__htab) __THROW;
+extern void hdestroy_r (struct hsearch_data *__htab) __THROW;
+#endif
+
+
+/* The tsearch routines are very interesting. They make many
+   assumptions about the compiler.  It assumes that the first field
+   in node must be the "key" field, which points to the datum.
+   Everything depends on that.  */
+/* For tsearch */
+typedef enum
+{
+  preorder,
+  postorder,
+  endorder,
+  leaf
+}
+VISIT;
+
+/* Search for an entry matching the given KEY in the tree pointed to
+   by *ROOTP and insert a new element if not found.  */
+extern void *tsearch (const void *__key, void **__rootp,
+		      __compar_fn_t __compar);
+
+/* Search for an entry matching the given KEY in the tree pointed to
+   by *ROOTP.  If no matching entry is available return NULL.  */
+extern void *tfind (const void *__key, void *const *__rootp,
+		    __compar_fn_t __compar);
+
+/* Remove the element matching KEY from the tree pointed to by *ROOTP.  */
+extern void *tdelete (const void *__restrict __key,
+		      void **__restrict __rootp,
+		      __compar_fn_t __compar);
+
+#ifndef __ACTION_FN_T
+# define __ACTION_FN_T
+typedef void (*__action_fn_t) (const void *__nodep, VISIT __value,
+			       int __level);
+#endif
+
+/* Walk through the whole tree and call the ACTION callback for every node
+   or leaf.  */
+extern void twalk (const void *__root, __action_fn_t __action);
+
+#ifdef __USE_GNU
+/* Callback type for function to free a tree node.  If the keys are atomic
+   data this function should do nothing.  */
+typedef void (*__free_fn_t) (void *__nodep);
+
+/* Destroy the whole tree, call FREEFCT for each node or leaf.  */
+extern void tdestroy (void *__root, __free_fn_t __freefct);
+#endif
+
+
+/* Perform linear search for KEY by comparing by COMPAR in an array
+   [BASE,BASE+NMEMB*SIZE).  */
+extern void *lfind (const void *__key, const void *__base,
+		    size_t *__nmemb, size_t __size, __compar_fn_t __compar);
+
+/* Perform linear search for KEY by comparing by COMPAR function in
+   array [BASE,BASE+NMEMB*SIZE) and insert entry if not found.  */
+extern void *lsearch (const void *__key, void *__base,
+		      size_t *__nmemb, size_t __size, __compar_fn_t __compar);
+
+__END_DECLS
+
+#endif /* search.h */
diff --git a/include/semaphore.h b/include/semaphore.h
new file mode 100644
index 0000000..64249f6
--- /dev/null
+++ b/include/semaphore.h
@@ -0,0 +1,81 @@
+/* Copyright (C) 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _SEMAPHORE_H
+#define _SEMAPHORE_H	1
+
+#include <features.h>
+#include <sys/types.h>
+#ifdef __USE_XOPEN2K
+# define __need_timespec
+# include <time.h>
+#endif
+
+/* Get the definition for struct __semaphore.  */
+#include <bits/semaphore.h>
+
+
+__BEGIN_DECLS
+
+#define SEM_FAILED ((void *) 0)
+
+typedef struct __semaphore sem_t;
+
+/* Initialize semaphore *SEM with value VALUE.  */
+extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
+     __THROW;
+/* Destroy semaphore *SEM created with sem_init.  */
+extern int sem_destroy (sem_t *__sem) __THROW;
+
+/* Open a named semaphore.  */
+extern sem_t *sem_open (const char *__name, int __oflag, ...) __THROW;
+
+/* Close a semaphore returned by sem_open.  */
+extern int sem_close (sem_t *__sem) __THROW;
+
+/* Unlink a named semaphore.  */
+extern int sem_unlink (const char *__name) __THROW;
+
+/* Perform a down operation on semaphore *SEM.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int sem_wait (sem_t *__sem);
+
+#ifdef __USE_XOPEN2K
+/* Perform a down operation on semaphore *SEM but don't wait longer
+   than TIMEOUT.  */
+extern int sem_timedwait (sem_t *__restrict __sem,
+			  const struct timespec *__restrict __abstime);
+#endif
+
+/* Perform a down operation on semaphore *SEM if it can be done so
+   without blocking.  */
+extern int sem_trywait (sem_t *__sem) __THROWNL;
+
+/* Perform an up operation on semaphore *SEM.  */
+extern int sem_post (sem_t *__sem) __THROWNL;
+
+/* Store the value of semaphore *SEM in *VALUE.  */
+extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
+    __THROW;
+
+
+__END_DECLS
+
+#endif /* semaphore.h */
diff --git a/include/setjmp.h b/include/setjmp.h
new file mode 100644
index 0000000..774b764
--- /dev/null
+++ b/include/setjmp.h
@@ -0,0 +1,114 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.13 Nonlocal jumps	<setjmp.h>
+ */
+
+#ifndef	_SETJMP_H
+#define	_SETJMP_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/setjmp.h>		/* Get `__jmp_buf'.  */
+#include <bits/sigset.h>		/* Get `__sigset_t'.  */
+
+
+/* Calling environment, plus possibly a saved signal mask.  */
+struct __jmp_buf_tag
+  {
+    /* NOTE: The machine-dependent definitions of `__sigsetjmp'
+       assume that a `jmp_buf' begins with a `__jmp_buf' and that
+       `__mask_was_saved' follows it.  Do not move these members
+       or add others before it.  */
+    __jmp_buf __jmpbuf;		/* Calling environment.  */
+    int __mask_was_saved;	/* Saved the signal mask?  */
+    __sigset_t __saved_mask;	/* Saved signal mask.  */
+  };
+
+
+__BEGIN_NAMESPACE_STD
+
+typedef struct __jmp_buf_tag jmp_buf[1];
+
+/* Store the calling environment in ENV, also saving the signal mask.
+   Return 0.  */
+extern int setjmp (jmp_buf __env) __THROWNL;
+
+__END_NAMESPACE_STD
+
+/* Store the calling environment in ENV, also saving the
+   signal mask if SAVEMASK is nonzero.  Return 0.
+   This is the internal name for `sigsetjmp'.  */
+extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __THROWNL;
+
+/* Store the calling environment in ENV, not saving the signal mask.
+   Return 0.  */
+extern int _setjmp (struct __jmp_buf_tag __env[1]) __THROWNL;
+
+/* Do not save the signal mask.  This is equivalent to the `_setjmp'
+   BSD function.  */
+#define setjmp(env)	_setjmp (env)
+
+
+__BEGIN_NAMESPACE_STD
+
+/* Jump to the environment saved in ENV, making the
+   `setjmp' call there return VAL, or 1 if VAL is 0.  */
+extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
+     __THROWNL __attribute__ ((__noreturn__));
+
+__END_NAMESPACE_STD
+
+#if defined __USE_BSD || defined __USE_XOPEN
+/* Same.  Usually `_longjmp' is used with `_setjmp', which does not save
+   the signal mask.  But it is how ENV was saved that determines whether
+   `longjmp' restores the mask; `_longjmp' is just an alias.  */
+extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
+     __THROWNL __attribute__ ((__noreturn__));
+#endif
+
+
+#ifdef	__USE_POSIX
+/* Use the same type for `jmp_buf' and `sigjmp_buf'.
+   The `__mask_was_saved' flag determines whether
+   or not `longjmp' will restore the signal mask.  */
+typedef struct __jmp_buf_tag sigjmp_buf[1];
+
+/* Store the calling environment in ENV, also saving the
+   signal mask if SAVEMASK is nonzero.  Return 0.  */
+# define sigsetjmp(env, savemask)	__sigsetjmp (env, savemask)
+
+/* Jump to the environment saved in ENV, making the
+   sigsetjmp call there return VAL, or 1 if VAL is 0.
+   Restore the signal mask if that sigsetjmp call saved it.
+   This is just an alias `longjmp'.  */
+extern void siglongjmp (sigjmp_buf __env, int __val)
+     __THROWNL __attribute__ ((__noreturn__));
+#endif /* Use POSIX.  */
+
+
+/* Define helper functions to catch unsafe code.  */
+#if __USE_FORTIFY_LEVEL > 0
+# include <bits/setjmp2.h>
+#endif
+
+__END_DECLS
+
+#endif /* setjmp.h  */
diff --git a/include/sgtty.h b/include/sgtty.h
new file mode 100644
index 0000000..a2128eb
--- /dev/null
+++ b/include/sgtty.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SGTTY_H
+#define	_SGTTY_H	1
+
+#include <features.h>
+
+#include <sys/ioctl.h>
+
+/* On some systems this type is not defined by <bits/ioctl-types.h>;
+   in that case, the functions are just stubs that return ENOSYS.  */
+struct sgttyb;
+
+__BEGIN_DECLS
+
+/* Fill in *PARAMS with terminal parameters associated with FD.  */
+extern int gtty (int __fd, struct sgttyb *__params) __THROW;
+
+/* Set the terminal parameters associated with FD to *PARAMS.  */
+extern int stty (int __fd, const struct sgttyb *__params) __THROW;
+
+
+__END_DECLS
+
+#endif /* sgtty.h  */
diff --git a/include/shadow.h b/include/shadow.h
new file mode 100644
index 0000000..d931e68
--- /dev/null
+++ b/include/shadow.h
@@ -0,0 +1,148 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Declaration of types and functions for shadow password suite.  */
+
+#ifndef _SHADOW_H
+#define _SHADOW_H	1
+
+#include <features.h>
+
+#include <paths.h>
+
+#define	__need_FILE
+#include <stdio.h>
+#define __need_size_t
+#include <stddef.h>
+
+/* Paths to the user database files.  */
+#define	SHADOW _PATH_SHADOW
+
+
+__BEGIN_DECLS
+
+/* Structure of the password file.  */
+struct spwd
+  {
+    char *sp_namp;		/* Login name.  */
+    char *sp_pwdp;		/* Encrypted password.  */
+    long int sp_lstchg;		/* Date of last change.  */
+    long int sp_min;		/* Minimum number of days between changes.  */
+    long int sp_max;		/* Maximum number of days between changes.  */
+    long int sp_warn;		/* Number of days to warn user to change
+				   the password.  */
+    long int sp_inact;		/* Number of days the account may be
+				   inactive.  */
+    long int sp_expire;		/* Number of days since 1970-01-01 until
+				   account expires.  */
+    unsigned long int sp_flag;	/* Reserved.  */
+  };
+
+
+/* Open database for reading.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern void setspent (void);
+
+/* Close database.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern void endspent (void);
+
+/* Get next entry from database, perhaps after opening the file.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct spwd *getspent (void);
+
+/* Get shadow entry matching NAME.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct spwd *getspnam (const char *__name);
+
+/* Read shadow entry from STRING.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct spwd *sgetspent (const char *__string);
+
+/* Read next shadow entry from STREAM.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern struct spwd *fgetspent (FILE *__stream);
+
+/* Write line containing shadow password entry to stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int putspent (const struct spwd *__p, FILE *__stream);
+
+
+#ifdef __USE_MISC
+/* Reentrant versions of some of the functions above.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern int getspent_r (struct spwd *__result_buf, char *__buffer,
+		       size_t __buflen, struct spwd **__result);
+
+extern int getspnam_r (const char *__name, struct spwd *__result_buf,
+		       char *__buffer, size_t __buflen,
+		       struct spwd **__result);
+
+extern int sgetspent_r (const char *__string, struct spwd *__result_buf,
+			char *__buffer, size_t __buflen,
+			struct spwd **__result);
+
+extern int fgetspent_r (FILE *__stream, struct spwd *__result_buf,
+			char *__buffer, size_t __buflen,
+			struct spwd **__result);
+#endif	/* misc */
+
+
+/* The simple locking functionality provided here is not suitable for
+   multi-threaded applications.  */
+
+/* Protect password file against multi writers.  */
+extern int lckpwdf (void) __THROW;
+
+/* Unlock password file.  */
+extern int ulckpwdf (void) __THROW;
+
+__END_DECLS
+
+#endif /* shadow.h */
diff --git a/include/signal.h b/include/signal.h
new file mode 100644
index 0000000..1807658
--- /dev/null
+++ b/include/signal.h
@@ -0,0 +1,403 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.14 Signal handling <signal.h>
+ */
+
+#ifndef	_SIGNAL_H
+
+#if !defined __need_sig_atomic_t && !defined __need_sigset_t
+# define _SIGNAL_H
+#endif
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/sigset.h>		/* __sigset_t, __sig_atomic_t.  */
+
+/* An integral type that can be modified atomically, without the
+   possibility of a signal arriving in the middle of the operation.  */
+#if defined __need_sig_atomic_t || defined _SIGNAL_H
+# ifndef __sig_atomic_t_defined
+#  define __sig_atomic_t_defined
+__BEGIN_NAMESPACE_STD
+typedef __sig_atomic_t sig_atomic_t;
+__END_NAMESPACE_STD
+# endif
+# undef __need_sig_atomic_t
+#endif
+
+#if defined __need_sigset_t || (defined _SIGNAL_H && defined __USE_POSIX)
+# ifndef __sigset_t_defined
+#  define __sigset_t_defined
+typedef __sigset_t sigset_t;
+# endif
+# undef __need_sigset_t
+#endif
+
+#ifdef _SIGNAL_H
+
+#include <bits/types.h>
+#include <bits/signum.h>
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K
+# ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#  define __pid_t_defined
+#endif
+#ifdef __USE_XOPEN
+# endif
+# ifndef __uid_t_defined
+typedef __uid_t uid_t;
+#  define __uid_t_defined
+# endif
+#endif	/* Unix98 */
+
+#ifdef __USE_POSIX199309
+/* We need `struct timespec' later on.  */
+# define __need_timespec
+# include <time.h>
+#endif
+
+#if defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED
+/* Get the `siginfo_t' type plus the needed symbols.  */
+# include <bits/siginfo.h>
+#endif
+
+
+/* Type of a signal handler.  */
+typedef void (*__sighandler_t) (int);
+
+/* The X/Open definition of `signal' specifies the SVID semantic.  Use
+   the additional function `sysv_signal' when X/Open compatibility is
+   requested.  */
+extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
+     __THROW;
+#ifdef __USE_GNU
+extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
+     __THROW;
+#endif
+
+/* Set the handler for the signal SIG to HANDLER, returning the old
+   handler, or SIG_ERR on error.
+   By default `signal' has the BSD semantic.  */
+__BEGIN_NAMESPACE_STD
+#ifdef __USE_BSD
+extern __sighandler_t signal (int __sig, __sighandler_t __handler)
+     __THROW;
+#else
+/* Make sure the used `signal' implementation is the SVID version. */
+# ifdef __REDIRECT_NTH
+extern __sighandler_t __REDIRECT_NTH (signal,
+				      (int __sig, __sighandler_t __handler),
+				      __sysv_signal);
+# else
+#  define signal __sysv_signal
+# endif
+#endif
+__END_NAMESPACE_STD
+
+#ifdef __USE_XOPEN
+/* The X/Open definition of `signal' conflicts with the BSD version.
+   So they defined another function `bsd_signal'.  */
+extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
+     __THROW;
+#endif
+
+/* Send signal SIG to process number PID.  If PID is zero,
+   send SIG to all processes in the current process's process group.
+   If PID is < -1, send SIG to all processes in process group - PID.  */
+#ifdef __USE_POSIX
+extern int kill (__pid_t __pid, int __sig) __THROW;
+#endif /* Use POSIX.  */
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Send SIG to all processes in process group PGRP.
+   If PGRP is zero, send SIG to all processes in
+   the current process's process group.  */
+extern int killpg (__pid_t __pgrp, int __sig) __THROW;
+#endif /* Use BSD || X/Open Unix.  */
+
+__BEGIN_NAMESPACE_STD
+/* Raise signal SIG, i.e., send SIG to yourself.  */
+extern int raise (int __sig) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_SVID
+/* SVID names for the same things.  */
+extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
+     __THROW;
+extern int gsignal (int __sig) __THROW;
+#endif /* Use SVID.  */
+
+#if defined __USE_MISC || defined __USE_XOPEN2K
+/* Print a message describing the meaning of the given signal number.  */
+extern void psignal (int __sig, const char *__s);
+#endif /* Use misc or POSIX 2008.  */
+
+#ifdef __USE_XOPEN2K
+/* Print a message describing the meaning of the given signal information.  */
+extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
+#endif /* POSIX 2008.  */
+
+
+
+/* The `sigpause' function in X/Open defines the argument as the
+   signal number.  This requires redirecting to another function
+   because the default version in glibc uses an old BSD interface.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int __sigpause (int __sig_or_mask, int __is_sig);
+
+#ifdef __USE_XOPEN
+# ifdef __GNUC__
+extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
+# else
+/* Remove a signal from the signal mask and suspend the process.  */
+#  define sigpause(sig) __sigpause ((sig), 1)
+# endif
+#endif
+
+
+#ifdef __USE_BSD
+/* None of the following functions should be used anymore.  They are here
+   only for compatibility.  A single word (`int') is not guaranteed to be
+   enough to hold a complete signal mask and therefore these functions
+   simply do not work in many situations.  Use `sigprocmask' instead.  */
+
+/* Compute mask for signal SIG.  */
+# define sigmask(sig)	__sigmask(sig)
+
+/* Block signals in MASK, returning the old mask.  */
+extern int sigblock (int __mask) __THROW __attribute_deprecated__;
+
+/* Set the mask of blocked signals to MASK, returning the old mask.  */
+extern int sigsetmask (int __mask) __THROW __attribute_deprecated__;
+
+/* Return currently selected signal mask.  */
+extern int siggetmask (void) __THROW __attribute_deprecated__;
+#endif /* Use BSD.  */
+
+
+#ifdef __USE_MISC
+# define NSIG	_NSIG
+#endif
+
+#ifdef __USE_GNU
+typedef __sighandler_t sighandler_t;
+#endif
+
+/* 4.4 BSD uses the name `sig_t' for this.  */
+#ifdef __USE_BSD
+typedef __sighandler_t sig_t;
+#endif
+
+#ifdef __USE_POSIX
+
+/* Clear all signals from SET.  */
+extern int sigemptyset (sigset_t *__set) __THROW __nonnull ((1));
+
+/* Set all signals in SET.  */
+extern int sigfillset (sigset_t *__set) __THROW __nonnull ((1));
+
+/* Add SIGNO to SET.  */
+extern int sigaddset (sigset_t *__set, int __signo) __THROW __nonnull ((1));
+
+/* Remove SIGNO from SET.  */
+extern int sigdelset (sigset_t *__set, int __signo) __THROW __nonnull ((1));
+
+/* Return 1 if SIGNO is in SET, 0 if not.  */
+extern int sigismember (const sigset_t *__set, int __signo)
+     __THROW __nonnull ((1));
+
+# ifdef __USE_GNU
+/* Return non-empty value is SET is not empty.  */
+extern int sigisemptyset (const sigset_t *__set) __THROW __nonnull ((1));
+
+/* Build new signal set by combining the two inputs set using logical AND.  */
+extern int sigandset (sigset_t *__set, const sigset_t *__left,
+		      const sigset_t *__right) __THROW __nonnull ((1, 2, 3));
+
+/* Build new signal set by combining the two inputs set using logical OR.  */
+extern int sigorset (sigset_t *__set, const sigset_t *__left,
+		     const sigset_t *__right) __THROW __nonnull ((1, 2, 3));
+# endif /* GNU */
+
+/* Get the system-specific definitions of `struct sigaction'
+   and the `SA_*' and `SIG_*'. constants.  */
+# include <bits/sigaction.h>
+
+/* Get and/or change the set of blocked signals.  */
+extern int sigprocmask (int __how, const sigset_t *__restrict __set,
+			sigset_t *__restrict __oset) __THROW;
+
+/* Change the set of blocked signals to SET,
+   wait until a signal arrives, and restore the set of blocked signals.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int sigsuspend (const sigset_t *__set) __nonnull ((1));
+
+/* Get and/or set the action for signal SIG.  */
+extern int sigaction (int __sig, const struct sigaction *__restrict __act,
+		      struct sigaction *__restrict __oact) __THROW;
+
+/* Put in SET all signals that are blocked and waiting to be delivered.  */
+extern int sigpending (sigset_t *__set) __THROW __nonnull ((1));
+
+
+/* Select any of pending signals from SET or wait for any to arrive.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
+     __nonnull ((1, 2));
+
+# ifdef __USE_POSIX199309
+/* Select any of pending signals from SET and place information in INFO.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int sigwaitinfo (const sigset_t *__restrict __set,
+			siginfo_t *__restrict __info) __nonnull ((1));
+
+/* Select any of pending signals from SET and place information in INFO.
+   Wait the time specified by TIMEOUT if no signal is pending.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int sigtimedwait (const sigset_t *__restrict __set,
+			 siginfo_t *__restrict __info,
+			 const struct timespec *__restrict __timeout)
+     __nonnull ((1));
+
+/* Send signal SIG to the process PID.  Associate data in VAL with the
+   signal.  */
+extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
+     __THROW;
+# endif	/* Use POSIX 199306.  */
+
+#endif /* Use POSIX.  */
+
+#ifdef __USE_BSD
+
+/* Names of the signals.  This variable exists only for compatibility.
+   Use `strsignal' instead (see <string.h>).  */
+extern const char *const _sys_siglist[_NSIG];
+extern const char *const sys_siglist[_NSIG];
+
+/* Structure passed to `sigvec'.  */
+struct sigvec
+  {
+    __sighandler_t sv_handler;	/* Signal handler.  */
+    int sv_mask;		/* Mask of signals to be blocked.  */
+
+    int sv_flags;		/* Flags (see below).  */
+# define sv_onstack	sv_flags /* 4.2 BSD compatibility.  */
+  };
+
+/* Bits in `sv_flags'.  */
+# define SV_ONSTACK	(1 << 0)/* Take the signal on the signal stack.  */
+# define SV_INTERRUPT	(1 << 1)/* Do not restart system calls.  */
+# define SV_RESETHAND	(1 << 2)/* Reset handler to SIG_DFL on receipt.  */
+
+
+/* If VEC is non-NULL, set the handler for SIG to the `sv_handler' member
+   of VEC.  The signals in `sv_mask' will be blocked while the handler runs.
+   If the SV_RESETHAND bit is set in `sv_flags', the handler for SIG will be
+   reset to SIG_DFL before `sv_handler' is entered.  If OVEC is non-NULL,
+   it is filled in with the old information for SIG.  */
+extern int sigvec (int __sig, const struct sigvec *__vec,
+		   struct sigvec *__ovec) __THROW;
+
+
+/* Get machine-dependent `struct sigcontext' and signal subcodes.  */
+# include <bits/sigcontext.h>
+
+/* Restore the state saved in SCP.  */
+extern int sigreturn (struct sigcontext *__scp) __THROW;
+
+#endif /*  use BSD.  */
+
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+# define __need_size_t
+# include <stddef.h>
+
+/* If INTERRUPT is nonzero, make signal SIG interrupt system calls
+   (causing them to fail with EINTR); if INTERRUPT is zero, make system
+   calls be restarted after signal SIG.  */
+extern int siginterrupt (int __sig, int __interrupt) __THROW;
+
+# include <bits/sigstack.h>
+# if defined __USE_XOPEN || defined __USE_XOPEN2K8
+/* This will define `ucontext_t' and `mcontext_t'.  */
+#  include <sys/ucontext.h>
+# endif
+
+/* Run signals handlers on the stack specified by SS (if not NULL).
+   If OSS is not NULL, it is filled in with the old signal stack status.
+   This interface is obsolete and on many platform not implemented.  */
+extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
+     __THROW __attribute_deprecated__;
+
+/* Alternate signal handler stack interface.
+   This interface should always be preferred over `sigstack'.  */
+extern int sigaltstack (const struct sigaltstack *__restrict __ss,
+			struct sigaltstack *__restrict __oss) __THROW;
+
+#endif /* use BSD or X/Open Unix.  */
+
+#ifdef __USE_XOPEN_EXTENDED
+/* Simplified interface for signal management.  */
+
+/* Add SIG to the calling process' signal mask.  */
+extern int sighold (int __sig) __THROW;
+
+/* Remove SIG from the calling process' signal mask.  */
+extern int sigrelse (int __sig) __THROW;
+
+/* Set the disposition of SIG to SIG_IGN.  */
+extern int sigignore (int __sig) __THROW;
+
+/* Set the disposition of SIG.  */
+extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __THROW;
+#endif
+
+#if defined __USE_POSIX199506 || defined __USE_UNIX98
+/* Some of the functions for handling signals in threaded programs must
+   be defined here.  */
+# include <bits/pthreadtypes.h>
+# include <bits/sigthread.h>
+#endif /* use Unix98 */
+
+/* The following functions are used internally in the C library and in
+   other code which need deep insights.  */
+
+/* Return number of available real-time signal with highest priority.  */
+extern int __libc_current_sigrtmin (void) __THROW;
+/* Return number of available real-time signal with lowest priority.  */
+extern int __libc_current_sigrtmax (void) __THROW;
+
+#endif /* signal.h  */
+
+__END_DECLS
+
+#endif /* not signal.h */
diff --git a/include/spawn.h b/include/spawn.h
new file mode 100644
index 0000000..82b6761
--- /dev/null
+++ b/include/spawn.h
@@ -0,0 +1,190 @@
+/* Definitions for POSIX spawn interface.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SPAWN_H
+#define	_SPAWN_H	1
+
+#include <features.h>
+#include <sched.h>
+#define __need_sigset_t
+#include <signal.h>
+#include <sys/types.h>
+
+
+/* Data structure to contain attributes for thread creation.  */
+typedef struct
+{
+  short int __flags;
+  pid_t __pgrp;
+  sigset_t __sd;
+  sigset_t __ss;
+  struct sched_param __sp;
+  int __policy;
+  int __pad[16];
+} posix_spawnattr_t;
+
+
+/* Data structure to contain information about the actions to be
+   performed in the new process with respect to file descriptors.  */
+typedef struct
+{
+  int __allocated;
+  int __used;
+  struct __spawn_action *__actions;
+  int __pad[16];
+} posix_spawn_file_actions_t;
+
+
+/* Flags to be set in the `posix_spawnattr_t'.  */
+#define POSIX_SPAWN_RESETIDS		0x01
+#define POSIX_SPAWN_SETPGROUP		0x02
+#define POSIX_SPAWN_SETSIGDEF		0x04
+#define POSIX_SPAWN_SETSIGMASK		0x08
+#define POSIX_SPAWN_SETSCHEDPARAM	0x10
+#define POSIX_SPAWN_SETSCHEDULER	0x20
+#ifdef __USE_GNU
+# define POSIX_SPAWN_USEVFORK		0x40
+#endif
+
+
+__BEGIN_DECLS
+
+/* Spawn a new process executing PATH with the attributes describes in *ATTRP.
+   Before running the process perform the actions described in FILE-ACTIONS.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW. */
+extern int posix_spawn (pid_t *__restrict __pid,
+			const char *__restrict __path,
+			const posix_spawn_file_actions_t *__restrict
+			__file_actions,
+			const posix_spawnattr_t *__restrict __attrp,
+			char *const __argv[__restrict_arr],
+			char *const __envp[__restrict_arr]);
+
+/* Similar to `posix_spawn' but search for FILE in the PATH.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int posix_spawnp (pid_t *__pid, const char *__file,
+			 const posix_spawn_file_actions_t *__file_actions,
+			 const posix_spawnattr_t *__attrp,
+			 char *const __argv[], char *const __envp[]);
+
+
+/* Initialize data structure with attributes for `spawn' to default values.  */
+extern int posix_spawnattr_init (posix_spawnattr_t *__attr) __THROW;
+
+/* Free resources associated with ATTR.  */
+extern int posix_spawnattr_destroy (posix_spawnattr_t *__attr) __THROW;
+
+/* Store signal mask for signals with default handling from ATTR in
+   SIGDEFAULT.  */
+extern int posix_spawnattr_getsigdefault (const posix_spawnattr_t *
+					  __restrict __attr,
+					  sigset_t *__restrict __sigdefault)
+     __THROW;
+
+/* Set signal mask for signals with default handling in ATTR to SIGDEFAULT.  */
+extern int posix_spawnattr_setsigdefault (posix_spawnattr_t *__restrict __attr,
+					  const sigset_t *__restrict
+					  __sigdefault)
+     __THROW;
+
+/* Store signal mask for the new process from ATTR in SIGMASK.  */
+extern int posix_spawnattr_getsigmask (const posix_spawnattr_t *__restrict
+				       __attr,
+				       sigset_t *__restrict __sigmask) __THROW;
+
+/* Set signal mask for the new process in ATTR to SIGMASK.  */
+extern int posix_spawnattr_setsigmask (posix_spawnattr_t *__restrict __attr,
+				       const sigset_t *__restrict __sigmask)
+     __THROW;
+
+/* Get flag word from the attribute structure.  */
+extern int posix_spawnattr_getflags (const posix_spawnattr_t *__restrict
+				     __attr,
+				     short int *__restrict __flags) __THROW;
+
+/* Store flags in the attribute structure.  */
+extern int posix_spawnattr_setflags (posix_spawnattr_t *_attr,
+				     short int __flags) __THROW;
+
+/* Get process group ID from the attribute structure.  */
+extern int posix_spawnattr_getpgroup (const posix_spawnattr_t *__restrict
+				      __attr, pid_t *__restrict __pgroup)
+     __THROW;
+
+/* Store process group ID in the attribute structure.  */
+extern int posix_spawnattr_setpgroup (posix_spawnattr_t *__attr,
+				      pid_t __pgroup) __THROW;
+
+/* Get scheduling policy from the attribute structure.  */
+extern int posix_spawnattr_getschedpolicy (const posix_spawnattr_t *
+					   __restrict __attr,
+					   int *__restrict __schedpolicy)
+     __THROW;
+
+/* Store scheduling policy in the attribute structure.  */
+extern int posix_spawnattr_setschedpolicy (posix_spawnattr_t *__attr,
+					   int __schedpolicy) __THROW;
+
+/* Get scheduling parameters from the attribute structure.  */
+extern int posix_spawnattr_getschedparam (const posix_spawnattr_t *
+					  __restrict __attr,
+					  struct sched_param *__restrict
+					  __schedparam) __THROW;
+
+/* Store scheduling parameters in the attribute structure.  */
+extern int posix_spawnattr_setschedparam (posix_spawnattr_t *__restrict __attr,
+					  const struct sched_param *
+					  __restrict __schedparam) __THROW;
+
+
+/* Initialize data structure for file attribute for `spawn' call.  */
+extern int posix_spawn_file_actions_init (posix_spawn_file_actions_t *
+					  __file_actions) __THROW;
+
+/* Free resources associated with FILE-ACTIONS.  */
+extern int posix_spawn_file_actions_destroy (posix_spawn_file_actions_t *
+					     __file_actions) __THROW;
+
+/* Add an action to FILE-ACTIONS which tells the implementation to call
+   `open' for the given file during the `spawn' call.  */
+extern int posix_spawn_file_actions_addopen (posix_spawn_file_actions_t *
+					     __restrict __file_actions,
+					     int __fd,
+					     const char *__restrict __path,
+					     int __oflag, mode_t __mode)
+     __THROW;
+
+/* Add an action to FILE-ACTIONS which tells the implementation to call
+   `close' for the given file descriptor during the `spawn' call.  */
+extern int posix_spawn_file_actions_addclose (posix_spawn_file_actions_t *
+					      __file_actions, int __fd)
+     __THROW;
+
+/* Add an action to FILE-ACTIONS which tells the implementation to call
+   `dup2' for the given file descriptors during the `spawn' call.  */
+extern int posix_spawn_file_actions_adddup2 (posix_spawn_file_actions_t *
+					     __file_actions,
+					     int __fd, int __newfd) __THROW;
+
+__END_DECLS
+
+#endif /* spawn.h */
diff --git a/include/spin-lock.h b/include/spin-lock.h
new file mode 100644
index 0000000..fc21b1e
--- /dev/null
+++ b/include/spin-lock.h
@@ -0,0 +1,33 @@
+/* Definitions of user-visible names for spin locks.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SPIN_LOCK_H
+#define _SPIN_LOCK_H
+
+#include <lock-intern.h>	/* This does all the work.  */
+
+typedef __spin_lock_t spin_lock_t;
+#define SPIN_LOCK_INITIALIZER	__SPIN_LOCK_INITIALIZER
+
+#define spin_lock_init(lock)	__spin_lock_init (lock)
+#define spin_lock(lock)		__spin_lock (lock)
+#define spin_try_lock(lock)	__spin_try_lock (lock)
+#define spin_unlock(lock)	__spin_unlock (lock)
+#define spin_lock_locked(lock)	__spin_lock_locked (lock)
+
+#endif /* spin-lock.h */
diff --git a/include/stab.h b/include/stab.h
new file mode 100644
index 0000000..9dc3c32
--- /dev/null
+++ b/include/stab.h
@@ -0,0 +1,17 @@
+#ifndef __GNU_STAB__
+
+/* Indicate the GNU stab.h is in use.  */
+
+#define __GNU_STAB__
+
+#define __define_stab(NAME, CODE, STRING) NAME=CODE,
+
+enum __stab_debug_code
+{
+#include <bits/stab.def>
+LAST_UNUSED_STAB_CODE
+};
+
+#undef __define_stab
+
+#endif /* __GNU_STAB_ */
diff --git a/include/stdc-predef.h b/include/stdc-predef.h
new file mode 100644
index 0000000..87e3666
--- /dev/null
+++ b/include/stdc-predef.h
@@ -0,0 +1,59 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_STDC_PREDEF_H
+#define	_STDC_PREDEF_H	1
+
+/* This header is separate from features.h so that the compiler can
+   include it implicitly at the start of every compilation.  It must
+   not itself include <features.h> or any other header that includes
+   <features.h> because the implicit include comes before any feature
+   test macros that may be defined in a source file before it first
+   explicitly includes a system header.  GCC knows the name of this
+   header in order to preinclude it.  */
+
+/* glibc's intent is to support the IEC 559 math functionality, real
+   and complex.  If the GCC (4.9 and later) predefined macros
+   specifying compiler intent are available, use them to determine
+   whether the overall intent is to support these features; otherwise,
+   presume an older compiler has intent to support these features and
+   define these macros by default.  */
+
+#ifdef __GCC_IEC_559
+# if __GCC_IEC_559 > 0
+#  define __STDC_IEC_559__		1
+# endif
+#else
+# define __STDC_IEC_559__		1
+#endif
+
+#ifdef __GCC_IEC_559_COMPLEX
+# if __GCC_IEC_559_COMPLEX > 0
+#  define __STDC_IEC_559_COMPLEX__	1
+# endif
+#else
+# define __STDC_IEC_559_COMPLEX__	1
+#endif
+
+/* wchar_t uses ISO/IEC 10646 (2nd ed., published 2011-03-15) /
+   Unicode 6.0.  */
+#define __STDC_ISO_10646__		201103L
+
+/* We do not support C11 <threads.h>.  */
+#define __STDC_NO_THREADS__		1
+
+#endif
diff --git a/include/stdint.h b/include/stdint.h
new file mode 100644
index 0000000..4660748
--- /dev/null
+++ b/include/stdint.h
@@ -0,0 +1,306 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99: 7.18 Integer types <stdint.h>
+ */
+
+#ifndef _STDINT_H
+#define _STDINT_H	1
+
+#include <features.h>
+#include <bits/wchar.h>
+#include <bits/wordsize.h>
+
+/* Exact integral types.  */
+
+/* Signed.  */
+
+/* There is some amount of overlap with <sys/types.h> as known by inet code */
+#ifndef __int8_t_defined
+# define __int8_t_defined
+typedef signed char		int8_t;
+typedef short int		int16_t;
+typedef int			int32_t;
+# if __WORDSIZE == 64
+typedef long int		int64_t;
+# else
+__extension__
+typedef long long int		int64_t;
+# endif
+#endif
+
+/* Unsigned.  */
+typedef unsigned char		uint8_t;
+typedef unsigned short int	uint16_t;
+#ifndef __uint32_t_defined
+typedef unsigned int		uint32_t;
+# define __uint32_t_defined
+#endif
+#if __WORDSIZE == 64
+typedef unsigned long int	uint64_t;
+#else
+__extension__
+typedef unsigned long long int	uint64_t;
+#endif
+
+
+/* Small types.  */
+
+/* Signed.  */
+typedef signed char		int_least8_t;
+typedef short int		int_least16_t;
+typedef int			int_least32_t;
+#if __WORDSIZE == 64
+typedef long int		int_least64_t;
+#else
+__extension__
+typedef long long int		int_least64_t;
+#endif
+
+/* Unsigned.  */
+typedef unsigned char		uint_least8_t;
+typedef unsigned short int	uint_least16_t;
+typedef unsigned int		uint_least32_t;
+#if __WORDSIZE == 64
+typedef unsigned long int	uint_least64_t;
+#else
+__extension__
+typedef unsigned long long int	uint_least64_t;
+#endif
+
+
+/* Fast types.  */
+
+/* Signed.  */
+typedef signed char		int_fast8_t;
+#if __WORDSIZE == 64
+typedef long int		int_fast16_t;
+typedef long int		int_fast32_t;
+typedef long int		int_fast64_t;
+#else
+typedef int			int_fast16_t;
+typedef int			int_fast32_t;
+__extension__
+typedef long long int		int_fast64_t;
+#endif
+
+/* Unsigned.  */
+typedef unsigned char		uint_fast8_t;
+#if __WORDSIZE == 64
+typedef unsigned long int	uint_fast16_t;
+typedef unsigned long int	uint_fast32_t;
+typedef unsigned long int	uint_fast64_t;
+#else
+typedef unsigned int		uint_fast16_t;
+typedef unsigned int		uint_fast32_t;
+__extension__
+typedef unsigned long long int	uint_fast64_t;
+#endif
+
+
+/* Types for `void *' pointers.  */
+#if __WORDSIZE == 64
+# ifndef __intptr_t_defined
+typedef long int		intptr_t;
+#  define __intptr_t_defined
+# endif
+typedef unsigned long int	uintptr_t;
+#else
+# ifndef __intptr_t_defined
+typedef int			intptr_t;
+#  define __intptr_t_defined
+# endif
+typedef unsigned int		uintptr_t;
+#endif
+
+
+/* Largest integral types.  */
+#if __WORDSIZE == 64
+typedef long int		intmax_t;
+typedef unsigned long int	uintmax_t;
+#else
+__extension__
+typedef long long int		intmax_t;
+__extension__
+typedef unsigned long long int	uintmax_t;
+#endif
+
+
+# if __WORDSIZE == 64
+#  define __INT64_C(c)	c ## L
+#  define __UINT64_C(c)	c ## UL
+# else
+#  define __INT64_C(c)	c ## LL
+#  define __UINT64_C(c)	c ## ULL
+# endif
+
+/* Limits of integral types.  */
+
+/* Minimum of signed integral types.  */
+# define INT8_MIN		(-128)
+# define INT16_MIN		(-32767-1)
+# define INT32_MIN		(-2147483647-1)
+# define INT64_MIN		(-__INT64_C(9223372036854775807)-1)
+/* Maximum of signed integral types.  */
+# define INT8_MAX		(127)
+# define INT16_MAX		(32767)
+# define INT32_MAX		(2147483647)
+# define INT64_MAX		(__INT64_C(9223372036854775807))
+
+/* Maximum of unsigned integral types.  */
+# define UINT8_MAX		(255)
+# define UINT16_MAX		(65535)
+# define UINT32_MAX		(4294967295U)
+# define UINT64_MAX		(__UINT64_C(18446744073709551615))
+
+
+/* Minimum of signed integral types having a minimum size.  */
+# define INT_LEAST8_MIN		(-128)
+# define INT_LEAST16_MIN	(-32767-1)
+# define INT_LEAST32_MIN	(-2147483647-1)
+# define INT_LEAST64_MIN	(-__INT64_C(9223372036854775807)-1)
+/* Maximum of signed integral types having a minimum size.  */
+# define INT_LEAST8_MAX		(127)
+# define INT_LEAST16_MAX	(32767)
+# define INT_LEAST32_MAX	(2147483647)
+# define INT_LEAST64_MAX	(__INT64_C(9223372036854775807))
+
+/* Maximum of unsigned integral types having a minimum size.  */
+# define UINT_LEAST8_MAX	(255)
+# define UINT_LEAST16_MAX	(65535)
+# define UINT_LEAST32_MAX	(4294967295U)
+# define UINT_LEAST64_MAX	(__UINT64_C(18446744073709551615))
+
+
+/* Minimum of fast signed integral types having a minimum size.  */
+# define INT_FAST8_MIN		(-128)
+# if __WORDSIZE == 64
+#  define INT_FAST16_MIN	(-9223372036854775807L-1)
+#  define INT_FAST32_MIN	(-9223372036854775807L-1)
+# else
+#  define INT_FAST16_MIN	(-2147483647-1)
+#  define INT_FAST32_MIN	(-2147483647-1)
+# endif
+# define INT_FAST64_MIN		(-__INT64_C(9223372036854775807)-1)
+/* Maximum of fast signed integral types having a minimum size.  */
+# define INT_FAST8_MAX		(127)
+# if __WORDSIZE == 64
+#  define INT_FAST16_MAX	(9223372036854775807L)
+#  define INT_FAST32_MAX	(9223372036854775807L)
+# else
+#  define INT_FAST16_MAX	(2147483647)
+#  define INT_FAST32_MAX	(2147483647)
+# endif
+# define INT_FAST64_MAX		(__INT64_C(9223372036854775807))
+
+/* Maximum of fast unsigned integral types having a minimum size.  */
+# define UINT_FAST8_MAX		(255)
+# if __WORDSIZE == 64
+#  define UINT_FAST16_MAX	(18446744073709551615UL)
+#  define UINT_FAST32_MAX	(18446744073709551615UL)
+# else
+#  define UINT_FAST16_MAX	(4294967295U)
+#  define UINT_FAST32_MAX	(4294967295U)
+# endif
+# define UINT_FAST64_MAX	(__UINT64_C(18446744073709551615))
+
+
+/* Values to test for integral types holding `void *' pointer.  */
+# if __WORDSIZE == 64
+#  define INTPTR_MIN		(-9223372036854775807L-1)
+#  define INTPTR_MAX		(9223372036854775807L)
+#  define UINTPTR_MAX		(18446744073709551615UL)
+# else
+#  define INTPTR_MIN		(-2147483647-1)
+#  define INTPTR_MAX		(2147483647)
+#  define UINTPTR_MAX		(4294967295U)
+# endif
+
+
+/* Minimum for largest signed integral type.  */
+# define INTMAX_MIN		(-__INT64_C(9223372036854775807)-1)
+/* Maximum for largest signed integral type.  */
+# define INTMAX_MAX		(__INT64_C(9223372036854775807))
+
+/* Maximum for largest unsigned integral type.  */
+# define UINTMAX_MAX		(__UINT64_C(18446744073709551615))
+
+
+/* Limits of other integer types.  */
+
+/* Limits of `ptrdiff_t' type.  */
+# if __WORDSIZE == 64
+#  define PTRDIFF_MIN		(-9223372036854775807L-1)
+#  define PTRDIFF_MAX		(9223372036854775807L)
+# else
+#  define PTRDIFF_MIN		(-2147483647-1)
+#  define PTRDIFF_MAX		(2147483647)
+# endif
+
+/* Limits of `sig_atomic_t'.  */
+# define SIG_ATOMIC_MIN		(-2147483647-1)
+# define SIG_ATOMIC_MAX		(2147483647)
+
+/* Limit of `size_t' type.  */
+# if __WORDSIZE == 64
+#  define SIZE_MAX		(18446744073709551615UL)
+# else
+#  define SIZE_MAX		(4294967295U)
+# endif
+
+/* Limits of `wchar_t'.  */
+# ifndef WCHAR_MIN
+/* These constants might also be defined in <wchar.h>.  */
+#  define WCHAR_MIN		__WCHAR_MIN
+#  define WCHAR_MAX		__WCHAR_MAX
+# endif
+
+/* Limits of `wint_t'.  */
+# define WINT_MIN		(0u)
+# define WINT_MAX		(4294967295u)
+
+/* Signed.  */
+# define INT8_C(c)	c
+# define INT16_C(c)	c
+# define INT32_C(c)	c
+# if __WORDSIZE == 64
+#  define INT64_C(c)	c ## L
+# else
+#  define INT64_C(c)	c ## LL
+# endif
+
+/* Unsigned.  */
+# define UINT8_C(c)	c
+# define UINT16_C(c)	c
+# define UINT32_C(c)	c ## U
+# if __WORDSIZE == 64
+#  define UINT64_C(c)	c ## UL
+# else
+#  define UINT64_C(c)	c ## ULL
+# endif
+
+/* Maximal type.  */
+# if __WORDSIZE == 64
+#  define INTMAX_C(c)	c ## L
+#  define UINTMAX_C(c)	c ## UL
+# else
+#  define INTMAX_C(c)	c ## LL
+#  define UINTMAX_C(c)	c ## ULL
+# endif
+
+#endif /* stdint.h */
diff --git a/include/stdio.h b/include/stdio.h
new file mode 100644
index 0000000..bdc79ea
--- /dev/null
+++ b/include/stdio.h
@@ -0,0 +1,947 @@
+/* Define ISO C stdio on top of C++ iostreams.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
+ */
+
+#ifndef _STDIO_H
+
+#if !defined __need_FILE && !defined __need___FILE
+# define _STDIO_H	1
+# include <features.h>
+
+__BEGIN_DECLS
+
+# define __need_size_t
+# define __need_NULL
+# include <stddef.h>
+
+# include <bits/types.h>
+# define __need_FILE
+# define __need___FILE
+#endif /* Don't need FILE.  */
+
+
+#if !defined __FILE_defined && defined __need_FILE
+
+/* Define outside of namespace so the C++ is happy.  */
+struct _IO_FILE;
+
+__BEGIN_NAMESPACE_STD
+/* The opaque type of streams.  This is the definition used elsewhere.  */
+typedef struct _IO_FILE FILE;
+__END_NAMESPACE_STD
+#if defined __USE_LARGEFILE64 || defined __USE_SVID || defined __USE_POSIX \
+    || defined __USE_BSD || defined __USE_ISOC99 || defined __USE_XOPEN \
+    || defined __USE_POSIX2
+__USING_NAMESPACE_STD(FILE)
+#endif
+
+# define __FILE_defined	1
+#endif /* FILE not defined.  */
+#undef	__need_FILE
+
+
+#if !defined ____FILE_defined && defined __need___FILE
+
+/* The opaque type of streams.  This is the definition used elsewhere.  */
+typedef struct _IO_FILE __FILE;
+
+# define ____FILE_defined	1
+#endif /* __FILE not defined.  */
+#undef	__need___FILE
+
+
+#ifdef	_STDIO_H
+#define _STDIO_USES_IOSTREAM
+
+#include <libio.h>
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K8
+# ifdef __GNUC__
+#  ifndef _VA_LIST_DEFINED
+typedef _G_va_list va_list;
+#   define _VA_LIST_DEFINED
+#  endif
+# else
+#  include <stdarg.h>
+# endif
+#endif
+
+#ifdef __USE_XOPEN2K8
+# ifndef __off_t_defined
+# ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+# else
+typedef __off64_t off_t;
+# endif
+# define __off_t_defined
+# endif
+# if defined __USE_LARGEFILE64 && !defined __off64_t_defined
+typedef __off64_t off64_t;
+# define __off64_t_defined
+# endif
+
+# ifndef __ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+# endif
+#endif
+
+/* The type of the second argument to `fgetpos' and `fsetpos'.  */
+__BEGIN_NAMESPACE_STD
+#ifndef __USE_FILE_OFFSET64
+typedef _G_fpos_t fpos_t;
+#else
+typedef _G_fpos64_t fpos_t;
+#endif
+__END_NAMESPACE_STD
+#ifdef __USE_LARGEFILE64
+typedef _G_fpos64_t fpos64_t;
+#endif
+
+/* The possibilities for the third argument to `setvbuf'.  */
+#define _IOFBF 0		/* Fully buffered.  */
+#define _IOLBF 1		/* Line buffered.  */
+#define _IONBF 2		/* No buffering.  */
+
+
+/* Default buffer size.  */
+#ifndef BUFSIZ
+# define BUFSIZ _IO_BUFSIZ
+#endif
+
+
+/* End of file character.
+   Some things throughout the library rely on this being -1.  */
+#ifndef EOF
+# define EOF (-1)
+#endif
+
+
+/* The possibilities for the third argument to `fseek'.
+   These values should not be changed.  */
+#define SEEK_SET	0	/* Seek from beginning of file.  */
+#define SEEK_CUR	1	/* Seek from current position.  */
+#define SEEK_END	2	/* Seek from end of file.  */
+#ifdef __USE_GNU
+# define SEEK_DATA	3	/* Seek to next data.  */
+# define SEEK_HOLE	4	/* Seek to next hole.  */
+#endif
+
+
+#if defined __USE_SVID || defined __USE_XOPEN
+/* Default path prefix for `tempnam' and `tmpnam'.  */
+# define P_tmpdir	"/tmp"
+#endif
+
+
+/* Get the values:
+   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
+   TMP_MAX	The minimum number of unique filenames generated by tmpnam
+		(and tempnam when it uses tmpnam's name space),
+		or tempnam (the two are separate).
+   L_ctermid	How long an array to pass to `ctermid'.
+   L_cuserid	How long an array to pass to `cuserid'.
+   FOPEN_MAX	Minimum number of files that can be open at once.
+   FILENAME_MAX	Maximum length of a filename.  */
+#include <bits/stdio_lim.h>
+
+
+/* Standard streams.  */
+extern struct _IO_FILE *stdin;		/* Standard input stream.  */
+extern struct _IO_FILE *stdout;		/* Standard output stream.  */
+extern struct _IO_FILE *stderr;		/* Standard error output stream.  */
+/* C89/C99 say they're macros.  Make them happy.  */
+#define stdin stdin
+#define stdout stdout
+#define stderr stderr
+
+__BEGIN_NAMESPACE_STD
+/* Remove file FILENAME.  */
+extern int remove (const char *__filename) __THROW;
+/* Rename file OLD to NEW.  */
+extern int rename (const char *__old, const char *__new) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_ATFILE
+/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */
+extern int renameat (int __oldfd, const char *__old, int __newfd,
+		     const char *__new) __THROW;
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Create a temporary file and open it read/write.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+#ifndef __USE_FILE_OFFSET64
+extern FILE *tmpfile (void) __wur;
+#else
+# ifdef __REDIRECT
+extern FILE *__REDIRECT (tmpfile, (void), tmpfile64) __wur;
+# else
+#  define tmpfile tmpfile64
+# endif
+#endif
+
+#ifdef __USE_LARGEFILE64
+extern FILE *tmpfile64 (void) __wur;
+#endif
+
+/* Generate a temporary filename.  */
+extern char *tmpnam (char *__s) __THROW __wur;
+__END_NAMESPACE_STD
+
+#ifdef __USE_MISC
+/* This is the reentrant variant of `tmpnam'.  The only difference is
+   that it does not allow S to be NULL.  */
+extern char *tmpnam_r (char *__s) __THROW __wur;
+#endif
+
+
+#if defined __USE_SVID || defined __USE_XOPEN
+/* Generate a unique temporary filename using up to five characters of PFX
+   if it is not NULL.  The directory to put this file in is searched for
+   as follows: First the environment variable "TMPDIR" is checked.
+   If it contains the name of a writable directory, that directory is used.
+   If not and if DIR is not NULL, that value is checked.  If that fails,
+   P_tmpdir is tried and finally "/tmp".  The storage for the filename
+   is allocated by `malloc'.  */
+extern char *tempnam (const char *__dir, const char *__pfx)
+     __THROW __attribute_malloc__ __wur;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Close STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fclose (FILE *__stream);
+/* Flush STREAM, or all streams if STREAM is NULL.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fflush (FILE *__stream);
+__END_NAMESPACE_STD
+
+#ifdef __USE_MISC
+/* Faster versions when locking is not required.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fflush_unlocked (FILE *__stream);
+#endif
+
+#ifdef __USE_GNU
+/* Close all streams.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fcloseall (void);
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+#ifndef __USE_FILE_OFFSET64
+/* Open a file and create a new stream for it.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern FILE *fopen (const char *__restrict __filename,
+		    const char *__restrict __modes) __wur;
+/* Open a file, replacing an existing stream with it.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern FILE *freopen (const char *__restrict __filename,
+		      const char *__restrict __modes,
+		      FILE *__restrict __stream) __wur;
+#else
+# ifdef __REDIRECT
+extern FILE *__REDIRECT (fopen, (const char *__restrict __filename,
+				 const char *__restrict __modes), fopen64)
+  __wur;
+extern FILE *__REDIRECT (freopen, (const char *__restrict __filename,
+				   const char *__restrict __modes,
+				   FILE *__restrict __stream), freopen64)
+  __wur;
+# else
+#  define fopen fopen64
+#  define freopen freopen64
+# endif
+#endif
+__END_NAMESPACE_STD
+#ifdef __USE_LARGEFILE64
+extern FILE *fopen64 (const char *__restrict __filename,
+		      const char *__restrict __modes) __wur;
+extern FILE *freopen64 (const char *__restrict __filename,
+			const char *__restrict __modes,
+			FILE *__restrict __stream) __wur;
+#endif
+
+#ifdef	__USE_POSIX
+/* Create a new stream that refers to an existing system file descriptor.  */
+extern FILE *fdopen (int __fd, const char *__modes) __THROW __wur;
+#endif
+
+#ifdef	__USE_GNU
+/* Create a new stream that refers to the given magic cookie,
+   and uses the given functions for input and output.  */
+extern FILE *fopencookie (void *__restrict __magic_cookie,
+			  const char *__restrict __modes,
+			  _IO_cookie_io_functions_t __io_funcs) __THROW __wur;
+#endif
+
+#ifdef __USE_XOPEN2K8
+/* Create a new stream that refers to a memory buffer.  */
+extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
+  __THROW __wur;
+
+/* Open a stream that writes into a malloc'd buffer that is expanded as
+   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
+   and the number of characters written on fflush or fclose.  */
+extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __THROW __wur;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* If BUF is NULL, make STREAM unbuffered.
+   Else make it use buffer BUF, of size BUFSIZ.  */
+extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __THROW;
+/* Make STREAM use buffering mode MODE.
+   If BUF is not NULL, use N bytes of it for buffering;
+   else allocate an internal buffer N bytes long.  */
+extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
+		    int __modes, size_t __n) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef	__USE_BSD
+/* If BUF is NULL, make STREAM unbuffered.
+   Else make it use SIZE bytes of BUF for buffering.  */
+extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
+		       size_t __size) __THROW;
+
+/* Make STREAM line-buffered.  */
+extern void setlinebuf (FILE *__stream) __THROW;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Write formatted output to STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fprintf (FILE *__restrict __stream,
+		    const char *__restrict __format, ...);
+/* Write formatted output to stdout.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int printf (const char *__restrict __format, ...);
+/* Write formatted output to S.  */
+extern int sprintf (char *__restrict __s,
+		    const char *__restrict __format, ...) __THROWNL;
+
+/* Write formatted output to S from argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
+		     _G_va_list __arg);
+/* Write formatted output to stdout from argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vprintf (const char *__restrict __format, _G_va_list __arg);
+/* Write formatted output to S from argument list ARG.  */
+extern int vsprintf (char *__restrict __s, const char *__restrict __format,
+		     _G_va_list __arg) __THROWNL;
+__END_NAMESPACE_STD
+
+#if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
+__BEGIN_NAMESPACE_C99
+/* Maximum chars of output to write in MAXLEN.  */
+extern int snprintf (char *__restrict __s, size_t __maxlen,
+		     const char *__restrict __format, ...)
+     __THROWNL __attribute__ ((__format__ (__printf__, 3, 4)));
+
+extern int vsnprintf (char *__restrict __s, size_t __maxlen,
+		      const char *__restrict __format, _G_va_list __arg)
+     __THROWNL __attribute__ ((__format__ (__printf__, 3, 0)));
+__END_NAMESPACE_C99
+#endif
+
+#ifdef __USE_GNU
+/* Write formatted output to a string dynamically allocated with `malloc'.
+   Store the address of the string in *PTR.  */
+extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
+		      _G_va_list __arg)
+     __THROWNL __attribute__ ((__format__ (__printf__, 2, 0))) __wur;
+extern int __asprintf (char **__restrict __ptr,
+		       const char *__restrict __fmt, ...)
+     __THROWNL __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
+extern int asprintf (char **__restrict __ptr,
+		     const char *__restrict __fmt, ...)
+     __THROWNL __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
+#endif
+
+#ifdef __USE_XOPEN2K8
+/* Write formatted output to a file descriptor.  */
+extern int vdprintf (int __fd, const char *__restrict __fmt,
+		     _G_va_list __arg)
+     __attribute__ ((__format__ (__printf__, 2, 0)));
+extern int dprintf (int __fd, const char *__restrict __fmt, ...)
+     __attribute__ ((__format__ (__printf__, 2, 3)));
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Read formatted input from STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fscanf (FILE *__restrict __stream,
+		   const char *__restrict __format, ...) __wur;
+/* Read formatted input from stdin.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int scanf (const char *__restrict __format, ...) __wur;
+/* Read formatted input from S.  */
+extern int sscanf (const char *__restrict __s,
+		   const char *__restrict __format, ...) __THROW;
+
+#if defined __USE_ISOC99 && !defined __USE_GNU \
+    && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
+    && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
+# ifdef __REDIRECT
+/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
+   GNU extension which conflicts with valid %a followed by letter
+   s, S or [.  */
+extern int __REDIRECT (fscanf, (FILE *__restrict __stream,
+				const char *__restrict __format, ...),
+		       __isoc99_fscanf) __wur;
+extern int __REDIRECT (scanf, (const char *__restrict __format, ...),
+		       __isoc99_scanf) __wur;
+extern int __REDIRECT_NTH (sscanf, (const char *__restrict __s,
+				    const char *__restrict __format, ...),
+			   __isoc99_sscanf);
+# else
+extern int __isoc99_fscanf (FILE *__restrict __stream,
+			    const char *__restrict __format, ...) __wur;
+extern int __isoc99_scanf (const char *__restrict __format, ...) __wur;
+extern int __isoc99_sscanf (const char *__restrict __s,
+			    const char *__restrict __format, ...) __THROW;
+#  define fscanf __isoc99_fscanf
+#  define scanf __isoc99_scanf
+#  define sscanf __isoc99_sscanf
+# endif
+#endif
+
+__END_NAMESPACE_STD
+
+#ifdef	__USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Read formatted input from S into argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
+		    _G_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 2, 0))) __wur;
+
+/* Read formatted input from stdin into argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vscanf (const char *__restrict __format, _G_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 1, 0))) __wur;
+
+/* Read formatted input from S into argument list ARG.  */
+extern int vsscanf (const char *__restrict __s,
+		    const char *__restrict __format, _G_va_list __arg)
+     __THROW __attribute__ ((__format__ (__scanf__, 2, 0)));
+
+# if !defined __USE_GNU \
+     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
+     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
+#  ifdef __REDIRECT
+/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
+   GNU extension which conflicts with valid %a followed by letter
+   s, S or [.  */
+extern int __REDIRECT (vfscanf,
+		       (FILE *__restrict __s,
+			const char *__restrict __format, _G_va_list __arg),
+		       __isoc99_vfscanf)
+     __attribute__ ((__format__ (__scanf__, 2, 0))) __wur;
+extern int __REDIRECT (vscanf, (const char *__restrict __format,
+				_G_va_list __arg), __isoc99_vscanf)
+     __attribute__ ((__format__ (__scanf__, 1, 0))) __wur;
+extern int __REDIRECT_NTH (vsscanf,
+			   (const char *__restrict __s,
+			    const char *__restrict __format,
+			    _G_va_list __arg), __isoc99_vsscanf)
+     __attribute__ ((__format__ (__scanf__, 2, 0)));
+#  else
+extern int __isoc99_vfscanf (FILE *__restrict __s,
+			     const char *__restrict __format,
+			     _G_va_list __arg) __wur;
+extern int __isoc99_vscanf (const char *__restrict __format,
+			    _G_va_list __arg) __wur;
+extern int __isoc99_vsscanf (const char *__restrict __s,
+			     const char *__restrict __format,
+			     _G_va_list __arg) __THROW;
+#   define vfscanf __isoc99_vfscanf
+#   define vscanf __isoc99_vscanf
+#   define vsscanf __isoc99_vsscanf
+#  endif
+# endif
+
+__END_NAMESPACE_C99
+#endif /* Use ISO C9x.  */
+
+
+__BEGIN_NAMESPACE_STD
+/* Read a character from STREAM.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int fgetc (FILE *__stream);
+extern int getc (FILE *__stream);
+
+/* Read a character from stdin.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int getchar (void);
+__END_NAMESPACE_STD
+
+/* The C standard explicitly says this is a macro, so we always do the
+   optimization for it.  */
+#define getc(_fp) _IO_getc (_fp)
+
+#if defined __USE_POSIX || defined __USE_MISC
+/* These are defined in POSIX.1:1996.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int getc_unlocked (FILE *__stream);
+extern int getchar_unlocked (void);
+#endif /* Use POSIX or MISC.  */
+
+#ifdef __USE_MISC
+/* Faster version when locking is not necessary.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fgetc_unlocked (FILE *__stream);
+#endif /* Use MISC.  */
+
+
+__BEGIN_NAMESPACE_STD
+/* Write a character to STREAM.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.
+
+   These functions is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fputc (int __c, FILE *__stream);
+extern int putc (int __c, FILE *__stream);
+
+/* Write a character to stdout.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int putchar (int __c);
+__END_NAMESPACE_STD
+
+/* The C standard explicitly says this can be a macro,
+   so we always do the optimization for it.  */
+#define putc(_ch, _fp) _IO_putc (_ch, _fp)
+
+#ifdef __USE_MISC
+/* Faster version when locking is not necessary.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fputc_unlocked (int __c, FILE *__stream);
+#endif /* Use MISC.  */
+
+#if defined __USE_POSIX || defined __USE_MISC
+/* These are defined in POSIX.1:1996.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern int putc_unlocked (int __c, FILE *__stream);
+extern int putchar_unlocked (int __c);
+#endif /* Use POSIX or MISC.  */
+
+
+#if defined __USE_SVID || defined __USE_MISC \
+    || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
+/* Get a word (int) from STREAM.  */
+extern int getw (FILE *__stream);
+
+/* Write a word (int) to STREAM.  */
+extern int putw (int __w, FILE *__stream);
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Get a newline-terminated string of finite length from STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
+     __wur;
+
+#if !defined __USE_ISOC11 \
+    || (defined __cplusplus && __cplusplus <= 201103L)
+/* Get a newline-terminated string from stdin, removing the newline.
+   DO NOT USE THIS FUNCTION!!  There is no limit on how much it will read.
+
+   The function has been officially removed in ISO C11.  This opportunity
+   is used to also remove it from the GNU feature list.  It is now only
+   available when explicitly using an old ISO C, Unix, or POSIX standard.
+   GCC defines _GNU_SOURCE when building C++ code and the function is still
+   in C++11, so it is also available for C++.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern char *gets (char *__s) __wur __attribute_deprecated__;
+#endif
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* This function does the same as `fgets' but does not lock the stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern char *fgets_unlocked (char *__restrict __s, int __n,
+			     FILE *__restrict __stream) __wur;
+#endif
+
+
+#ifdef	__USE_XOPEN2K8
+/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
+   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
+   NULL), pointing to *N characters of space.  It is realloc'd as
+   necessary.  Returns the number of characters read (not including the
+   null terminator), or -1 on error or EOF.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern _IO_ssize_t __getdelim (char **__restrict __lineptr,
+			       size_t *__restrict __n, int __delimiter,
+			       FILE *__restrict __stream) __wur;
+extern _IO_ssize_t getdelim (char **__restrict __lineptr,
+			     size_t *__restrict __n, int __delimiter,
+			     FILE *__restrict __stream) __wur;
+
+/* Like `getdelim', but reads up to a newline.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern _IO_ssize_t getline (char **__restrict __lineptr,
+			    size_t *__restrict __n,
+			    FILE *__restrict __stream) __wur;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Write a string to STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fputs (const char *__restrict __s, FILE *__restrict __stream);
+
+/* Write a string, followed by a newline, to stdout.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int puts (const char *__s);
+
+
+/* Push a character back onto the input buffer of STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int ungetc (int __c, FILE *__stream);
+
+
+/* Read chunks of generic data from STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern size_t fread (void *__restrict __ptr, size_t __size,
+		     size_t __n, FILE *__restrict __stream) __wur;
+/* Write chunks of generic data to STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern size_t fwrite (const void *__restrict __ptr, size_t __size,
+		      size_t __n, FILE *__restrict __s);
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* This function does the same as `fputs' but does not lock the stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fputs_unlocked (const char *__restrict __s,
+			   FILE *__restrict __stream);
+#endif
+
+#ifdef __USE_MISC
+/* Faster versions when locking is not necessary.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
+			      size_t __n, FILE *__restrict __stream) __wur;
+extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
+			       size_t __n, FILE *__restrict __stream);
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Seek to a certain position on STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fseek (FILE *__stream, long int __off, int __whence);
+/* Return the current position of STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern long int ftell (FILE *__stream) __wur;
+/* Rewind to the beginning of STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void rewind (FILE *__stream);
+__END_NAMESPACE_STD
+
+/* The Single Unix Specification, Version 2, specifies an alternative,
+   more adequate interface for the two functions above which deal with
+   file offset.  `long int' is not the right type.  These definitions
+   are originally defined in the Large File Support API.  */
+
+#if defined __USE_LARGEFILE || defined __USE_XOPEN2K
+# ifndef __USE_FILE_OFFSET64
+/* Seek to a certain position on STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fseeko (FILE *__stream, __off_t __off, int __whence);
+/* Return the current position of STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern __off_t ftello (FILE *__stream) __wur;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (fseeko,
+		       (FILE *__stream, __off64_t __off, int __whence),
+		       fseeko64);
+extern __off64_t __REDIRECT (ftello, (FILE *__stream), ftello64);
+#  else
+#   define fseeko fseeko64
+#   define ftello ftello64
+#  endif
+# endif
+#endif
+
+__BEGIN_NAMESPACE_STD
+#ifndef __USE_FILE_OFFSET64
+/* Get STREAM's position.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
+/* Set STREAM's position.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fsetpos (FILE *__stream, const fpos_t *__pos);
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fgetpos, (FILE *__restrict __stream,
+				 fpos_t *__restrict __pos), fgetpos64);
+extern int __REDIRECT (fsetpos,
+		       (FILE *__stream, const fpos_t *__pos), fsetpos64);
+# else
+#  define fgetpos fgetpos64
+#  define fsetpos fsetpos64
+# endif
+#endif
+__END_NAMESPACE_STD
+
+#ifdef __USE_LARGEFILE64
+extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
+extern __off64_t ftello64 (FILE *__stream) __wur;
+extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
+extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Clear the error and EOF indicators for STREAM.  */
+extern void clearerr (FILE *__stream) __THROW;
+/* Return the EOF indicator for STREAM.  */
+extern int feof (FILE *__stream) __THROW __wur;
+/* Return the error indicator for STREAM.  */
+extern int ferror (FILE *__stream) __THROW __wur;
+__END_NAMESPACE_STD
+
+#ifdef __USE_MISC
+/* Faster versions when locking is not required.  */
+extern void clearerr_unlocked (FILE *__stream) __THROW;
+extern int feof_unlocked (FILE *__stream) __THROW __wur;
+extern int ferror_unlocked (FILE *__stream) __THROW __wur;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Print a message describing the meaning of the value of errno.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void perror (const char *__s);
+__END_NAMESPACE_STD
+
+/* Provide the declarations for `sys_errlist' and `sys_nerr' if they
+   are available on this system.  Even if available, these variables
+   should not be used directly.  The `strerror' function provides
+   all the necessary functionality.  */
+#include <bits/sys_errlist.h>
+
+
+#ifdef	__USE_POSIX
+/* Return the system file descriptor for STREAM.  */
+extern int fileno (FILE *__stream) __THROW __wur;
+#endif /* Use POSIX.  */
+
+#ifdef __USE_MISC
+/* Faster version when locking is not required.  */
+extern int fileno_unlocked (FILE *__stream) __THROW __wur;
+#endif
+
+
+#if (defined __USE_POSIX2 || defined __USE_SVID  || defined __USE_BSD || \
+     defined __USE_MISC)
+/* Create a new stream connected to a pipe running the given command.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern FILE *popen (const char *__command, const char *__modes) __wur;
+
+/* Close a stream opened by popen and return the status of its child.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int pclose (FILE *__stream);
+#endif
+
+
+#ifdef	__USE_POSIX
+/* Return the name of the controlling terminal.  */
+extern char *ctermid (char *__s) __THROW;
+#endif /* Use POSIX.  */
+
+
+#ifdef __USE_XOPEN
+/* Return the name of the current user.  */
+extern char *cuserid (char *__s);
+#endif /* Use X/Open, but not issue 6.  */
+
+
+#ifdef	__USE_GNU
+struct obstack;			/* See <obstack.h>.  */
+
+/* Write formatted output to an obstack.  */
+extern int obstack_printf (struct obstack *__restrict __obstack,
+			   const char *__restrict __format, ...)
+     __THROWNL __attribute__ ((__format__ (__printf__, 2, 3)));
+extern int obstack_vprintf (struct obstack *__restrict __obstack,
+			    const char *__restrict __format,
+			    _G_va_list __args)
+     __THROWNL __attribute__ ((__format__ (__printf__, 2, 0)));
+#endif /* Use GNU.  */
+
+
+#if defined __USE_POSIX || defined __USE_MISC
+/* These are defined in POSIX.1:1996.  */
+
+/* Acquire ownership of STREAM.  */
+extern void flockfile (FILE *__stream) __THROW;
+
+/* Try to acquire ownership of STREAM but do not block if it is not
+   possible.  */
+extern int ftrylockfile (FILE *__stream) __THROW __wur;
+
+/* Relinquish the ownership granted for STREAM.  */
+extern void funlockfile (FILE *__stream) __THROW;
+#endif /* POSIX || misc */
+
+#if defined __USE_XOPEN && !defined __USE_XOPEN2K && !defined __USE_GNU
+/* The X/Open standard requires some functions and variables to be
+   declared here which do not belong into this header.  But we have to
+   follow.  In GNU mode we don't do this nonsense.  */
+# define __need_getopt
+# include <getopt.h>
+#endif	/* X/Open, but not issue 6 and not for GNU.  */
+
+/* If we are compiling with optimizing read this file.  It contains
+   several optimizing inline functions and macros.  */
+#ifdef __USE_EXTERN_INLINES
+# include <bits/stdio.h>
+#endif
+#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
+# include <bits/stdio2.h>
+#endif
+#ifdef __LDBL_COMPAT
+# include <bits/stdio-ldbl.h>
+#endif
+
+__END_DECLS
+
+#endif /* <stdio.h> included.  */
+
+#endif /* !_STDIO_H */
diff --git a/include/stdio_ext.h b/include/stdio_ext.h
new file mode 100644
index 0000000..c32d5a5
--- /dev/null
+++ b/include/stdio_ext.h
@@ -0,0 +1,86 @@
+/* Functions to access FILE structure internals.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This header contains the same definitions as the header of the same name
+   on Sun's Solaris OS.  */
+
+#ifndef _STDIO_EXT_H
+#define _STDIO_EXT_H	1
+
+#include <stdio.h>
+
+enum
+{
+  /* Query current state of the locking status.  */
+  FSETLOCKING_QUERY = 0,
+#define FSETLOCKING_QUERY	FSETLOCKING_QUERY
+  /* The library protects all uses of the stream functions, except for
+     uses of the *_unlocked functions, by calls equivalent to flockfile().  */
+  FSETLOCKING_INTERNAL,
+#define FSETLOCKING_INTERNAL	FSETLOCKING_INTERNAL
+  /* The user will take care of locking.  */
+  FSETLOCKING_BYCALLER
+#define FSETLOCKING_BYCALLER	FSETLOCKING_BYCALLER
+};
+
+
+__BEGIN_DECLS
+
+/* Return the size of the buffer of FP in bytes currently in use by
+   the given stream.  */
+extern size_t __fbufsize (FILE *__fp) __THROW;
+
+
+/* Return non-zero value iff the stream FP is opened readonly, or if the
+   last operation on the stream was a read operation.  */
+extern int __freading (FILE *__fp) __THROW;
+
+/* Return non-zero value iff the stream FP is opened write-only or
+   append-only, or if the last operation on the stream was a write
+   operation.  */
+extern int __fwriting (FILE *__fp) __THROW;
+
+
+/* Return non-zero value iff stream FP is not opened write-only or
+   append-only.  */
+extern int __freadable (FILE *__fp) __THROW;
+
+/* Return non-zero value iff stream FP is not opened read-only.  */
+extern int __fwritable (FILE *__fp) __THROW;
+
+
+/* Return non-zero value iff the stream FP is line-buffered.  */
+extern int __flbf (FILE *__fp) __THROW;
+
+
+/* Discard all pending buffered I/O on the stream FP.  */
+extern void __fpurge (FILE *__fp) __THROW;
+
+/* Return amount of output in bytes pending on a stream FP.  */
+extern size_t __fpending (FILE *__fp) __THROW;
+
+/* Flush all line-buffered files.  */
+extern void _flushlbf (void);
+
+
+/* Set locking status of stream FP to TYPE.  */
+extern int __fsetlocking (FILE *__fp, int __type) __THROW;
+
+__END_DECLS
+
+#endif	/* stdio_ext.h */
diff --git a/include/stdlib.h b/include/stdlib.h
new file mode 100644
index 0000000..d35ffac
--- /dev/null
+++ b/include/stdlib.h
@@ -0,0 +1,970 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
+ */
+
+#ifndef	_STDLIB_H
+
+#include <features.h>
+
+/* Get size_t, wchar_t and NULL from <stddef.h>.  */
+#define		__need_size_t
+#ifndef __need_malloc_and_calloc
+# define	__need_wchar_t
+# define	__need_NULL
+#endif
+#include <stddef.h>
+
+__BEGIN_DECLS
+
+#ifndef __need_malloc_and_calloc
+#define	_STDLIB_H	1
+
+#if (defined __USE_XOPEN || defined __USE_XOPEN2K8) && !defined _SYS_WAIT_H
+/* XPG requires a few symbols from <sys/wait.h> being defined.  */
+# include <bits/waitflags.h>
+# include <bits/waitstatus.h>
+
+# ifdef __USE_BSD
+
+/* Lots of hair to allow traditional BSD use of `union wait'
+   as well as POSIX.1 use of `int' for the status word.  */
+
+#  if defined __GNUC__ && !defined __cplusplus
+#   define __WAIT_INT(status) \
+  (__extension__ (((union { __typeof(status) __in; int __i; }) \
+		   { .__in = (status) }).__i))
+#  else
+#   define __WAIT_INT(status)	(*(int *) &(status))
+#  endif
+
+/* This is the type of the argument to `wait'.  The funky union
+   causes redeclarations with either `int *' or `union wait *' to be
+   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
+   the actual function definitions.  */
+
+#  if !defined __GNUC__ || __GNUC__ < 2 || defined __cplusplus
+#   define __WAIT_STATUS	void *
+#   define __WAIT_STATUS_DEFN	void *
+#  else
+/* This works in GCC 2.6.1 and later.  */
+typedef union
+  {
+    union wait *__uptr;
+    int *__iptr;
+  } __WAIT_STATUS __attribute__ ((__transparent_union__));
+#   define __WAIT_STATUS_DEFN	int *
+#  endif
+
+# else /* Don't use BSD.  */
+
+#  define __WAIT_INT(status)	(status)
+#  define __WAIT_STATUS		int *
+#  define __WAIT_STATUS_DEFN	int *
+
+# endif /* Use BSD.  */
+
+/* Define the macros <sys/wait.h> also would define this way.  */
+# define WEXITSTATUS(status)	__WEXITSTATUS (__WAIT_INT (status))
+# define WTERMSIG(status)	__WTERMSIG (__WAIT_INT (status))
+# define WSTOPSIG(status)	__WSTOPSIG (__WAIT_INT (status))
+# define WIFEXITED(status)	__WIFEXITED (__WAIT_INT (status))
+# define WIFSIGNALED(status)	__WIFSIGNALED (__WAIT_INT (status))
+# define WIFSTOPPED(status)	__WIFSTOPPED (__WAIT_INT (status))
+# ifdef __WIFCONTINUED
+#  define WIFCONTINUED(status)	__WIFCONTINUED (__WAIT_INT (status))
+# endif
+#endif	/* X/Open or XPG7 and <sys/wait.h> not included.  */
+
+__BEGIN_NAMESPACE_STD
+/* Returned by `div'.  */
+typedef struct
+  {
+    int quot;			/* Quotient.  */
+    int rem;			/* Remainder.  */
+  } div_t;
+
+/* Returned by `ldiv'.  */
+#ifndef __ldiv_t_defined
+typedef struct
+  {
+    long int quot;		/* Quotient.  */
+    long int rem;		/* Remainder.  */
+  } ldiv_t;
+# define __ldiv_t_defined	1
+#endif
+__END_NAMESPACE_STD
+
+#if defined __USE_ISOC99 && !defined __lldiv_t_defined
+__BEGIN_NAMESPACE_C99
+/* Returned by `lldiv'.  */
+__extension__ typedef struct
+  {
+    long long int quot;		/* Quotient.  */
+    long long int rem;		/* Remainder.  */
+  } lldiv_t;
+# define __lldiv_t_defined	1
+__END_NAMESPACE_C99
+#endif
+
+
+/* The largest number rand will return (same as INT_MAX).  */
+#define	RAND_MAX	2147483647
+
+
+/* We define these the same for all machines.
+   Changes from this to the outside world should be done in `_exit'.  */
+#define	EXIT_FAILURE	1	/* Failing exit status.  */
+#define	EXIT_SUCCESS	0	/* Successful exit status.  */
+
+
+/* Maximum length of a multibyte character in the current locale.  */
+#define	MB_CUR_MAX	(__ctype_get_mb_cur_max ())
+extern size_t __ctype_get_mb_cur_max (void) __THROW __wur;
+
+
+__BEGIN_NAMESPACE_STD
+/* Convert a string to a floating-point number.  */
+extern double atof (const char *__nptr)
+     __THROW __attribute_pure__ __nonnull ((1)) __wur;
+/* Convert a string to an integer.  */
+extern int atoi (const char *__nptr)
+     __THROW __attribute_pure__ __nonnull ((1)) __wur;
+/* Convert a string to a long integer.  */
+extern long int atol (const char *__nptr)
+     __THROW __attribute_pure__ __nonnull ((1)) __wur;
+__END_NAMESPACE_STD
+
+#if defined __USE_ISOC99 || defined __USE_MISC
+__BEGIN_NAMESPACE_C99
+/* Convert a string to a long long integer.  */
+__extension__ extern long long int atoll (const char *__nptr)
+     __THROW __attribute_pure__ __nonnull ((1)) __wur;
+__END_NAMESPACE_C99
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Convert a string to a floating-point number.  */
+extern double strtod (const char *__restrict __nptr,
+		      char **__restrict __endptr)
+     __THROW __nonnull ((1));
+__END_NAMESPACE_STD
+
+#ifdef	__USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
+extern float strtof (const char *__restrict __nptr,
+		     char **__restrict __endptr) __THROW __nonnull ((1));
+
+extern long double strtold (const char *__restrict __nptr,
+			    char **__restrict __endptr)
+     __THROW __nonnull ((1));
+__END_NAMESPACE_C99
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Convert a string to a long integer.  */
+extern long int strtol (const char *__restrict __nptr,
+			char **__restrict __endptr, int __base)
+     __THROW __nonnull ((1));
+/* Convert a string to an unsigned long integer.  */
+extern unsigned long int strtoul (const char *__restrict __nptr,
+				  char **__restrict __endptr, int __base)
+     __THROW __nonnull ((1));
+__END_NAMESPACE_STD
+
+#ifdef __USE_BSD
+/* Convert a string to a quadword integer.  */
+__extension__
+extern long long int strtoq (const char *__restrict __nptr,
+			     char **__restrict __endptr, int __base)
+     __THROW __nonnull ((1));
+/* Convert a string to an unsigned quadword integer.  */
+__extension__
+extern unsigned long long int strtouq (const char *__restrict __nptr,
+				       char **__restrict __endptr, int __base)
+     __THROW __nonnull ((1));
+#endif /* Use BSD.  */
+
+#if defined __USE_ISOC99 || defined __USE_MISC
+__BEGIN_NAMESPACE_C99
+/* Convert a string to a quadword integer.  */
+__extension__
+extern long long int strtoll (const char *__restrict __nptr,
+			      char **__restrict __endptr, int __base)
+     __THROW __nonnull ((1));
+/* Convert a string to an unsigned quadword integer.  */
+__extension__
+extern unsigned long long int strtoull (const char *__restrict __nptr,
+					char **__restrict __endptr, int __base)
+     __THROW __nonnull ((1));
+__END_NAMESPACE_C99
+#endif /* ISO C99 or use MISC.  */
+
+
+#ifdef __USE_GNU
+/* The concept of one static locale per category is not very well
+   thought out.  Many applications will need to process its data using
+   information from several different locales.  Another problem is
+   the implementation of the internationalization handling in the
+   ISO C++ standard library.  To support this another set of
+   the functions using locale data exist which take an additional
+   argument.
+
+   Attention: even though several *_l interfaces are part of POSIX:2008,
+   these are not.  */
+
+/* Structure for reentrant locale using functions.  This is an
+   (almost) opaque type for the user level programs.  */
+# include <xlocale.h>
+
+/* Special versions of the functions above which take the locale to
+   use as an additional parameter.  */
+extern long int strtol_l (const char *__restrict __nptr,
+			  char **__restrict __endptr, int __base,
+			  __locale_t __loc) __THROW __nonnull ((1, 4));
+
+extern unsigned long int strtoul_l (const char *__restrict __nptr,
+				    char **__restrict __endptr,
+				    int __base, __locale_t __loc)
+     __THROW __nonnull ((1, 4));
+
+__extension__
+extern long long int strtoll_l (const char *__restrict __nptr,
+				char **__restrict __endptr, int __base,
+				__locale_t __loc)
+     __THROW __nonnull ((1, 4));
+
+__extension__
+extern unsigned long long int strtoull_l (const char *__restrict __nptr,
+					  char **__restrict __endptr,
+					  int __base, __locale_t __loc)
+     __THROW __nonnull ((1, 4));
+
+extern double strtod_l (const char *__restrict __nptr,
+			char **__restrict __endptr, __locale_t __loc)
+     __THROW __nonnull ((1, 3));
+
+extern float strtof_l (const char *__restrict __nptr,
+		       char **__restrict __endptr, __locale_t __loc)
+     __THROW __nonnull ((1, 3));
+
+extern long double strtold_l (const char *__restrict __nptr,
+			      char **__restrict __endptr,
+			      __locale_t __loc)
+     __THROW __nonnull ((1, 3));
+#endif /* GNU */
+
+
+#ifdef __USE_EXTERN_INLINES
+__BEGIN_NAMESPACE_STD
+__extern_inline int
+__NTH (atoi (const char *__nptr))
+{
+  return (int) strtol (__nptr, (char **) NULL, 10);
+}
+__extern_inline long int
+__NTH (atol (const char *__nptr))
+{
+  return strtol (__nptr, (char **) NULL, 10);
+}
+__END_NAMESPACE_STD
+
+# if defined __USE_MISC || defined __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+__extension__ __extern_inline long long int
+__NTH (atoll (const char *__nptr))
+{
+  return strtoll (__nptr, (char **) NULL, 10);
+}
+__END_NAMESPACE_C99
+# endif
+#endif /* Optimizing and Inlining.  */
+
+
+#if defined __USE_SVID || defined __USE_XOPEN_EXTENDED
+/* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
+   digit first.  Returns a pointer to static storage overwritten by the
+   next call.  */
+extern char *l64a (long int __n) __THROW __wur;
+
+/* Read a number from a string S in base 64 as above.  */
+extern long int a64l (const char *__s)
+     __THROW __attribute_pure__ __nonnull ((1)) __wur;
+
+#endif	/* Use SVID || extended X/Open.  */
+
+#if defined __USE_SVID || defined __USE_XOPEN_EXTENDED || defined __USE_BSD
+# include <sys/types.h>	/* we need int32_t... */
+
+/* These are the functions that actually do things.  The `random', `srandom',
+   `initstate' and `setstate' functions are those from BSD Unices.
+   The `rand' and `srand' functions are required by the ANSI standard.
+   We provide both interfaces to the same random number generator.  */
+/* Return a random long integer between 0 and RAND_MAX inclusive.  */
+extern long int random (void) __THROW;
+
+/* Seed the random number generator with the given number.  */
+extern void srandom (unsigned int __seed) __THROW;
+
+/* Initialize the random number generator to use state buffer STATEBUF,
+   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
+   32, 64, 128 and 256, the bigger the better; values less than 8 will
+   cause an error and values greater than 256 will be rounded down.  */
+extern char *initstate (unsigned int __seed, char *__statebuf,
+			size_t __statelen) __THROW __nonnull ((2));
+
+/* Switch the random number generator to state buffer STATEBUF,
+   which should have been previously initialized by `initstate'.  */
+extern char *setstate (char *__statebuf) __THROW __nonnull ((1));
+
+
+# ifdef __USE_MISC
+/* Reentrant versions of the `random' family of functions.
+   These functions all use the following data structure to contain
+   state, rather than global state variables.  */
+
+struct random_data
+  {
+    int32_t *fptr;		/* Front pointer.  */
+    int32_t *rptr;		/* Rear pointer.  */
+    int32_t *state;		/* Array of state values.  */
+    int rand_type;		/* Type of random number generator.  */
+    int rand_deg;		/* Degree of random number generator.  */
+    int rand_sep;		/* Distance between front and rear.  */
+    int32_t *end_ptr;		/* Pointer behind state table.  */
+  };
+
+extern int random_r (struct random_data *__restrict __buf,
+		     int32_t *__restrict __result) __THROW __nonnull ((1, 2));
+
+extern int srandom_r (unsigned int __seed, struct random_data *__buf)
+     __THROW __nonnull ((2));
+
+extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
+			size_t __statelen,
+			struct random_data *__restrict __buf)
+     __THROW __nonnull ((2, 4));
+
+extern int setstate_r (char *__restrict __statebuf,
+		       struct random_data *__restrict __buf)
+     __THROW __nonnull ((1, 2));
+# endif	/* Use misc.  */
+#endif	/* Use SVID || extended X/Open || BSD. */
+
+
+__BEGIN_NAMESPACE_STD
+/* Return a random integer between 0 and RAND_MAX inclusive.  */
+extern int rand (void) __THROW;
+/* Seed the random number generator with the given number.  */
+extern void srand (unsigned int __seed) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_POSIX
+/* Reentrant interface according to POSIX.1.  */
+extern int rand_r (unsigned int *__seed) __THROW;
+#endif
+
+
+#if defined __USE_SVID || defined __USE_XOPEN
+/* System V style 48-bit random number generator functions.  */
+
+/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
+extern double drand48 (void) __THROW;
+extern double erand48 (unsigned short int __xsubi[3]) __THROW __nonnull ((1));
+
+/* Return non-negative, long integer in [0,2^31).  */
+extern long int lrand48 (void) __THROW;
+extern long int nrand48 (unsigned short int __xsubi[3])
+     __THROW __nonnull ((1));
+
+/* Return signed, long integers in [-2^31,2^31).  */
+extern long int mrand48 (void) __THROW;
+extern long int jrand48 (unsigned short int __xsubi[3])
+     __THROW __nonnull ((1));
+
+/* Seed random number generator.  */
+extern void srand48 (long int __seedval) __THROW;
+extern unsigned short int *seed48 (unsigned short int __seed16v[3])
+     __THROW __nonnull ((1));
+extern void lcong48 (unsigned short int __param[7]) __THROW __nonnull ((1));
+
+# ifdef __USE_MISC
+/* Data structure for communication with thread safe versions.  This
+   type is to be regarded as opaque.  It's only exported because users
+   have to allocate objects of this type.  */
+struct drand48_data
+  {
+    unsigned short int __x[3];	/* Current state.  */
+    unsigned short int __old_x[3]; /* Old state.  */
+    unsigned short int __c;	/* Additive const. in congruential formula.  */
+    unsigned short int __init;	/* Flag for initializing.  */
+    __extension__ unsigned long long int __a;	/* Factor in congruential
+						   formula.  */
+  };
+
+/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
+extern int drand48_r (struct drand48_data *__restrict __buffer,
+		      double *__restrict __result) __THROW __nonnull ((1, 2));
+extern int erand48_r (unsigned short int __xsubi[3],
+		      struct drand48_data *__restrict __buffer,
+		      double *__restrict __result) __THROW __nonnull ((1, 2));
+
+/* Return non-negative, long integer in [0,2^31).  */
+extern int lrand48_r (struct drand48_data *__restrict __buffer,
+		      long int *__restrict __result)
+     __THROW __nonnull ((1, 2));
+extern int nrand48_r (unsigned short int __xsubi[3],
+		      struct drand48_data *__restrict __buffer,
+		      long int *__restrict __result)
+     __THROW __nonnull ((1, 2));
+
+/* Return signed, long integers in [-2^31,2^31).  */
+extern int mrand48_r (struct drand48_data *__restrict __buffer,
+		      long int *__restrict __result)
+     __THROW __nonnull ((1, 2));
+extern int jrand48_r (unsigned short int __xsubi[3],
+		      struct drand48_data *__restrict __buffer,
+		      long int *__restrict __result)
+     __THROW __nonnull ((1, 2));
+
+/* Seed random number generator.  */
+extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
+     __THROW __nonnull ((2));
+
+extern int seed48_r (unsigned short int __seed16v[3],
+		     struct drand48_data *__buffer) __THROW __nonnull ((1, 2));
+
+extern int lcong48_r (unsigned short int __param[7],
+		      struct drand48_data *__buffer)
+     __THROW __nonnull ((1, 2));
+# endif	/* Use misc.  */
+#endif	/* Use SVID or X/Open.  */
+
+#endif /* don't just need malloc and calloc */
+
+#ifndef __malloc_and_calloc_defined
+# define __malloc_and_calloc_defined
+__BEGIN_NAMESPACE_STD
+/* Allocate SIZE bytes of memory.  */
+extern void *malloc (size_t __size) __THROW __attribute_malloc__ __wur;
+/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
+extern void *calloc (size_t __nmemb, size_t __size)
+     __THROW __attribute_malloc__ __wur;
+__END_NAMESPACE_STD
+#endif
+
+#ifndef __need_malloc_and_calloc
+__BEGIN_NAMESPACE_STD
+/* Re-allocate the previously allocated block
+   in PTR, making the new block SIZE bytes long.  */
+/* __attribute_malloc__ is not used, because if realloc returns
+   the same pointer that was passed to it, aliasing needs to be allowed
+   between objects pointed by the old and new pointers.  */
+extern void *realloc (void *__ptr, size_t __size)
+     __THROW __attribute_warn_unused_result__;
+/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
+extern void free (void *__ptr) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef	__USE_MISC
+/* Free a block.  An alias for `free'.	(Sun Unices).  */
+extern void cfree (void *__ptr) __THROW;
+#endif /* Use misc.  */
+
+#if defined __USE_GNU || defined __USE_BSD || defined __USE_MISC
+# include <alloca.h>
+#endif /* Use GNU, BSD, or misc.  */
+
+#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \
+    || defined __USE_BSD
+/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
+extern void *valloc (size_t __size) __THROW __attribute_malloc__ __wur;
+#endif
+
+#ifdef __USE_XOPEN2K
+/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */
+extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
+     __THROW __nonnull ((1)) __wur;
+#endif
+
+#ifdef __USE_ISOC11
+/* ISO C variant of aligned allocation.  */
+extern void *aligned_alloc (size_t __alignment, size_t __size)
+     __THROW __attribute_malloc__ __attribute_alloc_size__ ((2)) __wur;
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Abort execution and generate a core-dump.  */
+extern void abort (void) __THROW __attribute__ ((__noreturn__));
+
+
+/* Register a function to be called when `exit' is called.  */
+extern int atexit (void (*__func) (void)) __THROW __nonnull ((1));
+
+#if defined __USE_ISOC11 || defined __USE_ISOCXX11
+/* Register a function to be called when `quick_exit' is called.  */
+# ifdef __cplusplus
+extern "C++" int at_quick_exit (void (*__func) (void))
+     __THROW __asm ("at_quick_exit") __nonnull ((1));
+# else
+extern int at_quick_exit (void (*__func) (void)) __THROW __nonnull ((1));
+# endif
+#endif
+__END_NAMESPACE_STD
+
+#ifdef	__USE_MISC
+/* Register a function to be called with the status
+   given to `exit' and the given argument.  */
+extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
+     __THROW __nonnull ((1));
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Call all functions registered with `atexit' and `on_exit',
+   in the reverse of the order in which they were registered,
+   perform stdio cleanup, and terminate program execution with STATUS.  */
+extern void exit (int __status) __THROW __attribute__ ((__noreturn__));
+
+#if defined __USE_ISOC11 || defined __USE_ISOCXX11
+/* Call all functions registered with `at_quick_exit' in the reverse
+   of the order in which they were registered and terminate program
+   execution with STATUS.  */
+extern void quick_exit (int __status) __THROW __attribute__ ((__noreturn__));
+#endif
+__END_NAMESPACE_STD
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Terminate the program with STATUS without calling any of the
+   functions registered with `atexit' or `on_exit'.  */
+extern void _Exit (int __status) __THROW __attribute__ ((__noreturn__));
+__END_NAMESPACE_C99
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
+extern char *getenv (const char *__name) __THROW __nonnull ((1)) __wur;
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* This function is similar to the above but returns NULL if the
+   programs is running with SUID or SGID enabled.  */
+extern char *secure_getenv (const char *__name)
+     __THROW __nonnull ((1)) __wur;
+#endif
+
+#if defined __USE_SVID || defined __USE_XOPEN
+/* The SVID says this is in <stdio.h>, but this seems a better place.	*/
+/* Put STRING, which is of the form "NAME=VALUE", in the environment.
+   If there is no `=', remove NAME from the environment.  */
+extern int putenv (char *__string) __THROW __nonnull ((1));
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+/* Set NAME to VALUE in the environment.
+   If REPLACE is nonzero, overwrite an existing value.  */
+extern int setenv (const char *__name, const char *__value, int __replace)
+     __THROW __nonnull ((2));
+
+/* Remove the variable NAME from the environment.  */
+extern int unsetenv (const char *__name) __THROW __nonnull ((1));
+#endif
+
+#ifdef	__USE_MISC
+/* The `clearenv' was planned to be added to POSIX.1 but probably
+   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
+   for Fortran 77) requires this function.  */
+extern int clearenv (void) __THROW;
+#endif
+
+
+#if defined __USE_MISC \
+    || (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8)
+/* Generate a unique temporary file name from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   Always returns TEMPLATE, it's either a temporary file name or a null
+   string if it cannot get a unique file name.  */
+extern char *mktemp (char *__template) __THROW __nonnull ((1));
+#endif
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED \
+    || defined __USE_XOPEN2K8
+/* Generate a unique temporary file name from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the filename unique.
+   Returns a file descriptor open on the file for reading and writing,
+   or -1 if it cannot create a uniquely-named file.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int mkstemp (char *__template) __nonnull ((1)) __wur;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (mkstemp, (char *__template), mkstemp64)
+     __nonnull ((1)) __wur;
+#  else
+#   define mkstemp mkstemp64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int mkstemp64 (char *__template) __nonnull ((1)) __wur;
+# endif
+#endif
+
+#ifdef __USE_MISC
+/* Similar to mkstemp, but the template can have a suffix after the
+   XXXXXX.  The length of the suffix is specified in the second
+   parameter.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int mkstemps (char *__template, int __suffixlen) __nonnull ((1)) __wur;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (mkstemps, (char *__template, int __suffixlen),
+		       mkstemps64) __nonnull ((1)) __wur;
+#  else
+#   define mkstemps mkstemps64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int mkstemps64 (char *__template, int __suffixlen)
+     __nonnull ((1)) __wur;
+# endif
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN2K8
+/* Create a unique temporary directory from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the directory name unique.
+   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
+   The directory is created mode 700.  */
+extern char *mkdtemp (char *__template) __THROW __nonnull ((1)) __wur;
+#endif
+
+#ifdef __USE_GNU
+/* Generate a unique temporary file name from TEMPLATE similar to
+   mkstemp.  But allow the caller to pass additional flags which are
+   used in the open call to create the file..
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int mkostemp (char *__template, int __flags) __nonnull ((1)) __wur;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (mkostemp, (char *__template, int __flags), mkostemp64)
+     __nonnull ((1)) __wur;
+#  else
+#   define mkostemp mkostemp64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int mkostemp64 (char *__template, int __flags) __nonnull ((1)) __wur;
+# endif
+
+/* Similar to mkostemp, but the template can have a suffix after the
+   XXXXXX.  The length of the suffix is specified in the second
+   parameter.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int mkostemps (char *__template, int __suffixlen, int __flags)
+     __nonnull ((1)) __wur;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (mkostemps, (char *__template, int __suffixlen,
+				   int __flags), mkostemps64)
+     __nonnull ((1)) __wur;
+#  else
+#   define mkostemps mkostemps64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
+     __nonnull ((1)) __wur;
+# endif
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Execute the given line as a shell command.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int system (const char *__command) __wur;
+__END_NAMESPACE_STD
+
+
+#ifdef	__USE_GNU
+/* Return a malloc'd string containing the canonical absolute name of the
+   existing named file.  */
+extern char *canonicalize_file_name (const char *__name)
+     __THROW __nonnull ((1)) __wur;
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Return the canonical absolute name of file NAME.  If RESOLVED is
+   null, the result is malloc'd; otherwise, if the canonical name is
+   PATH_MAX chars or more, returns null with `errno' set to
+   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
+   returns the name in RESOLVED.  */
+extern char *realpath (const char *__restrict __name,
+		       char *__restrict __resolved) __THROW __wur;
+#endif
+
+
+/* Shorthand for type of comparison functions.  */
+#ifndef __COMPAR_FN_T
+# define __COMPAR_FN_T
+typedef int (*__compar_fn_t) (const void *, const void *);
+
+# ifdef	__USE_GNU
+typedef __compar_fn_t comparison_fn_t;
+# endif
+#endif
+#ifdef __USE_GNU
+typedef int (*__compar_d_fn_t) (const void *, const void *, void *);
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Do a binary search for KEY in BASE, which consists of NMEMB elements
+   of SIZE bytes each, using COMPAR to perform the comparisons.  */
+extern void *bsearch (const void *__key, const void *__base,
+		      size_t __nmemb, size_t __size, __compar_fn_t __compar)
+     __nonnull ((1, 2, 5)) __wur;
+
+#ifdef __USE_EXTERN_INLINES
+# include <bits/stdlib-bsearch.h>
+#endif
+
+/* Sort NMEMB elements of BASE, of SIZE bytes each,
+   using COMPAR to perform the comparisons.  */
+extern void qsort (void *__base, size_t __nmemb, size_t __size,
+		   __compar_fn_t __compar) __nonnull ((1, 4));
+#ifdef __USE_GNU
+extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
+		     __compar_d_fn_t __compar, void *__arg)
+  __nonnull ((1, 4));
+#endif
+
+
+/* Return the absolute value of X.  */
+extern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;
+extern long int labs (long int __x) __THROW __attribute__ ((__const__)) __wur;
+__END_NAMESPACE_STD
+
+#ifdef __USE_ISOC99
+__extension__ extern long long int llabs (long long int __x)
+     __THROW __attribute__ ((__const__)) __wur;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return the `div_t', `ldiv_t' or `lldiv_t' representation
+   of the value of NUMER over DENOM. */
+/* GCC may have built-ins for these someday.  */
+extern div_t div (int __numer, int __denom)
+     __THROW __attribute__ ((__const__)) __wur;
+extern ldiv_t ldiv (long int __numer, long int __denom)
+     __THROW __attribute__ ((__const__)) __wur;
+__END_NAMESPACE_STD
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+__extension__ extern lldiv_t lldiv (long long int __numer,
+				    long long int __denom)
+     __THROW __attribute__ ((__const__)) __wur;
+__END_NAMESPACE_C99
+#endif
+
+
+#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \
+    || defined __USE_SVID
+/* Convert floating point numbers to strings.  The returned values are
+   valid only until another call to the same function.  */
+
+/* Convert VALUE to a string with NDIGIT digits and return a pointer to
+   this.  Set *DECPT with the position of the decimal character and *SIGN
+   with the sign of the number.  */
+extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
+		   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;
+
+/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT
+   with the position of the decimal character and *SIGN with the sign of
+   the number.  */
+extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
+		   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;
+
+/* If possible convert VALUE to a string with NDIGIT significant digits.
+   Otherwise use exponential representation.  The resulting string will
+   be written to BUF.  */
+extern char *gcvt (double __value, int __ndigit, char *__buf)
+     __THROW __nonnull ((3)) __wur;
+#endif
+
+#ifdef __USE_MISC
+/* Long double versions of above functions.  */
+extern char *qecvt (long double __value, int __ndigit,
+		    int *__restrict __decpt, int *__restrict __sign)
+     __THROW __nonnull ((3, 4)) __wur;
+extern char *qfcvt (long double __value, int __ndigit,
+		    int *__restrict __decpt, int *__restrict __sign)
+     __THROW __nonnull ((3, 4)) __wur;
+extern char *qgcvt (long double __value, int __ndigit, char *__buf)
+     __THROW __nonnull ((3)) __wur;
+
+
+/* Reentrant version of the functions above which provide their own
+   buffers.  */
+extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
+		   int *__restrict __sign, char *__restrict __buf,
+		   size_t __len) __THROW __nonnull ((3, 4, 5));
+extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
+		   int *__restrict __sign, char *__restrict __buf,
+		   size_t __len) __THROW __nonnull ((3, 4, 5));
+
+extern int qecvt_r (long double __value, int __ndigit,
+		    int *__restrict __decpt, int *__restrict __sign,
+		    char *__restrict __buf, size_t __len)
+     __THROW __nonnull ((3, 4, 5));
+extern int qfcvt_r (long double __value, int __ndigit,
+		    int *__restrict __decpt, int *__restrict __sign,
+		    char *__restrict __buf, size_t __len)
+     __THROW __nonnull ((3, 4, 5));
+#endif	/* misc */
+
+
+__BEGIN_NAMESPACE_STD
+/* Return the length of the multibyte character
+   in S, which is no longer than N.  */
+extern int mblen (const char *__s, size_t __n) __THROW;
+/* Return the length of the given multibyte character,
+   putting its `wchar_t' representation in *PWC.  */
+extern int mbtowc (wchar_t *__restrict __pwc,
+		   const char *__restrict __s, size_t __n) __THROW;
+/* Put the multibyte character represented
+   by WCHAR in S, returning its length.  */
+extern int wctomb (char *__s, wchar_t __wchar) __THROW;
+
+
+/* Convert a multibyte string to a wide char string.  */
+extern size_t mbstowcs (wchar_t *__restrict  __pwcs,
+			const char *__restrict __s, size_t __n) __THROW;
+/* Convert a wide char string to multibyte string.  */
+extern size_t wcstombs (char *__restrict __s,
+			const wchar_t *__restrict __pwcs, size_t __n)
+     __THROW;
+__END_NAMESPACE_STD
+
+
+#ifdef __USE_SVID
+/* Determine whether the string value of RESPONSE matches the affirmation
+   or negative response expression as specified by the LC_MESSAGES category
+   in the program's current locale.  Returns 1 if affirmative, 0 if
+   negative, and -1 if not matching.  */
+extern int rpmatch (const char *__response) __THROW __nonnull ((1)) __wur;
+#endif
+
+
+#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+/* Parse comma separated suboption from *OPTIONP and match against
+   strings in TOKENS.  If found return index and set *VALUEP to
+   optional value introduced by an equal sign.  If the suboption is
+   not part of TOKENS return in *VALUEP beginning of unknown
+   suboption.  On exit *OPTIONP is set to the beginning of the next
+   token or at the terminating NUL character.  */
+extern int getsubopt (char **__restrict __optionp,
+		      char *const *__restrict __tokens,
+		      char **__restrict __valuep)
+     __THROW __nonnull ((1, 2, 3)) __wur;
+#endif
+
+
+#ifdef __USE_XOPEN
+/* Setup DES tables according KEY.  */
+extern void setkey (const char *__key) __THROW __nonnull ((1));
+#endif
+
+
+/* X/Open pseudo terminal handling.  */
+
+#ifdef __USE_XOPEN2KXSI
+/* Return a master pseudo-terminal handle.  */
+extern int posix_openpt (int __oflag) __wur;
+#endif
+
+#ifdef __USE_XOPEN
+/* The next four functions all take a master pseudo-tty fd and
+   perform an operation on the associated slave:  */
+
+/* Chown the slave to the calling user.  */
+extern int grantpt (int __fd) __THROW;
+
+/* Release an internal lock so the slave can be opened.
+   Call after grantpt().  */
+extern int unlockpt (int __fd) __THROW;
+
+/* Return the pathname of the pseudo terminal slave associated with
+   the master FD is open on, or NULL on errors.
+   The returned storage is good until the next call to this function.  */
+extern char *ptsname (int __fd) __THROW __wur;
+#endif
+
+#ifdef __USE_GNU
+/* Store at most BUFLEN characters of the pathname of the slave pseudo
+   terminal associated with the master FD is open on in BUF.
+   Return 0 on success, otherwise an error number.  */
+extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
+     __THROW __nonnull ((2));
+
+/* Open a master pseudo terminal and return its file descriptor.  */
+extern int getpt (void);
+#endif
+
+#ifdef __USE_BSD
+/* Put the 1 minute, 5 minute and 15 minute load averages into the first
+   NELEM elements of LOADAVG.  Return the number written (never more than
+   three, but may be less than NELEM), or -1 if an error occurred.  */
+extern int getloadavg (double __loadavg[], int __nelem)
+     __THROW __nonnull ((1));
+#endif
+
+#include <bits/stdlib-float.h>
+
+/* Define some macros helping to catch buffer overflows.  */
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+# include <bits/stdlib.h>
+#endif
+#ifdef __LDBL_COMPAT
+# include <bits/stdlib-ldbl.h>
+#endif
+
+#endif /* don't just need malloc and calloc */
+#undef __need_malloc_and_calloc
+
+__END_DECLS
+
+#endif /* stdlib.h  */
diff --git a/include/string.h b/include/string.h
new file mode 100644
index 0000000..b127e8d
--- /dev/null
+++ b/include/string.h
@@ -0,0 +1,646 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.21 String handling	<string.h>
+ */
+
+#ifndef	_STRING_H
+#define	_STRING_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Get size_t and NULL from <stddef.h>.  */
+#define	__need_size_t
+#define	__need_NULL
+#include <stddef.h>
+
+/* Provide correct C++ prototypes, and indicate this to the caller.  This
+   requires a compatible C++ standard library.  As a heuristic, we provide
+   these when the compiler indicates full conformance with C++98 or later,
+   and for older GCC versions that are known to provide a compatible
+   libstdc++.  */
+#if defined __cplusplus && (__cplusplus >= 199711L || __GNUC_PREREQ (4, 4))
+# define __CORRECT_ISO_CPP_STRING_H_PROTO
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Copy N bytes of SRC to DEST.  */
+extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
+		     size_t __n) __THROW __nonnull ((1, 2));
+/* Copy N bytes of SRC to DEST, guaranteeing
+   correct behavior for overlapping strings.  */
+extern void *memmove (void *__dest, const void *__src, size_t __n)
+     __THROW __nonnull ((1, 2));
+__END_NAMESPACE_STD
+
+/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
+   Return the position in DEST one byte past where C was copied,
+   or NULL if C was not found in the first N bytes of SRC.  */
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN
+extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
+		      int __c, size_t __n)
+     __THROW __nonnull ((1, 2));
+#endif /* SVID.  */
+
+
+__BEGIN_NAMESPACE_STD
+/* Set N bytes of S to C.  */
+extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1));
+
+/* Compare N bytes of S1 and S2.  */
+extern int memcmp (const void *__s1, const void *__s2, size_t __n)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Search N bytes of S for C.  */
+#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++"
+{
+extern void *memchr (void *__s, int __c, size_t __n)
+      __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
+extern const void *memchr (const void *__s, int __c, size_t __n)
+      __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
+
+# ifdef __OPTIMIZE__
+__extern_always_inline void *
+memchr (void *__s, int __c, size_t __n) __THROW
+{
+  return __builtin_memchr (__s, __c, __n);
+}
+
+__extern_always_inline const void *
+memchr (const void *__s, int __c, size_t __n) __THROW
+{
+  return __builtin_memchr (__s, __c, __n);
+}
+# endif
+}
+#else
+extern void *memchr (const void *__s, int __c, size_t __n)
+      __THROW __attribute_pure__ __nonnull ((1));
+#endif
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* Search in S for C.  This is similar to `memchr' but there is no
+   length limit.  */
+# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++" void *rawmemchr (void *__s, int __c)
+     __THROW __asm ("rawmemchr") __attribute_pure__ __nonnull ((1));
+extern "C++" const void *rawmemchr (const void *__s, int __c)
+     __THROW __asm ("rawmemchr") __attribute_pure__ __nonnull ((1));
+# else
+extern void *rawmemchr (const void *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+# endif
+
+/* Search N bytes of S for the final occurrence of C.  */
+# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++" void *memrchr (void *__s, int __c, size_t __n)
+      __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1));
+extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
+      __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1));
+# else
+extern void *memrchr (const void *__s, int __c, size_t __n)
+      __THROW __attribute_pure__ __nonnull ((1));
+# endif
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Copy SRC to DEST.  */
+extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
+     __THROW __nonnull ((1, 2));
+/* Copy no more than N characters of SRC to DEST.  */
+extern char *strncpy (char *__restrict __dest,
+		      const char *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+
+/* Append SRC onto DEST.  */
+extern char *strcat (char *__restrict __dest, const char *__restrict __src)
+     __THROW __nonnull ((1, 2));
+/* Append no more than N characters from SRC onto DEST.  */
+extern char *strncat (char *__restrict __dest, const char *__restrict __src,
+		      size_t __n) __THROW __nonnull ((1, 2));
+
+/* Compare S1 and S2.  */
+extern int strcmp (const char *__s1, const char *__s2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+/* Compare N characters of S1 and S2.  */
+extern int strncmp (const char *__s1, const char *__s2, size_t __n)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Compare the collated forms of S1 and S2.  */
+extern int strcoll (const char *__s1, const char *__s2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+/* Put a transformation of SRC into no more than N bytes of DEST.  */
+extern size_t strxfrm (char *__restrict __dest,
+		       const char *__restrict __src, size_t __n)
+     __THROW __nonnull ((2));
+__END_NAMESPACE_STD
+
+#ifdef __USE_XOPEN2K8
+/* The following functions are equivalent to the both above but they
+   take the locale they use for the collation as an extra argument.
+   This is not standardsized but something like will come.  */
+# include <xlocale.h>
+
+/* Compare the collated forms of S1 and S2 using rules from L.  */
+extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 3));
+/* Put a transformation of SRC into no more than N bytes of DEST.  */
+extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
+			 __locale_t __l) __THROW __nonnull ((2, 4));
+#endif
+
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED \
+    || defined __USE_XOPEN2K8
+/* Duplicate S, returning an identical malloc'd string.  */
+extern char *strdup (const char *__s)
+     __THROW __attribute_malloc__ __nonnull ((1));
+#endif
+
+/* Return a malloc'd copy of at most N bytes of STRING.  The
+   resultant string is terminated even if no null terminator
+   appears before STRING[N].  */
+#if defined __USE_XOPEN2K8
+extern char *strndup (const char *__string, size_t __n)
+     __THROW __attribute_malloc__ __nonnull ((1));
+#endif
+
+#if defined __USE_GNU && defined __GNUC__
+/* Duplicate S, returning an identical alloca'd string.  */
+# define strdupa(s)							      \
+  (__extension__							      \
+    ({									      \
+      const char *__old = (s);						      \
+      size_t __len = strlen (__old) + 1;				      \
+      char *__new = (char *) __builtin_alloca (__len);			      \
+      (char *) memcpy (__new, __old, __len);				      \
+    }))
+
+/* Return an alloca'd copy of at most N bytes of string.  */
+# define strndupa(s, n)							      \
+  (__extension__							      \
+    ({									      \
+      const char *__old = (s);						      \
+      size_t __len = strnlen (__old, (n));				      \
+      char *__new = (char *) __builtin_alloca (__len + 1);		      \
+      __new[__len] = '\0';						      \
+      (char *) memcpy (__new, __old, __len);				      \
+    }))
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Find the first occurrence of C in S.  */
+#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++"
+{
+extern char *strchr (char *__s, int __c)
+     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
+extern const char *strchr (const char *__s, int __c)
+     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
+
+# ifdef __OPTIMIZE__
+__extern_always_inline char *
+strchr (char *__s, int __c) __THROW
+{
+  return __builtin_strchr (__s, __c);
+}
+
+__extern_always_inline const char *
+strchr (const char *__s, int __c) __THROW
+{
+  return __builtin_strchr (__s, __c);
+}
+# endif
+}
+#else
+extern char *strchr (const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+#endif
+/* Find the last occurrence of C in S.  */
+#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++"
+{
+extern char *strrchr (char *__s, int __c)
+     __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));
+extern const char *strrchr (const char *__s, int __c)
+     __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));
+
+# ifdef __OPTIMIZE__
+__extern_always_inline char *
+strrchr (char *__s, int __c) __THROW
+{
+  return __builtin_strrchr (__s, __c);
+}
+
+__extern_always_inline const char *
+strrchr (const char *__s, int __c) __THROW
+{
+  return __builtin_strrchr (__s, __c);
+}
+# endif
+}
+#else
+extern char *strrchr (const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+#endif
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* This function is similar to `strchr'.  But it returns a pointer to
+   the closing NUL byte in case C is not found in S.  */
+# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++" char *strchrnul (char *__s, int __c)
+     __THROW __asm ("strchrnul") __attribute_pure__ __nonnull ((1));
+extern "C++" const char *strchrnul (const char *__s, int __c)
+     __THROW __asm ("strchrnul") __attribute_pure__ __nonnull ((1));
+# else
+extern char *strchrnul (const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+# endif
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Return the length of the initial segment of S which
+   consists entirely of characters not in REJECT.  */
+extern size_t strcspn (const char *__s, const char *__reject)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+/* Return the length of the initial segment of S which
+   consists entirely of characters in ACCEPT.  */
+extern size_t strspn (const char *__s, const char *__accept)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+/* Find the first occurrence in S of any character in ACCEPT.  */
+#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++"
+{
+extern char *strpbrk (char *__s, const char *__accept)
+     __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2));
+extern const char *strpbrk (const char *__s, const char *__accept)
+     __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2));
+
+# ifdef __OPTIMIZE__
+__extern_always_inline char *
+strpbrk (char *__s, const char *__accept) __THROW
+{
+  return __builtin_strpbrk (__s, __accept);
+}
+
+__extern_always_inline const char *
+strpbrk (const char *__s, const char *__accept) __THROW
+{
+  return __builtin_strpbrk (__s, __accept);
+}
+# endif
+}
+#else
+extern char *strpbrk (const char *__s, const char *__accept)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+#endif
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++"
+{
+extern char *strstr (char *__haystack, const char *__needle)
+     __THROW __asm ("strstr") __attribute_pure__ __nonnull ((1, 2));
+extern const char *strstr (const char *__haystack, const char *__needle)
+     __THROW __asm ("strstr") __attribute_pure__ __nonnull ((1, 2));
+
+# ifdef __OPTIMIZE__
+__extern_always_inline char *
+strstr (char *__haystack, const char *__needle) __THROW
+{
+  return __builtin_strstr (__haystack, __needle);
+}
+
+__extern_always_inline const char *
+strstr (const char *__haystack, const char *__needle) __THROW
+{
+  return __builtin_strstr (__haystack, __needle);
+}
+# endif
+}
+#else
+extern char *strstr (const char *__haystack, const char *__needle)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+#endif
+
+
+/* Divide S into tokens separated by characters in DELIM.  */
+extern char *strtok (char *__restrict __s, const char *__restrict __delim)
+     __THROW __nonnull ((2));
+__END_NAMESPACE_STD
+
+/* Divide S into tokens separated by characters in DELIM.  Information
+   passed between calls are stored in SAVE_PTR.  */
+extern char *__strtok_r (char *__restrict __s,
+			 const char *__restrict __delim,
+			 char **__restrict __save_ptr)
+     __THROW __nonnull ((2, 3));
+#if defined __USE_POSIX || defined __USE_MISC
+extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
+		       char **__restrict __save_ptr)
+     __THROW __nonnull ((2, 3));
+#endif
+
+#ifdef __USE_GNU
+/* Similar to `strstr' but this function ignores the case of both strings.  */
+# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++" char *strcasestr (char *__haystack, const char *__needle)
+     __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
+extern "C++" const char *strcasestr (const char *__haystack,
+				     const char *__needle)
+     __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
+# else
+extern char *strcasestr (const char *__haystack, const char *__needle)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+# endif
+#endif
+
+#ifdef __USE_GNU
+/* Find the first occurrence of NEEDLE in HAYSTACK.
+   NEEDLE is NEEDLELEN bytes long;
+   HAYSTACK is HAYSTACKLEN bytes long.  */
+extern void *memmem (const void *__haystack, size_t __haystacklen,
+		     const void *__needle, size_t __needlelen)
+     __THROW __attribute_pure__ __nonnull ((1, 3));
+
+/* Copy N bytes of SRC to DEST, return pointer to bytes after the
+   last written byte.  */
+extern void *__mempcpy (void *__restrict __dest,
+			const void *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+extern void *mempcpy (void *__restrict __dest,
+		      const void *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return the length of S.  */
+extern size_t strlen (const char *__s)
+     __THROW __attribute_pure__ __nonnull ((1));
+__END_NAMESPACE_STD
+
+#ifdef	__USE_XOPEN2K8
+/* Find the length of STRING, but scan at most MAXLEN characters.
+   If no '\0' terminator is found in that many characters, return MAXLEN.  */
+extern size_t strnlen (const char *__string, size_t __maxlen)
+     __THROW __attribute_pure__ __nonnull ((1));
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
+extern char *strerror (int __errnum) __THROW;
+__END_NAMESPACE_STD
+#if defined __USE_XOPEN2K || defined __USE_MISC
+/* Reentrant version of `strerror'.
+   There are 2 flavors of `strerror_r', GNU which returns the string
+   and may or may not use the supplied temporary buffer and POSIX one
+   which fills the string into the buffer.
+   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
+   without -D_GNU_SOURCE is needed, otherwise the GNU version is
+   preferred.  */
+# if defined __USE_XOPEN2K && !defined __USE_GNU
+/* Fill BUF with a string describing the meaning of the `errno' code in
+   ERRNUM.  */
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (strerror_r,
+			   (int __errnum, char *__buf, size_t __buflen),
+			   __xpg_strerror_r) __nonnull ((2));
+#  else
+extern int __xpg_strerror_r (int __errnum, char *__buf, size_t __buflen)
+     __THROW __nonnull ((2));
+#   define strerror_r __xpg_strerror_r
+#  endif
+# else
+/* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
+   used.  */
+extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
+     __THROW __nonnull ((2)) __wur;
+# endif
+#endif
+
+#ifdef __USE_XOPEN2K8
+/* Translate error number to string according to the locale L.  */
+extern char *strerror_l (int __errnum, __locale_t __l) __THROW;
+#endif
+
+
+/* We define this function always since `bzero' is sometimes needed when
+   the namespace rules does not allow this.  */
+extern void __bzero (void *__s, size_t __n) __THROW __nonnull ((1));
+
+#ifdef __USE_BSD
+/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
+extern void bcopy (const void *__src, void *__dest, size_t __n)
+     __THROW __nonnull ((1, 2));
+
+/* Set N bytes of S to 0.  */
+extern void bzero (void *__s, size_t __n) __THROW __nonnull ((1));
+
+/* Compare N bytes of S1 and S2 (same as memcmp).  */
+extern int bcmp (const void *__s1, const void *__s2, size_t __n)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Find the first occurrence of C in S (same as strchr).  */
+# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++"
+{
+extern char *index (char *__s, int __c)
+     __THROW __asm ("index") __attribute_pure__ __nonnull ((1));
+extern const char *index (const char *__s, int __c)
+     __THROW __asm ("index") __attribute_pure__ __nonnull ((1));
+
+#  if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRINGS_H_PROTO
+__extern_always_inline char *
+index (char *__s, int __c) __THROW
+{
+  return __builtin_index (__s, __c);
+}
+
+__extern_always_inline const char *
+index (const char *__s, int __c) __THROW
+{
+  return __builtin_index (__s, __c);
+}
+#  endif
+}
+# else
+extern char *index (const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+# endif
+
+/* Find the last occurrence of C in S (same as strrchr).  */
+# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++"
+{
+extern char *rindex (char *__s, int __c)
+     __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1));
+extern const char *rindex (const char *__s, int __c)
+     __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1));
+
+#  if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRINGS_H_PROTO
+__extern_always_inline char *
+rindex (char *__s, int __c) __THROW
+{
+  return __builtin_rindex (__s, __c);
+}
+
+__extern_always_inline const char *
+rindex (const char *__s, int __c) __THROW
+{
+  return __builtin_rindex (__s, __c);
+}
+#endif
+}
+# else
+extern char *rindex (const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+# endif
+
+/* Return the position of the first bit set in I, or 0 if none are set.
+   The least-significant bit is position 1, the most-significant 32.  */
+extern int ffs (int __i) __THROW __attribute__ ((__const__));
+
+/* The following two functions are non-standard but necessary for non-32 bit
+   platforms.  */
+# ifdef	__USE_GNU
+extern int ffsl (long int __l) __THROW __attribute__ ((__const__));
+__extension__ extern int ffsll (long long int __ll)
+     __THROW __attribute__ ((__const__));
+# endif
+
+/* Compare S1 and S2, ignoring case.  */
+extern int strcasecmp (const char *__s1, const char *__s2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Compare no more than N chars of S1 and S2, ignoring case.  */
+extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+#endif /* Use BSD.  */
+
+#ifdef	__USE_GNU
+/* Again versions of a few functions which use the given locale instead
+   of the global one.  */
+extern int strcasecmp_l (const char *__s1, const char *__s2,
+			 __locale_t __loc)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 3));
+
+extern int strncasecmp_l (const char *__s1, const char *__s2,
+			  size_t __n, __locale_t __loc)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 4));
+#endif
+
+#ifdef	__USE_BSD
+/* Return the next DELIM-delimited token from *STRINGP,
+   terminating it with a '\0', and update *STRINGP to point past it.  */
+extern char *strsep (char **__restrict __stringp,
+		     const char *__restrict __delim)
+     __THROW __nonnull ((1, 2));
+#endif
+
+#ifdef	__USE_XOPEN2K8
+/* Return a string describing the meaning of the signal number in SIG.  */
+extern char *strsignal (int __sig) __THROW;
+
+/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
+extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
+     __THROW __nonnull ((1, 2));
+extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
+     __THROW __nonnull ((1, 2));
+
+/* Copy no more than N characters of SRC to DEST, returning the address of
+   the last character written into DEST.  */
+extern char *__stpncpy (char *__restrict __dest,
+			const char *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+extern char *stpncpy (char *__restrict __dest,
+		      const char *__restrict __src, size_t __n)
+     __THROW __nonnull ((1, 2));
+#endif
+
+#ifdef	__USE_GNU
+/* Compare S1 and S2 as strings holding name & indices/version numbers.  */
+extern int strverscmp (const char *__s1, const char *__s2)
+     __THROW __attribute_pure__ __nonnull ((1, 2));
+
+/* Sautee STRING briskly.  */
+extern char *strfry (char *__string) __THROW __nonnull ((1));
+
+/* Frobnicate N bytes of S.  */
+extern void *memfrob (void *__s, size_t __n) __THROW __nonnull ((1));
+
+# ifndef basename
+/* Return the file name within directory of FILENAME.  We don't
+   declare the function if the `basename' macro is available (defined
+   in <libgen.h>) which makes the XPG version of this function
+   available.  */
+#  ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+extern "C++" char *basename (char *__filename)
+     __THROW __asm ("basename") __nonnull ((1));
+extern "C++" const char *basename (const char *__filename)
+     __THROW __asm ("basename") __nonnull ((1));
+#  else
+extern char *basename (const char *__filename) __THROW __nonnull ((1));
+#  endif
+# endif
+#endif
+
+
+#if defined __GNUC__ && __GNUC__ >= 2
+# if defined __OPTIMIZE__ && !defined __OPTIMIZE_SIZE__ \
+     && !defined __NO_INLINE__ && !defined __cplusplus
+/* When using GNU CC we provide some optimized versions of selected
+   functions from this header.  There are two kinds of optimizations:
+
+   - machine-dependent optimizations, most probably using inline
+     assembler code; these might be quite expensive since the code
+     size can increase significantly.
+     These optimizations are not used unless the symbol
+	__USE_STRING_INLINES
+     is defined before including this header.
+
+   - machine-independent optimizations which do not increase the
+     code size significantly and which optimize mainly situations
+     where one or more arguments are compile-time constants.
+     These optimizations are used always when the compiler is
+     taught to optimize.
+
+   One can inhibit all optimizations by defining __NO_STRING_INLINES.  */
+
+/* Get the machine-dependent optimizations (if any).  */
+#  include <bits/string.h>
+
+/* These are generic optimizations which do not add too much inline code.  */
+#  include <bits/string2.h>
+# endif
+
+# if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+/* Functions with security checks.  */
+#  include <bits/string3.h>
+# endif
+#endif
+
+__END_DECLS
+
+#endif /* string.h  */
diff --git a/include/strings.h b/include/strings.h
new file mode 100644
index 0000000..994c4b0
--- /dev/null
+++ b/include/strings.h
@@ -0,0 +1,143 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_STRINGS_H
+#define	_STRINGS_H	1
+
+/* We don't need and should not read this file if <string.h> was already
+   read. The one exception being that if __USE_BSD isn't defined, then
+   these aren't defined in string.h, so we need to define them here.  */
+#if !defined _STRING_H || !defined __USE_BSD
+
+# include <features.h>
+# define __need_size_t
+# include <stddef.h>
+
+/* Provide correct C++ prototypes, and indicate this to the caller.  This
+   requires a compatible C++ standard library.  As a heuristic, we provide
+   these when the compiler indicates full conformance with C++98 or later,
+   and for older GCC versions that are known to provide a compatible
+   libstdc++.  */
+# if defined __cplusplus && (__cplusplus >= 199711L || __GNUC_PREREQ (4, 4))
+#  define __CORRECT_ISO_CPP_STRINGS_H_PROTO
+# endif
+
+__BEGIN_DECLS
+
+# if defined __USE_MISC || !defined __USE_XOPEN2K8
+/* Compare N bytes of S1 and S2 (same as memcmp).  */
+extern int bcmp (const void *__s1, const void *__s2, size_t __n)
+     __THROW __attribute_pure__;
+
+/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
+extern void bcopy (const void *__src, void *__dest, size_t __n) __THROW;
+
+/* Set N bytes of S to 0.  */
+extern void bzero (void *__s, size_t __n) __THROW;
+
+/* Find the first occurrence of C in S (same as strchr).  */
+#  ifdef __CORRECT_ISO_CPP_STRINGS_H_PROTO
+extern "C++"
+{
+extern char *index (char *__s, int __c)
+     __THROW __asm ("index") __attribute_pure__ __nonnull ((1));
+extern const char *index (const char *__s, int __c)
+     __THROW __asm ("index") __attribute_pure__ __nonnull ((1));
+
+#   if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRING_H_PROTO
+__extern_always_inline char *
+index (char *__s, int __c) __THROW
+{
+  return __builtin_index (__s, __c);
+}
+
+__extern_always_inline const char *
+index (const char *__s, int __c) __THROW
+{
+  return __builtin_index (__s, __c);
+}
+#   endif
+}
+#  else
+extern char *index (const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+#  endif
+
+/* Find the last occurrence of C in S (same as strrchr).  */
+#  ifdef __CORRECT_ISO_CPP_STRINGS_H_PROTO
+extern "C++"
+{
+extern char *rindex (char *__s, int __c)
+     __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1));
+extern const char *rindex (const char *__s, int __c)
+     __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1));
+
+#   if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRING_H_PROTO
+__extern_always_inline char *
+rindex (char *__s, int __c) __THROW
+{
+  return __builtin_rindex (__s, __c);
+}
+
+__extern_always_inline const char *
+rindex (const char *__s, int __c) __THROW
+{
+  return __builtin_rindex (__s, __c);
+}
+#   endif
+}
+#  else
+extern char *rindex (const char *__s, int __c)
+     __THROW __attribute_pure__ __nonnull ((1));
+#  endif
+# endif
+
+#if defined __USE_MISC || !defined __USE_XOPEN2K8 || defined __USE_XOPEN2K8XSI
+/* Return the position of the first bit set in I, or 0 if none are set.
+   The least-significant bit is position 1, the most-significant 32.  */
+extern int ffs (int __i) __THROW __attribute__ ((const));
+#endif
+
+/* Compare S1 and S2, ignoring case.  */
+extern int strcasecmp (const char *__s1, const char *__s2)
+     __THROW __attribute_pure__;
+
+/* Compare no more than N chars of S1 and S2, ignoring case.  */
+extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
+     __THROW __attribute_pure__;
+
+#ifdef	__USE_XOPEN2K8
+/* The following functions are equivalent to the both above but they
+   take the locale they use for the collation as an extra argument.
+   This is not standardsized but something like will come.  */
+# include <xlocale.h>
+
+/* Again versions of a few functions which use the given locale instead
+   of the global one.  */
+extern int strcasecmp_l (const char *__s1, const char *__s2, __locale_t __loc)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 3));
+
+extern int strncasecmp_l (const char *__s1, const char *__s2,
+			  size_t __n, __locale_t __loc)
+     __THROW __attribute_pure__ __nonnull ((1, 2, 4));
+#endif
+
+__END_DECLS
+
+#endif	/* string.h  */
+
+#endif	/* strings.h  */
diff --git a/include/stropts.h b/include/stropts.h
new file mode 100644
index 0000000..16de4ba
--- /dev/null
+++ b/include/stropts.h
@@ -0,0 +1,92 @@
+/* Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _STROPTS_H
+#define _STROPTS_H	1
+
+#include <features.h>
+#include <bits/types.h>
+#include <bits/xtitypes.h>
+
+#ifndef __gid_t_defined
+typedef __gid_t gid_t;
+# define __gid_t_defined
+#endif
+
+#ifndef __uid_t_defined
+typedef __uid_t uid_t;
+# define __uid_t_defined
+#endif
+
+typedef __t_scalar_t t_scalar_t;
+typedef __t_uscalar_t t_uscalar_t;
+
+/* Get system specific constants.  */
+#include <bits/stropts.h>
+
+
+__BEGIN_DECLS
+
+/* Test whether FILDES is associated with a STREAM-based file.  */
+extern int isastream (int __fildes) __THROW;
+
+/* Receive next message from a STREAMS file.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int getmsg (int __fildes, struct strbuf *__restrict __ctlptr,
+		   struct strbuf *__restrict __dataptr,
+		   int *__restrict __flagsp);
+
+/* Receive next message from a STREAMS file, with *FLAGSP allowing to
+   control which message.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int getpmsg (int __fildes, struct strbuf *__restrict __ctlptr,
+		    struct strbuf *__restrict __dataptr,
+		    int *__restrict __bandp, int *__restrict __flagsp);
+
+/* Perform the I/O control operation specified by REQUEST on FD.
+   One argument may follow; its presence and type depend on REQUEST.
+   Return value depends on REQUEST.  Usually -1 indicates error.  */
+extern int ioctl (int __fd, unsigned long int __request, ...) __THROW;
+
+/* Send a message on a STREAM.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int putmsg (int __fildes, const struct strbuf *__ctlptr,
+		   const struct strbuf *__dataptr, int __flags);
+
+/* Send a message on a STREAM to the BAND.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int putpmsg (int __fildes, const struct strbuf *__ctlptr,
+		    const struct strbuf *__dataptr, int __band, int __flags);
+
+/* Attach a STREAMS-based file descriptor FILDES to a file PATH in the
+   file system name space.  */
+extern int fattach (int __fildes, const char *__path) __THROW;
+
+/* Detach a name PATH from a STREAMS-based file descriptor.  */
+extern int fdetach (const char *__path) __THROW;
+
+__END_DECLS
+
+#endif /* stropts.h */
diff --git a/include/sys/auxv.h b/include/sys/auxv.h
new file mode 100644
index 0000000..b2db69e
--- /dev/null
+++ b/include/sys/auxv.h
@@ -0,0 +1,36 @@
+/* Access to the auxiliary vector.
+   Copyright (C) 2012-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_AUXV_H
+#define _SYS_AUXV_H 1
+
+#include <elf.h>
+#include <sys/cdefs.h>
+#include <bits/hwcap.h>
+
+__BEGIN_DECLS
+
+/* Return the value associated with an Elf*_auxv_t type from the auxv list
+   passed to the program on startup.  If TYPE was not present in the auxv
+   list, returns zero and sets errno to ENOENT.  */
+extern unsigned long int getauxval (unsigned long int __type)
+  __THROW;
+
+__END_DECLS
+
+#endif /* sys/auxv.h */
diff --git a/include/sys/bitypes.h b/include/sys/bitypes.h
new file mode 100644
index 0000000..3a9860f
--- /dev/null
+++ b/include/sys/bitypes.h
@@ -0,0 +1,3 @@
+/* The GNU <sys/types.h> defines all the necessary types.  */
+
+#include <sys/types.h>
diff --git a/include/sys/cdefs.h b/include/sys/cdefs.h
new file mode 100644
index 0000000..4d958ea
--- /dev/null
+++ b/include/sys/cdefs.h
@@ -0,0 +1,419 @@
+/* Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_CDEFS_H
+#define	_SYS_CDEFS_H	1
+
+/* We are almost always included from features.h. */
+#ifndef _FEATURES_H
+# include <features.h>
+#endif
+
+/* The GNU libc does not support any K&R compilers or the traditional mode
+   of ISO C compilers anymore.  Check for some of the combinations not
+   anymore supported.  */
+#if defined __GNUC__ && !defined __STDC__
+# error "You need a ISO C conforming compiler to use the glibc headers"
+#endif
+
+/* Some user header file might have defined this before.  */
+#undef	__P
+#undef	__PMT
+
+#ifdef __GNUC__
+
+/* All functions, except those with callbacks or those that
+   synchronize memory, are leaf functions.  */
+# if __GNUC_PREREQ (4, 6) && !defined _LIBC
+#  define __LEAF , __leaf__
+#  define __LEAF_ATTR __attribute__ ((__leaf__))
+# else
+#  define __LEAF
+#  define __LEAF_ATTR
+# endif
+
+/* GCC can always grok prototypes.  For C++ programs we add throw()
+   to help it optimize the function calls.  But this works only with
+   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
+   as non-throwing using a function attribute since programs can use
+   the -fexceptions options for C code as well.  */
+# if !defined __cplusplus && __GNUC_PREREQ (3, 3)
+#  define __THROW	__attribute__ ((__nothrow__ __LEAF))
+#  define __THROWNL	__attribute__ ((__nothrow__))
+#  define __NTH(fct)	__attribute__ ((__nothrow__ __LEAF)) fct
+# else
+#  if defined __cplusplus && __GNUC_PREREQ (2,8)
+#   define __THROW	throw ()
+#   define __THROWNL	throw ()
+#   define __NTH(fct)	__LEAF_ATTR fct throw ()
+#  else
+#   define __THROW
+#   define __THROWNL
+#   define __NTH(fct)	fct
+#  endif
+# endif
+
+#else	/* Not GCC.  */
+
+# define __inline		/* No inline functions.  */
+
+# define __THROW
+# define __THROWNL
+# define __NTH(fct)	fct
+
+#endif	/* GCC.  */
+
+/* These two macros are not used in glibc anymore.  They are kept here
+   only because some other projects expect the macros to be defined.  */
+#define __P(args)	args
+#define __PMT(args)	args
+
+/* For these things, GCC behaves the ANSI way normally,
+   and the non-ANSI way under -traditional.  */
+
+#define __CONCAT(x,y)	x ## y
+#define __STRING(x)	#x
+
+/* This is not a typedef so `const __ptr_t' does the right thing.  */
+#define __ptr_t void *
+#define __long_double_t  long double
+
+
+/* C++ needs to know that types and declarations are C, not C++.  */
+#ifdef	__cplusplus
+# define __BEGIN_DECLS	extern "C" {
+# define __END_DECLS	}
+#else
+# define __BEGIN_DECLS
+# define __END_DECLS
+#endif
+
+
+/* The standard library needs the functions from the ISO C90 standard
+   in the std namespace.  At the same time we want to be safe for
+   future changes and we include the ISO C99 code in the non-standard
+   namespace __c99.  The C++ wrapper header take case of adding the
+   definitions to the global namespace.  */
+#if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES
+# define __BEGIN_NAMESPACE_STD	namespace std {
+# define __END_NAMESPACE_STD	}
+# define __USING_NAMESPACE_STD(name) using std::name;
+# define __BEGIN_NAMESPACE_C99	namespace __c99 {
+# define __END_NAMESPACE_C99	}
+# define __USING_NAMESPACE_C99(name) using __c99::name;
+#else
+/* For compatibility we do not add the declarations into any
+   namespace.  They will end up in the global namespace which is what
+   old code expects.  */
+# define __BEGIN_NAMESPACE_STD
+# define __END_NAMESPACE_STD
+# define __USING_NAMESPACE_STD(name)
+# define __BEGIN_NAMESPACE_C99
+# define __END_NAMESPACE_C99
+# define __USING_NAMESPACE_C99(name)
+#endif
+
+
+/* Fortify support.  */
+#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
+#define __bos0(ptr) __builtin_object_size (ptr, 0)
+#define __fortify_function __extern_always_inline __attribute_artificial__
+
+#if __GNUC_PREREQ (4,3)
+# define __warndecl(name, msg) \
+  extern void name (void) __attribute__((__warning__ (msg)))
+# define __warnattr(msg) __attribute__((__warning__ (msg)))
+# define __errordecl(name, msg) \
+  extern void name (void) __attribute__((__error__ (msg)))
+#else
+# define __warndecl(name, msg) extern void name (void)
+# define __warnattr(msg)
+# define __errordecl(name, msg) extern void name (void)
+#endif
+
+/* Support for flexible arrays.  */
+#if __GNUC_PREREQ (2,97)
+/* GCC 2.97 supports C99 flexible array members.  */
+# define __flexarr	[]
+#else
+# ifdef __GNUC__
+#  define __flexarr	[0]
+# else
+#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#   define __flexarr	[]
+#  else
+/* Some other non-C99 compiler.  Approximate with [1].  */
+#   define __flexarr	[1]
+#  endif
+# endif
+#endif
+
+
+/* __asm__ ("xyz") is used throughout the headers to rename functions
+   at the assembly language level.  This is wrapped by the __REDIRECT
+   macro, in order to support compilers that can do this some other
+   way.  When compilers don't support asm-names at all, we have to do
+   preprocessor tricks instead (which don't have exactly the right
+   semantics, but it's the best we can do).
+
+   Example:
+   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+# define __REDIRECT(name, proto, alias) name proto __asm__ (__ASMNAME (#alias))
+# ifdef __cplusplus
+#  define __REDIRECT_NTH(name, proto, alias) \
+     name proto __THROW __asm__ (__ASMNAME (#alias))
+#  define __REDIRECT_NTHNL(name, proto, alias) \
+     name proto __THROWNL __asm__ (__ASMNAME (#alias))
+# else
+#  define __REDIRECT_NTH(name, proto, alias) \
+     name proto __asm__ (__ASMNAME (#alias)) __THROW
+#  define __REDIRECT_NTHNL(name, proto, alias) \
+     name proto __asm__ (__ASMNAME (#alias)) __THROWNL
+# endif
+# define __ASMNAME(cname)  __ASMNAME2 (__USER_LABEL_PREFIX__, cname)
+# define __ASMNAME2(prefix, cname) __STRING (prefix) cname
+
+/*
+#elif __SOME_OTHER_COMPILER__
+
+# define __REDIRECT(name, proto, alias) name proto; \
+	_Pragma("let " #name " = " #alias)
+*/
+#endif
+
+/* GCC has various useful declarations that can be made with the
+   `__attribute__' syntax.  All of the ways we use this do fine if
+   they are omitted for compilers that don't understand it. */
+#if !defined __GNUC__ || __GNUC__ < 2
+# define __attribute__(xyz)	/* Ignore */
+#endif
+
+/* At some point during the gcc 2.96 development the `malloc' attribute
+   for functions was introduced.  We don't want to use it unconditionally
+   (although this would be possible) since it generates warnings.  */
+#if __GNUC_PREREQ (2,96)
+# define __attribute_malloc__ __attribute__ ((__malloc__))
+#else
+# define __attribute_malloc__ /* Ignore */
+#endif
+
+/* Tell the compiler which arguments to an allocation function
+   indicate the size of the allocation.  */
+#if __GNUC_PREREQ (4, 3)
+# define __attribute_alloc_size__(params) \
+  __attribute__ ((__alloc_size__ params))
+#else
+# define __attribute_alloc_size__(params) /* Ignore.  */
+#endif
+
+/* At some point during the gcc 2.96 development the `pure' attribute
+   for functions was introduced.  We don't want to use it unconditionally
+   (although this would be possible) since it generates warnings.  */
+#if __GNUC_PREREQ (2,96)
+# define __attribute_pure__ __attribute__ ((__pure__))
+#else
+# define __attribute_pure__ /* Ignore */
+#endif
+
+/* This declaration tells the compiler that the value is constant.  */
+#if __GNUC_PREREQ (2,5)
+# define __attribute_const__ __attribute__ ((__const__))
+#else
+# define __attribute_const__ /* Ignore */
+#endif
+
+/* At some point during the gcc 3.1 development the `used' attribute
+   for functions was introduced.  We don't want to use it unconditionally
+   (although this would be possible) since it generates warnings.  */
+#if __GNUC_PREREQ (3,1)
+# define __attribute_used__ __attribute__ ((__used__))
+# define __attribute_noinline__ __attribute__ ((__noinline__))
+#else
+# define __attribute_used__ __attribute__ ((__unused__))
+# define __attribute_noinline__ /* Ignore */
+#endif
+
+/* gcc allows marking deprecated functions.  */
+#if __GNUC_PREREQ (3,2)
+# define __attribute_deprecated__ __attribute__ ((__deprecated__))
+#else
+# define __attribute_deprecated__ /* Ignore */
+#endif
+
+/* At some point during the gcc 2.8 development the `format_arg' attribute
+   for functions was introduced.  We don't want to use it unconditionally
+   (although this would be possible) since it generates warnings.
+   If several `format_arg' attributes are given for the same function, in
+   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
+   all designated arguments are considered.  */
+#if __GNUC_PREREQ (2,8)
+# define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))
+#else
+# define __attribute_format_arg__(x) /* Ignore */
+#endif
+
+/* At some point during the gcc 2.97 development the `strfmon' format
+   attribute for functions was introduced.  We don't want to use it
+   unconditionally (although this would be possible) since it
+   generates warnings.  */
+#if __GNUC_PREREQ (2,97)
+# define __attribute_format_strfmon__(a,b) \
+  __attribute__ ((__format__ (__strfmon__, a, b)))
+#else
+# define __attribute_format_strfmon__(a,b) /* Ignore */
+#endif
+
+/* The nonull function attribute allows to mark pointer parameters which
+   must not be NULL.  */
+#if __GNUC_PREREQ (3,3)
+# define __nonnull(params) __attribute__ ((__nonnull__ params))
+#else
+# define __nonnull(params)
+#endif
+
+/* If fortification mode, we warn about unused results of certain
+   function calls which can lead to problems.  */
+#if __GNUC_PREREQ (3,4)
+# define __attribute_warn_unused_result__ \
+   __attribute__ ((__warn_unused_result__))
+# if __USE_FORTIFY_LEVEL > 0
+#  define __wur __attribute_warn_unused_result__
+# endif
+#else
+# define __attribute_warn_unused_result__ /* empty */
+#endif
+#ifndef __wur
+# define __wur /* Ignore */
+#endif
+
+/* Forces a function to be always inlined.  */
+#if __GNUC_PREREQ (3,2)
+# define __always_inline __inline __attribute__ ((__always_inline__))
+#else
+# define __always_inline __inline
+#endif
+
+/* Associate error messages with the source location of the call site rather
+   than with the source location inside the function.  */
+#if __GNUC_PREREQ (4,3)
+# define __attribute_artificial__ __attribute__ ((__artificial__))
+#else
+# define __attribute_artificial__ /* Ignore */
+#endif
+
+#ifdef __GNUC__
+/* One of these will be defined if the __gnu_inline__ attribute is
+   available.  In C++, __GNUC_GNU_INLINE__ will be defined even though
+   __inline does not use the GNU inlining rules.  If neither macro is
+   defined, this version of GCC only supports GNU inline semantics. */
+# if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+#  define __extern_inline extern __inline __attribute__ ((__gnu_inline__))
+#  define __extern_always_inline \
+  extern __always_inline __attribute__ ((__gnu_inline__))
+# else
+#  define __extern_inline extern __inline
+#  define __extern_always_inline extern __always_inline
+# endif
+#else /* Not GCC.  */
+# define __extern_inline  /* Ignore */
+# define __extern_always_inline /* Ignore */
+#endif
+
+/* GCC 4.3 and above allow passing all anonymous arguments of an
+   __extern_always_inline function to some other vararg function.  */
+#if __GNUC_PREREQ (4,3)
+# define __va_arg_pack() __builtin_va_arg_pack ()
+# define __va_arg_pack_len() __builtin_va_arg_pack_len ()
+#endif
+
+/* It is possible to compile containing GCC extensions even if GCC is
+   run in pedantic mode if the uses are carefully marked using the
+   `__extension__' keyword.  But this is not generally available before
+   version 2.8.  */
+#if !__GNUC_PREREQ (2,8)
+# define __extension__		/* Ignore */
+#endif
+
+/* __restrict is known in EGCS 1.2 and above. */
+#if !__GNUC_PREREQ (2,92)
+# define __restrict	/* Ignore */
+#endif
+
+/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
+     array_name[restrict]
+   GCC 3.1 supports this.  */
+#if __GNUC_PREREQ (3,1) && !defined __GNUG__
+# define __restrict_arr	__restrict
+#else
+# ifdef __GNUC__
+#  define __restrict_arr	/* Not supported in old GCC.  */
+# else
+#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#   define __restrict_arr	restrict
+#  else
+/* Some other non-C99 compiler.  */
+#   define __restrict_arr	/* Not supported.  */
+#  endif
+# endif
+#endif
+
+#if __GNUC__ >= 3
+# define __glibc_unlikely(cond)	__builtin_expect ((cond), 0)
+# define __glibc_likely(cond)	__builtin_expect ((cond), 1)
+#else
+# define __glibc_unlikely(cond)	(cond)
+# define __glibc_likely(cond)	(cond)
+#endif
+
+#include <bits/wordsize.h>
+
+#if defined __LONG_DOUBLE_MATH_OPTIONAL && defined __NO_LONG_DOUBLE_MATH
+# define __LDBL_COMPAT 1
+# ifdef __REDIRECT
+#  define __LDBL_REDIR1(name, proto, alias) __REDIRECT (name, proto, alias)
+#  define __LDBL_REDIR(name, proto) \
+  __LDBL_REDIR1 (name, proto, __nldbl_##name)
+#  define __LDBL_REDIR1_NTH(name, proto, alias) __REDIRECT_NTH (name, proto, alias)
+#  define __LDBL_REDIR_NTH(name, proto) \
+  __LDBL_REDIR1_NTH (name, proto, __nldbl_##name)
+#  define __LDBL_REDIR1_DECL(name, alias) \
+  extern __typeof (name) name __asm (__ASMNAME (#alias));
+#  define __LDBL_REDIR_DECL(name) \
+  extern __typeof (name) name __asm (__ASMNAME ("__nldbl_" #name));
+#  define __REDIRECT_LDBL(name, proto, alias) \
+  __LDBL_REDIR1 (name, proto, __nldbl_##alias)
+#  define __REDIRECT_NTH_LDBL(name, proto, alias) \
+  __LDBL_REDIR1_NTH (name, proto, __nldbl_##alias)
+# endif
+#endif
+#if !defined __LDBL_COMPAT || !defined __REDIRECT
+# define __LDBL_REDIR1(name, proto, alias) name proto
+# define __LDBL_REDIR(name, proto) name proto
+# define __LDBL_REDIR1_NTH(name, proto, alias) name proto __THROW
+# define __LDBL_REDIR_NTH(name, proto) name proto __THROW
+# define __LDBL_REDIR_DECL(name)
+# ifdef __REDIRECT
+#  define __REDIRECT_LDBL(name, proto, alias) __REDIRECT (name, proto, alias)
+#  define __REDIRECT_NTH_LDBL(name, proto, alias) \
+  __REDIRECT_NTH (name, proto, alias)
+# endif
+#endif
+
+#endif	 /* sys/cdefs.h */
diff --git a/include/sys/dir.h b/include/sys/dir.h
new file mode 100644
index 0000000..31a56f3
--- /dev/null
+++ b/include/sys/dir.h
@@ -0,0 +1,27 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_DIR_H
+#define	_SYS_DIR_H	1
+
+#include <features.h>
+
+#include <dirent.h>
+
+#define	direct	dirent
+
+#endif	/* sys/dir.h  */
diff --git a/include/sys/errno.h b/include/sys/errno.h
new file mode 100644
index 0000000..339f4fc
--- /dev/null
+++ b/include/sys/errno.h
@@ -0,0 +1 @@
+#include <errno.h>
diff --git a/include/sys/fcntl.h b/include/sys/fcntl.h
new file mode 100644
index 0000000..cd30455
--- /dev/null
+++ b/include/sys/fcntl.h
@@ -0,0 +1 @@
+#include <fcntl.h>
diff --git a/include/sys/file.h b/include/sys/file.h
new file mode 100644
index 0000000..4c3e3c6
--- /dev/null
+++ b/include/sys/file.h
@@ -0,0 +1,56 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_FILE_H
+#define	_SYS_FILE_H	1
+
+#include <features.h>
+
+#ifndef	_FCNTL_H
+# include <fcntl.h>
+#endif
+
+__BEGIN_DECLS
+
+
+/* Alternate names for values for the WHENCE argument to `lseek'.
+   These are the same as SEEK_SET, SEEK_CUR, and SEEK_END, respectively.  */
+#ifndef L_SET
+# define L_SET	0	/* Seek from beginning of file.  */
+# define L_INCR	1	/* Seek from current position.  */
+# define L_XTND	2	/* Seek from end of file.  */
+#endif
+
+
+/* Operations for the `flock' call.  */
+#define	LOCK_SH	1	/* Shared lock.  */
+#define	LOCK_EX	2 	/* Exclusive lock.  */
+#define	LOCK_UN	8	/* Unlock.  */
+#define	__LOCK_ATOMIC	16	/* Atomic update.  */
+
+/* Can be OR'd in to one of the above.  */
+#define	LOCK_NB	4	/* Don't block when locking.  */
+
+
+/* Apply or remove an advisory lock, according to OPERATION,
+   on the file FD refers to.  */
+extern int flock (int __fd, int __operation) __THROW;
+
+
+__END_DECLS
+
+#endif /* sys/file.h  */
diff --git a/include/sys/gmon.h b/include/sys/gmon.h
new file mode 100644
index 0000000..5b430ab
--- /dev/null
+++ b/include/sys/gmon.h
@@ -0,0 +1,201 @@
+/*-
+ * Copyright (c) 1982, 1986, 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)gmon.h	8.2 (Berkeley) 1/4/94
+ */
+
+#ifndef	_SYS_GMON_H
+#define	_SYS_GMON_H	1
+
+#include <features.h>
+
+#include <sys/types.h>
+
+/*
+ * See gmon_out.h for gmon.out format.
+ */
+
+/* structure emitted by "gcc -a".  This must match struct bb in
+   gcc/libgcc2.c.  It is OK for gcc to declare a longer structure as
+   long as the members below are present.  */
+struct __bb
+{
+  long			zero_word;
+  const char		*filename;
+  long			*counts;
+  long			ncounts;
+  struct __bb		*next;
+  const unsigned long	*addresses;
+};
+
+extern struct __bb *__bb_head;
+
+/*
+ * histogram counters are unsigned shorts (according to the kernel).
+ */
+#define	HISTCOUNTER	unsigned short
+
+/*
+ * fraction of text space to allocate for histogram counters here, 1/2
+ */
+#define	HISTFRACTION	2
+
+/*
+ * Fraction of text space to allocate for from hash buckets.
+ * The value of HASHFRACTION is based on the minimum number of bytes
+ * of separation between two subroutine call points in the object code.
+ * Given MIN_SUBR_SEPARATION bytes of separation the value of
+ * HASHFRACTION is calculated as:
+ *
+ *	HASHFRACTION = MIN_SUBR_SEPARATION / (2 * sizeof(short) - 1);
+ *
+ * For example, on the VAX, the shortest two call sequence is:
+ *
+ *	calls	$0,(r0)
+ *	calls	$0,(r0)
+ *
+ * which is separated by only three bytes, thus HASHFRACTION is
+ * calculated as:
+ *
+ *	HASHFRACTION = 3 / (2 * 2 - 1) = 1
+ *
+ * Note that the division above rounds down, thus if MIN_SUBR_FRACTION
+ * is less than three, this algorithm will not work!
+ *
+ * In practice, however, call instructions are rarely at a minimal
+ * distance.  Hence, we will define HASHFRACTION to be 2 across all
+ * architectures.  This saves a reasonable amount of space for
+ * profiling data structures without (in practice) sacrificing
+ * any granularity.
+ */
+#define	HASHFRACTION	2
+
+/*
+ * Percent of text space to allocate for tostructs.
+ * This is a heuristic; we will fail with a warning when profiling programs
+ * with a very large number of very small functions, but that's
+ * normally OK.
+ * 2 is probably still a good value for normal programs.
+ * Profiling a test case with 64000 small functions will work if
+ * you raise this value to 3 and link statically (which bloats the
+ * text size, thus raising the number of arcs expected by the heuristic).
+ */
+#define ARCDENSITY	3
+
+/*
+ * Always allocate at least this many tostructs.  This
+ * hides the inadequacy of the ARCDENSITY heuristic, at least
+ * for small programs.
+ */
+#define MINARCS		50
+
+/*
+ * The type used to represent indices into gmonparam.tos[].
+ */
+#define	ARCINDEX	u_long
+
+/*
+ * Maximum number of arcs we want to allow.
+ * Used to be max representable value of ARCINDEX minus 2, but now
+ * that ARCINDEX is a long, that's too large; we don't really want
+ * to allow a 48 gigabyte table.
+ * The old value of 1<<16 wasn't high enough in practice for large C++
+ * programs; will 1<<20 be adequate for long?  FIXME
+ */
+#define MAXARCS		(1 << 20)
+
+struct tostruct {
+	u_long		selfpc;
+	long		count;
+	ARCINDEX	link;
+};
+
+/*
+ * a raw arc, with pointers to the calling site and
+ * the called site and a count.
+ */
+struct rawarc {
+	u_long	raw_frompc;
+	u_long	raw_selfpc;
+	long	raw_count;
+};
+
+/*
+ * general rounding functions.
+ */
+#define ROUNDDOWN(x,y)	(((x)/(y))*(y))
+#define ROUNDUP(x,y)	((((x)+(y)-1)/(y))*(y))
+
+/*
+ * The profiling data structures are housed in this structure.
+ */
+struct gmonparam {
+	long int	state;
+	u_short		*kcount;
+	u_long		kcountsize;
+	ARCINDEX	*froms;
+	u_long		fromssize;
+	struct tostruct	*tos;
+	u_long		tossize;
+	long		tolimit;
+	u_long		lowpc;
+	u_long		highpc;
+	u_long		textsize;
+	u_long		hashfraction;
+	long		log_hashfraction;
+};
+
+/*
+ * Possible states of profiling.
+ */
+#define	GMON_PROF_ON	0
+#define	GMON_PROF_BUSY	1
+#define	GMON_PROF_ERROR	2
+#define	GMON_PROF_OFF	3
+
+/*
+ * Sysctl definitions for extracting profiling information from the kernel.
+ */
+#define	GPROF_STATE	0	/* int: profiling enabling variable */
+#define	GPROF_COUNT	1	/* struct: profile tick count buffer */
+#define	GPROF_FROMS	2	/* struct: from location hash bucket */
+#define	GPROF_TOS	3	/* struct: destination/count structure */
+#define	GPROF_GMONPARAM	4	/* struct: profiling parameters (see above) */
+
+__BEGIN_DECLS
+
+/* Set up data structures and start profiling.  */
+extern void __monstartup (u_long __lowpc, u_long __highpc) __THROW;
+extern void monstartup (u_long __lowpc, u_long __highpc) __THROW;
+
+/* Clean up profiling and write out gmon.out.  */
+extern void _mcleanup (void) __THROW;
+
+__END_DECLS
+
+#endif /* sys/gmon.h */
diff --git a/include/sys/gmon_out.h b/include/sys/gmon_out.h
new file mode 100644
index 0000000..bbc9134
--- /dev/null
+++ b/include/sys/gmon_out.h
@@ -0,0 +1,79 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by David Mosberger <davidm@cs.arizona.edu>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This file specifies the format of gmon.out files.  It should have
+   as few external dependencies as possible as it is going to be included
+   in many different programs.  That is, minimize the number of #include's.
+
+   A gmon.out file consists of a header (defined by gmon_hdr) followed by
+   a sequence of records.  Each record starts with a one-byte tag
+   identifying the type of records, followed by records specific data. */
+
+#ifndef _SYS_GMON_OUT_H
+#define _SYS_GMON_OUT_H	1
+
+#include <features.h>
+
+#define	GMON_MAGIC	"gmon"	/* magic cookie */
+#define GMON_VERSION	1	/* version number */
+
+/* For profiling shared object we need a new format.  */
+#define GMON_SHOBJ_VERSION	0x1ffff
+
+__BEGIN_DECLS
+
+/*
+ * Raw header as it appears on file (without padding).  This header
+ * always comes first in gmon.out and is then followed by a series
+ * records defined below.
+ */
+struct gmon_hdr
+  {
+    char cookie[4];
+    char version[4];
+    char spare[3 * 4];
+  };
+
+/* types of records in this file: */
+typedef enum
+  {
+    GMON_TAG_TIME_HIST = 0,
+    GMON_TAG_CG_ARC = 1,
+    GMON_TAG_BB_COUNT = 2
+  } GMON_Record_Tag;
+
+struct gmon_hist_hdr
+  {
+    char low_pc[sizeof (char *)];	/* base pc address of sample buffer */
+    char high_pc[sizeof (char *)];	/* max pc address of sampled buffer */
+    char hist_size[4];			/* size of sample buffer */
+    char prof_rate[4];			/* profiling clock rate */
+    char dimen[15];			/* phys. dim., usually "seconds" */
+    char dimen_abbrev;			/* usually 's' for "seconds" */
+  };
+
+struct gmon_cg_arc_record
+  {
+    char from_pc[sizeof (char *)];	/* address within caller's body */
+    char self_pc[sizeof (char *)];	/* address within callee's body */
+    char count[4];			/* number of arc traversals */
+  };
+
+__END_DECLS
+
+#endif /* sys/gmon_out.h */
diff --git a/include/sys/io.h b/include/sys/io.h
new file mode 100644
index 0000000..6ad2d94
--- /dev/null
+++ b/include/sys/io.h
@@ -0,0 +1,177 @@
+/* Access to hardware i/o ports.  GNU/x86 version.
+   Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_IO_H
+#define	_SYS_IO_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+                   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+static __inline unsigned char
+inb (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned char
+inb_p (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw (unsigned short int port)
+{
+  unsigned short _v;
+
+  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw_p (unsigned short int port)
+{
+  unsigned short int _v;
+
+  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl (unsigned short int port)
+{
+  unsigned int _v;
+
+  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl_p (unsigned short int port)
+{
+  unsigned int _v;
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline void
+outb (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outb_p (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outw (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (port));
+
+}
+
+static __inline void
+outw_p (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outl (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outl_p (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+insb (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insw (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insl (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsb (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsw (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsl (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+#endif	/* GNU C */
+
+__END_DECLS
+#endif /* _SYS_IO_H */
diff --git a/include/sys/ioctl.h b/include/sys/ioctl.h
new file mode 100644
index 0000000..c4d35d9
--- /dev/null
+++ b/include/sys/ioctl.h
@@ -0,0 +1,45 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_IOCTL_H
+#define	_SYS_IOCTL_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Get the list of `ioctl' requests and related constants.  */
+#include <bits/ioctls.h>
+
+/* Define some types used by `ioctl' requests.  */
+#include <bits/ioctl-types.h>
+
+/* On a Unix system, the system <sys/ioctl.h> probably defines some of
+   the symbols we define in <sys/ttydefaults.h> (usually with the same
+   values).  The code to generate <bits/ioctls.h> has omitted these
+   symbols to avoid the conflict, but a Unix program expects <sys/ioctl.h>
+   to define them, so we must include <sys/ttydefaults.h> here.  */
+#include <sys/ttydefaults.h>
+
+/* Perform the I/O control operation specified by REQUEST on FD.
+   One argument may follow; its presence and type depend on REQUEST.
+   Return value depends on REQUEST.  Usually -1 indicates error.  */
+extern int ioctl (int __fd, unsigned long int __request, ...) __THROW;
+
+__END_DECLS
+
+#endif /* sys/ioctl.h */
diff --git a/include/sys/ipc.h b/include/sys/ipc.h
new file mode 100644
index 0000000..8d5d6ac
--- /dev/null
+++ b/include/sys/ipc.h
@@ -0,0 +1,58 @@
+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_IPC_H
+#define _SYS_IPC_H	1
+
+#include <features.h>
+
+#if !defined __USE_SVID && !defined __USE_XOPEN && __GNUC__ >= 2
+# warning "Files using this header must be compiled with _SVID_SOURCE or _XOPEN_SOURCE"
+#endif
+
+/* Get system dependent definition of `struct ipc_perm' and more.  */
+#include <bits/ipctypes.h>
+#include <bits/ipc.h>
+
+#ifndef __uid_t_defined
+typedef __uid_t uid_t;
+# define __uid_t_defined
+#endif
+
+#ifndef __gid_t_defined
+typedef __gid_t gid_t;
+# define __gid_t_defined
+#endif
+
+#ifndef __mode_t_defined
+typedef __mode_t mode_t;
+# define __mode_t_defined
+#endif
+
+#ifndef __key_t_defined
+typedef __key_t key_t;
+# define __key_t_defined
+#endif
+
+__BEGIN_DECLS
+
+/* Generates key for System V style IPC.  */
+extern key_t ftok (const char *__pathname, int __proj_id) __THROW;
+
+__END_DECLS
+
+#endif /* sys/ipc.h */
diff --git a/include/sys/mman.h b/include/sys/mman.h
new file mode 100644
index 0000000..5a3be79
--- /dev/null
+++ b/include/sys/mman.h
@@ -0,0 +1,151 @@
+/* Definitions for BSD-style memory management.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_MMAN_H
+#define	_SYS_MMAN_H	1
+
+#include <features.h>
+#include <bits/types.h>
+#define __need_size_t
+#include <stddef.h>
+
+#ifndef __off_t_defined
+# ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+# else
+typedef __off64_t off_t;
+# endif
+# define __off_t_defined
+#endif
+
+#ifndef __mode_t_defined
+typedef __mode_t mode_t;
+# define __mode_t_defined
+#endif
+
+#include <bits/mman.h>
+
+/* Return value of `mmap' in case of an error.  */
+#define MAP_FAILED	((void *) -1)
+
+__BEGIN_DECLS
+/* Map addresses starting near ADDR and extending for LEN bytes.  from
+   OFFSET into the file FD describes according to PROT and FLAGS.  If ADDR
+   is nonzero, it is the desired mapping address.  If the MAP_FIXED bit is
+   set in FLAGS, the mapping will be at ADDR exactly (which must be
+   page-aligned); otherwise the system chooses a convenient nearby address.
+   The return value is the actual mapping address chosen or MAP_FAILED
+   for errors (in which case `errno' is set).  A successful `mmap' call
+   deallocates any previous mapping for the affected region.  */
+
+#ifndef __USE_FILE_OFFSET64
+extern void *mmap (void *__addr, size_t __len, int __prot,
+		   int __flags, int __fd, __off_t __offset) __THROW;
+#else
+# ifdef __REDIRECT_NTH
+extern void * __REDIRECT_NTH (mmap,
+			      (void *__addr, size_t __len, int __prot,
+			       int __flags, int __fd, __off64_t __offset),
+			      mmap64);
+# else
+#  define mmap mmap64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern void *mmap64 (void *__addr, size_t __len, int __prot,
+		     int __flags, int __fd, __off64_t __offset) __THROW;
+#endif
+
+/* Deallocate any mapping for the region starting at ADDR and extending LEN
+   bytes.  Returns 0 if successful, -1 for errors (and sets errno).  */
+extern int munmap (void *__addr, size_t __len) __THROW;
+
+/* Change the memory protection of the region starting at ADDR and
+   extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors
+   (and sets errno).  */
+extern int mprotect (void *__addr, size_t __len, int __prot) __THROW;
+
+/* Synchronize the region starting at ADDR and extending LEN bytes with the
+   file it maps.  Filesystem operations on a file being mapped are
+   unpredictable before this is done.  Flags are from the MS_* set.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int msync (void *__addr, size_t __len, int __flags);
+
+#ifdef __USE_BSD
+/* Advise the system about particular usage patterns the program follows
+   for the region starting at ADDR and extending LEN bytes.  */
+extern int madvise (void *__addr, size_t __len, int __advice) __THROW;
+#endif
+#ifdef __USE_XOPEN2K
+/* This is the POSIX name for this function.  */
+extern int posix_madvise (void *__addr, size_t __len, int __advice) __THROW;
+#endif
+
+/* Guarantee all whole pages mapped by the range [ADDR,ADDR+LEN) to
+   be memory resident.  */
+extern int mlock (const void *__addr, size_t __len) __THROW;
+
+/* Unlock whole pages previously mapped by the range [ADDR,ADDR+LEN).  */
+extern int munlock (const void *__addr, size_t __len) __THROW;
+
+/* Cause all currently mapped pages of the process to be memory resident
+   until unlocked by a call to the `munlockall', until the process exits,
+   or until the process calls `execve'.  */
+extern int mlockall (int __flags) __THROW;
+
+/* All currently mapped pages of the process' address space become
+   unlocked.  */
+extern int munlockall (void) __THROW;
+
+#ifdef __USE_MISC
+/* mincore returns the memory residency status of the pages in the
+   current process's address space specified by [start, start + len).
+   The status is returned in a vector of bytes.  The least significant
+   bit of each byte is 1 if the referenced page is in memory, otherwise
+   it is zero.  */
+extern int mincore (void *__start, size_t __len, unsigned char *__vec)
+     __THROW;
+#endif
+
+#ifdef __USE_GNU
+/* Remap pages mapped by the range [ADDR,ADDR+OLD_LEN) to new length
+   NEW_LEN.  If MREMAP_MAYMOVE is set in FLAGS the returned address
+   may differ from ADDR.  If MREMAP_FIXED is set in FLAGS the function
+   takes another parameter which is a fixed address at which the block
+   resides after a successful call.  */
+extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
+		     int __flags, ...) __THROW;
+
+/* Remap arbitrary pages of a shared backing store within an existing
+   VMA.  */
+extern int remap_file_pages (void *__start, size_t __size, int __prot,
+			     size_t __pgoff, int __flags) __THROW;
+#endif
+
+
+/* Open shared memory segment.  */
+extern int shm_open (const char *__name, int __oflag, mode_t __mode);
+
+/* Remove shared memory segment.  */
+extern int shm_unlink (const char *__name);
+
+__END_DECLS
+
+#endif	/* sys/mman.h */
diff --git a/include/sys/msg.h b/include/sys/msg.h
new file mode 100644
index 0000000..ce91240
--- /dev/null
+++ b/include/sys/msg.h
@@ -0,0 +1,83 @@
+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_MSG_H
+#define _SYS_MSG_H
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+/* Get common definition of System V style IPC.  */
+#include <sys/ipc.h>
+
+/* Get system dependent definition of `struct msqid_ds' and more.  */
+#include <bits/msq.h>
+
+/* Define types required by the standard.  */
+#define	__need_time_t
+#include <time.h>
+
+#ifndef __pid_t_defined
+typedef __pid_t pid_t;
+# define __pid_t_defined
+#endif
+
+#ifndef __ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+#endif
+
+/* The following System V style IPC functions implement a message queue
+   system.  The definition is found in XPG2.  */
+
+#ifdef __USE_GNU
+/* Template for struct to be used as argument for `msgsnd' and `msgrcv'.  */
+struct msgbuf
+  {
+    __syscall_slong_t mtype;	/* type of received/sent message */
+    char mtext[1];		/* text of the message */
+  };
+#endif
+
+
+__BEGIN_DECLS
+
+/* Message queue control operation.  */
+extern int msgctl (int __msqid, int __cmd, struct msqid_ds *__buf) __THROW;
+
+/* Get messages queue.  */
+extern int msgget (key_t __key, int __msgflg) __THROW;
+
+/* Receive message from message queue.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t msgrcv (int __msqid, void *__msgp, size_t __msgsz,
+		       long int __msgtyp, int __msgflg);
+
+/* Send message to message queue.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int msgsnd (int __msqid, const void *__msgp, size_t __msgsz,
+		   int __msgflg);
+
+__END_DECLS
+
+#endif /* sys/msg.h */
diff --git a/include/sys/mtio.h b/include/sys/mtio.h
new file mode 100644
index 0000000..f40a351
--- /dev/null
+++ b/include/sys/mtio.h
@@ -0,0 +1,276 @@
+/* Structures and definitions for magnetic tape I/O control commands.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Written by H. Bergman <hennus@cybercomm.nl>.  */
+
+#ifndef _SYS_MTIO_H
+#define _SYS_MTIO_H	1
+
+/* Get necessary definitions from system and kernel headers.  */
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+
+/* Structure for MTIOCTOP - magnetic tape operation command.  */
+struct mtop
+  {
+    short int mt_op;		/* Operations defined below.  */
+    int mt_count;		/* How many of them.  */
+  };
+#define _IOT_mtop /* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (short), 1, _IOTS (int), 1, 0, 0)
+
+/* Magnetic Tape operations [Not all operations supported by all drivers].  */
+#define MTRESET 0	/* +reset drive in case of problems.  */
+#define MTFSF	1	/* Forward space over FileMark,
+			 * position at first record of next file.  */
+#define MTBSF	2	/* Backward space FileMark (position before FM).  */
+#define MTFSR	3	/* Forward space record.  */
+#define MTBSR	4	/* Backward space record.  */
+#define MTWEOF	5	/* Write an end-of-file record (mark).  */
+#define MTREW	6	/* Rewind.  */
+#define MTOFFL	7	/* Rewind and put the drive offline (eject?).  */
+#define MTNOP	8	/* No op, set status only (read with MTIOCGET).  */
+#define MTRETEN 9	/* Retension tape.  */
+#define MTBSFM	10	/* +backward space FileMark, position at FM.  */
+#define MTFSFM  11	/* +forward space FileMark, position at FM.  */
+#define MTEOM	12	/* Goto end of recorded media (for appending files).
+			   MTEOM positions after the last FM, ready for
+			   appending another file.  */
+#define MTERASE 13	/* Erase tape -- be careful!  */
+
+#define MTRAS1  14	/* Run self test 1 (nondestructive).  */
+#define MTRAS2	15	/* Run self test 2 (destructive).  */
+#define MTRAS3  16	/* Reserved for self test 3.  */
+
+#define MTSETBLK 20	/* Set block length (SCSI).  */
+#define MTSETDENSITY 21	/* Set tape density (SCSI).  */
+#define MTSEEK	22	/* Seek to block (Tandberg, etc.).  */
+#define MTTELL	23	/* Tell block (Tandberg, etc.).  */
+#define MTSETDRVBUFFER 24 /* Set the drive buffering according to SCSI-2.
+			     Ordinary buffered operation with code 1.  */
+#define MTFSS	25	/* Space forward over setmarks.  */
+#define MTBSS	26	/* Space backward over setmarks.  */
+#define MTWSM	27	/* Write setmarks.  */
+
+#define MTLOCK  28	/* Lock the drive door.  */
+#define MTUNLOCK 29	/* Unlock the drive door.  */
+#define MTLOAD  30	/* Execute the SCSI load command.  */
+#define MTUNLOAD 31	/* Execute the SCSI unload command.  */
+#define MTCOMPRESSION 32/* Control compression with SCSI mode page 15.  */
+#define MTSETPART 33	/* Change the active tape partition.  */
+#define MTMKPART  34	/* Format the tape with one or two partitions.  */
+
+/* structure for MTIOCGET - mag tape get status command */
+
+struct mtget
+  {
+    long int mt_type;		/* Type of magtape device.  */
+    long int mt_resid;		/* Residual count: (not sure)
+				   number of bytes ignored, or
+				   number of files not skipped, or
+				   number of records not skipped.  */
+    /* The following registers are device dependent.  */
+    long int mt_dsreg;		/* Status register.  */
+    long int mt_gstat;		/* Generic (device independent) status.  */
+    long int mt_erreg;		/* Error register.  */
+    /* The next two fields are not always used.  */
+    __daddr_t mt_fileno;	/* Number of current file on tape.  */
+    __daddr_t mt_blkno;		/* Current block number.  */
+  };
+#define _IOT_mtget /* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (long), 7, 0, 0, 0, 0)
+
+
+/* Constants for mt_type. Not all of these are supported, and
+   these are not all of the ones that are supported.  */
+#define MT_ISUNKNOWN		0x01
+#define MT_ISQIC02		0x02	/* Generic QIC-02 tape streamer.  */
+#define MT_ISWT5150		0x03	/* Wangtek 5150EQ, QIC-150, QIC-02.  */
+#define MT_ISARCHIVE_5945L2	0x04	/* Archive 5945L-2, QIC-24, QIC-02?. */
+#define MT_ISCMSJ500		0x05	/* CMS Jumbo 500 (QIC-02?).  */
+#define MT_ISTDC3610		0x06	/* Tandberg 6310, QIC-24.  */
+#define MT_ISARCHIVE_VP60I	0x07	/* Archive VP60i, QIC-02.  */
+#define MT_ISARCHIVE_2150L	0x08	/* Archive Viper 2150L.  */
+#define MT_ISARCHIVE_2060L	0x09	/* Archive Viper 2060L.  */
+#define MT_ISARCHIVESC499	0x0A	/* Archive SC-499 QIC-36 controller. */
+#define MT_ISQIC02_ALL_FEATURES	0x0F	/* Generic QIC-02 with all features. */
+#define MT_ISWT5099EEN24	0x11	/* Wangtek 5099-een24, 60MB, QIC-24. */
+#define MT_ISTEAC_MT2ST		0x12	/* Teac MT-2ST 155mb drive,
+					   Teac DC-1 card (Wangtek type).  */
+#define MT_ISEVEREX_FT40A	0x32	/* Everex FT40A (QIC-40).  */
+#define MT_ISDDS1		0x51	/* DDS device without partitions.  */
+#define MT_ISDDS2		0x52	/* DDS device with partitions.  */
+#define MT_ISSCSI1		0x71	/* Generic ANSI SCSI-1 tape unit.  */
+#define MT_ISSCSI2		0x72	/* Generic ANSI SCSI-2 tape unit.  */
+
+/* QIC-40/80/3010/3020 ftape supported drives.
+   20bit vendor ID + 0x800000 (see vendors.h in ftape distribution).  */
+#define MT_ISFTAPE_UNKNOWN	0x800000 /* obsolete */
+#define MT_ISFTAPE_FLAG		0x800000
+
+struct mt_tape_info
+  {
+    long int t_type;		/* Device type id (mt_type).  */
+    char *t_name;		/* Descriptive name.  */
+  };
+
+#define MT_TAPE_INFO \
+  {									      \
+	{MT_ISUNKNOWN,		"Unknown type of tape device"},		      \
+	{MT_ISQIC02,		"Generic QIC-02 tape streamer"},	      \
+	{MT_ISWT5150,		"Wangtek 5150, QIC-150"},		      \
+	{MT_ISARCHIVE_5945L2,	"Archive 5945L-2"},			      \
+	{MT_ISCMSJ500,		"CMS Jumbo 500"},			      \
+	{MT_ISTDC3610,		"Tandberg TDC 3610, QIC-24"},		      \
+	{MT_ISARCHIVE_VP60I,	"Archive VP60i, QIC-02"},		      \
+	{MT_ISARCHIVE_2150L,	"Archive Viper 2150L"},			      \
+	{MT_ISARCHIVE_2060L,	"Archive Viper 2060L"},			      \
+	{MT_ISARCHIVESC499,	"Archive SC-499 QIC-36 controller"},	      \
+	{MT_ISQIC02_ALL_FEATURES, "Generic QIC-02 tape, all features"},	      \
+	{MT_ISWT5099EEN24,	"Wangtek 5099-een24, 60MB"},		      \
+	{MT_ISTEAC_MT2ST,	"Teac MT-2ST 155mb data cassette drive"},     \
+	{MT_ISEVEREX_FT40A,	"Everex FT40A, QIC-40"},		      \
+	{MT_ISSCSI1,		"Generic SCSI-1 tape"},			      \
+	{MT_ISSCSI2,		"Generic SCSI-2 tape"},			      \
+	{0, NULL}							      \
+  }
+
+
+/* Structure for MTIOCPOS - mag tape get position command.  */
+
+struct mtpos
+  {
+    long int mt_blkno;	/* Current block number.  */
+  };
+#define _IOT_mtpos /* Hurd ioctl type field.  */ \
+  _IOT_SIMPLE (long)
+
+
+/* Structure for MTIOCGETCONFIG/MTIOCSETCONFIG primarily intended
+   as an interim solution for QIC-02 until DDI is fully implemented.  */
+struct mtconfiginfo
+  {
+    long int mt_type;		/* Drive type.  */
+    long int ifc_type;		/* Interface card type.  */
+    unsigned short int irqnr;	/* IRQ number to use.  */
+    unsigned short int dmanr;	/* DMA channel to use.  */
+    unsigned short int port;	/* IO port base address.  */
+
+    unsigned long int debug;	/* Debugging flags.  */
+
+    unsigned have_dens:1;
+    unsigned have_bsf:1;
+    unsigned have_fsr:1;
+    unsigned have_bsr:1;
+    unsigned have_eod:1;
+    unsigned have_seek:1;
+    unsigned have_tell:1;
+    unsigned have_ras1:1;
+    unsigned have_ras2:1;
+    unsigned have_ras3:1;
+    unsigned have_qfa:1;
+
+    unsigned pad1:5;
+    char reserved[10];
+  };
+#define _IOT_mtconfiginfo /* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (long), 2, _IOTS (short), 3, _IOTS (long), 1) /* XXX wrong */
+
+
+/* Magnetic tape I/O control commands.  */
+#define	MTIOCTOP	_IOW('m', 1, struct mtop)	/* Do a mag tape op. */
+#define	MTIOCGET	_IOR('m', 2, struct mtget)	/* Get tape status.  */
+#define	MTIOCPOS	_IOR('m', 3, struct mtpos)	/* Get tape position.*/
+
+/* The next two are used by the QIC-02 driver for runtime reconfiguration.
+   See tpqic02.h for struct mtconfiginfo.  */
+#define	MTIOCGETCONFIG	_IOR('m', 4, struct mtconfiginfo) /* Get tape config.*/
+#define	MTIOCSETCONFIG	_IOW('m', 5, struct mtconfiginfo) /* Set tape config.*/
+
+/* Generic Mag Tape (device independent) status macros for examining
+   mt_gstat -- HP-UX compatible.
+   There is room for more generic status bits here, but I don't
+   know which of them are reserved. At least three or so should
+   be added to make this really useful.  */
+#define GMT_EOF(x)              ((x) & 0x80000000)
+#define GMT_BOT(x)              ((x) & 0x40000000)
+#define GMT_EOT(x)              ((x) & 0x20000000)
+#define GMT_SM(x)               ((x) & 0x10000000)  /* DDS setmark */
+#define GMT_EOD(x)              ((x) & 0x08000000)  /* DDS EOD */
+#define GMT_WR_PROT(x)          ((x) & 0x04000000)
+/* #define GMT_ ? 		((x) & 0x02000000) */
+#define GMT_ONLINE(x)           ((x) & 0x01000000)
+#define GMT_D_6250(x)           ((x) & 0x00800000)
+#define GMT_D_1600(x)           ((x) & 0x00400000)
+#define GMT_D_800(x)            ((x) & 0x00200000)
+/* #define GMT_ ? 		((x) & 0x00100000) */
+/* #define GMT_ ? 		((x) & 0x00080000) */
+#define GMT_DR_OPEN(x)          ((x) & 0x00040000)  /* Door open (no tape).  */
+/* #define GMT_ ? 		((x) & 0x00020000) */
+#define GMT_IM_REP_EN(x)        ((x) & 0x00010000)  /* Immediate report mode.*/
+/* 16 generic status bits unused.  */
+
+
+/* SCSI-tape specific definitions.  Bitfield shifts in the status  */
+#define MT_ST_BLKSIZE_SHIFT	0
+#define MT_ST_BLKSIZE_MASK	0xffffff
+#define MT_ST_DENSITY_SHIFT	24
+#define MT_ST_DENSITY_MASK	0xff000000
+
+#define MT_ST_SOFTERR_SHIFT	0
+#define MT_ST_SOFTERR_MASK	0xffff
+
+/* Bitfields for the MTSETDRVBUFFER ioctl.  */
+#define MT_ST_OPTIONS		0xf0000000
+#define MT_ST_BOOLEANS		0x10000000
+#define MT_ST_SETBOOLEANS	0x30000000
+#define MT_ST_CLEARBOOLEANS	0x40000000
+#define MT_ST_WRITE_THRESHOLD	0x20000000
+#define MT_ST_DEF_BLKSIZE	0x50000000
+#define MT_ST_DEF_OPTIONS	0x60000000
+
+#define MT_ST_BUFFER_WRITES	0x1
+#define MT_ST_ASYNC_WRITES	0x2
+#define MT_ST_READ_AHEAD	0x4
+#define MT_ST_DEBUGGING		0x8
+#define MT_ST_TWO_FM		0x10
+#define MT_ST_FAST_MTEOM	0x20
+#define MT_ST_AUTO_LOCK		0x40
+#define MT_ST_DEF_WRITES	0x80
+#define MT_ST_CAN_BSR		0x100
+#define MT_ST_NO_BLKLIMS	0x200
+#define MT_ST_CAN_PARTITIONS    0x400
+#define MT_ST_SCSI2LOGICAL      0x800
+
+/* The mode parameters to be controlled. Parameter chosen with bits 20-28.  */
+#define MT_ST_CLEAR_DEFAULT	0xfffff
+#define MT_ST_DEF_DENSITY	(MT_ST_DEF_OPTIONS | 0x100000)
+#define MT_ST_DEF_COMPRESSION	(MT_ST_DEF_OPTIONS | 0x200000)
+#define MT_ST_DEF_DRVBUFFER	(MT_ST_DEF_OPTIONS | 0x300000)
+
+/* The offset for the arguments for the special HP changer load command.  */
+#define MT_ST_HPLOADER_OFFSET 10000
+
+
+/* Specify default tape device.  */
+#ifndef DEFTAPE
+# define DEFTAPE	"/dev/tape"
+#endif
+
+#endif /* mtio.h */
diff --git a/include/sys/param.h b/include/sys/param.h
new file mode 100644
index 0000000..8ac62ac
--- /dev/null
+++ b/include/sys/param.h
@@ -0,0 +1,103 @@
+/* Compatibility header for old-style Unix parameters and limits.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_PARAM_H
+#define _SYS_PARAM_H    1
+
+#define __need_NULL
+#include <stddef.h>
+
+#include <sys/types.h>
+#include <limits.h>
+#include <endian.h>                     /* Define BYTE_ORDER et al.  */
+#include <signal.h>                     /* Define NSIG.  */
+
+/* This file defines some things in system-specific ways.  */
+#include <bits/param.h>
+
+
+/* BSD names for some <limits.h> values.  */
+
+#define NBBY		CHAR_BIT
+
+#if !defined NGROUPS && defined NGROUPS_MAX
+# define NGROUPS	NGROUPS_MAX
+#endif
+#if !defined MAXSYMLINKS && defined SYMLOOP_MAX
+# define MAXSYMLINKS	SYMLOOP_MAX
+#endif
+#if !defined CANBSIZ && defined MAX_CANON
+# define CANBSIZ	MAX_CANON
+#endif
+#if !defined MAXPATHLEN && defined PATH_MAX
+# define MAXPATHLEN	PATH_MAX
+#endif
+#if !defined NOFILE && defined OPEN_MAX
+# define NOFILE		OPEN_MAX
+#endif
+#ifndef NCARGS
+# ifdef ARG_MAX
+#  define NCARGS	ARG_MAX
+# else
+/* ARG_MAX is unlimited, but we define NCARGS for BSD programs that want to
+   compare against some fixed limit.  */
+# define NCARGS		INT_MAX
+# endif
+#endif
+
+
+/* Magical constants.  */
+#ifndef NOGROUP
+# define NOGROUP	65535     /* Marker for empty group set member.  */
+#endif
+#ifndef NODEV
+# define NODEV		((dev_t) -1)    /* Non-existent device.  */
+#endif
+
+
+/* Unit of `st_blocks'.  */
+#ifndef DEV_BSIZE
+# define DEV_BSIZE	512
+#endif
+
+
+/* Bit map related macros.  */
+#define setbit(a,i)     ((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define clrbit(a,i)     ((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define isset(a,i)      ((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define isclr(a,i)      (((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+
+/* Macros for counting and rounding.  */
+#ifndef howmany
+# define howmany(x, y)  (((x) + ((y) - 1)) / (y))
+#endif
+#ifdef __GNUC__
+# define roundup(x, y)  (__builtin_constant_p (y) && powerof2 (y)             \
+                         ? (((x) + (y) - 1) & ~((y) - 1))                     \
+                         : ((((x) + ((y) - 1)) / (y)) * (y)))
+#else
+# define roundup(x, y)  ((((x) + ((y) - 1)) / (y)) * (y))
+#endif
+#define powerof2(x)     ((((x) - 1) & (x)) == 0)
+
+/* Macros for min/max.  */
+#define MIN(a,b) (((a)<(b))?(a):(b))
+#define MAX(a,b) (((a)>(b))?(a):(b))
+
+
+#endif  /* sys/param.h */
diff --git a/include/sys/poll.h b/include/sys/poll.h
new file mode 100644
index 0000000..35d2f0b
--- /dev/null
+++ b/include/sys/poll.h
@@ -0,0 +1,79 @@
+/* Compatibility definitions for System V `poll' interface.
+   Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_POLL_H
+#define	_SYS_POLL_H	1
+
+#include <features.h>
+
+/* Get the platform dependent bits of `poll'.  */
+#include <bits/poll.h>
+#ifdef __USE_GNU
+/* Get the __sigset_t definition.  */
+# include <bits/sigset.h>
+/* Get the timespec definition.  */
+# define __need_timespec
+# include <time.h>
+#endif
+
+
+/* Type used for the number of file descriptors.  */
+typedef unsigned long int nfds_t;
+
+/* Data structure describing a polling request.  */
+struct pollfd
+  {
+    int fd;			/* File descriptor to poll.  */
+    short int events;		/* Types of events poller cares about.  */
+    short int revents;		/* Types of events that actually occurred.  */
+  };
+
+
+__BEGIN_DECLS
+
+/* Poll the file descriptors described by the NFDS structures starting at
+   FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for
+   an event to occur; if TIMEOUT is -1, block until an event occurs.
+   Returns the number of file descriptors with events, zero if timed out,
+   or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);
+
+#ifdef __USE_GNU
+/* Like poll, but before waiting the threads signal mask is replaced
+   with that specified in the fourth parameter.  For better usability,
+   the timeout value is specified using a TIMESPEC object.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int ppoll (struct pollfd *__fds, nfds_t __nfds,
+		  const struct timespec *__timeout,
+		  const __sigset_t *__ss);
+#endif
+
+__END_DECLS
+
+
+/* Define some inlines helping to catch common problems.  */
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+# include <bits/poll2.h>
+#endif
+
+#endif	/* sys/poll.h */
diff --git a/include/sys/profil.h b/include/sys/profil.h
new file mode 100644
index 0000000..2c9b00d
--- /dev/null
+++ b/include/sys/profil.h
@@ -0,0 +1,60 @@
+/* Copyright (C) 2001-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _PROFIL_H
+#define _PROFIL_H	1
+
+#include <features.h>
+
+#include <sys/time.h>
+#include <sys/types.h>
+
+/* This interface is intended to follow the sprofil() system calls as
+   described by the sprofil(2) man page of Irix v6.5, except that:
+
+	- there is no a priori limit on number of text sections
+	- pr_scale is declared as unsigned long (instead of "unsigned int")
+	- pr_size is declared as size_t (instead of "unsigned int")
+	- pr_off is declared as void * (instead of "__psunsigned_t")
+	- the overflow bin (pr_base==0, pr_scale==2) can appear anywhere
+	  in the profp array
+	- PROF_FAST has no effect  */
+
+struct prof
+  {
+    void *pr_base;		/* buffer base */
+    size_t pr_size;		/* buffer size */
+    size_t pr_off;		/* pc offset */
+    unsigned long int pr_scale;	/* pc scaling (fixed-point number) */
+  };
+
+enum
+  {
+    PROF_USHORT	= 0,		/* use 16-bit counters (default) */
+    PROF_UINT	= 1 << 0,	/* use 32-bit counters */
+    PROF_FAST   = 1 << 1	/* profile faster than usual */
+  };
+
+
+__BEGIN_DECLS
+
+extern int sprofil (struct prof *__profp, int __profcnt,
+		    struct timeval *__tvp, unsigned int __flags) __THROW;
+
+__END_DECLS
+
+#endif /* profil.h */
diff --git a/include/sys/ptrace.h b/include/sys/ptrace.h
new file mode 100644
index 0000000..7c252a8
--- /dev/null
+++ b/include/sys/ptrace.h
@@ -0,0 +1,137 @@
+/* `ptrace' debugger support interface.  Generic version; constants are common.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_PTRACE_H
+
+#define	_PTRACE_H	1
+#include <features.h>
+
+__BEGIN_DECLS
+
+
+/* Type of the REQUEST argument to `ptrace.'  */
+enum __ptrace_request
+{
+  /* Indicate that the process making this request should be traced.
+     All signals received by this process can be intercepted by its
+     parent, and its parent can use the other `ptrace' requests.  */
+  PTRACE_TRACEME = 0,
+#define PT_TRACE_ME PTRACE_TRACEME
+
+  /* Return the word in the process's text space at address ADDR.  */
+  PTRACE_PEEKTEXT,
+#define PT_READ_I PTRACE_PEEKTEXT
+
+  /* Return the word in the process's data space at address ADDR.  */
+  PTRACE_PEEKDATA,
+#define PT_READ_D PTRACE_PEEKDATA
+
+  /* Return the word in the process's user area at offset ADDR.  */
+  PTRACE_PEEKUSER,
+#define PT_READ_U PTRACE_PEEKUSER
+
+  /* Write the word DATA into the process's text space at address ADDR.  */
+  PTRACE_POKETEXT,
+#define PT_WRITE_I PTRACE_POKETEXT
+
+  /* Write the word DATA into the process's data space at address ADDR.  */
+  PTRACE_POKEDATA,
+#define PT_WRITE_D PTRACE_POKEDATA
+
+  /* Write the word DATA into the process's user space at offset ADDR.  */
+  PTRACE_POKEUSER,
+#define PT_WRITE_U PTRACE_POKEUSER
+
+  /* Continue the process.  */
+  PTRACE_CONT,
+#define PT_CONTINUE PTRACE_CONT
+
+  /* Kill the process.  */
+  PTRACE_KILL,
+#define PT_KILL PTRACE_KILL
+
+  /* Single step the process.
+     This is not supported on all machines.  */
+  PTRACE_SINGLESTEP,
+#define PT_STEP PTRACE_SINGLESTEP
+
+  /* Attach to a process that is already running. */
+  PTRACE_ATTACH,
+#define PT_ATTACH PTRACE_ATTACH
+
+  /* Detach from a process attached to with PTRACE_ATTACH.  */
+  PTRACE_DETACH,
+#define PT_DETACH PTRACE_DETACH
+
+  /* Get the process's registers (not including floating-point registers)
+     and put them in the `struct regs' (see <machine/regs.h>) at ADDR.  */
+  PTRACE_GETREGS = 12,
+
+  /* Set the process's registers (not including floating-point registers)
+     to the contents of the `struct regs' (see <machine/regs.h>) at ADDR.  */
+  PTRACE_SETREGS,
+
+  /* Get the process's floating point registers and put them
+     in the `struct fp_status' (see <machine/regs.h>) at ADDR.  */
+  PTRACE_GETFPREGS = 14,
+
+  /* Set the process's floating point registers to the contents
+     of the `struct fp_status' (see <machine/regs.h>) at ADDR.  */
+  PTRACE_SETFPREGS,
+
+  /* Read DATA bytes from the process's data space at address ADDR.
+     Put the result starting at address ADDR2 in the caller's
+     address space.  */
+  PTRACE_READDATA = 16,
+
+  /* Write DATA bytes from ADDR2 in the caller's address space into
+     the process's data space at address ADDR.  */
+  PTRACE_WRITEDATA,
+
+  /* Read DATA bytes from the process's text space at address ADDR.
+     Put the result starting at address ADDR2 in the caller's
+     address space.  */
+  PTRACE_READTEXT = 18,
+
+  /* Write DATA bytes from ADDR2 in the caller's address space into
+     the process's text space at address ADDR.  */
+  PTRACE_WRITETEXT,
+
+  /* Read the floating-point accelerator unit registers and
+     put them into the `struct fpa_regs' (see <machine/regs.h>) at ADDR.  */
+  PTRACE_GETFPAREGS = 20,
+
+  /* Write the floating-point accelerator unit registers from
+     the contents of the `struct fpa_regs' at ADDR.  */
+  PTRACE_SETFPAREGS
+};
+
+/* Perform process tracing functions.  REQUEST is one of the values
+   above, and determines the action to be taken.
+   For all requests except PTRACE_TRACEME, PID specifies the process to be
+   traced.
+
+   PID and the other arguments described above for the various requests should
+   appear (those that are used for the particular request) as:
+     pid_t PID, void *ADDR, int DATA, void *ADDR2
+   after REQUEST.  */
+extern int ptrace (enum __ptrace_request __request, ...);
+
+__END_DECLS
+
+#endif /* ptrace.h */
diff --git a/include/sys/queue.h b/include/sys/queue.h
new file mode 100644
index 0000000..daf4553
--- /dev/null
+++ b/include/sys/queue.h
@@ -0,0 +1,574 @@
+/*
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
+ */
+
+#ifndef	_SYS_QUEUE_H_
+#define	_SYS_QUEUE_H_
+
+/*
+ * This file defines five types of data structures: singly-linked lists,
+ * lists, simple queues, tail queues, and circular queues.
+ *
+ * A singly-linked list is headed by a single forward pointer. The
+ * elements are singly linked for minimum space and pointer manipulation
+ * overhead at the expense of O(n) removal for arbitrary elements. New
+ * elements can be added to the list after an existing element or at the
+ * head of the list.  Elements being removed from the head of the list
+ * should use the explicit macro for this purpose for optimum
+ * efficiency. A singly-linked list may only be traversed in the forward
+ * direction.  Singly-linked lists are ideal for applications with large
+ * datasets and few or no removals or for implementing a LIFO queue.
+ *
+ * A list is headed by a single forward pointer (or an array of forward
+ * pointers for a hash table header). The elements are doubly linked
+ * so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before
+ * or after an existing element or at the head of the list. A list
+ * may only be traversed in the forward direction.
+ *
+ * A simple queue is headed by a pair of pointers, one the head of the
+ * list and the other to the tail of the list. The elements are singly
+ * linked to save space, so elements can only be removed from the
+ * head of the list. New elements can be added to the list after
+ * an existing element, at the head of the list, or at the end of the
+ * list. A simple queue may only be traversed in the forward direction.
+ *
+ * A tail queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or
+ * after an existing element, at the head of the list, or at the end of
+ * the list. A tail queue may be traversed in either direction.
+ *
+ * A circle queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or after
+ * an existing element, at the head of the list, or at the end of the list.
+ * A circle queue may be traversed in either direction, but has a more
+ * complex end of list detection.
+ *
+ * For details on the use of these macros, see the queue(3) manual page.
+ */
+
+/*
+ * List definitions.
+ */
+#define	LIST_HEAD(name, type)						\
+struct name {								\
+	struct type *lh_first;	/* first element */			\
+}
+
+#define	LIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	LIST_ENTRY(type)						\
+struct {								\
+	struct type *le_next;	/* next element */			\
+	struct type **le_prev;	/* address of previous next element */	\
+}
+
+/*
+ * List functions.
+ */
+#define	LIST_INIT(head) do {						\
+	(head)->lh_first = NULL;					\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_INSERT_AFTER(listelm, elm, field) do {			\
+	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
+		(listelm)->field.le_next->field.le_prev =		\
+		    &(elm)->field.le_next;				\
+	(listelm)->field.le_next = (elm);				\
+	(elm)->field.le_prev = &(listelm)->field.le_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.le_prev = (listelm)->field.le_prev;		\
+	(elm)->field.le_next = (listelm);				\
+	*(listelm)->field.le_prev = (elm);				\
+	(listelm)->field.le_prev = &(elm)->field.le_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_INSERT_HEAD(head, elm, field) do {				\
+	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
+		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
+	(head)->lh_first = (elm);					\
+	(elm)->field.le_prev = &(head)->lh_first;			\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_REMOVE(elm, field) do {					\
+	if ((elm)->field.le_next != NULL)				\
+		(elm)->field.le_next->field.le_prev = 			\
+		    (elm)->field.le_prev;				\
+	*(elm)->field.le_prev = (elm)->field.le_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_FOREACH(var, head, field)					\
+	for ((var) = ((head)->lh_first);				\
+		(var);							\
+		(var) = ((var)->field.le_next))
+
+/*
+ * List access methods.
+ */
+#define	LIST_EMPTY(head)		((head)->lh_first == NULL)
+#define	LIST_FIRST(head)		((head)->lh_first)
+#define	LIST_NEXT(elm, field)		((elm)->field.le_next)
+
+
+/*
+ * Singly-linked List definitions.
+ */
+#define	SLIST_HEAD(name, type)						\
+struct name {								\
+	struct type *slh_first;	/* first element */			\
+}
+
+#define	SLIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	SLIST_ENTRY(type)						\
+struct {								\
+	struct type *sle_next;	/* next element */			\
+}
+
+/*
+ * Singly-linked List functions.
+ */
+#define	SLIST_INIT(head) do {						\
+	(head)->slh_first = NULL;					\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
+	(elm)->field.sle_next = (slistelm)->field.sle_next;		\
+	(slistelm)->field.sle_next = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
+	(elm)->field.sle_next = (head)->slh_first;			\
+	(head)->slh_first = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_REMOVE_HEAD(head, field) do {				\
+	(head)->slh_first = (head)->slh_first->field.sle_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_REMOVE(head, elm, type, field) do {			\
+	if ((head)->slh_first == (elm)) {				\
+		SLIST_REMOVE_HEAD((head), field);			\
+	}								\
+	else {								\
+		struct type *curelm = (head)->slh_first;		\
+		while(curelm->field.sle_next != (elm))			\
+			curelm = curelm->field.sle_next;		\
+		curelm->field.sle_next =				\
+		    curelm->field.sle_next->field.sle_next;		\
+	}								\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_FOREACH(var, head, field)					\
+	for((var) = (head)->slh_first; (var); (var) = (var)->field.sle_next)
+
+/*
+ * Singly-linked List access methods.
+ */
+#define	SLIST_EMPTY(head)	((head)->slh_first == NULL)
+#define	SLIST_FIRST(head)	((head)->slh_first)
+#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
+
+
+/*
+ * Singly-linked Tail queue declarations.
+ */
+#define	STAILQ_HEAD(name, type)					\
+struct name {								\
+	struct type *stqh_first;	/* first element */			\
+	struct type **stqh_last;	/* addr of last next element */		\
+}
+
+#define	STAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).stqh_first }
+
+#define	STAILQ_ENTRY(type)						\
+struct {								\
+	struct type *stqe_next;	/* next element */			\
+}
+
+/*
+ * Singly-linked Tail queue functions.
+ */
+#define	STAILQ_INIT(head) do {						\
+	(head)->stqh_first = NULL;					\
+	(head)->stqh_last = &(head)->stqh_first;				\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.stqe_next = (head)->stqh_first) == NULL)	\
+		(head)->stqh_last = &(elm)->field.stqe_next;		\
+	(head)->stqh_first = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.stqe_next = NULL;					\
+	*(head)->stqh_last = (elm);					\
+	(head)->stqh_last = &(elm)->field.stqe_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.stqe_next = (listelm)->field.stqe_next) == NULL)\
+		(head)->stqh_last = &(elm)->field.stqe_next;		\
+	(listelm)->field.stqe_next = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_REMOVE_HEAD(head, field) do {				\
+	if (((head)->stqh_first = (head)->stqh_first->field.stqe_next) == NULL) \
+		(head)->stqh_last = &(head)->stqh_first;			\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_REMOVE(head, elm, type, field) do {			\
+	if ((head)->stqh_first == (elm)) {				\
+		STAILQ_REMOVE_HEAD((head), field);			\
+	} else {							\
+		struct type *curelm = (head)->stqh_first;		\
+		while (curelm->field.stqe_next != (elm))			\
+			curelm = curelm->field.stqe_next;		\
+		if ((curelm->field.stqe_next =				\
+			curelm->field.stqe_next->field.stqe_next) == NULL) \
+			    (head)->stqh_last = &(curelm)->field.stqe_next; \
+	}								\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_FOREACH(var, head, field)				\
+	for ((var) = ((head)->stqh_first);				\
+		(var);							\
+		(var) = ((var)->field.stqe_next))
+
+#define	STAILQ_CONCAT(head1, head2) do {				\
+	if (!STAILQ_EMPTY((head2))) {					\
+		*(head1)->stqh_last = (head2)->stqh_first;		\
+		(head1)->stqh_last = (head2)->stqh_last;		\
+		STAILQ_INIT((head2));					\
+	}								\
+} while (/*CONSTCOND*/0)
+
+/*
+ * Singly-linked Tail queue access methods.
+ */
+#define	STAILQ_EMPTY(head)	((head)->stqh_first == NULL)
+#define	STAILQ_FIRST(head)	((head)->stqh_first)
+#define	STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
+
+
+/*
+ * Simple queue definitions.
+ */
+#define	SIMPLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *sqh_first;	/* first element */			\
+	struct type **sqh_last;	/* addr of last next element */		\
+}
+
+#define	SIMPLEQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).sqh_first }
+
+#define	SIMPLEQ_ENTRY(type)						\
+struct {								\
+	struct type *sqe_next;	/* next element */			\
+}
+
+/*
+ * Simple queue functions.
+ */
+#define	SIMPLEQ_INIT(head) do {						\
+	(head)->sqh_first = NULL;					\
+	(head)->sqh_last = &(head)->sqh_first;				\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.sqe_next = (head)->sqh_first) == NULL)	\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(head)->sqh_first = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.sqe_next = NULL;					\
+	*(head)->sqh_last = (elm);					\
+	(head)->sqh_last = &(elm)->field.sqe_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(listelm)->field.sqe_next = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_REMOVE_HEAD(head, field) do {				\
+	if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \
+		(head)->sqh_last = &(head)->sqh_first;			\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_REMOVE(head, elm, type, field) do {			\
+	if ((head)->sqh_first == (elm)) {				\
+		SIMPLEQ_REMOVE_HEAD((head), field);			\
+	} else {							\
+		struct type *curelm = (head)->sqh_first;		\
+		while (curelm->field.sqe_next != (elm))			\
+			curelm = curelm->field.sqe_next;		\
+		if ((curelm->field.sqe_next =				\
+			curelm->field.sqe_next->field.sqe_next) == NULL) \
+			    (head)->sqh_last = &(curelm)->field.sqe_next; \
+	}								\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_FOREACH(var, head, field)				\
+	for ((var) = ((head)->sqh_first);				\
+		(var);							\
+		(var) = ((var)->field.sqe_next))
+
+/*
+ * Simple queue access methods.
+ */
+#define	SIMPLEQ_EMPTY(head)		((head)->sqh_first == NULL)
+#define	SIMPLEQ_FIRST(head)		((head)->sqh_first)
+#define	SIMPLEQ_NEXT(elm, field)	((elm)->field.sqe_next)
+
+
+/*
+ * Tail queue definitions.
+ */
+#define	_TAILQ_HEAD(name, type, qual)					\
+struct name {								\
+	qual type *tqh_first;		/* first element */		\
+	qual type *qual *tqh_last;	/* addr of last next element */	\
+}
+#define TAILQ_HEAD(name, type)	_TAILQ_HEAD(name, struct type,)
+
+#define	TAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).tqh_first }
+
+#define	_TAILQ_ENTRY(type, qual)					\
+struct {								\
+	qual type *tqe_next;		/* next element */		\
+	qual type *qual *tqe_prev;	/* address of previous next element */\
+}
+#define TAILQ_ENTRY(type)	_TAILQ_ENTRY(struct type,)
+
+/*
+ * Tail queue functions.
+ */
+#define	TAILQ_INIT(head) do {						\
+	(head)->tqh_first = NULL;					\
+	(head)->tqh_last = &(head)->tqh_first;				\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
+		(head)->tqh_first->field.tqe_prev =			\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(head)->tqh_first = (elm);					\
+	(elm)->field.tqe_prev = &(head)->tqh_first;			\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.tqe_next = NULL;					\
+	(elm)->field.tqe_prev = (head)->tqh_last;			\
+	*(head)->tqh_last = (elm);					\
+	(head)->tqh_last = &(elm)->field.tqe_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
+		(elm)->field.tqe_next->field.tqe_prev = 		\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(listelm)->field.tqe_next = (elm);				\
+	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
+	(elm)->field.tqe_next = (listelm);				\
+	*(listelm)->field.tqe_prev = (elm);				\
+	(listelm)->field.tqe_prev = &(elm)->field.tqe_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_REMOVE(head, elm, field) do {				\
+	if (((elm)->field.tqe_next) != NULL)				\
+		(elm)->field.tqe_next->field.tqe_prev = 		\
+		    (elm)->field.tqe_prev;				\
+	else								\
+		(head)->tqh_last = (elm)->field.tqe_prev;		\
+	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_FOREACH(var, head, field)					\
+	for ((var) = ((head)->tqh_first);				\
+		(var);							\
+		(var) = ((var)->field.tqe_next))
+
+#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for ((var) = (*(((struct headname *)((head)->tqh_last))->tqh_last));	\
+		(var);							\
+		(var) = (*(((struct headname *)((var)->field.tqe_prev))->tqh_last)))
+
+#define	TAILQ_CONCAT(head1, head2, field) do {				\
+	if (!TAILQ_EMPTY(head2)) {					\
+		*(head1)->tqh_last = (head2)->tqh_first;		\
+		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
+		(head1)->tqh_last = (head2)->tqh_last;			\
+		TAILQ_INIT((head2));					\
+	}								\
+} while (/*CONSTCOND*/0)
+
+/*
+ * Tail queue access methods.
+ */
+#define	TAILQ_EMPTY(head)		((head)->tqh_first == NULL)
+#define	TAILQ_FIRST(head)		((head)->tqh_first)
+#define	TAILQ_NEXT(elm, field)		((elm)->field.tqe_next)
+
+#define	TAILQ_LAST(head, headname) \
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+#define	TAILQ_PREV(elm, headname, field) \
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+
+
+/*
+ * Circular queue definitions.
+ */
+#define	CIRCLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *cqh_first;		/* first element */		\
+	struct type *cqh_last;		/* last element */		\
+}
+
+#define	CIRCLEQ_HEAD_INITIALIZER(head)					\
+	{ (void *)&head, (void *)&head }
+
+#define	CIRCLEQ_ENTRY(type)						\
+struct {								\
+	struct type *cqe_next;		/* next element */		\
+	struct type *cqe_prev;		/* previous element */		\
+}
+
+/*
+ * Circular queue functions.
+ */
+#define	CIRCLEQ_INIT(head) do {						\
+	(head)->cqh_first = (void *)(head);				\
+	(head)->cqh_last = (void *)(head);				\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	(elm)->field.cqe_next = (listelm)->field.cqe_next;		\
+	(elm)->field.cqe_prev = (listelm);				\
+	if ((listelm)->field.cqe_next == (void *)(head))		\
+		(head)->cqh_last = (elm);				\
+	else								\
+		(listelm)->field.cqe_next->field.cqe_prev = (elm);	\
+	(listelm)->field.cqe_next = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\
+	(elm)->field.cqe_next = (listelm);				\
+	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;		\
+	if ((listelm)->field.cqe_prev == (void *)(head))		\
+		(head)->cqh_first = (elm);				\
+	else								\
+		(listelm)->field.cqe_prev->field.cqe_next = (elm);	\
+	(listelm)->field.cqe_prev = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_INSERT_HEAD(head, elm, field) do {			\
+	(elm)->field.cqe_next = (head)->cqh_first;			\
+	(elm)->field.cqe_prev = (void *)(head);				\
+	if ((head)->cqh_last == (void *)(head))				\
+		(head)->cqh_last = (elm);				\
+	else								\
+		(head)->cqh_first->field.cqe_prev = (elm);		\
+	(head)->cqh_first = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.cqe_next = (void *)(head);				\
+	(elm)->field.cqe_prev = (head)->cqh_last;			\
+	if ((head)->cqh_first == (void *)(head))			\
+		(head)->cqh_first = (elm);				\
+	else								\
+		(head)->cqh_last->field.cqe_next = (elm);		\
+	(head)->cqh_last = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_REMOVE(head, elm, field) do {				\
+	if ((elm)->field.cqe_next == (void *)(head))			\
+		(head)->cqh_last = (elm)->field.cqe_prev;		\
+	else								\
+		(elm)->field.cqe_next->field.cqe_prev =			\
+		    (elm)->field.cqe_prev;				\
+	if ((elm)->field.cqe_prev == (void *)(head))			\
+		(head)->cqh_first = (elm)->field.cqe_next;		\
+	else								\
+		(elm)->field.cqe_prev->field.cqe_next =			\
+		    (elm)->field.cqe_next;				\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_FOREACH(var, head, field)				\
+	for ((var) = ((head)->cqh_first);				\
+		(var) != (const void *)(head);				\
+		(var) = ((var)->field.cqe_next))
+
+#define	CIRCLEQ_FOREACH_REVERSE(var, head, field)			\
+	for ((var) = ((head)->cqh_last);				\
+		(var) != (const void *)(head);				\
+		(var) = ((var)->field.cqe_prev))
+
+/*
+ * Circular queue access methods.
+ */
+#define	CIRCLEQ_EMPTY(head)		((head)->cqh_first == (void *)(head))
+#define	CIRCLEQ_FIRST(head)		((head)->cqh_first)
+#define	CIRCLEQ_LAST(head)		((head)->cqh_last)
+#define	CIRCLEQ_NEXT(elm, field)	((elm)->field.cqe_next)
+#define	CIRCLEQ_PREV(elm, field)	((elm)->field.cqe_prev)
+
+#define CIRCLEQ_LOOP_NEXT(head, elm, field)				\
+	(((elm)->field.cqe_next == (void *)(head))			\
+	    ? ((head)->cqh_first)					\
+	    : (elm->field.cqe_next))
+#define CIRCLEQ_LOOP_PREV(head, elm, field)				\
+	(((elm)->field.cqe_prev == (void *)(head))			\
+	    ? ((head)->cqh_last)					\
+	    : (elm->field.cqe_prev))
+
+#endif	/* sys/queue.h */
diff --git a/include/sys/reboot.h b/include/sys/reboot.h
new file mode 100644
index 0000000..fc73089
--- /dev/null
+++ b/include/sys/reboot.h
@@ -0,0 +1,171 @@
+/*
+ * Mach Operating System
+ * Copyright (C) 1993,1991,1990 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ *
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ *
+ * Carnegie Mellon requests users of this software to return to
+ *
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ *
+ * any improvements or extensions that they make and grant Carnegie Mellon
+ * the rights to redistribute these changes.
+ */
+/*
+ * (pre-GNU) HISTORY
+ *
+ * Revision 2.8  93/03/11  13:46:40  danner
+ * 	u_long -> u_int.
+ * 	[93/03/09            danner]
+ *
+ * Revision 2.7  92/05/21  17:25:11  jfriedl
+ * 	Appended 'U' to constants that would otherwise be signed.
+ * 	[92/05/16            jfriedl]
+ *
+ * Revision 2.6  91/06/19  11:59:44  rvb
+ * 	Second byte of boothowto is flags for "startup" program.
+ * 	[91/06/18            rvb]
+ * 	Add ifndef __ASSEMBLER__ so that vax_init.s can include it.
+ * 	[91/06/11            rvb]
+ *
+ * Revision 2.5  91/05/14  17:40:11  mrt
+ * 	Correcting copyright
+ *
+ * Revision 2.4  91/02/05  17:56:48  mrt
+ * 	Changed to new Mach copyright
+ * 	[91/02/01  17:49:12  mrt]
+ *
+ * Revision 2.3  90/08/27  22:12:56  dbg
+ * 	Added definitions used by Mach Kernel: RB_DEBUGGER, RB_UNIPROC,
+ * 	RB_NOBOOTRC, RB_ALTBOOT.  Moved RB_KDB to 0x04 (Mach value).
+ * 	Removed RB_RDONLY, RB_DUMP, RB_NOSYNC.
+ * 	[90/08/14            dbg]
+ *
+ */
+
+/*
+   Copyright (C) 1982, 1986, 1988 Regents of the University of California.
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+   4. Neither the name of the University nor the names of its contributors
+      may be used to endorse or promote products derived from this software
+      without specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.*/
+
+/*
+ *	@(#)reboot.h	7.5 (Berkeley) 6/27/88
+ */
+
+#ifndef	_SYS_REBOOT_H_
+#define	_SYS_REBOOT_H_
+
+#include <features.h>
+
+/*
+ * Arguments to reboot system call.
+ * These are converted to switches, and passed to startup program,
+ * and on to init.
+ */
+#define	RB_AUTOBOOT	0	/* flags for system auto-booting itself */
+
+#define	RB_ASKNAME	0x01	/* -a: ask for file name to reboot from */
+#define	RB_SINGLE	0x02	/* -s: reboot to single user only */
+#define	RB_KDB		0x04	/* -d: kernel debugger symbols loaded */
+#define	RB_HALT		0x08	/* -h: enter KDB at bootup */
+				/*     for host_reboot(): don't reboot,
+				       just halt */
+#define	RB_INITNAME	0x10	/* -i: name given for /etc/init (unused) */
+#define	RB_DFLTROOT	0x20	/*     use compiled-in rootdev */
+#define	RB_NOBOOTRC	0x20	/* -b: don't run /etc/rc.boot */
+#define RB_ALTBOOT	0x40	/*     use /boot.old vs /boot */
+#define	RB_UNIPROC	0x80	/* -u: start only one processor */
+
+#define	RB_SHIFT	8	/* second byte is for ux */
+
+#define	RB_DEBUGGER	0x1000	/*     for host_reboot(): enter kernel
+				       debugger from user level */
+
+/*
+ * Constants for converting boot-style device number to type,
+ * adaptor (uba, mba, etc), unit number and partition number.
+ * Type (== major device number) is in the low byte
+ * for backward compatibility.  Except for that of the "magic
+ * number", each mask applies to the shifted value.
+ * Format:
+ *	 (4) (4) (4) (4)  (8)     (8)
+ *	--------------------------------
+ *	|MA | AD| CT| UN| PART  | TYPE |
+ *	--------------------------------
+ */
+#define	B_ADAPTORSHIFT		24
+#define	B_ADAPTORMASK		0x0f
+#define	B_ADAPTOR(val)		(((val) >> B_ADAPTORSHIFT) & B_ADAPTORMASK)
+#define B_CONTROLLERSHIFT	20
+#define B_CONTROLLERMASK	0xf
+#define	B_CONTROLLER(val)	(((val)>>B_CONTROLLERSHIFT) & B_CONTROLLERMASK)
+#define B_UNITSHIFT		16
+#define B_UNITMASK		0xf
+#define	B_UNIT(val)		(((val) >> B_UNITSHIFT) & B_UNITMASK)
+#define B_PARTITIONSHIFT	8
+#define B_PARTITIONMASK		0xff
+#define	B_PARTITION(val)	(((val) >> B_PARTITIONSHIFT) & B_PARTITIONMASK)
+#define	B_TYPESHIFT		0
+#define	B_TYPEMASK		0xff
+#define	B_TYPE(val)		(((val) >> B_TYPESHIFT) & B_TYPEMASK)
+
+#define	B_MAGICMASK	((u_int)0xf0000000U)
+#define	B_DEVMAGIC	((u_int)0xa0000000U)
+
+#define MAKEBOOTDEV(type, adaptor, controller, unit, partition) \
+	(((type) << B_TYPESHIFT) | ((adaptor) << B_ADAPTORSHIFT) | \
+	((controller) << B_CONTROLLERSHIFT) | ((unit) << B_UNITSHIFT) | \
+	((partition) << B_PARTITIONSHIFT) | B_DEVMAGIC)
+
+
+#ifdef	KERNEL
+#ifndef	__ASSEMBLER__
+extern int boothowto;
+#endif	/* __ASSEMBLER__ */
+#endif
+
+__BEGIN_DECLS
+
+/* Reboot or halt the system.  */
+extern int reboot (int __howto) __THROW;
+
+__END_DECLS
+
+
+#endif	/* _SYS_REBOOT_H_ */
diff --git a/include/sys/resource.h b/include/sys/resource.h
new file mode 100644
index 0000000..1da04c5
--- /dev/null
+++ b/include/sys/resource.h
@@ -0,0 +1,102 @@
+/* Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_RESOURCE_H
+#define	_SYS_RESOURCE_H	1
+
+#include <features.h>
+
+/* Get the system-dependent definitions of structures and bit values.  */
+#include <bits/resource.h>
+
+#ifndef __id_t_defined
+typedef __id_t id_t;
+# define __id_t_defined
+#endif
+
+__BEGIN_DECLS
+
+/* The X/Open standard defines that all the functions below must use
+   `int' as the type for the first argument.  When we are compiling with
+   GNU extensions we change this slightly to provide better error
+   checking.  */
+#if defined __USE_GNU && !defined __cplusplus
+typedef enum __rlimit_resource __rlimit_resource_t;
+typedef enum __rusage_who __rusage_who_t;
+typedef enum __priority_which __priority_which_t;
+#else
+typedef int __rlimit_resource_t;
+typedef int __rusage_who_t;
+typedef int __priority_which_t;
+#endif
+
+/* Put the soft and hard limits for RESOURCE in *RLIMITS.
+   Returns 0 if successful, -1 if not (and sets errno).  */
+#ifndef __USE_FILE_OFFSET64
+extern int getrlimit (__rlimit_resource_t __resource,
+		      struct rlimit *__rlimits) __THROW;
+#else
+# ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (getrlimit, (__rlimit_resource_t __resource,
+				       struct rlimit *__rlimits), getrlimit64);
+# else
+#  define getrlimit getrlimit64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int getrlimit64 (__rlimit_resource_t __resource,
+			struct rlimit64 *__rlimits) __THROW;
+#endif
+
+/* Set the soft and hard limits for RESOURCE to *RLIMITS.
+   Only the super-user can increase hard limits.
+   Return 0 if successful, -1 if not (and sets errno).  */
+#ifndef __USE_FILE_OFFSET64
+extern int setrlimit (__rlimit_resource_t __resource,
+		      const struct rlimit *__rlimits) __THROW;
+#else
+# ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (setrlimit, (__rlimit_resource_t __resource,
+				       const struct rlimit *__rlimits),
+			   setrlimit64);
+# else
+#  define setrlimit setrlimit64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int setrlimit64 (__rlimit_resource_t __resource,
+			const struct rlimit64 *__rlimits) __THROW;
+#endif
+
+/* Return resource usage information on process indicated by WHO
+   and put it in *USAGE.  Returns 0 for success, -1 for failure.  */
+extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __THROW;
+
+/* Return the highest priority of any process specified by WHICH and WHO
+   (see above); if WHO is zero, the current process, process group, or user
+   (as specified by WHO) is used.  A lower priority number means higher
+   priority.  Priorities range from PRIO_MIN to PRIO_MAX (above).  */
+extern int getpriority (__priority_which_t __which, id_t __who) __THROW;
+
+/* Set the priority of all processes specified by WHICH and WHO (see above)
+   to PRIO.  Returns 0 on success, -1 on errors.  */
+extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
+     __THROW;
+
+__END_DECLS
+
+#endif	/* sys/resource.h  */
diff --git a/include/sys/select.h b/include/sys/select.h
new file mode 100644
index 0000000..fd13bab
--- /dev/null
+++ b/include/sys/select.h
@@ -0,0 +1,133 @@
+/* `fd_set' type and related macros, and `select'/`pselect' declarations.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */
+
+#ifndef _SYS_SELECT_H
+#define _SYS_SELECT_H	1
+
+#include <features.h>
+
+/* Get definition of needed basic types.  */
+#include <bits/types.h>
+
+/* Get __FD_* definitions.  */
+#include <bits/select.h>
+
+/* Get __sigset_t.  */
+#include <bits/sigset.h>
+
+#ifndef __sigset_t_defined
+# define __sigset_t_defined
+typedef __sigset_t sigset_t;
+#endif
+
+/* Get definition of timer specification structures.  */
+#define __need_time_t
+#define __need_timespec
+#include <time.h>
+#define __need_timeval
+#include <bits/time.h>
+
+#ifndef __suseconds_t_defined
+typedef __suseconds_t suseconds_t;
+# define __suseconds_t_defined
+#endif
+
+
+/* The fd_set member is required to be an array of longs.  */
+typedef long int __fd_mask;
+
+/* Some versions of <linux/posix_types.h> define this macros.  */
+#undef	__NFDBITS
+/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
+#define __NFDBITS	(8 * (int) sizeof (__fd_mask))
+#define	__FD_ELT(d)	((d) / __NFDBITS)
+#define	__FD_MASK(d)	((__fd_mask) 1 << ((d) % __NFDBITS))
+
+/* fd_set for select and pselect.  */
+typedef struct
+  {
+    /* XPG4.2 requires this member name.  Otherwise avoid the name
+       from the global namespace.  */
+#ifdef __USE_XOPEN
+    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
+# define __FDS_BITS(set) ((set)->fds_bits)
+#else
+    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
+# define __FDS_BITS(set) ((set)->__fds_bits)
+#endif
+  } fd_set;
+
+/* Maximum number of file descriptors in `fd_set'.  */
+#define	FD_SETSIZE		__FD_SETSIZE
+
+#ifdef __USE_MISC
+/* Sometimes the fd_set member is assumed to have this type.  */
+typedef __fd_mask fd_mask;
+
+/* Number of bits per word of `fd_set' (some code assumes this is 32).  */
+# define NFDBITS		__NFDBITS
+#endif
+
+
+/* Access macros for `fd_set'.  */
+#define	FD_SET(fd, fdsetp)	__FD_SET (fd, fdsetp)
+#define	FD_CLR(fd, fdsetp)	__FD_CLR (fd, fdsetp)
+#define	FD_ISSET(fd, fdsetp)	__FD_ISSET (fd, fdsetp)
+#define	FD_ZERO(fdsetp)		__FD_ZERO (fdsetp)
+
+
+__BEGIN_DECLS
+
+/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
+   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
+   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
+   after waiting the interval specified therein.  Returns the number of ready
+   descriptors, or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int select (int __nfds, fd_set *__restrict __readfds,
+		   fd_set *__restrict __writefds,
+		   fd_set *__restrict __exceptfds,
+		   struct timeval *__restrict __timeout);
+
+#ifdef __USE_XOPEN2K
+/* Same as above only that the TIMEOUT value is given with higher
+   resolution and a sigmask which is been set temporarily.  This version
+   should be used.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int pselect (int __nfds, fd_set *__restrict __readfds,
+		    fd_set *__restrict __writefds,
+		    fd_set *__restrict __exceptfds,
+		    const struct timespec *__restrict __timeout,
+		    const __sigset_t *__restrict __sigmask);
+#endif
+
+
+/* Define some inlines helping to catch common problems.  */
+#if __USE_FORTIFY_LEVEL > 0 && defined __GNUC__
+# include <bits/select2.h>
+#endif
+
+__END_DECLS
+
+#endif /* sys/select.h */
diff --git a/include/sys/sem.h b/include/sys/sem.h
new file mode 100644
index 0000000..1f43a3a
--- /dev/null
+++ b/include/sys/sem.h
@@ -0,0 +1,68 @@
+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SEM_H
+#define _SYS_SEM_H	1
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+/* Get common definition of System V style IPC.  */
+#include <sys/ipc.h>
+
+/* Get system dependent definition of `struct semid_ds' and more.  */
+#include <bits/sem.h>
+
+#ifdef __USE_GNU
+# define __need_timespec
+# include <time.h>
+#endif
+
+/* The following System V style IPC functions implement a semaphore
+   handling.  The definition is found in XPG2.  */
+
+/* Structure used for argument to `semop' to describe operations.  */
+struct sembuf
+{
+  unsigned short int sem_num;	/* semaphore number */
+  short int sem_op;		/* semaphore operation */
+  short int sem_flg;		/* operation flag */
+};
+
+
+__BEGIN_DECLS
+
+/* Semaphore control operation.  */
+extern int semctl (int __semid, int __semnum, int __cmd, ...) __THROW;
+
+/* Get semaphore.  */
+extern int semget (key_t __key, int __nsems, int __semflg) __THROW;
+
+/* Operate on semaphore.  */
+extern int semop (int __semid, struct sembuf *__sops, size_t __nsops) __THROW;
+
+#ifdef __USE_GNU
+/* Operate on semaphore with timeout.  */
+extern int semtimedop (int __semid, struct sembuf *__sops, size_t __nsops,
+		       const struct timespec *__timeout) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* sys/sem.h */
diff --git a/include/sys/sendfile.h b/include/sys/sendfile.h
new file mode 100644
index 0000000..3cccab6
--- /dev/null
+++ b/include/sys/sendfile.h
@@ -0,0 +1,51 @@
+/* sendfile -- copy data directly from one file descriptor to another
+   Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SENDFILE_H
+#define _SYS_SENDFILE_H	1
+
+#include <features.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+/* Send up to COUNT bytes from file associated with IN_FD starting at
+   *OFFSET to descriptor OUT_FD.  Set *OFFSET to the IN_FD's file position
+   following the read bytes.  If OFFSET is a null pointer, use the normal
+   file position instead.  Return the number of written bytes, or -1 in
+   case of error.  */
+#ifndef __USE_FILE_OFFSET64
+extern ssize_t sendfile (int __out_fd, int __in_fd, off_t *__offset,
+			 size_t __count) __THROW;
+#else
+# ifdef __REDIRECT_NTH
+extern ssize_t __REDIRECT_NTH (sendfile,
+			       (int __out_fd, int __in_fd, __off64_t *__offset,
+				size_t __count), sendfile64);
+# else
+#  define sendfile sendfile64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern ssize_t sendfile64 (int __out_fd, int __in_fd, __off64_t *__offset,
+			   size_t __count) __THROW;
+#endif
+
+__END_DECLS
+
+#endif	/* sys/sendfile.h */
diff --git a/include/sys/shm.h b/include/sys/shm.h
new file mode 100644
index 0000000..fa2a7a5
--- /dev/null
+++ b/include/sys/shm.h
@@ -0,0 +1,64 @@
+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SHM_H
+#define _SYS_SHM_H	1
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+/* Get common definition of System V style IPC.  */
+#include <sys/ipc.h>
+
+/* Get system dependent definition of `struct shmid_ds' and more.  */
+#include <bits/shm.h>
+
+/* Define types required by the standard.  */
+#define __need_time_t
+#include <time.h>
+
+#ifdef __USE_XOPEN
+# ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#  define __pid_t_defined
+# endif
+#endif	/* X/Open */
+
+
+__BEGIN_DECLS
+
+/* The following System V style IPC functions implement a shared memory
+   facility.  The definition is found in XPG4.2.  */
+
+/* Shared memory control operation.  */
+extern int shmctl (int __shmid, int __cmd, struct shmid_ds *__buf) __THROW;
+
+/* Get shared memory segment.  */
+extern int shmget (key_t __key, size_t __size, int __shmflg) __THROW;
+
+/* Attach shared memory segment.  */
+extern void *shmat (int __shmid, const void *__shmaddr, int __shmflg)
+     __THROW;
+
+/* Detach shared memory segment.  */
+extern int shmdt (const void *__shmaddr) __THROW;
+
+__END_DECLS
+
+#endif /* sys/shm.h */
diff --git a/include/sys/signal.h b/include/sys/signal.h
new file mode 100644
index 0000000..2e602da
--- /dev/null
+++ b/include/sys/signal.h
@@ -0,0 +1 @@
+#include <signal.h>
diff --git a/include/sys/socket.h b/include/sys/socket.h
new file mode 100644
index 0000000..10e17d3
--- /dev/null
+++ b/include/sys/socket.h
@@ -0,0 +1,285 @@
+/* Declarations of socket constants, types, and functions.
+   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_SOCKET_H
+#define	_SYS_SOCKET_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <sys/uio.h>
+#define	__need_size_t
+#include <stddef.h>
+#ifdef __USE_GNU
+/* Get the __sigset_t definition.  */
+# include <bits/sigset.h>
+#endif
+
+
+/* This operating system-specific header file defines the SOCK_*, PF_*,
+   AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr',
+   `struct msghdr', and `struct linger' types.  */
+#include <bits/socket.h>
+
+#ifdef __USE_BSD
+/* This is the 4.3 BSD `struct sockaddr' format, which is used as wire
+   format in the grotty old 4.3 `talk' protocol.  */
+struct osockaddr
+  {
+    unsigned short int sa_family;
+    unsigned char sa_data[14];
+  };
+#endif
+
+/* The following constants should be used for the second parameter of
+   `shutdown'.  */
+enum
+{
+  SHUT_RD = 0,		/* No more receptions.  */
+#define SHUT_RD		SHUT_RD
+  SHUT_WR,		/* No more transmissions.  */
+#define SHUT_WR		SHUT_WR
+  SHUT_RDWR		/* No more receptions or transmissions.  */
+#define SHUT_RDWR	SHUT_RDWR
+};
+
+/* This is the type we use for generic socket address arguments.
+
+   With GCC 2.7 and later, the funky union causes redeclarations or
+   uses with any of the listed types to be allowed without complaint.
+   G++ 2.7 does not support transparent unions so there we want the
+   old-style declaration, too.  */
+#if defined __cplusplus || !__GNUC_PREREQ (2, 7) || !defined __USE_GNU
+# define __SOCKADDR_ARG		struct sockaddr *__restrict
+# define __CONST_SOCKADDR_ARG	const struct sockaddr *
+#else
+/* Add more `struct sockaddr_AF' types here as necessary.
+   These are all the ones I found on NetBSD and Linux.  */
+# define __SOCKADDR_ALLTYPES \
+  __SOCKADDR_ONETYPE (sockaddr) \
+  __SOCKADDR_ONETYPE (sockaddr_at) \
+  __SOCKADDR_ONETYPE (sockaddr_ax25) \
+  __SOCKADDR_ONETYPE (sockaddr_dl) \
+  __SOCKADDR_ONETYPE (sockaddr_eon) \
+  __SOCKADDR_ONETYPE (sockaddr_in) \
+  __SOCKADDR_ONETYPE (sockaddr_in6) \
+  __SOCKADDR_ONETYPE (sockaddr_inarp) \
+  __SOCKADDR_ONETYPE (sockaddr_ipx) \
+  __SOCKADDR_ONETYPE (sockaddr_iso) \
+  __SOCKADDR_ONETYPE (sockaddr_ns) \
+  __SOCKADDR_ONETYPE (sockaddr_un) \
+  __SOCKADDR_ONETYPE (sockaddr_x25)
+
+# define __SOCKADDR_ONETYPE(type) struct type *__restrict __##type##__;
+typedef union { __SOCKADDR_ALLTYPES
+	      } __SOCKADDR_ARG __attribute__ ((__transparent_union__));
+# undef __SOCKADDR_ONETYPE
+# define __SOCKADDR_ONETYPE(type) const struct type *__restrict __##type##__;
+typedef union { __SOCKADDR_ALLTYPES
+	      } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));
+# undef __SOCKADDR_ONETYPE
+#endif
+
+#ifdef __USE_GNU
+/* For `recvmmsg' and `sendmmsg'.  */
+struct mmsghdr
+  {
+    struct msghdr msg_hdr;	/* Actual message header.  */
+    unsigned int msg_len;	/* Number of received or sent bytes for the
+				   entry.  */
+  };
+#endif
+
+
+/* Create a new socket of type TYPE in domain DOMAIN, using
+   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
+   Returns a file descriptor for the new socket, or -1 for errors.  */
+extern int socket (int __domain, int __type, int __protocol) __THROW;
+
+/* Create two new sockets, of type TYPE in domain DOMAIN and using
+   protocol PROTOCOL, which are connected to each other, and put file
+   descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,
+   one will be chosen automatically.  Returns 0 on success, -1 for errors.  */
+extern int socketpair (int __domain, int __type, int __protocol,
+		       int __fds[2]) __THROW;
+
+/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
+extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
+     __THROW;
+
+/* Put the local address of FD into *ADDR and its length in *LEN.  */
+extern int getsockname (int __fd, __SOCKADDR_ARG __addr,
+			socklen_t *__restrict __len) __THROW;
+
+/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
+   For connectionless socket types, just set the default address to send to
+   and the only address from which to accept transmissions.
+   Return 0 on success, -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);
+
+/* Put the address of the peer connected to socket FD into *ADDR
+   (which is *LEN bytes long), and its actual length into *LEN.  */
+extern int getpeername (int __fd, __SOCKADDR_ARG __addr,
+			socklen_t *__restrict __len) __THROW;
+
+
+/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);
+
+/* Read N bytes into BUF from socket FD.
+   Returns the number read or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);
+
+/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
+   ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
+		       int __flags, __CONST_SOCKADDR_ARG __addr,
+		       socklen_t __addr_len);
+
+/* Read N bytes into BUF through socket FD.
+   If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of
+   the sender, and store the actual size of the address in *ADDR_LEN.
+   Returns the number of bytes read or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
+			 int __flags, __SOCKADDR_ARG __addr,
+			 socklen_t *__restrict __addr_len);
+
+
+/* Send a message described MESSAGE on socket FD.
+   Returns the number of bytes sent, or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
+			int __flags);
+
+#ifdef __USE_GNU
+/* Send a VLEN messages as described by VMESSAGES to socket FD.
+   Returns the number of datagrams successfully written or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
+		     unsigned int __vlen, int __flags);
+#endif
+
+/* Receive a message as described by MESSAGE from socket FD.
+   Returns the number of bytes read or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);
+
+#ifdef __USE_GNU
+/* Receive up to VLEN messages as described by VMESSAGES from socket FD.
+   Returns the number of bytes read or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
+		     unsigned int __vlen, int __flags,
+		     const struct timespec *__tmo);
+#endif
+
+
+/* Put the current value for socket FD's option OPTNAME at protocol level LEVEL
+   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's
+   actual length.  Returns 0 on success, -1 for errors.  */
+extern int getsockopt (int __fd, int __level, int __optname,
+		       void *__restrict __optval,
+		       socklen_t *__restrict __optlen) __THROW;
+
+/* Set socket FD's option OPTNAME at protocol level LEVEL
+   to *OPTVAL (which is OPTLEN bytes long).
+   Returns 0 on success, -1 for errors.  */
+extern int setsockopt (int __fd, int __level, int __optname,
+		       const void *__optval, socklen_t __optlen) __THROW;
+
+
+/* Prepare to accept connections on socket FD.
+   N connection requests will be queued before further requests are refused.
+   Returns 0 on success, -1 for errors.  */
+extern int listen (int __fd, int __n) __THROW;
+
+/* Await a connection on socket FD.
+   When a connection arrives, open a new socket to communicate with it,
+   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
+   peer and *ADDR_LEN to the address's actual length, and return the
+   new socket's descriptor, or -1 for errors.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int accept (int __fd, __SOCKADDR_ARG __addr,
+		   socklen_t *__restrict __addr_len);
+
+#ifdef __USE_GNU
+/* Similar to 'accept' but takes an additional parameter to specify flags.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int accept4 (int __fd, __SOCKADDR_ARG __addr,
+		    socklen_t *__restrict __addr_len, int __flags);
+#endif
+
+/* Shut down all or part of the connection open on socket FD.
+   HOW determines what to shut down:
+     SHUT_RD   = No more receptions;
+     SHUT_WR   = No more transmissions;
+     SHUT_RDWR = No more receptions or transmissions.
+   Returns 0 on success, -1 for errors.  */
+extern int shutdown (int __fd, int __how) __THROW;
+
+
+#ifdef __USE_XOPEN2K
+/* Determine wheter socket is at a out-of-band mark.  */
+extern int sockatmark (int __fd) __THROW;
+#endif
+
+
+#ifdef __USE_MISC
+/* FDTYPE is S_IFSOCK or another S_IF* macro defined in <sys/stat.h>;
+   returns 1 if FD is open on an object of the indicated type, 0 if not,
+   or -1 for errors (setting errno).  */
+extern int isfdtype (int __fd, int __fdtype) __THROW;
+#endif
+
+
+/* Define some macros helping to catch buffer overflows.  */
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+# include <bits/socket2.h>
+#endif
+
+__END_DECLS
+
+#endif /* sys/socket.h */
diff --git a/include/sys/socketvar.h b/include/sys/socketvar.h
new file mode 100644
index 0000000..b177158
--- /dev/null
+++ b/include/sys/socketvar.h
@@ -0,0 +1,3 @@
+/* This header is used on many systems but for GNU we have everything
+   already defined in the standard header.  */
+#include <sys/socket.h>
diff --git a/include/sys/stat.h b/include/sys/stat.h
new file mode 100644
index 0000000..63e64dd
--- /dev/null
+++ b/include/sys/stat.h
@@ -0,0 +1,537 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 5.6 File Characteristics	<sys/stat.h>
+ */
+
+#ifndef	_SYS_STAT_H
+#define	_SYS_STAT_H	1
+
+#include <features.h>
+
+#include <bits/types.h>		/* For __mode_t and __dev_t.  */
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K || defined __USE_MISC \
+	 || defined __USE_ATFILE
+# if defined __USE_XOPEN || defined __USE_XOPEN2K
+#  define __need_time_t
+# endif
+# if defined __USE_MISC || defined __USE_ATFILE
+#  define __need_timespec
+# endif
+# include <time.h>		/* For time_t resp. timespec.  */
+#endif
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K
+/* The Single Unix specification says that some more types are
+   available here.  */
+# ifndef __dev_t_defined
+typedef __dev_t dev_t;
+#  define __dev_t_defined
+# endif
+
+# ifndef __gid_t_defined
+typedef __gid_t gid_t;
+#  define __gid_t_defined
+# endif
+
+# ifndef __ino_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __ino_t ino_t;
+#  else
+typedef __ino64_t ino_t;
+#  endif
+#  define __ino_t_defined
+# endif
+
+# ifndef __mode_t_defined
+typedef __mode_t mode_t;
+#  define __mode_t_defined
+# endif
+
+# ifndef __nlink_t_defined
+typedef __nlink_t nlink_t;
+#  define __nlink_t_defined
+# endif
+
+# ifndef __off_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+#  else
+typedef __off64_t off_t;
+#  endif
+#  define __off_t_defined
+# endif
+
+# ifndef __uid_t_defined
+typedef __uid_t uid_t;
+#  define __uid_t_defined
+# endif
+#endif	/* X/Open */
+
+#ifdef __USE_UNIX98
+# ifndef __blkcnt_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __blkcnt_t blkcnt_t;
+#  else
+typedef __blkcnt64_t blkcnt_t;
+#  endif
+#  define __blkcnt_t_defined
+# endif
+
+# ifndef __blksize_t_defined
+typedef __blksize_t blksize_t;
+#  define __blksize_t_defined
+# endif
+#endif	/* Unix98 */
+
+__BEGIN_DECLS
+
+#include <bits/stat.h>
+
+#if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
+# define S_IFMT		__S_IFMT
+# define S_IFDIR	__S_IFDIR
+# define S_IFCHR	__S_IFCHR
+# define S_IFBLK	__S_IFBLK
+# define S_IFREG	__S_IFREG
+# ifdef __S_IFIFO
+#  define S_IFIFO	__S_IFIFO
+# endif
+# ifdef __S_IFLNK
+#  define S_IFLNK	__S_IFLNK
+# endif
+# if (defined __USE_BSD || defined __USE_MISC || defined __USE_UNIX98) \
+     && defined __S_IFSOCK
+#  define S_IFSOCK	__S_IFSOCK
+# endif
+#endif
+
+/* Test macros for file types.	*/
+
+#define	__S_ISTYPE(mode, mask)	(((mode) & __S_IFMT) == (mask))
+
+#define	S_ISDIR(mode)	 __S_ISTYPE((mode), __S_IFDIR)
+#define	S_ISCHR(mode)	 __S_ISTYPE((mode), __S_IFCHR)
+#define	S_ISBLK(mode)	 __S_ISTYPE((mode), __S_IFBLK)
+#define	S_ISREG(mode)	 __S_ISTYPE((mode), __S_IFREG)
+#ifdef __S_IFIFO
+# define S_ISFIFO(mode)	 __S_ISTYPE((mode), __S_IFIFO)
+#endif
+#ifdef __S_IFLNK
+# define S_ISLNK(mode)	 __S_ISTYPE((mode), __S_IFLNK)
+#endif
+
+#if defined __USE_BSD && !defined __S_IFLNK
+# define S_ISLNK(mode)  0
+#endif
+
+#if (defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K) \
+    && defined __S_IFSOCK
+# define S_ISSOCK(mode) __S_ISTYPE((mode), __S_IFSOCK)
+#elif defined __USE_XOPEN2K
+# define S_ISSOCK(mode) 0
+#endif
+
+/* These are from POSIX.1b.  If the objects are not implemented using separate
+   distinct file types, the macros always will evaluate to zero.  Unlike the
+   other S_* macros the following three take a pointer to a `struct stat'
+   object as the argument.  */
+#ifdef	__USE_POSIX199309
+# define S_TYPEISMQ(buf) __S_TYPEISMQ(buf)
+# define S_TYPEISSEM(buf) __S_TYPEISSEM(buf)
+# define S_TYPEISSHM(buf) __S_TYPEISSHM(buf)
+#endif
+
+
+/* Protection bits.  */
+
+#define	S_ISUID __S_ISUID	/* Set user ID on execution.  */
+#define	S_ISGID	__S_ISGID	/* Set group ID on execution.  */
+
+#if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
+/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */
+# define S_ISVTX	__S_ISVTX
+#endif
+
+#define	S_IRUSR	__S_IREAD	/* Read by owner.  */
+#define	S_IWUSR	__S_IWRITE	/* Write by owner.  */
+#define	S_IXUSR	__S_IEXEC	/* Execute by owner.  */
+/* Read, write, and execute by owner.  */
+#define	S_IRWXU	(__S_IREAD|__S_IWRITE|__S_IEXEC)
+
+#if defined __USE_MISC && defined __USE_BSD
+# define S_IREAD	S_IRUSR
+# define S_IWRITE	S_IWUSR
+# define S_IEXEC	S_IXUSR
+#endif
+
+#define	S_IRGRP	(S_IRUSR >> 3)	/* Read by group.  */
+#define	S_IWGRP	(S_IWUSR >> 3)	/* Write by group.  */
+#define	S_IXGRP	(S_IXUSR >> 3)	/* Execute by group.  */
+/* Read, write, and execute by group.  */
+#define	S_IRWXG	(S_IRWXU >> 3)
+
+#define	S_IROTH	(S_IRGRP >> 3)	/* Read by others.  */
+#define	S_IWOTH	(S_IWGRP >> 3)	/* Write by others.  */
+#define	S_IXOTH	(S_IXGRP >> 3)	/* Execute by others.  */
+/* Read, write, and execute by others.  */
+#define	S_IRWXO	(S_IRWXG >> 3)
+
+
+#ifdef	__USE_BSD
+/* Macros for common mode bit masks.  */
+# define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO) /* 0777 */
+# define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)/* 07777 */
+# define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)/* 0666*/
+
+# define S_BLKSIZE	512	/* Block size for `st_blocks'.  */
+#endif
+
+
+#ifndef __USE_FILE_OFFSET64
+/* Get file attributes for FILE and put them in BUF.  */
+extern int stat (const char *__restrict __file,
+		 struct stat *__restrict __buf) __THROW __nonnull ((1, 2));
+
+/* Get file attributes for the file, device, pipe, or socket
+   that file descriptor FD is open on and put them in BUF.  */
+extern int fstat (int __fd, struct stat *__buf) __THROW __nonnull ((2));
+#else
+# ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (stat, (const char *__restrict __file,
+				  struct stat *__restrict __buf), stat64)
+     __nonnull ((1, 2));
+extern int __REDIRECT_NTH (fstat, (int __fd, struct stat *__buf), fstat64)
+     __nonnull ((2));
+# else
+#  define stat stat64
+#  define fstat fstat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int stat64 (const char *__restrict __file,
+		   struct stat64 *__restrict __buf) __THROW __nonnull ((1, 2));
+extern int fstat64 (int __fd, struct stat64 *__buf) __THROW __nonnull ((2));
+#endif
+
+#ifdef __USE_ATFILE
+/* Similar to stat, get the attributes for FILE and put them in BUF.
+   Relative path names are interpreted relative to FD unless FD is
+   AT_FDCWD.  */
+# ifndef __USE_FILE_OFFSET64
+extern int fstatat (int __fd, const char *__restrict __file,
+		    struct stat *__restrict __buf, int __flag)
+     __THROW __nonnull ((2, 3));
+# else
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (fstatat, (int __fd, const char *__restrict __file,
+				     struct stat *__restrict __buf,
+				     int __flag),
+			   fstatat64) __nonnull ((2, 3));
+#  else
+#   define fstatat fstatat64
+#  endif
+# endif
+
+# ifdef __USE_LARGEFILE64
+extern int fstatat64 (int __fd, const char *__restrict __file,
+		      struct stat64 *__restrict __buf, int __flag)
+     __THROW __nonnull ((2, 3));
+# endif
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K
+# ifndef __USE_FILE_OFFSET64
+/* Get file attributes about FILE and put them in BUF.
+   If FILE is a symbolic link, do not follow it.  */
+extern int lstat (const char *__restrict __file,
+		  struct stat *__restrict __buf) __THROW __nonnull ((1, 2));
+# else
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (lstat,
+			   (const char *__restrict __file,
+			    struct stat *__restrict __buf), lstat64)
+     __nonnull ((1, 2));
+#  else
+#   define lstat lstat64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int lstat64 (const char *__restrict __file,
+		    struct stat64 *__restrict __buf)
+     __THROW __nonnull ((1, 2));
+# endif
+#endif
+
+/* Set file access permissions for FILE to MODE.
+   If FILE is a symbolic link, this affects its target instead.  */
+extern int chmod (const char *__file, __mode_t __mode)
+     __THROW __nonnull ((1));
+
+#ifdef __USE_BSD
+/* Set file access permissions for FILE to MODE.
+   If FILE is a symbolic link, this affects the link itself
+   rather than its target.  */
+extern int lchmod (const char *__file, __mode_t __mode)
+     __THROW __nonnull ((1));
+#endif
+
+/* Set file access permissions of the file FD is open on to MODE.  */
+#if defined __USE_BSD || defined __USE_POSIX
+extern int fchmod (int __fd, __mode_t __mode) __THROW;
+#endif
+
+#ifdef __USE_ATFILE
+/* Set file access permissions of FILE relative to
+   the directory FD is open on.  */
+extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
+		     int __flag)
+     __THROW __nonnull ((2)) __wur;
+#endif /* Use ATFILE.  */
+
+
+
+/* Set the file creation mask of the current process to MASK,
+   and return the old creation mask.  */
+extern __mode_t umask (__mode_t __mask) __THROW;
+
+#ifdef	__USE_GNU
+/* Get the current `umask' value without changing it.
+   This function is only available under the GNU Hurd.  */
+extern __mode_t getumask (void) __THROW;
+#endif
+
+/* Create a new directory named PATH, with permission bits MODE.  */
+extern int mkdir (const char *__path, __mode_t __mode)
+     __THROW __nonnull ((1));
+
+#ifdef __USE_ATFILE
+/* Like mkdir, create a new directory with permission bits MODE.  But
+   interpret relative PATH names relative to the directory associated
+   with FD.  */
+extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
+     __THROW __nonnull ((2));
+#endif
+
+/* Create a device file named PATH, with permission and special bits MODE
+   and device number DEV (which can be constructed from major and minor
+   device numbers with the `makedev' macro above).  */
+#if defined __USE_MISC || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
+     __THROW __nonnull ((1));
+
+# ifdef __USE_ATFILE
+/* Like mknod, create a new device file with permission bits MODE and
+   device number DEV.  But interpret relative PATH names relative to
+   the directory associated with FD.  */
+extern int mknodat (int __fd, const char *__path, __mode_t __mode,
+		    __dev_t __dev) __THROW __nonnull ((2));
+# endif
+#endif
+
+
+/* Create a new FIFO named PATH, with permission bits MODE.  */
+extern int mkfifo (const char *__path, __mode_t __mode)
+     __THROW __nonnull ((1));
+
+#ifdef __USE_ATFILE
+/* Like mkfifo, create a new FIFO with permission bits MODE.  But
+   interpret relative PATH names relative to the directory associated
+   with FD.  */
+extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
+     __THROW __nonnull ((2));
+#endif
+
+#ifdef __USE_ATFILE
+/* Set file access and modification times relative to directory file
+   descriptor.  */
+extern int utimensat (int __fd, const char *__path,
+		      const struct timespec __times[2],
+		      int __flags)
+     __THROW __nonnull ((2));
+#endif
+
+#ifdef __USE_XOPEN2K8
+/* Set file access and modification times of the file associated with FD.  */
+extern int futimens (int __fd, const struct timespec __times[2]) __THROW;
+#endif
+
+/* To allow the `struct stat' structure and the file type `mode_t'
+   bits to vary without changing shared library major version number,
+   the `stat' family of functions and `mknod' are in fact inline
+   wrappers around calls to `xstat', `fxstat', `lxstat', and `xmknod',
+   which all take a leading version-number argument designating the
+   data structure and bits used.  <bits/stat.h> defines _STAT_VER with
+   the version number corresponding to `struct stat' as defined in
+   that file; and _MKNOD_VER with the version number corresponding to
+   the S_IF* macros defined therein.  It is arranged that when not
+   inlined these function are always statically linked; that way a
+   dynamically-linked executable always encodes the version number
+   corresponding to the data structures it uses, so the `x' functions
+   in the shared library can adapt without needing to recompile all
+   callers.  */
+
+#ifndef _STAT_VER
+# define _STAT_VER	0
+#endif
+#ifndef _MKNOD_VER
+# define _MKNOD_VER	0
+#endif
+
+/* Wrappers for stat and mknod system calls.  */
+#ifndef __USE_FILE_OFFSET64
+extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
+     __THROW __nonnull ((3));
+extern int __xstat (int __ver, const char *__filename,
+		    struct stat *__stat_buf) __THROW __nonnull ((2, 3));
+extern int __lxstat (int __ver, const char *__filename,
+		     struct stat *__stat_buf) __THROW __nonnull ((2, 3));
+extern int __fxstatat (int __ver, int __fildes, const char *__filename,
+		       struct stat *__stat_buf, int __flag)
+     __THROW __nonnull ((3, 4));
+#else
+# ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (__fxstat, (int __ver, int __fildes,
+				      struct stat *__stat_buf), __fxstat64)
+     __nonnull ((3));
+extern int __REDIRECT_NTH (__xstat, (int __ver, const char *__filename,
+				     struct stat *__stat_buf), __xstat64)
+     __nonnull ((2, 3));
+extern int __REDIRECT_NTH (__lxstat, (int __ver, const char *__filename,
+				      struct stat *__stat_buf), __lxstat64)
+     __nonnull ((2, 3));
+extern int __REDIRECT_NTH (__fxstatat, (int __ver, int __fildes,
+					const char *__filename,
+					struct stat *__stat_buf, int __flag),
+			   __fxstatat64) __nonnull ((3, 4));
+
+# else
+#  define __fxstat __fxstat64
+#  define __xstat __xstat64
+#  define __lxstat __lxstat64
+# endif
+#endif
+
+#ifdef __USE_LARGEFILE64
+extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
+     __THROW __nonnull ((3));
+extern int __xstat64 (int __ver, const char *__filename,
+		      struct stat64 *__stat_buf) __THROW __nonnull ((2, 3));
+extern int __lxstat64 (int __ver, const char *__filename,
+		       struct stat64 *__stat_buf) __THROW __nonnull ((2, 3));
+extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
+			 struct stat64 *__stat_buf, int __flag)
+     __THROW __nonnull ((3, 4));
+#endif
+extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
+		     __dev_t *__dev) __THROW __nonnull ((2, 4));
+
+extern int __xmknodat (int __ver, int __fd, const char *__path,
+		       __mode_t __mode, __dev_t *__dev)
+     __THROW __nonnull ((3, 5));
+
+#ifdef __USE_EXTERN_INLINES
+/* Inlined versions of the real stat and mknod functions.  */
+
+__extern_inline int
+__NTH (stat (const char *__path, struct stat *__statbuf))
+{
+  return __xstat (_STAT_VER, __path, __statbuf);
+}
+
+# if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+__extern_inline int
+__NTH (lstat (const char *__path, struct stat *__statbuf))
+{
+  return __lxstat (_STAT_VER, __path, __statbuf);
+}
+# endif
+
+__extern_inline int
+__NTH (fstat (int __fd, struct stat *__statbuf))
+{
+  return __fxstat (_STAT_VER, __fd, __statbuf);
+}
+
+# ifdef __USE_ATFILE
+__extern_inline int
+__NTH (fstatat (int __fd, const char *__filename, struct stat *__statbuf,
+		int __flag))
+{
+  return __fxstatat (_STAT_VER, __fd, __filename, __statbuf, __flag);
+}
+# endif
+
+# if defined __USE_MISC || defined __USE_BSD
+__extern_inline int
+__NTH (mknod (const char *__path, __mode_t __mode, __dev_t __dev))
+{
+  return __xmknod (_MKNOD_VER, __path, __mode, &__dev);
+}
+# endif
+
+# ifdef __USE_ATFILE
+__extern_inline int
+__NTH (mknodat (int __fd, const char *__path, __mode_t __mode,
+		__dev_t __dev))
+{
+  return __xmknodat (_MKNOD_VER, __fd, __path, __mode, &__dev);
+}
+# endif
+
+# if defined __USE_LARGEFILE64 \
+  && (! defined __USE_FILE_OFFSET64 \
+      || (defined __REDIRECT_NTH && defined __OPTIMIZE__))
+__extern_inline int
+__NTH (stat64 (const char *__path, struct stat64 *__statbuf))
+{
+  return __xstat64 (_STAT_VER, __path, __statbuf);
+}
+
+#  if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+__extern_inline int
+__NTH (lstat64 (const char *__path, struct stat64 *__statbuf))
+{
+  return __lxstat64 (_STAT_VER, __path, __statbuf);
+}
+#  endif
+
+__extern_inline int
+__NTH (fstat64 (int __fd, struct stat64 *__statbuf))
+{
+  return __fxstat64 (_STAT_VER, __fd, __statbuf);
+}
+
+#  ifdef __USE_ATFILE
+__extern_inline int
+__NTH (fstatat64 (int __fd, const char *__filename, struct stat64 *__statbuf,
+		  int __flag))
+{
+  return __fxstatat64 (_STAT_VER, __fd, __filename, __statbuf, __flag);
+}
+#  endif
+
+# endif
+
+#endif
+
+__END_DECLS
+
+
+#endif /* sys/stat.h  */
diff --git a/include/sys/statfs.h b/include/sys/statfs.h
new file mode 100644
index 0000000..a78481e
--- /dev/null
+++ b/include/sys/statfs.h
@@ -0,0 +1,67 @@
+/* Definitions for getting information about a filesystem.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_STATFS_H
+#define	_SYS_STATFS_H	1
+
+#include <features.h>
+
+/* Get the system-specific definition of `struct statfs'.  */
+#include <bits/statfs.h>
+
+__BEGIN_DECLS
+
+/* Return information about the filesystem on which FILE resides.  */
+#ifndef __USE_FILE_OFFSET64
+extern int statfs (const char *__file, struct statfs *__buf)
+     __THROW __nonnull ((1, 2));
+#else
+# ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (statfs,
+			   (const char *__file, struct statfs *__buf),
+			   statfs64) __nonnull ((1, 2));
+# else
+#  define statfs statfs64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int statfs64 (const char *__file, struct statfs64 *__buf)
+     __THROW __nonnull ((1, 2));
+#endif
+
+/* Return information about the filesystem containing the file FILDES
+   refers to.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fstatfs (int __fildes, struct statfs *__buf)
+     __THROW __nonnull ((2));
+#else
+# ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (fstatfs, (int __fildes, struct statfs *__buf),
+			   fstatfs64) __nonnull ((2));
+# else
+#  define fstatfs fstatfs64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int fstatfs64 (int __fildes, struct statfs64 *__buf)
+     __THROW __nonnull ((2));
+#endif
+
+__END_DECLS
+
+#endif	/* sys/statfs.h */
diff --git a/include/sys/statvfs.h b/include/sys/statvfs.h
new file mode 100644
index 0000000..5264385
--- /dev/null
+++ b/include/sys/statvfs.h
@@ -0,0 +1,90 @@
+/* Definitions for getting information about a filesystem.
+   Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_STATVFS_H
+#define	_SYS_STATVFS_H	1
+
+#include <features.h>
+
+/* Get the system-specific definition of `struct statfs'.  */
+#include <bits/statvfs.h>
+
+#ifndef __USE_FILE_OFFSET64
+# ifndef __fsblkcnt_t_defined
+typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */
+#  define __fsblkcnt_t_defined
+# endif
+# ifndef __fsfilcnt_t_defined
+typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
+#  define __fsfilcnt_t_defined
+# endif
+#else
+# ifndef __fsblkcnt_t_defined
+typedef __fsblkcnt64_t fsblkcnt_t; /* Type to count file system blocks.  */
+#  define __fsblkcnt_t_defined
+# endif
+# ifndef __fsfilcnt_t_defined
+typedef __fsfilcnt64_t fsfilcnt_t; /* Type to count file system inodes.  */
+#  define __fsfilcnt_t_defined
+# endif
+#endif
+
+__BEGIN_DECLS
+
+/* Return information about the filesystem on which FILE resides.  */
+#ifndef __USE_FILE_OFFSET64
+extern int statvfs (const char *__restrict __file,
+		    struct statvfs *__restrict __buf)
+     __THROW __nonnull ((1, 2));
+#else
+# ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (statvfs,
+			   (const char *__restrict __file,
+			    struct statvfs *__restrict __buf), statvfs64)
+     __nonnull ((1, 2));
+# else
+#  define statvfs statvfs64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int statvfs64 (const char *__restrict __file,
+		      struct statvfs64 *__restrict __buf)
+     __THROW __nonnull ((1, 2));
+#endif
+
+/* Return information about the filesystem containing the file FILDES
+   refers to.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fstatvfs (int __fildes, struct statvfs *__buf)
+     __THROW __nonnull ((2));
+#else
+# ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (fstatvfs, (int __fildes, struct statvfs *__buf),
+			   fstatvfs64) __nonnull ((2));
+# else
+#  define fstatvfs fstatvfs64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int fstatvfs64 (int __fildes, struct statvfs64 *__buf)
+     __THROW __nonnull ((2));
+#endif
+
+__END_DECLS
+
+#endif	/* sys/statvfs.h */
diff --git a/include/sys/stropts.h b/include/sys/stropts.h
new file mode 100644
index 0000000..5b5bc02
--- /dev/null
+++ b/include/sys/stropts.h
@@ -0,0 +1 @@
+#include <stropts.h>
diff --git a/include/sys/swap.h b/include/sys/swap.h
new file mode 100644
index 0000000..1db0498
--- /dev/null
+++ b/include/sys/swap.h
@@ -0,0 +1,32 @@
+/* Calls to enable and disable swapping on specified locations.  Unix version.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef __SYS_SWAP_H
+
+#define __SYS_SWAP_H	1
+#include <features.h>
+
+
+/* Make the block special device PATH available to the system for swapping.
+   This call is restricted to the super-user.  */
+extern int swapon (const char *__path, int __flags) __THROW;
+
+/* Stop using block special device PATH for swapping.  */
+extern int swapoff (const char *__path) __THROW;
+
+#endif /* sys/swap.h */
diff --git a/include/sys/syscall.h b/include/sys/syscall.h
new file mode 100644
index 0000000..6e4ed4d
--- /dev/null
+++ b/include/sys/syscall.h
@@ -0,0 +1 @@
+/* The Mach syscalls are in <mach/syscall_sw.h>.  */
diff --git a/include/sys/sysinfo.h b/include/sys/sysinfo.h
new file mode 100644
index 0000000..85f0438
--- /dev/null
+++ b/include/sys/sysinfo.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SYSINFO_H
+#define _SYS_SYSINFO_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Return number of configured processors.  */
+extern int get_nprocs_conf (void) __THROW;
+
+/* Return number of available processors.  */
+extern int get_nprocs (void) __THROW;
+
+
+/* Return number of physical pages of memory in the system.  */
+extern long int get_phys_pages (void) __THROW;
+
+/* Return number of available physical pages of memory in the system.  */
+extern long int get_avphys_pages (void) __THROW;
+
+__END_DECLS
+
+#endif	/* sys/sysinfo.h */
diff --git a/include/sys/syslog.h b/include/sys/syslog.h
new file mode 100644
index 0000000..41331a8
--- /dev/null
+++ b/include/sys/syslog.h
@@ -0,0 +1,215 @@
+/*
+ * Copyright (c) 1982, 1986, 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)syslog.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _SYS_SYSLOG_H
+#define _SYS_SYSLOG_H 1
+
+#include <features.h>
+#define __need___va_list
+#include <stdarg.h>
+
+/* This file defines _PATH_LOG.  */
+#include <bits/syslog-path.h>
+
+/*
+ * priorities/facilities are encoded into a single 32-bit quantity, where the
+ * bottom 3 bits are the priority (0-7) and the top 28 bits are the facility
+ * (0-big number).  Both the priorities and the facilities map roughly
+ * one-to-one to strings in the syslogd(8) source code.  This mapping is
+ * included in this file.
+ *
+ * priorities (these are ordered)
+ */
+#define	LOG_EMERG	0	/* system is unusable */
+#define	LOG_ALERT	1	/* action must be taken immediately */
+#define	LOG_CRIT	2	/* critical conditions */
+#define	LOG_ERR		3	/* error conditions */
+#define	LOG_WARNING	4	/* warning conditions */
+#define	LOG_NOTICE	5	/* normal but significant condition */
+#define	LOG_INFO	6	/* informational */
+#define	LOG_DEBUG	7	/* debug-level messages */
+
+#define	LOG_PRIMASK	0x07	/* mask to extract priority part (internal) */
+				/* extract priority */
+#define	LOG_PRI(p)	((p) & LOG_PRIMASK)
+#define	LOG_MAKEPRI(fac, pri)	((fac) | (pri))
+
+#ifdef SYSLOG_NAMES
+#define	INTERNAL_NOPRI	0x10	/* the "no priority" priority */
+				/* mark "facility" */
+#define	INTERNAL_MARK	LOG_MAKEPRI(LOG_NFACILITIES << 3, 0)
+typedef struct _code {
+	char	*c_name;
+	int	c_val;
+} CODE;
+
+CODE prioritynames[] =
+  {
+    { "alert", LOG_ALERT },
+    { "crit", LOG_CRIT },
+    { "debug", LOG_DEBUG },
+    { "emerg", LOG_EMERG },
+    { "err", LOG_ERR },
+    { "error", LOG_ERR },		/* DEPRECATED */
+    { "info", LOG_INFO },
+    { "none", INTERNAL_NOPRI },		/* INTERNAL */
+    { "notice", LOG_NOTICE },
+    { "panic", LOG_EMERG },		/* DEPRECATED */
+    { "warn", LOG_WARNING },		/* DEPRECATED */
+    { "warning", LOG_WARNING },
+    { NULL, -1 }
+  };
+#endif
+
+/* facility codes */
+#define	LOG_KERN	(0<<3)	/* kernel messages */
+#define	LOG_USER	(1<<3)	/* random user-level messages */
+#define	LOG_MAIL	(2<<3)	/* mail system */
+#define	LOG_DAEMON	(3<<3)	/* system daemons */
+#define	LOG_AUTH	(4<<3)	/* security/authorization messages */
+#define	LOG_SYSLOG	(5<<3)	/* messages generated internally by syslogd */
+#define	LOG_LPR		(6<<3)	/* line printer subsystem */
+#define	LOG_NEWS	(7<<3)	/* network news subsystem */
+#define	LOG_UUCP	(8<<3)	/* UUCP subsystem */
+#define	LOG_CRON	(9<<3)	/* clock daemon */
+#define	LOG_AUTHPRIV	(10<<3)	/* security/authorization messages (private) */
+#define	LOG_FTP		(11<<3)	/* ftp daemon */
+
+	/* other codes through 15 reserved for system use */
+#define	LOG_LOCAL0	(16<<3)	/* reserved for local use */
+#define	LOG_LOCAL1	(17<<3)	/* reserved for local use */
+#define	LOG_LOCAL2	(18<<3)	/* reserved for local use */
+#define	LOG_LOCAL3	(19<<3)	/* reserved for local use */
+#define	LOG_LOCAL4	(20<<3)	/* reserved for local use */
+#define	LOG_LOCAL5	(21<<3)	/* reserved for local use */
+#define	LOG_LOCAL6	(22<<3)	/* reserved for local use */
+#define	LOG_LOCAL7	(23<<3)	/* reserved for local use */
+
+#define	LOG_NFACILITIES	24	/* current number of facilities */
+#define	LOG_FACMASK	0x03f8	/* mask to extract facility part */
+				/* facility of pri */
+#define	LOG_FAC(p)	(((p) & LOG_FACMASK) >> 3)
+
+#ifdef SYSLOG_NAMES
+CODE facilitynames[] =
+  {
+    { "auth", LOG_AUTH },
+    { "authpriv", LOG_AUTHPRIV },
+    { "cron", LOG_CRON },
+    { "daemon", LOG_DAEMON },
+    { "ftp", LOG_FTP },
+    { "kern", LOG_KERN },
+    { "lpr", LOG_LPR },
+    { "mail", LOG_MAIL },
+    { "mark", INTERNAL_MARK },		/* INTERNAL */
+    { "news", LOG_NEWS },
+    { "security", LOG_AUTH },		/* DEPRECATED */
+    { "syslog", LOG_SYSLOG },
+    { "user", LOG_USER },
+    { "uucp", LOG_UUCP },
+    { "local0", LOG_LOCAL0 },
+    { "local1", LOG_LOCAL1 },
+    { "local2", LOG_LOCAL2 },
+    { "local3", LOG_LOCAL3 },
+    { "local4", LOG_LOCAL4 },
+    { "local5", LOG_LOCAL5 },
+    { "local6", LOG_LOCAL6 },
+    { "local7", LOG_LOCAL7 },
+    { NULL, -1 }
+  };
+#endif
+
+/*
+ * arguments to setlogmask.
+ */
+#define	LOG_MASK(pri)	(1 << (pri))		/* mask for one priority */
+#define	LOG_UPTO(pri)	((1 << ((pri)+1)) - 1)	/* all priorities through pri */
+
+/*
+ * Option flags for openlog.
+ *
+ * LOG_ODELAY no longer does anything.
+ * LOG_NDELAY is the inverse of what it used to be.
+ */
+#define	LOG_PID		0x01	/* log the pid with each message */
+#define	LOG_CONS	0x02	/* log on the console if errors in sending */
+#define	LOG_ODELAY	0x04	/* delay open until first syslog() (default) */
+#define	LOG_NDELAY	0x08	/* don't delay open */
+#define	LOG_NOWAIT	0x10	/* don't wait for console forks: DEPRECATED */
+#define	LOG_PERROR	0x20	/* log to stderr as well */
+
+__BEGIN_DECLS
+
+/* Close descriptor used to write to system logger.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void closelog (void);
+
+/* Open connection to system logger.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void openlog (const char *__ident, int __option, int __facility);
+
+/* Set the log mask level.  */
+extern int setlogmask (int __mask) __THROW;
+
+/* Generate a log message using FMT string and option arguments.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void syslog (int __pri, const char *__fmt, ...)
+     __attribute__ ((__format__ (__printf__, 2, 3)));
+
+#ifdef __USE_BSD
+/* Generate a log message using FMT and using arguments pointed to by AP.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern void vsyslog (int __pri, const char *__fmt, __gnuc_va_list __ap)
+     __attribute__ ((__format__ (__printf__, 2, 0)));
+#endif
+
+
+/* Define some macros helping to catch buffer overflows.  */
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+# include <bits/syslog.h>
+#endif
+#ifdef __LDBL_COMPAT
+# include <bits/syslog-ldbl.h>
+#endif
+
+__END_DECLS
+
+#endif /* sys/syslog.h */
diff --git a/include/sys/sysmacros.h b/include/sys/sysmacros.h
new file mode 100644
index 0000000..1d37322
--- /dev/null
+++ b/include/sys/sysmacros.h
@@ -0,0 +1,30 @@
+/* Definitions of macros to access `dev_t' values.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H	1
+
+/* For compatibility we provide alternative names.
+
+   The problem here is that compilers other than GCC probably don't
+   have the `long long' type and so `dev_t' is actually an array.  */
+#define major(dev) ((int)(((unsigned int) (dev) >> 8) & 0xff))
+#define minor(dev) ((int)((dev) & 0xff))
+#define makedev(major, minor) (((major) << 8) | (minor))
+
+#endif /* sys/sysmacros.h */
diff --git a/include/sys/termios.h b/include/sys/termios.h
new file mode 100644
index 0000000..3e18805
--- /dev/null
+++ b/include/sys/termios.h
@@ -0,0 +1,4 @@
+#ifndef _SYS_TERMIOS_H
+#define _SYS_TERMIOS_H
+#include <termios.h>
+#endif
diff --git a/include/sys/time.h b/include/sys/time.h
new file mode 100644
index 0000000..c01b23b
--- /dev/null
+++ b/include/sys/time.h
@@ -0,0 +1,191 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_TIME_H
+#define _SYS_TIME_H	1
+
+#include <features.h>
+
+#include <bits/types.h>
+#define __need_time_t
+#include <time.h>
+#define __need_timeval
+#include <bits/time.h>
+
+#include <sys/select.h>
+
+#ifndef __suseconds_t_defined
+typedef __suseconds_t suseconds_t;
+# define __suseconds_t_defined
+#endif
+
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+/* Macros for converting between `struct timeval' and `struct timespec'.  */
+# define TIMEVAL_TO_TIMESPEC(tv, ts) {                                   \
+	(ts)->tv_sec = (tv)->tv_sec;                                    \
+	(ts)->tv_nsec = (tv)->tv_usec * 1000;                           \
+}
+# define TIMESPEC_TO_TIMEVAL(tv, ts) {                                   \
+	(tv)->tv_sec = (ts)->tv_sec;                                    \
+	(tv)->tv_usec = (ts)->tv_nsec / 1000;                           \
+}
+#endif
+
+
+#ifdef __USE_BSD
+/* Structure crudely representing a timezone.
+   This is obsolete and should never be used.  */
+struct timezone
+  {
+    int tz_minuteswest;		/* Minutes west of GMT.  */
+    int tz_dsttime;		/* Nonzero if DST is ever in effect.  */
+  };
+
+typedef struct timezone *__restrict __timezone_ptr_t;
+#else
+typedef void *__restrict __timezone_ptr_t;
+#endif
+
+/* Get the current time of day and timezone information,
+   putting it into *TV and *TZ.  If TZ is NULL, *TZ is not filled.
+   Returns 0 on success, -1 on errors.
+   NOTE: This form of timezone information is obsolete.
+   Use the functions and variables declared in <time.h> instead.  */
+extern int gettimeofday (struct timeval *__restrict __tv,
+			 __timezone_ptr_t __tz) __THROW __nonnull ((1));
+
+#ifdef __USE_BSD
+/* Set the current time of day and timezone information.
+   This call is restricted to the super-user.  */
+extern int settimeofday (const struct timeval *__tv,
+			 const struct timezone *__tz)
+     __THROW;
+
+/* Adjust the current time of day by the amount in DELTA.
+   If OLDDELTA is not NULL, it is filled in with the amount
+   of time adjustment remaining to be done from the last `adjtime' call.
+   This call is restricted to the super-user.  */
+extern int adjtime (const struct timeval *__delta,
+		    struct timeval *__olddelta) __THROW;
+#endif
+
+
+/* Values for the first argument to `getitimer' and `setitimer'.  */
+enum __itimer_which
+  {
+    /* Timers run in real time.  */
+    ITIMER_REAL = 0,
+#define ITIMER_REAL ITIMER_REAL
+    /* Timers run only when the process is executing.  */
+    ITIMER_VIRTUAL = 1,
+#define ITIMER_VIRTUAL ITIMER_VIRTUAL
+    /* Timers run when the process is executing and when
+       the system is executing on behalf of the process.  */
+    ITIMER_PROF = 2
+#define ITIMER_PROF ITIMER_PROF
+  };
+
+/* Type of the second argument to `getitimer' and
+   the second and third arguments `setitimer'.  */
+struct itimerval
+  {
+    /* Value to put into `it_value' when the timer expires.  */
+    struct timeval it_interval;
+    /* Time to the next timer expiration.  */
+    struct timeval it_value;
+  };
+
+#if defined __USE_GNU && !defined __cplusplus
+/* Use the nicer parameter type only in GNU mode and not for C++ since the
+   strict C++ rules prevent the automatic promotion.  */
+typedef enum __itimer_which __itimer_which_t;
+#else
+typedef int __itimer_which_t;
+#endif
+
+/* Set *VALUE to the current setting of timer WHICH.
+   Return 0 on success, -1 on errors.  */
+extern int getitimer (__itimer_which_t __which,
+		      struct itimerval *__value) __THROW;
+
+/* Set the timer WHICH to *NEW.  If OLD is not NULL,
+   set *OLD to the old value of timer WHICH.
+   Returns 0 on success, -1 on errors.  */
+extern int setitimer (__itimer_which_t __which,
+		      const struct itimerval *__restrict __new,
+		      struct itimerval *__restrict __old) __THROW;
+
+/* Change the access time of FILE to TVP[0] and the modification time of
+   FILE to TVP[1].  If TVP is a null pointer, use the current time instead.
+   Returns 0 on success, -1 on errors.  */
+extern int utimes (const char *__file, const struct timeval __tvp[2])
+     __THROW __nonnull ((1));
+
+#ifdef __USE_BSD
+/* Same as `utimes', but does not follow symbolic links.  */
+extern int lutimes (const char *__file, const struct timeval __tvp[2])
+     __THROW __nonnull ((1));
+
+/* Same as `utimes', but takes an open file descriptor instead of a name.  */
+extern int futimes (int __fd, const struct timeval __tvp[2]) __THROW;
+#endif
+
+#ifdef __USE_GNU
+/* Change the access time of FILE relative to FD to TVP[0] and the
+   modification time of FILE to TVP[1].  If TVP is a null pointer, use
+   the current time instead.  Returns 0 on success, -1 on errors.  */
+extern int futimesat (int __fd, const char *__file,
+		      const struct timeval __tvp[2]) __THROW;
+#endif
+
+
+#ifdef __USE_BSD
+/* Convenience macros for operations on timevals.
+   NOTE: `timercmp' does not work for >= or <=.  */
+# define timerisset(tvp)	((tvp)->tv_sec || (tvp)->tv_usec)
+# define timerclear(tvp)	((tvp)->tv_sec = (tvp)->tv_usec = 0)
+# define timercmp(a, b, CMP) 						      \
+  (((a)->tv_sec == (b)->tv_sec) ? 					      \
+   ((a)->tv_usec CMP (b)->tv_usec) : 					      \
+   ((a)->tv_sec CMP (b)->tv_sec))
+# define timeradd(a, b, result)						      \
+  do {									      \
+    (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;			      \
+    (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;			      \
+    if ((result)->tv_usec >= 1000000)					      \
+      {									      \
+	++(result)->tv_sec;						      \
+	(result)->tv_usec -= 1000000;					      \
+      }									      \
+  } while (0)
+# define timersub(a, b, result)						      \
+  do {									      \
+    (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;			      \
+    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;			      \
+    if ((result)->tv_usec < 0) {					      \
+      --(result)->tv_sec;						      \
+      (result)->tv_usec += 1000000;					      \
+    }									      \
+  } while (0)
+#endif	/* BSD */
+
+__END_DECLS
+
+#endif /* sys/time.h */
diff --git a/include/sys/timeb.h b/include/sys/timeb.h
new file mode 100644
index 0000000..3c36f02
--- /dev/null
+++ b/include/sys/timeb.h
@@ -0,0 +1,45 @@
+/* Copyright (C) 1994-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_TIMEB_H
+#define _SYS_TIMEB_H	1
+
+#include <features.h>
+
+#define __need_time_t
+#include <time.h>
+
+
+__BEGIN_DECLS
+
+/* Structure returned by the `ftime' function.  */
+
+struct timeb
+  {
+    time_t time;		/* Seconds since epoch, as from `time'.  */
+    unsigned short int millitm;	/* Additional milliseconds.  */
+    short int timezone;		/* Minutes west of GMT.  */
+    short int dstflag;		/* Nonzero if Daylight Savings Time used.  */
+  };
+
+/* Fill in TIMEBUF with information about the current time.  */
+
+extern int ftime (struct timeb *__timebuf);
+
+__END_DECLS
+
+#endif	/* sys/timeb.h */
diff --git a/include/sys/times.h b/include/sys/times.h
new file mode 100644
index 0000000..7edead0
--- /dev/null
+++ b/include/sys/times.h
@@ -0,0 +1,52 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 4.5.2 Process Times	<sys/times.h>
+ */
+
+#ifndef	_SYS_TIMES_H
+#define	_SYS_TIMES_H	1
+
+#include <features.h>
+
+#define	__need_clock_t
+#include <time.h>
+
+
+__BEGIN_DECLS
+
+/* Structure describing CPU time used by a process and its children.  */
+struct tms
+  {
+    clock_t tms_utime;		/* User CPU time.  */
+    clock_t tms_stime;		/* System CPU time.  */
+
+    clock_t tms_cutime;		/* User CPU time of dead children.  */
+    clock_t tms_cstime;		/* System CPU time of dead children.  */
+  };
+
+
+/* Store the CPU time used by this process and all its
+   dead children (and their dead children) in BUFFER.
+   Return the elapsed real time, or (clock_t) -1 for errors.
+   All times are in CLK_TCKths of a second.  */
+extern clock_t times (struct tms *__buffer) __THROW;
+
+__END_DECLS
+
+#endif /* sys/times.h	*/
diff --git a/include/sys/ttychars.h b/include/sys/ttychars.h
new file mode 100644
index 0000000..7043f60
--- /dev/null
+++ b/include/sys/ttychars.h
@@ -0,0 +1,61 @@
+/*-
+ * Copyright (c) 1982, 1986, 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ttychars.h	8.2 (Berkeley) 1/4/94
+ */
+
+/*
+ * 4.3 COMPATIBILITY FILE
+ *
+ * User visible structures and constants related to terminal handling.
+ */
+#ifndef _SYS_TTYCHARS_H
+#define	_SYS_TTYCHARS_H 1
+
+struct ttychars {
+	char	tc_erase;	/* erase last character */
+	char	tc_kill;	/* erase entire line */
+	char	tc_intrc;	/* interrupt */
+	char	tc_quitc;	/* quit */
+	char	tc_startc;	/* start output */
+	char	tc_stopc;	/* stop output */
+	char	tc_eofc;	/* end-of-file */
+	char	tc_brkc;	/* input delimiter (like nl) */
+	char	tc_suspc;	/* stop process signal */
+	char	tc_dsuspc;	/* delayed stop process signal */
+	char	tc_rprntc;	/* reprint line */
+	char	tc_flushc;	/* flush output (toggles) */
+	char	tc_werasc;	/* word erase */
+	char	tc_lnextc;	/* literal next character */
+};
+
+#ifdef __USE_OLD_TTY
+#include <sys/ttydefaults.h>	/* to pick up character defaults */
+#endif
+
+#endif /* sys/ttychars.h */
diff --git a/include/sys/ttydefaults.h b/include/sys/ttydefaults.h
new file mode 100644
index 0000000..683dc8d
--- /dev/null
+++ b/include/sys/ttydefaults.h
@@ -0,0 +1,100 @@
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
+ */
+
+/*
+ * System wide defaults for terminal state.  4.4 BSD/generic GNU version.
+ */
+#ifndef _SYS_TTYDEFAULTS_H_
+#define	_SYS_TTYDEFAULTS_H_
+
+/*
+ * Defaults on "first" open.
+ */
+#define	TTYDEF_IFLAG	(BRKINT | ISTRIP | ICRNL | IMAXBEL | IXON | IXANY)
+#define TTYDEF_OFLAG	(OPOST | ONLCR | OXTABS)
+#define TTYDEF_LFLAG	(ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
+#define TTYDEF_CFLAG	(CREAD | CS7 | PARENB | HUPCL)
+#define TTYDEF_SPEED	(B9600)
+
+/*
+ * Control Character Defaults
+ */
+#define CTRL(x)	(x&037)
+#define	CEOF		CTRL('d')
+#ifdef _POSIX_VDISABLE
+# define CEOL		_POSIX_VDISABLE
+#else
+# define CEOL		((unsigned char)'\377')	/* XXX avoid _POSIX_VDISABLE */
+#endif
+#define	CERASE		0177
+#define	CINTR		CTRL('c')
+#ifdef _POSIX_VDISABLE
+# define CSTATUS	_POSIX_VDISABLE
+#else
+# define CSTATUS	((unsigned char)'\377')	/* XXX avoid _POSIX_VDISABLE */
+#endif
+#define	CKILL		CTRL('u')
+#define	CMIN		1
+#define	CQUIT		034		/* FS, ^\ */
+#define	CSUSP		CTRL('z')
+#define	CTIME		0
+#define	CDSUSP		CTRL('y')
+#define	CSTART		CTRL('q')
+#define	CSTOP		CTRL('s')
+#define	CLNEXT		CTRL('v')
+#define	CDISCARD 	CTRL('o')
+#define	CWERASE 	CTRL('w')
+#define	CREPRINT 	CTRL('r')
+#define	CEOT		CEOF
+/* compat */
+#define	CBRK		CEOL
+#define CRPRNT		CREPRINT
+#define	CFLUSH		CDISCARD
+
+/* PROTECTED INCLUSION ENDS HERE */
+#endif /* !_SYS_TTYDEFAULTS_H_ */
+
+/*
+ * #define TTYDEFCHARS to include an array of default control characters.
+ */
+#ifdef TTYDEFCHARS
+cc_t	ttydefchars[NCCS] = {
+	CEOF,	CEOL,	CEOL,	CERASE, CWERASE, CKILL, CREPRINT,
+	_POSIX_VDISABLE, CINTR,	CQUIT,	CSUSP,	CDSUSP,	CSTART,	CSTOP,	CLNEXT,
+	CDISCARD, CMIN,	CTIME,  CSTATUS, _POSIX_VDISABLE
+};
+#undef TTYDEFCHARS
+#endif
diff --git a/include/sys/types.h b/include/sys/types.h
new file mode 100644
index 0000000..0d51ae8
--- /dev/null
+++ b/include/sys/types.h
@@ -0,0 +1,275 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
+ */
+
+#ifndef	_SYS_TYPES_H
+#define	_SYS_TYPES_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#ifdef	__USE_BSD
+# ifndef __u_char_defined
+typedef __u_char u_char;
+typedef __u_short u_short;
+typedef __u_int u_int;
+typedef __u_long u_long;
+typedef __quad_t quad_t;
+typedef __u_quad_t u_quad_t;
+typedef __fsid_t fsid_t;
+#  define __u_char_defined
+# endif
+#endif
+
+typedef __loff_t loff_t;
+
+#ifndef __ino_t_defined
+# ifndef __USE_FILE_OFFSET64
+typedef __ino_t ino_t;
+# else
+typedef __ino64_t ino_t;
+# endif
+# define __ino_t_defined
+#endif
+#if defined __USE_LARGEFILE64 && !defined __ino64_t_defined
+typedef __ino64_t ino64_t;
+# define __ino64_t_defined
+#endif
+
+#ifndef __dev_t_defined
+typedef __dev_t dev_t;
+# define __dev_t_defined
+#endif
+
+#ifndef __gid_t_defined
+typedef __gid_t gid_t;
+# define __gid_t_defined
+#endif
+
+#ifndef __mode_t_defined
+typedef __mode_t mode_t;
+# define __mode_t_defined
+#endif
+
+#ifndef __nlink_t_defined
+typedef __nlink_t nlink_t;
+# define __nlink_t_defined
+#endif
+
+#ifndef __uid_t_defined
+typedef __uid_t uid_t;
+# define __uid_t_defined
+#endif
+
+#ifndef __off_t_defined
+# ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+# else
+typedef __off64_t off_t;
+# endif
+# define __off_t_defined
+#endif
+#if defined __USE_LARGEFILE64 && !defined __off64_t_defined
+typedef __off64_t off64_t;
+# define __off64_t_defined
+#endif
+
+#ifndef __pid_t_defined
+typedef __pid_t pid_t;
+# define __pid_t_defined
+#endif
+
+#if (defined __USE_SVID || defined __USE_XOPEN || defined __USE_XOPEN2K8) \
+    && !defined __id_t_defined
+typedef __id_t id_t;
+# define __id_t_defined
+#endif
+
+#ifndef __ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+#endif
+
+#ifdef	__USE_BSD
+# ifndef __daddr_t_defined
+typedef __daddr_t daddr_t;
+typedef __caddr_t caddr_t;
+#  define __daddr_t_defined
+# endif
+#endif
+
+#if (defined __USE_SVID || defined __USE_XOPEN) && !defined __key_t_defined
+typedef __key_t key_t;
+# define __key_t_defined
+#endif
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K8
+# define __need_clock_t
+#endif
+#define	__need_time_t
+#define __need_timer_t
+#define __need_clockid_t
+#include <time.h>
+
+#ifdef __USE_XOPEN
+# ifndef __useconds_t_defined
+typedef __useconds_t useconds_t;
+#  define __useconds_t_defined
+# endif
+# ifndef __suseconds_t_defined
+typedef __suseconds_t suseconds_t;
+#  define __suseconds_t_defined
+# endif
+#endif
+
+#define	__need_size_t
+#include <stddef.h>
+
+#ifdef __USE_MISC
+/* Old compatibility names for C types.  */
+typedef unsigned long int ulong;
+typedef unsigned short int ushort;
+typedef unsigned int uint;
+#endif
+
+/* These size-specific names are used by some of the inet code.  */
+
+#if !__GNUC_PREREQ (2, 7)
+
+/* These types are defined by the ISO C99 header <inttypes.h>. */
+# ifndef __int8_t_defined
+#  define __int8_t_defined
+typedef	char int8_t;
+typedef	short int int16_t;
+typedef	int int32_t;
+#  if __WORDSIZE == 64
+typedef long int int64_t;
+#  else
+__extension__ typedef long long int int64_t;
+#  endif
+# endif
+
+/* But these were defined by ISO C without the first `_'.  */
+typedef	unsigned char u_int8_t;
+typedef	unsigned short int u_int16_t;
+typedef	unsigned int u_int32_t;
+# if __WORDSIZE == 64
+typedef unsigned long int u_int64_t;
+# else
+__extension__ typedef unsigned long long int u_int64_t;
+# endif
+
+typedef int register_t;
+
+#else
+
+/* For GCC 2.7 and later, we can use specific type-size attributes.  */
+# define __intN_t(N, MODE) \
+  typedef int int##N##_t __attribute__ ((__mode__ (MODE)))
+# define __u_intN_t(N, MODE) \
+  typedef unsigned int u_int##N##_t __attribute__ ((__mode__ (MODE)))
+
+# ifndef __int8_t_defined
+#  define __int8_t_defined
+__intN_t (8, __QI__);
+__intN_t (16, __HI__);
+__intN_t (32, __SI__);
+__intN_t (64, __DI__);
+# endif
+
+__u_intN_t (8, __QI__);
+__u_intN_t (16, __HI__);
+__u_intN_t (32, __SI__);
+__u_intN_t (64, __DI__);
+
+typedef int register_t __attribute__ ((__mode__ (__word__)));
+
+
+/* Some code from BIND tests this macro to see if the types above are
+   defined.  */
+#endif
+#define __BIT_TYPES_DEFINED__	1
+
+
+#ifdef	__USE_BSD
+/* In BSD <sys/types.h> is expected to define BYTE_ORDER.  */
+# include <endian.h>
+
+/* It also defines `fd_set' and the FD_* macros for `select'.  */
+# include <sys/select.h>
+
+/* BSD defines these symbols, so we follow.  */
+# include <sys/sysmacros.h>
+#endif /* Use BSD.  */
+
+
+#if (defined __USE_UNIX98 || defined __USE_XOPEN2K8) \
+    && !defined __blksize_t_defined
+typedef __blksize_t blksize_t;
+# define __blksize_t_defined
+#endif
+
+/* Types from the Large File Support interface.  */
+#ifndef __USE_FILE_OFFSET64
+# ifndef __blkcnt_t_defined
+typedef __blkcnt_t blkcnt_t;	 /* Type to count number of disk blocks.  */
+#  define __blkcnt_t_defined
+# endif
+# ifndef __fsblkcnt_t_defined
+typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */
+#  define __fsblkcnt_t_defined
+# endif
+# ifndef __fsfilcnt_t_defined
+typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
+#  define __fsfilcnt_t_defined
+# endif
+#else
+# ifndef __blkcnt_t_defined
+typedef __blkcnt64_t blkcnt_t;	   /* Type to count number of disk blocks.  */
+#  define __blkcnt_t_defined
+# endif
+# ifndef __fsblkcnt_t_defined
+typedef __fsblkcnt64_t fsblkcnt_t; /* Type to count file system blocks.  */
+#  define __fsblkcnt_t_defined
+# endif
+# ifndef __fsfilcnt_t_defined
+typedef __fsfilcnt64_t fsfilcnt_t; /* Type to count file system inodes.  */
+#  define __fsfilcnt_t_defined
+# endif
+#endif
+
+#ifdef __USE_LARGEFILE64
+typedef __blkcnt64_t blkcnt64_t;     /* Type to count number of disk blocks. */
+typedef __fsblkcnt64_t fsblkcnt64_t; /* Type to count file system blocks.  */
+typedef __fsfilcnt64_t fsfilcnt64_t; /* Type to count file system inodes.  */
+#endif
+
+
+/* Now add the thread types.  */
+#if defined __USE_POSIX199506 || defined __USE_UNIX98
+# include <bits/pthreadtypes.h>
+#endif
+
+__END_DECLS
+
+#endif /* sys/types.h */
diff --git a/include/sys/ucontext.h b/include/sys/ucontext.h
new file mode 100644
index 0000000..c7ab13a
--- /dev/null
+++ b/include/sys/ucontext.h
@@ -0,0 +1,119 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* System V/i386 ABI compliant context switching support.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* Type for general register.  */
+typedef int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	19
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NGREG];
+
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  REG_GS = 0,
+#define REG_GS	REG_GS
+  REG_FS,
+#define REG_FS	REG_FS
+  REG_ES,
+#define REG_ES	REG_ES
+  REG_DS,
+#define REG_DS	REG_DS
+  REG_EDI,
+#define REG_EDI	REG_EDI
+  REG_ESI,
+#define REG_ESI	REG_ESI
+  REG_EBP,
+#define REG_EBP	REG_EBP
+  REG_ESP,
+#define REG_ESP	REG_ESP
+  REG_EBX,
+#define REG_EBX	REG_EBX
+  REG_EDX,
+#define REG_EDX	REG_EDX
+  REG_ECX,
+#define REG_ECX	REG_ECX
+  REG_EAX,
+#define REG_EAX	REG_EAX
+  REG_TRAPNO,
+#define REG_TRAPNO	REG_TRAPNO
+  REG_ERR,
+#define REG_ERR	REG_ERR
+  REG_EIP,
+#define REG_EIP	REG_EIP
+  REG_CS,
+#define REG_CS	REG_CS
+  REG_EFL,
+#define REG_EFL	REG_EFL
+  REG_UESP,
+#define REG_UESP	REG_UESP
+  REG_SS
+#define REG_SS	REG_SS
+};
+
+/* Structure to describe FPU registers.  */
+typedef struct fpregset
+  {
+    union
+      {
+	struct fpchip_state
+	  {
+	    int state[27];
+	    int status;
+	  } fpchip_state;
+
+	struct fp_emul_space
+	  {
+	    char fp_emul[246];
+	    char fp_epad[2];
+	  } fp_emul_space;
+
+	int f_fpregs[62];
+      } fp_reg_set;
+
+    long int f_wregs[33];
+  } fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct
+  {
+    gregset_t gregs;
+    fpregset_t fpregs;
+  } mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    __sigset_t uc_sigmask;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    long int uc_filler[5];
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --git a/include/sys/uio.h b/include/sys/uio.h
new file mode 100644
index 0000000..183ea9d
--- /dev/null
+++ b/include/sys/uio.h
@@ -0,0 +1,122 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_UIO_H
+#define _SYS_UIO_H	1
+
+#include <features.h>
+
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+/* This file defines `struct iovec'.  */
+#include <bits/uio.h>
+
+
+/* Read data from file descriptor FD, and put the result in the
+   buffers described by IOVEC, which is a vector of COUNT 'struct iovec's.
+   The buffers are filled in the order specified.
+   Operates just like 'read' (see <unistd.h>) except that data are
+   put in IOVEC instead of a contiguous buffer.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
+  __wur;
+
+/* Write data pointed by the buffers described by IOVEC, which
+   is a vector of COUNT 'struct iovec's, to file descriptor FD.
+   The data is written in the order specified.
+   Operates just like 'write' (see <unistd.h>) except that the data
+   are taken from IOVEC instead of a contiguous buffer.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
+  __wur;
+
+
+#ifdef __USE_BSD
+# ifndef __USE_FILE_OFFSET64
+/* Read data from file descriptor FD at the given position OFFSET
+   without change the file pointer, and put the result in the buffers
+   described by IOVEC, which is a vector of COUNT 'struct iovec's.
+   The buffers are filled in the order specified.  Operates just like
+   'pread' (see <unistd.h>) except that data are put in IOVEC instead
+   of a contiguous buffer.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
+		       __off_t __offset) __wur;
+
+/* Write data pointed by the buffers described by IOVEC, which is a
+   vector of COUNT 'struct iovec's, to file descriptor FD at the given
+   position OFFSET without change the file pointer.  The data is
+   written in the order specified.  Operates just like 'pwrite' (see
+   <unistd.h>) except that the data are taken from IOVEC instead of a
+   contiguous buffer.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
+			__off_t __offset) __wur;
+# else
+#  ifdef __REDIRECT
+extern ssize_t __REDIRECT (preadv, (int __fd, const struct iovec *__iovec,
+				    int __count, __off64_t __offset),
+			   preadv64) __wur;
+extern ssize_t __REDIRECT (pwritev, (int __fd, const struct iovec *__iovec,
+				     int __count, __off64_t __offset),
+			   pwritev64) __wur;
+#  else
+#   define preadv preadv64
+#   define pwritev pwritev64
+#  endif
+# endif
+
+# ifdef __USE_LARGEFILE64
+/* Read data from file descriptor FD at the given position OFFSET
+   without change the file pointer, and put the result in the buffers
+   described by IOVEC, which is a vector of COUNT 'struct iovec's.
+   The buffers are filled in the order specified.  Operates just like
+   'pread' (see <unistd.h>) except that data are put in IOVEC instead
+   of a contiguous buffer.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t preadv64 (int __fd, const struct iovec *__iovec, int __count,
+			 __off64_t __offset) __wur;
+
+/* Write data pointed by the buffers described by IOVEC, which is a
+   vector of COUNT 'struct iovec's, to file descriptor FD at the given
+   position OFFSET without change the file pointer.  The data is
+   written in the order specified.  Operates just like 'pwrite' (see
+   <unistd.h>) except that the data are taken from IOVEC instead of a
+   contiguous buffer.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t pwritev64 (int __fd, const struct iovec *__iovec, int __count,
+			  __off64_t __offset) __wur;
+# endif
+#endif	/* Use BSD */
+
+__END_DECLS
+
+#endif /* sys/uio.h */
diff --git a/include/sys/un.h b/include/sys/un.h
new file mode 100644
index 0000000..fc0ed39
--- /dev/null
+++ b/include/sys/un.h
@@ -0,0 +1,46 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_UN_H
+#define	_SYS_UN_H	1
+
+#include <sys/cdefs.h>
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+__BEGIN_DECLS
+
+/* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */
+struct sockaddr_un
+  {
+    __SOCKADDR_COMMON (sun_);
+    char sun_path[108];		/* Path name.  */
+  };
+
+
+#ifdef __USE_MISC
+# include <string.h>		/* For prototype of `strlen'.  */
+
+/* Evaluate to actual length of the `sockaddr_un' structure.  */
+# define SUN_LEN(ptr) ((size_t) (((struct sockaddr_un *) 0)->sun_path)	      \
+		      + strlen ((ptr)->sun_path))
+#endif
+
+__END_DECLS
+
+#endif	/* sys/un.h  */
diff --git a/include/sys/unistd.h b/include/sys/unistd.h
new file mode 100644
index 0000000..1e823fb
--- /dev/null
+++ b/include/sys/unistd.h
@@ -0,0 +1 @@
+#include <unistd.h>
diff --git a/include/sys/ustat.h b/include/sys/ustat.h
new file mode 100644
index 0000000..ee82a45
--- /dev/null
+++ b/include/sys/ustat.h
@@ -0,0 +1,37 @@
+/* Header describing obsolete `ustat' interface.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ * This interface is obsolete.  Use <sys/statfs.h> instead.
+ */
+
+#ifndef _SYS_USTAT_H
+#define	_SYS_USTAT_H	1
+
+#include <features.h>
+
+#include <sys/types.h>
+#include <bits/ustat.h>
+
+__BEGIN_DECLS
+
+extern int ustat (__dev_t __dev, struct ustat *__ubuf) __THROW;
+
+__END_DECLS
+
+#endif /* sys/ustat.h */
diff --git a/include/sys/utsname.h b/include/sys/utsname.h
new file mode 100644
index 0000000..32e3ba6
--- /dev/null
+++ b/include/sys/utsname.h
@@ -0,0 +1,86 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 4.4 System Identification	<sys/utsname.h>
+ */
+
+#ifndef	_SYS_UTSNAME_H
+#define	_SYS_UTSNAME_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/utsname.h>
+
+#ifndef _UTSNAME_SYSNAME_LENGTH
+# define _UTSNAME_SYSNAME_LENGTH _UTSNAME_LENGTH
+#endif
+#ifndef _UTSNAME_NODENAME_LENGTH
+# define _UTSNAME_NODENAME_LENGTH _UTSNAME_LENGTH
+#endif
+#ifndef _UTSNAME_RELEASE_LENGTH
+# define _UTSNAME_RELEASE_LENGTH _UTSNAME_LENGTH
+#endif
+#ifndef _UTSNAME_VERSION_LENGTH
+# define _UTSNAME_VERSION_LENGTH _UTSNAME_LENGTH
+#endif
+#ifndef _UTSNAME_MACHINE_LENGTH
+# define _UTSNAME_MACHINE_LENGTH _UTSNAME_LENGTH
+#endif
+
+/* Structure describing the system and machine.  */
+struct utsname
+  {
+    /* Name of the implementation of the operating system.  */
+    char sysname[_UTSNAME_SYSNAME_LENGTH];
+
+    /* Name of this node on the network.  */
+    char nodename[_UTSNAME_NODENAME_LENGTH];
+
+    /* Current release level of this implementation.  */
+    char release[_UTSNAME_RELEASE_LENGTH];
+    /* Current version level of this release.  */
+    char version[_UTSNAME_VERSION_LENGTH];
+
+    /* Name of the hardware type the system is running on.  */
+    char machine[_UTSNAME_MACHINE_LENGTH];
+
+#if _UTSNAME_DOMAIN_LENGTH - 0
+    /* Name of the domain of this node on the network.  */
+# ifdef __USE_GNU
+    char domainname[_UTSNAME_DOMAIN_LENGTH];
+# else
+    char __domainname[_UTSNAME_DOMAIN_LENGTH];
+# endif
+#endif
+  };
+
+#ifdef __USE_SVID
+/* Note that SVID assumes all members have the same size.  */
+# define SYS_NMLN  _UTSNAME_LENGTH
+#endif
+
+
+/* Put information about the system in NAME.  */
+extern int uname (struct utsname *__name) __THROW;
+
+
+__END_DECLS
+
+#endif /* sys/utsname.h  */
diff --git a/include/sys/vfs.h b/include/sys/vfs.h
new file mode 100644
index 0000000..fa22d31
--- /dev/null
+++ b/include/sys/vfs.h
@@ -0,0 +1,4 @@
+/* Other systems declare `struct statfs' et al in <sys/vfs.h>,
+   so we have this file to be compatible with programs expecting it.  */
+
+#include <sys/statfs.h>
diff --git a/include/sys/vlimit.h b/include/sys/vlimit.h
new file mode 100644
index 0000000..f230335
--- /dev/null
+++ b/include/sys/vlimit.h
@@ -0,0 +1,67 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_VLIMIT_H
+#define _SYS_VLIMIT_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* This interface is obsolete, and is superseded by <sys/resource.h>.  */
+
+/* Kinds of resource limit.  */
+enum __vlimit_resource
+{
+  /* Setting this non-zero makes it impossible to raise limits.
+     Only the super-use can set it to zero.
+
+     This is not implemented in recent versions of BSD, nor by
+     the GNU C library.  */
+  LIM_NORAISE,
+
+  /* CPU time available for each process (seconds).  */
+  LIM_CPU,
+
+  /* Largest file which can be created (bytes).  */
+  LIM_FSIZE,
+
+  /* Maximum size of the data segment (bytes).  */
+  LIM_DATA,
+
+  /* Maximum size of the stack segment (bytes).  */
+  LIM_STACK,
+
+  /* Largest core file that will be created (bytes).  */
+  LIM_CORE,
+
+  /* Resident set size (bytes).  */
+  LIM_MAXRSS
+};
+
+/* This means no limit.  */
+#define INFINITY 0x7fffffff
+
+
+/* Set the soft limit for RESOURCE to be VALUE.
+   Returns 0 for success, -1 for failure.  */
+extern int vlimit (enum __vlimit_resource __resource, int __value) __THROW;
+
+
+__END_DECLS
+
+#endif /* sys/vlimit.h  */
diff --git a/include/sys/vtimes.h b/include/sys/vtimes.h
new file mode 100644
index 0000000..e100b7f
--- /dev/null
+++ b/include/sys/vtimes.h
@@ -0,0 +1,68 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_VTIMES_H
+#define _SYS_VTIMES_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* This interface is obsolete; use `getrusage' instead.  */
+
+/* Granularity of the `vm_utime' and `vm_stime' fields of a `struct vtimes'.
+   (This is the frequency of the machine's power supply, in Hz.)  */
+#define	VTIMES_UNITS_PER_SECOND	60
+
+struct vtimes
+{
+  /* User time used in units of 1/VTIMES_UNITS_PER_SECOND seconds.  */
+  int vm_utime;
+  /* System time used in units of 1/VTIMES_UNITS_PER_SECOND seconds.  */
+  int vm_stime;
+
+  /* Amount of data and stack memory used (kilobyte-seconds).  */
+  unsigned int vm_idsrss;
+  /* Amount of text memory used (kilobyte-seconds).  */
+  unsigned int vm_ixrss;
+  /* Maximum resident set size (text, data, and stack) (kilobytes).  */
+  int vm_maxrss;
+
+  /* Number of hard page faults (i.e. those that required I/O).  */
+  int vm_majflt;
+  /* Number of soft page faults (i.e. those serviced by reclaiming
+     a page from the list of pages awaiting reallocation.  */
+  int vm_minflt;
+
+  /* Number of times a process was swapped out of physical memory.  */
+  int vm_nswap;
+
+  /* Number of input operations via the file system.  Note: This
+     and `ru_oublock' do not include operations with the cache.  */
+  int vm_inblk;
+  /* Number of output operations via the file system.  */
+  int vm_oublk;
+};
+
+/* If CURRENT is not NULL, write statistics for the current process into
+   *CURRENT.  If CHILD is not NULL, write statistics for all terminated child
+   processes into *CHILD.  Returns 0 for success, -1 for failure.  */
+extern int vtimes (struct vtimes * __current, struct vtimes * __child) __THROW;
+
+__END_DECLS
+
+#endif /* sys/vtimes.h  */
diff --git a/include/sys/wait.h b/include/sys/wait.h
new file mode 100644
index 0000000..7298386
--- /dev/null
+++ b/include/sys/wait.h
@@ -0,0 +1,186 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 3.2.1 Wait for Process Termination	<sys/wait.h>
+ */
+
+#ifndef	_SYS_WAIT_H
+#define	_SYS_WAIT_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <signal.h>
+
+/* These macros could also be defined in <stdlib.h>.  */
+#if !defined _STDLIB_H || (!defined __USE_XOPEN && !defined __USE_XOPEN2K8)
+/* This will define the `W*' macros for the flag
+   bits to `waitpid', `wait3', and `wait4'.  */
+# include <bits/waitflags.h>
+
+# ifdef	__USE_BSD
+
+/* Lots of hair to allow traditional BSD use of `union wait'
+   as well as POSIX.1 use of `int' for the status word.  */
+
+#  if defined __GNUC__ && !defined __cplusplus
+#   define __WAIT_INT(status) \
+  (__extension__ (((union { __typeof(status) __in; int __i; }) \
+		   { .__in = (status) }).__i))
+#  else
+#   define __WAIT_INT(status)	(*(const int *) &(status))
+#  endif
+
+/* This is the type of the argument to `wait'.  The funky union
+   causes redeclarations with either `int *' or `union wait *' to be
+   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
+   the actual function definitions.  */
+
+#  if !defined __GNUC__ || __GNUC__ < 2 || defined __cplusplus
+#   define __WAIT_STATUS	void *
+#   define __WAIT_STATUS_DEFN	void *
+#  else
+/* This works in GCC 2.6.1 and later.  */
+typedef union
+  {
+    union wait *__uptr;
+    int *__iptr;
+  } __WAIT_STATUS __attribute__ ((__transparent_union__));
+#   define __WAIT_STATUS_DEFN	int *
+#  endif
+
+# else /* Don't use BSD.  */
+
+#  define __WAIT_INT(status)	(status)
+#  define __WAIT_STATUS		int *
+#  define __WAIT_STATUS_DEFN	int *
+
+# endif /* Use BSD.  */
+
+/* This will define all the `__W*' macros.  */
+# include <bits/waitstatus.h>
+
+# define WEXITSTATUS(status)	__WEXITSTATUS (__WAIT_INT (status))
+# define WTERMSIG(status)	__WTERMSIG (__WAIT_INT (status))
+# define WSTOPSIG(status)	__WSTOPSIG (__WAIT_INT (status))
+# define WIFEXITED(status)	__WIFEXITED (__WAIT_INT (status))
+# define WIFSIGNALED(status)	__WIFSIGNALED (__WAIT_INT (status))
+# define WIFSTOPPED(status)	__WIFSTOPPED (__WAIT_INT (status))
+# ifdef __WIFCONTINUED
+#  define WIFCONTINUED(status)	__WIFCONTINUED (__WAIT_INT (status))
+# endif
+#endif	/* <stdlib.h> not included.  */
+
+#ifdef	__USE_BSD
+# define WCOREFLAG		__WCOREFLAG
+# define WCOREDUMP(status)	__WCOREDUMP (__WAIT_INT (status))
+# define W_EXITCODE(ret, sig)	__W_EXITCODE (ret, sig)
+# define W_STOPCODE(sig)	__W_STOPCODE (sig)
+#endif
+
+/* The following values are used by the `waitid' function.  */
+#if defined __USE_SVID || defined __USE_XOPEN || defined __USE_XOPEN2K8
+typedef enum
+{
+  P_ALL,		/* Wait for any child.  */
+  P_PID,		/* Wait for specified process.  */
+  P_PGID		/* Wait for members of process group.  */
+} idtype_t;
+#endif
+
+
+/* Wait for a child to die.  When one does, put its status in *STAT_LOC
+   and return its process ID.  For errors, return (pid_t) -1.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern __pid_t wait (__WAIT_STATUS __stat_loc);
+
+#ifdef	__USE_BSD
+/* Special values for the PID argument to `waitpid' and `wait4'.  */
+# define WAIT_ANY	(-1)	/* Any process.  */
+# define WAIT_MYPGRP	0	/* Any process in my process group.  */
+#endif
+
+/* Wait for a child matching PID to die.
+   If PID is greater than 0, match any process whose process ID is PID.
+   If PID is (pid_t) -1, match any process.
+   If PID is (pid_t) 0, match any process with the
+   same process group as the current process.
+   If PID is less than -1, match any process whose
+   process group is the absolute value of PID.
+   If the WNOHANG bit is set in OPTIONS, and that child
+   is not already dead, return (pid_t) 0.  If successful,
+   return PID and store the dead child's status in STAT_LOC.
+   Return (pid_t) -1 for errors.  If the WUNTRACED bit is
+   set in OPTIONS, return status for stopped children; otherwise don't.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options);
+
+#if defined __USE_SVID || defined __USE_XOPEN || defined __USE_XOPEN2K8
+# ifndef __id_t_defined
+#  include <bits/types.h>
+typedef __id_t id_t;
+#  define __id_t_defined
+# endif
+
+# define __need_siginfo_t
+# include <bits/siginfo.h>
+
+/* Wait for a childing matching IDTYPE and ID to change the status and
+   place appropriate information in *INFOP.
+   If IDTYPE is P_PID, match any process whose process ID is ID.
+   If IDTYPE is P_PGID, match any process whose process group is ID.
+   If IDTYPE is P_ALL, match any process.
+   If the WNOHANG bit is set in OPTIONS, and that child
+   is not already dead, clear *INFOP and return 0.  If successful, store
+   exit code and status in *INFOP.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
+		   int __options);
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* This being here makes the prototypes valid whether or not
+   we have already included <sys/resource.h> to define `struct rusage'.  */
+struct rusage;
+
+/* Wait for a child to exit.  When one does, put its status in *STAT_LOC and
+   return its process ID.  For errors return (pid_t) -1.  If USAGE is not
+   nil, store information about the child's resource usage there.  If the
+   WUNTRACED bit is set in OPTIONS, return status for stopped children;
+   otherwise don't.  */
+extern __pid_t wait3 (__WAIT_STATUS __stat_loc, int __options,
+		      struct rusage * __usage) __THROWNL;
+#endif
+
+#ifdef __USE_BSD
+/* PID is like waitpid.  Other args are like wait3.  */
+extern __pid_t wait4 (__pid_t __pid, __WAIT_STATUS __stat_loc, int __options,
+		      struct rusage *__usage) __THROWNL;
+#endif /* Use BSD.  */
+
+
+__END_DECLS
+
+#endif /* sys/wait.h  */
diff --git a/include/sys/xattr.h b/include/sys/xattr.h
new file mode 100644
index 0000000..929cd87
--- /dev/null
+++ b/include/sys/xattr.h
@@ -0,0 +1,103 @@
+/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_XATTR_H
+#define _SYS_XATTR_H	1
+
+#include <features.h>
+#include <sys/types.h>
+
+
+__BEGIN_DECLS
+
+/* The following constants should be used for the fifth parameter of
+   `*setxattr'.  */
+enum
+{
+  XATTR_CREATE = 1,	/* set value, fail if attr already exists.  */
+#define XATTR_CREATE	XATTR_CREATE
+  XATTR_REPLACE = 2	/* set value, fail if attr does not exist.  */
+#define XATTR_REPLACE	XATTR_REPLACE
+};
+
+/* Set the attribute NAME of the file pointed to by PATH to VALUE (which
+   is SIZE bytes long).  Return 0 on success, -1 for errors.  */
+extern int setxattr (const char *__path, const char *__name,
+		     const void *__value, size_t __size, int __flags)
+	__THROW;
+
+/* Set the attribute NAME of the file pointed to by PATH to VALUE (which is
+   SIZE bytes long), not following symlinks for the last pathname component.
+   Return 0 on success, -1 for errors.  */
+extern int lsetxattr (const char *__path, const char *__name,
+		      const void *__value, size_t __size, int __flags)
+	__THROW;
+
+/* Set the attribute NAME of the file descriptor FD to VALUE (which is SIZE
+   bytes long).  Return 0 on success, -1 for errors.  */
+extern int fsetxattr (int __fd, const char *__name, const void *__value,
+		      size_t __size, int __flags) __THROW;
+
+/* Get the attribute NAME of the file pointed to by PATH to VALUE (which is
+   SIZE bytes long).  Return 0 on success, -1 for errors.  */
+extern ssize_t getxattr (const char *__path, const char *__name,
+			 void *__value, size_t __size) __THROW;
+
+/* Get the attribute NAME of the file pointed to by PATH to VALUE (which is
+   SIZE bytes long), not following symlinks for the last pathname component.
+   Return 0 on success, -1 for errors.  */
+extern ssize_t lgetxattr (const char *__path, const char *__name,
+			  void *__value, size_t __size) __THROW;
+
+/* Get the attribute NAME of the file descriptor FD to VALUE (which is SIZE
+   bytes long).  Return 0 on success, -1 for errors.  */
+extern ssize_t fgetxattr (int __fd, const char *__name, void *__value,
+			  size_t __size) __THROW;
+
+/* List attributes of the file pointed to by PATH into the user-supplied
+   buffer LIST (which is SIZE bytes big).  Return 0 on success, -1 for
+   errors.  */
+extern ssize_t listxattr (const char *__path, char *__list, size_t __size)
+	__THROW;
+
+/* List attributes of the file pointed to by PATH into the user-supplied
+   buffer LIST (which is SIZE bytes big), not following symlinks for the
+   last pathname component.  Return 0 on success, -1 for errors.  */
+extern ssize_t llistxattr (const char *__path, char *__list, size_t __size)
+	__THROW;
+
+/* List attributes of the file descriptor FD into the user-supplied buffer
+   LIST (which is SIZE bytes big).  Return 0 on success, -1 for errors.  */
+extern ssize_t flistxattr (int __fd, char *__list, size_t __size)
+	__THROW;
+
+/* Remove the attribute NAME from the file pointed to by PATH.  Return 0
+   on success, -1 for errors.  */
+extern int removexattr (const char *__path, const char *__name) __THROW;
+
+/* Remove the attribute NAME from the file pointed to by PATH, not
+   following symlinks for the last pathname component.  Return 0 on
+   success, -1 for errors.  */
+extern int lremovexattr (const char *__path, const char *__name) __THROW;
+
+/* Remove the attribute NAME from the file descriptor FD.  Return 0 on
+   success, -1 for errors.  */
+extern int fremovexattr (int __fd, const char *__name) __THROW;
+
+__END_DECLS
+
+#endif	/* sys/xattr.h  */
diff --git a/include/syscall.h b/include/syscall.h
new file mode 100644
index 0000000..4c30578
--- /dev/null
+++ b/include/syscall.h
@@ -0,0 +1 @@
+#include <sys/syscall.h>
diff --git a/include/sysexits.h b/include/sysexits.h
new file mode 100644
index 0000000..37246b6
--- /dev/null
+++ b/include/sysexits.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 1987, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)sysexits.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef	_SYSEXITS_H
+#define	_SYSEXITS_H 1
+
+/*
+ *  SYSEXITS.H -- Exit status codes for system programs.
+ *
+ *	This include file attempts to categorize possible error
+ *	exit statuses for system programs, notably delivermail
+ *	and the Berkeley network.
+ *
+ *	Error numbers begin at EX__BASE to reduce the possibility of
+ *	clashing with other exit statuses that random programs may
+ *	already return.  The meaning of the codes is approximately
+ *	as follows:
+ *
+ *	EX_USAGE -- The command was used incorrectly, e.g., with
+ *		the wrong number of arguments, a bad flag, a bad
+ *		syntax in a parameter, or whatever.
+ *	EX_DATAERR -- The input data was incorrect in some way.
+ *		This should only be used for user's data & not
+ *		system files.
+ *	EX_NOINPUT -- An input file (not a system file) did not
+ *		exist or was not readable.  This could also include
+ *		errors like "No message" to a mailer (if it cared
+ *		to catch it).
+ *	EX_NOUSER -- The user specified did not exist.  This might
+ *		be used for mail addresses or remote logins.
+ *	EX_NOHOST -- The host specified did not exist.  This is used
+ *		in mail addresses or network requests.
+ *	EX_UNAVAILABLE -- A service is unavailable.  This can occur
+ *		if a support program or file does not exist.  This
+ *		can also be used as a catchall message when something
+ *		you wanted to do doesn't work, but you don't know
+ *		why.
+ *	EX_SOFTWARE -- An internal software error has been detected.
+ *		This should be limited to non-operating system related
+ *		errors as possible.
+ *	EX_OSERR -- An operating system error has been detected.
+ *		This is intended to be used for such things as "cannot
+ *		fork", "cannot create pipe", or the like.  It includes
+ *		things like getuid returning a user that does not
+ *		exist in the passwd file.
+ *	EX_OSFILE -- Some system file (e.g., /etc/passwd, /etc/utmp,
+ *		etc.) does not exist, cannot be opened, or has some
+ *		sort of error (e.g., syntax error).
+ *	EX_CANTCREAT -- A (user specified) output file cannot be
+ *		created.
+ *	EX_IOERR -- An error occurred while doing I/O on some file.
+ *	EX_TEMPFAIL -- temporary failure, indicating something that
+ *		is not really an error.  In sendmail, this means
+ *		that a mailer (e.g.) could not create a connection,
+ *		and the request should be reattempted later.
+ *	EX_PROTOCOL -- the remote system returned something that
+ *		was "not possible" during a protocol exchange.
+ *	EX_NOPERM -- You did not have sufficient permission to
+ *		perform the operation.  This is not intended for
+ *		file system problems, which should use NOINPUT or
+ *		CANTCREAT, but rather for higher level permissions.
+ */
+
+#define EX_OK		0	/* successful termination */
+
+#define EX__BASE	64	/* base value for error messages */
+
+#define EX_USAGE	64	/* command line usage error */
+#define EX_DATAERR	65	/* data format error */
+#define EX_NOINPUT	66	/* cannot open input */
+#define EX_NOUSER	67	/* addressee unknown */
+#define EX_NOHOST	68	/* host name unknown */
+#define EX_UNAVAILABLE	69	/* service unavailable */
+#define EX_SOFTWARE	70	/* internal software error */
+#define EX_OSERR	71	/* system error (e.g., can't fork) */
+#define EX_OSFILE	72	/* critical OS file missing */
+#define EX_CANTCREAT	73	/* can't create (user) output file */
+#define EX_IOERR	74	/* input/output error */
+#define EX_TEMPFAIL	75	/* temp failure; user is invited to retry */
+#define EX_PROTOCOL	76	/* remote error in protocol */
+#define EX_NOPERM	77	/* permission denied */
+#define EX_CONFIG	78	/* configuration error */
+
+#define EX__MAX	78	/* maximum listed value */
+
+#endif /* sysexits.h */
diff --git a/include/syslog.h b/include/syslog.h
new file mode 100644
index 0000000..830b492
--- /dev/null
+++ b/include/syslog.h
@@ -0,0 +1 @@
+#include <sys/syslog.h>
diff --git a/include/tar.h b/include/tar.h
new file mode 100644
index 0000000..115f4df
--- /dev/null
+++ b/include/tar.h
@@ -0,0 +1,112 @@
+/* Extended tar format from POSIX.1.
+   Copyright (C) 1992-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Written by David J. MacKenzie.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_TAR_H
+#define	_TAR_H	1
+
+#include <features.h>
+
+
+/* A tar archive consists of 512-byte blocks.
+   Each file in the archive has a header block followed by 0+ data blocks.
+   Two blocks of NUL bytes indicate the end of the archive.  */
+
+/* The fields of header blocks:
+   All strings are stored as ISO 646 (approximately ASCII) strings.
+
+   Fields are numeric unless otherwise noted below; numbers are ISO 646
+   representations of octal numbers, with leading zeros as needed.
+
+   linkname is only valid when typeflag==LNKTYPE.  It doesn't use prefix;
+   files that are links to pathnames >100 chars long can not be stored
+   in a tar archive.
+
+   If typeflag=={LNKTYPE,SYMTYPE,DIRTYPE} then size must be 0.
+
+   devmajor and devminor are only valid for typeflag=={BLKTYPE,CHRTYPE}.
+
+   chksum contains the sum of all 512 bytes in the header block,
+   treating each byte as an 8-bit unsigned value and treating the
+   8 bytes of chksum as blank characters.
+
+   uname and gname are used in preference to uid and gid, if those
+   names exist locally.
+
+   Field Name	Byte Offset	Length in Bytes	Field Type
+   name		0		100		NUL-terminated if NUL fits
+   mode		100		8
+   uid		108		8
+   gid		116		8
+   size		124		12
+   mtime	136		12
+   chksum	148		8
+   typeflag	156		1		see below
+   linkname	157		100		NUL-terminated if NUL fits
+   magic	257		6		must be TMAGIC (NUL term.)
+   version	263		2		must be TVERSION
+   uname	265		32		NUL-terminated
+   gname	297		32		NUL-terminated
+   devmajor	329		8
+   devminor	337		8
+   prefix	345		155		NUL-terminated if NUL fits
+
+   If the first character of prefix is '\0', the file name is name;
+   otherwise, it is prefix/name.  Files whose pathnames don't fit in that
+   length can not be stored in a tar archive.  */
+
+/* The bits in mode: */
+#define TSUID	04000
+#define TSGID	02000
+#ifdef __USE_XOPEN
+# define TSVTX	01000
+#endif
+#define TUREAD	00400
+#define TUWRITE	00200
+#define TUEXEC	00100
+#define TGREAD	00040
+#define TGWRITE	00020
+#define TGEXEC	00010
+#define TOREAD	00004
+#define TOWRITE	00002
+#define TOEXEC	00001
+
+/* The values for typeflag:
+   Values 'A'-'Z' are reserved for custom implementations.
+   All other values are reserved for future POSIX.1 revisions.  */
+
+#define REGTYPE		'0'	/* Regular file (preferred code).  */
+#define AREGTYPE	'\0'	/* Regular file (alternate code).  */
+#define LNKTYPE		'1'	/* Hard link.  */
+#define SYMTYPE		'2'	/* Symbolic link (hard if not supported).  */
+#define CHRTYPE		'3'	/* Character special.  */
+#define BLKTYPE		'4'	/* Block special.  */
+#define DIRTYPE		'5'	/* Directory.  */
+#define FIFOTYPE	'6'	/* Named pipe.  */
+#define CONTTYPE	'7'	/* Contiguous file */
+ /* (regular file if not supported).  */
+
+/* Contents of magic field and its length.  */
+#define TMAGIC	"ustar"
+#define TMAGLEN	6
+
+/* Contents of the version field and its length.  */
+#define TVERSION	"00"
+#define TVERSLEN	2
+
+#endif /* tar.h */
diff --git a/include/termios.h b/include/termios.h
new file mode 100644
index 0000000..827ee23
--- /dev/null
+++ b/include/termios.h
@@ -0,0 +1,109 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 7.1-2 General Terminal Interface	<termios.h>
+ */
+
+#ifndef	_TERMIOS_H
+#define	_TERMIOS_H	1
+
+#include <features.h>
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
+/* We need `pid_t'.  */
+# include <bits/types.h>
+# ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#  define __pid_t_defined
+# endif
+#endif
+
+__BEGIN_DECLS
+
+/* Get the system-dependent definitions of `struct termios', `tcflag_t',
+   `cc_t', `speed_t', and all the macros specifying the flag bits.  */
+#include <bits/termios.h>
+
+#ifdef __USE_BSD
+/* Compare a character C to a value VAL from the `c_cc' array in a
+   `struct termios'.  If VAL is _POSIX_VDISABLE, no character can match it.  */
+# define CCEQ(val, c)	((c) == (val) && (val) != _POSIX_VDISABLE)
+#endif
+
+/* Return the output baud rate stored in *TERMIOS_P.  */
+extern speed_t cfgetospeed (const struct termios *__termios_p) __THROW;
+
+/* Return the input baud rate stored in *TERMIOS_P.  */
+extern speed_t cfgetispeed (const struct termios *__termios_p) __THROW;
+
+/* Set the output baud rate stored in *TERMIOS_P to SPEED.  */
+extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __THROW;
+
+/* Set the input baud rate stored in *TERMIOS_P to SPEED.  */
+extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __THROW;
+
+#ifdef	__USE_BSD
+/* Set both the input and output baud rates in *TERMIOS_OP to SPEED.  */
+extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __THROW;
+#endif
+
+
+/* Put the state of FD into *TERMIOS_P.  */
+extern int tcgetattr (int __fd, struct termios *__termios_p) __THROW;
+
+/* Set the state of FD to *TERMIOS_P.
+   Values for OPTIONAL_ACTIONS (TCSA*) are in <bits/termios.h>.  */
+extern int tcsetattr (int __fd, int __optional_actions,
+		      const struct termios *__termios_p) __THROW;
+
+
+#ifdef	__USE_BSD
+/* Set *TERMIOS_P to indicate raw mode.  */
+extern void cfmakeraw (struct termios *__termios_p) __THROW;
+#endif
+
+/* Send zero bits on FD.  */
+extern int tcsendbreak (int __fd, int __duration) __THROW;
+
+/* Wait for pending output to be written on FD.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int tcdrain (int __fd);
+
+/* Flush pending data on FD.
+   Values for QUEUE_SELECTOR (TC{I,O,IO}FLUSH) are in <bits/termios.h>.  */
+extern int tcflush (int __fd, int __queue_selector) __THROW;
+
+/* Suspend or restart transmission on FD.
+   Values for ACTION (TC[IO]{OFF,ON}) are in <bits/termios.h>.  */
+extern int tcflow (int __fd, int __action) __THROW;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
+/* Get process group ID for session leader for controlling terminal FD.  */
+extern __pid_t tcgetsid (int __fd) __THROW;
+#endif
+
+
+#ifdef __USE_BSD
+# include <sys/ttydefaults.h>
+#endif
+
+__END_DECLS
+
+#endif /* termios.h  */
diff --git a/include/tgmath.h b/include/tgmath.h
new file mode 100644
index 0000000..18313b5
--- /dev/null
+++ b/include/tgmath.h
@@ -0,0 +1,454 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.22 Type-generic math	<tgmath.h>
+ */
+
+#ifndef _TGMATH_H
+#define _TGMATH_H	1
+
+/* Include the needed headers.  */
+#include <math.h>
+#include <complex.h>
+
+
+/* Since `complex' is currently not really implemented in most C compilers
+   and if it is implemented, the implementations differ.  This makes it
+   quite difficult to write a generic implementation of this header.  We
+   do not try this for now and instead concentrate only on GNU CC.  Once
+   we have more information support for other compilers might follow.  */
+
+#if __GNUC_PREREQ (2, 7)
+
+# ifdef __NO_LONG_DOUBLE_MATH
+#  define __tgml(fct) fct
+# else
+#  define __tgml(fct) fct ## l
+# endif
+
+/* This is ugly but unless gcc gets appropriate builtins we have to do
+   something like this.  Don't ask how it works.  */
+
+/* 1 if 'type' is a floating type, 0 if 'type' is an integer type.
+   Allows for _Bool.  Expands to an integer constant expression.  */
+# if __GNUC_PREREQ (3, 1)
+#  define __floating_type(type) \
+  (__builtin_classify_type ((type) 0) == 8 \
+   || (__builtin_classify_type ((type) 0) == 9 \
+       && __builtin_classify_type (__real__ ((type) 0)) == 8))
+# else
+#  define __floating_type(type) (((type) 0.25) && ((type) 0.25 - 1))
+# endif
+
+/* The tgmath real type for T, where E is 0 if T is an integer type and
+   1 for a floating type.  */
+# define __tgmath_real_type_sub(T, E) \
+  __typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) (E))) 0	      \
+		  : (__typeof__ (0 ? (T *) 0 : (void *) (!(E)))) 0))
+
+/* The tgmath real type of EXPR.  */
+# define __tgmath_real_type(expr) \
+  __tgmath_real_type_sub (__typeof__ ((__typeof__ (expr)) 0),		      \
+			  __floating_type (__typeof__ (expr)))
+
+
+/* We have two kinds of generic macros: to support functions which are
+   only defined on real valued parameters and those which are defined
+   for complex functions as well.  */
+# define __TGMATH_UNARY_REAL_ONLY(Val, Fct) \
+     (__extension__ ((sizeof (Val) == sizeof (double)			      \
+		      || __builtin_classify_type (Val) != 8)		      \
+		     ? (__tgmath_real_type (Val)) Fct (Val)		      \
+		     : (sizeof (Val) == sizeof (float))			      \
+		     ? (__tgmath_real_type (Val)) Fct##f (Val)		      \
+		     : (__tgmath_real_type (Val)) __tgml(Fct) (Val)))
+
+# define __TGMATH_UNARY_REAL_RET_ONLY(Val, RetType, Fct) \
+     (__extension__ ((sizeof (Val) == sizeof (double)			      \
+		      || __builtin_classify_type (Val) != 8)		      \
+		     ? (RetType) Fct (Val)				      \
+		     : (sizeof (Val) == sizeof (float))			      \
+		     ? (RetType) Fct##f (Val)				      \
+		     : (RetType) __tgml(Fct) (Val)))
+
+# define __TGMATH_BINARY_FIRST_REAL_ONLY(Val1, Val2, Fct) \
+     (__extension__ ((sizeof (Val1) == sizeof (double)			      \
+		      || __builtin_classify_type (Val1) != 8)		      \
+		     ? (__tgmath_real_type (Val1)) Fct (Val1, Val2)	      \
+		     : (sizeof (Val1) == sizeof (float))		      \
+		     ? (__tgmath_real_type (Val1)) Fct##f (Val1, Val2)	      \
+		     : (__tgmath_real_type (Val1)) __tgml(Fct) (Val1, Val2)))
+
+# define __TGMATH_BINARY_REAL_ONLY(Val1, Val2, Fct) \
+     (__extension__ (((sizeof (Val1) > sizeof (double)			      \
+		       || sizeof (Val2) > sizeof (double))		      \
+		      && __builtin_classify_type ((Val1) + (Val2)) == 8)      \
+		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+		       __tgml(Fct) (Val1, Val2)				      \
+		     : (sizeof (Val1) == sizeof (double)		      \
+			|| sizeof (Val2) == sizeof (double)		      \
+			|| __builtin_classify_type (Val1) != 8		      \
+			|| __builtin_classify_type (Val2) != 8)		      \
+		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+		       Fct (Val1, Val2)					      \
+		     : (__typeof ((__tgmath_real_type (Val1)) 0		      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+		       Fct##f (Val1, Val2)))
+
+# define __TGMATH_TERNARY_FIRST_SECOND_REAL_ONLY(Val1, Val2, Val3, Fct) \
+     (__extension__ (((sizeof (Val1) > sizeof (double)			      \
+		       || sizeof (Val2) > sizeof (double))		      \
+		      && __builtin_classify_type ((Val1) + (Val2)) == 8)      \
+		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+		       __tgml(Fct) (Val1, Val2, Val3)			      \
+		     : (sizeof (Val1) == sizeof (double)		      \
+			|| sizeof (Val2) == sizeof (double)		      \
+			|| __builtin_classify_type (Val1) != 8		      \
+			|| __builtin_classify_type (Val2) != 8)		      \
+		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+		       Fct (Val1, Val2, Val3)				      \
+		     : (__typeof ((__tgmath_real_type (Val1)) 0		      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+		       Fct##f (Val1, Val2, Val3)))
+
+# define __TGMATH_TERNARY_REAL_ONLY(Val1, Val2, Val3, Fct) \
+     (__extension__ (((sizeof (Val1) > sizeof (double)			      \
+		       || sizeof (Val2) > sizeof (double)		      \
+		       || sizeof (Val3) > sizeof (double))		      \
+		      && __builtin_classify_type ((Val1) + (Val2) + (Val3))   \
+			 == 8)						      \
+		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
+				   + (__tgmath_real_type (Val2)) 0	      \
+				   + (__tgmath_real_type (Val3)) 0))	      \
+		       __tgml(Fct) (Val1, Val2, Val3)			      \
+		     : (sizeof (Val1) == sizeof (double)		      \
+			|| sizeof (Val2) == sizeof (double)		      \
+			|| sizeof (Val3) == sizeof (double)		      \
+			|| __builtin_classify_type (Val1) != 8		      \
+			|| __builtin_classify_type (Val2) != 8		      \
+			|| __builtin_classify_type (Val3) != 8)		      \
+		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
+				   + (__tgmath_real_type (Val2)) 0	      \
+				   + (__tgmath_real_type (Val3)) 0))	      \
+		       Fct (Val1, Val2, Val3)				      \
+		     : (__typeof ((__tgmath_real_type (Val1)) 0		      \
+				   + (__tgmath_real_type (Val2)) 0	      \
+				   + (__tgmath_real_type (Val3)) 0))	      \
+		       Fct##f (Val1, Val2, Val3)))
+
+/* XXX This definition has to be changed as soon as the compiler understands
+   the imaginary keyword.  */
+# define __TGMATH_UNARY_REAL_IMAG(Val, Fct, Cfct) \
+     (__extension__ ((sizeof (__real__ (Val)) == sizeof (double)	      \
+		      || __builtin_classify_type (__real__ (Val)) != 8)	      \
+		     ? ((sizeof (__real__ (Val)) == sizeof (Val))	      \
+			? (__tgmath_real_type (Val)) Fct (Val)		      \
+			: (__tgmath_real_type (Val)) Cfct (Val))	      \
+		     : (sizeof (__real__ (Val)) == sizeof (float))	      \
+		     ? ((sizeof (__real__ (Val)) == sizeof (Val))	      \
+			? (__tgmath_real_type (Val)) Fct##f (Val)	      \
+			: (__tgmath_real_type (Val)) Cfct##f (Val))	      \
+		     : ((sizeof (__real__ (Val)) == sizeof (Val))	      \
+			? (__tgmath_real_type (Val)) __tgml(Fct) (Val)	      \
+			: (__tgmath_real_type (Val)) __tgml(Cfct) (Val))))
+
+# define __TGMATH_UNARY_IMAG(Val, Cfct) \
+     (__extension__ ((sizeof (__real__ (Val)) == sizeof (double)	      \
+		      || __builtin_classify_type (__real__ (Val)) != 8)	      \
+		     ? (__typeof__ ((__tgmath_real_type (Val)) 0	      \
+				    + _Complex_I)) Cfct (Val)		      \
+		     : (sizeof (__real__ (Val)) == sizeof (float))	      \
+		     ? (__typeof__ ((__tgmath_real_type (Val)) 0	      \
+				    + _Complex_I)) Cfct##f (Val)	      \
+		     : (__typeof__ ((__tgmath_real_type (Val)) 0	      \
+				    + _Complex_I)) __tgml(Cfct) (Val)))
+
+/* XXX This definition has to be changed as soon as the compiler understands
+   the imaginary keyword.  */
+# define __TGMATH_UNARY_REAL_IMAG_RET_REAL(Val, Fct, Cfct) \
+     (__extension__ ((sizeof (__real__ (Val)) == sizeof (double)	      \
+		      || __builtin_classify_type (__real__ (Val)) != 8)	      \
+		     ? ((sizeof (__real__ (Val)) == sizeof (Val))	      \
+			? (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
+			  Fct (Val)					      \
+			: (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
+			  Cfct (Val))					      \
+		     : (sizeof (__real__ (Val)) == sizeof (float))	      \
+		     ? ((sizeof (__real__ (Val)) == sizeof (Val))	      \
+			? (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
+			  Fct##f (Val)					      \
+			: (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
+			  Cfct##f (Val))				      \
+		     : ((sizeof (__real__ (Val)) == sizeof (Val))	      \
+			? (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
+			  __tgml(Fct) (Val)				      \
+			: (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
+			  __tgml(Cfct) (Val))))
+
+/* XXX This definition has to be changed as soon as the compiler understands
+   the imaginary keyword.  */
+# define __TGMATH_BINARY_REAL_IMAG(Val1, Val2, Fct, Cfct) \
+     (__extension__ (((sizeof (__real__ (Val1)) > sizeof (double)	      \
+		       || sizeof (__real__ (Val2)) > sizeof (double))	      \
+		      && __builtin_classify_type (__real__ (Val1)	      \
+						  + __real__ (Val2)) == 8)    \
+		     ? ((sizeof (__real__ (Val1)) == sizeof (Val1)	      \
+			 && sizeof (__real__ (Val2)) == sizeof (Val2))	      \
+			? (__typeof ((__tgmath_real_type (Val1)) 0	      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+			  __tgml(Fct) (Val1, Val2)			      \
+			: (__typeof ((__tgmath_real_type (Val1)) 0	      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+			  __tgml(Cfct) (Val1, Val2))			      \
+		     : (sizeof (__real__ (Val1)) == sizeof (double)	      \
+			|| sizeof (__real__ (Val2)) == sizeof (double)	      \
+			|| __builtin_classify_type (__real__ (Val1)) != 8     \
+			|| __builtin_classify_type (__real__ (Val2)) != 8)    \
+		     ? ((sizeof (__real__ (Val1)) == sizeof (Val1)	      \
+			 && sizeof (__real__ (Val2)) == sizeof (Val2))	      \
+			? (__typeof ((__tgmath_real_type (Val1)) 0	      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+			  Fct (Val1, Val2)				      \
+			: (__typeof ((__tgmath_real_type (Val1)) 0	      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+			  Cfct (Val1, Val2))				      \
+		     : ((sizeof (__real__ (Val1)) == sizeof (Val1)	      \
+			 && sizeof (__real__ (Val2)) == sizeof (Val2))	      \
+			? (__typeof ((__tgmath_real_type (Val1)) 0	      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+			  Fct##f (Val1, Val2)				      \
+			: (__typeof ((__tgmath_real_type (Val1)) 0	      \
+				   + (__tgmath_real_type (Val2)) 0))	      \
+			  Cfct##f (Val1, Val2))))
+#else
+# error "Unsupported compiler; you cannot use <tgmath.h>"
+#endif
+
+
+/* Unary functions defined for real and complex values.  */
+
+
+/* Trigonometric functions.  */
+
+/* Arc cosine of X.  */
+#define acos(Val) __TGMATH_UNARY_REAL_IMAG (Val, acos, cacos)
+/* Arc sine of X.  */
+#define asin(Val) __TGMATH_UNARY_REAL_IMAG (Val, asin, casin)
+/* Arc tangent of X.  */
+#define atan(Val) __TGMATH_UNARY_REAL_IMAG (Val, atan, catan)
+/* Arc tangent of Y/X.  */
+#define atan2(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, atan2)
+
+/* Cosine of X.  */
+#define cos(Val) __TGMATH_UNARY_REAL_IMAG (Val, cos, ccos)
+/* Sine of X.  */
+#define sin(Val) __TGMATH_UNARY_REAL_IMAG (Val, sin, csin)
+/* Tangent of X.  */
+#define tan(Val) __TGMATH_UNARY_REAL_IMAG (Val, tan, ctan)
+
+
+/* Hyperbolic functions.  */
+
+/* Hyperbolic arc cosine of X.  */
+#define acosh(Val) __TGMATH_UNARY_REAL_IMAG (Val, acosh, cacosh)
+/* Hyperbolic arc sine of X.  */
+#define asinh(Val) __TGMATH_UNARY_REAL_IMAG (Val, asinh, casinh)
+/* Hyperbolic arc tangent of X.  */
+#define atanh(Val) __TGMATH_UNARY_REAL_IMAG (Val, atanh, catanh)
+
+/* Hyperbolic cosine of X.  */
+#define cosh(Val) __TGMATH_UNARY_REAL_IMAG (Val, cosh, ccosh)
+/* Hyperbolic sine of X.  */
+#define sinh(Val) __TGMATH_UNARY_REAL_IMAG (Val, sinh, csinh)
+/* Hyperbolic tangent of X.  */
+#define tanh(Val) __TGMATH_UNARY_REAL_IMAG (Val, tanh, ctanh)
+
+
+/* Exponential and logarithmic functions.  */
+
+/* Exponential function of X.  */
+#define exp(Val) __TGMATH_UNARY_REAL_IMAG (Val, exp, cexp)
+
+/* Break VALUE into a normalized fraction and an integral power of 2.  */
+#define frexp(Val1, Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, frexp)
+
+/* X times (two to the EXP power).  */
+#define ldexp(Val1, Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, ldexp)
+
+/* Natural logarithm of X.  */
+#define log(Val) __TGMATH_UNARY_REAL_IMAG (Val, log, clog)
+
+/* Base-ten logarithm of X.  */
+#ifdef __USE_GNU
+# define log10(Val) __TGMATH_UNARY_REAL_IMAG (Val, log10, __clog10)
+#else
+# define log10(Val) __TGMATH_UNARY_REAL_ONLY (Val, log10)
+#endif
+
+/* Return exp(X) - 1.  */
+#define expm1(Val) __TGMATH_UNARY_REAL_ONLY (Val, expm1)
+
+/* Return log(1 + X).  */
+#define log1p(Val) __TGMATH_UNARY_REAL_ONLY (Val, log1p)
+
+/* Return the base 2 signed integral exponent of X.  */
+#define logb(Val) __TGMATH_UNARY_REAL_ONLY (Val, logb)
+
+/* Compute base-2 exponential of X.  */
+#define exp2(Val) __TGMATH_UNARY_REAL_ONLY (Val, exp2)
+
+/* Compute base-2 logarithm of X.  */
+#define log2(Val) __TGMATH_UNARY_REAL_ONLY (Val, log2)
+
+
+/* Power functions.  */
+
+/* Return X to the Y power.  */
+#define pow(Val1, Val2) __TGMATH_BINARY_REAL_IMAG (Val1, Val2, pow, cpow)
+
+/* Return the square root of X.  */
+#define sqrt(Val) __TGMATH_UNARY_REAL_IMAG (Val, sqrt, csqrt)
+
+/* Return `sqrt(X*X + Y*Y)'.  */
+#define hypot(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, hypot)
+
+/* Return the cube root of X.  */
+#define cbrt(Val) __TGMATH_UNARY_REAL_ONLY (Val, cbrt)
+
+
+/* Nearest integer, absolute value, and remainder functions.  */
+
+/* Smallest integral value not less than X.  */
+#define ceil(Val) __TGMATH_UNARY_REAL_ONLY (Val, ceil)
+
+/* Absolute value of X.  */
+#define fabs(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL (Val, fabs, cabs)
+
+/* Largest integer not greater than X.  */
+#define floor(Val) __TGMATH_UNARY_REAL_ONLY (Val, floor)
+
+/* Floating-point modulo remainder of X/Y.  */
+#define fmod(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmod)
+
+/* Round X to integral valuein floating-point format using current
+   rounding direction, but do not raise inexact exception.  */
+#define nearbyint(Val) __TGMATH_UNARY_REAL_ONLY (Val, nearbyint)
+
+/* Round X to nearest integral value, rounding halfway cases away from
+   zero.  */
+#define round(Val) __TGMATH_UNARY_REAL_ONLY (Val, round)
+
+/* Round X to the integral value in floating-point format nearest but
+   not larger in magnitude.  */
+#define trunc(Val) __TGMATH_UNARY_REAL_ONLY (Val, trunc)
+
+/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
+   and magnitude congruent `mod 2^n' to the magnitude of the integral
+   quotient x/y, with n >= 3.  */
+#define remquo(Val1, Val2, Val3) \
+     __TGMATH_TERNARY_FIRST_SECOND_REAL_ONLY (Val1, Val2, Val3, remquo)
+
+/* Round X to nearest integral value according to current rounding
+   direction.  */
+#define lrint(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, long int, lrint)
+#define llrint(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, long long int, llrint)
+
+/* Round X to nearest integral value, rounding halfway cases away from
+   zero.  */
+#define lround(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, long int, lround)
+#define llround(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, long long int, llround)
+
+
+/* Return X with its signed changed to Y's.  */
+#define copysign(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, copysign)
+
+/* Error and gamma functions.  */
+#define erf(Val) __TGMATH_UNARY_REAL_ONLY (Val, erf)
+#define erfc(Val) __TGMATH_UNARY_REAL_ONLY (Val, erfc)
+#define tgamma(Val) __TGMATH_UNARY_REAL_ONLY (Val, tgamma)
+#define lgamma(Val) __TGMATH_UNARY_REAL_ONLY (Val, lgamma)
+
+
+/* Return the integer nearest X in the direction of the
+   prevailing rounding mode.  */
+#define rint(Val) __TGMATH_UNARY_REAL_ONLY (Val, rint)
+
+/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
+#define nextafter(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, nextafter)
+#define nexttoward(Val1, Val2) \
+     __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, nexttoward)
+
+/* Return the remainder of integer divison X / Y with infinite precision.  */
+#define remainder(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, remainder)
+
+/* Return X times (2 to the Nth power).  */
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED
+# define scalb(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, scalb)
+#endif
+
+/* Return X times (2 to the Nth power).  */
+#define scalbn(Val1, Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, scalbn)
+
+/* Return X times (2 to the Nth power).  */
+#define scalbln(Val1, Val2) \
+     __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, scalbln)
+
+/* Return the binary exponent of X, which must be nonzero.  */
+#define ilogb(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, int, ilogb)
+
+
+/* Return positive difference between X and Y.  */
+#define fdim(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fdim)
+
+/* Return maximum numeric value from X and Y.  */
+#define fmax(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmax)
+
+/* Return minimum numeric value from X and Y.  */
+#define fmin(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmin)
+
+
+/* Multiply-add function computed as a ternary operation.  */
+#define fma(Val1, Val2, Val3) \
+     __TGMATH_TERNARY_REAL_ONLY (Val1, Val2, Val3, fma)
+
+
+/* Absolute value, conjugates, and projection.  */
+
+/* Argument value of Z.  */
+#define carg(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL (Val, carg, carg)
+
+/* Complex conjugate of Z.  */
+#define conj(Val) __TGMATH_UNARY_IMAG (Val, conj)
+
+/* Projection of Z onto the Riemann sphere.  */
+#define cproj(Val) __TGMATH_UNARY_IMAG (Val, cproj)
+
+
+/* Decomposing complex values.  */
+
+/* Imaginary part of Z.  */
+#define cimag(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL (Val, cimag, cimag)
+
+/* Real part of Z.  */
+#define creal(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL (Val, creal, creal)
+
+#endif /* tgmath.h */
diff --git a/include/time.h b/include/time.h
new file mode 100644
index 0000000..9777dd9
--- /dev/null
+++ b/include/time.h
@@ -0,0 +1,434 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.23 Date and time	<time.h>
+ */
+
+#ifndef	_TIME_H
+
+#if (! defined __need_time_t && !defined __need_clock_t && \
+     ! defined __need_timespec)
+# define _TIME_H	1
+# include <features.h>
+
+__BEGIN_DECLS
+
+#endif
+
+#ifdef	_TIME_H
+/* Get size_t and NULL from <stddef.h>.  */
+# define __need_size_t
+# define __need_NULL
+# include <stddef.h>
+
+/* This defines CLOCKS_PER_SEC, which is the number of processor clock
+   ticks per second.  */
+# include <bits/time.h>
+
+/* This is the obsolete POSIX.1-1988 name for the same constant.  */
+# if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
+#  ifndef CLK_TCK
+#   define CLK_TCK	CLOCKS_PER_SEC
+#  endif
+# endif
+
+#endif /* <time.h> included.  */
+
+#if !defined __clock_t_defined && (defined _TIME_H || defined __need_clock_t)
+# define __clock_t_defined	1
+
+# include <bits/types.h>
+
+__BEGIN_NAMESPACE_STD
+/* Returned by `clock'.  */
+typedef __clock_t clock_t;
+__END_NAMESPACE_STD
+#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
+__USING_NAMESPACE_STD(clock_t)
+#endif
+
+#endif /* clock_t not defined and <time.h> or need clock_t.  */
+#undef	__need_clock_t
+
+#if !defined __time_t_defined && (defined _TIME_H || defined __need_time_t)
+# define __time_t_defined	1
+
+# include <bits/types.h>
+
+__BEGIN_NAMESPACE_STD
+/* Returned by `time'.  */
+typedef __time_t time_t;
+__END_NAMESPACE_STD
+#if defined __USE_POSIX || defined __USE_MISC || defined __USE_SVID
+__USING_NAMESPACE_STD(time_t)
+#endif
+
+#endif /* time_t not defined and <time.h> or need time_t.  */
+#undef	__need_time_t
+
+#if !defined __clockid_t_defined && \
+   ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_clockid_t)
+# define __clockid_t_defined	1
+
+# include <bits/types.h>
+
+/* Clock ID used in clock and timer functions.  */
+typedef __clockid_t clockid_t;
+
+#endif /* clockid_t not defined and <time.h> or need clockid_t.  */
+#undef	__clockid_time_t
+
+#if !defined __timer_t_defined && \
+    ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_timer_t)
+# define __timer_t_defined	1
+
+# include <bits/types.h>
+
+/* Timer ID returned by `timer_create'.  */
+typedef __timer_t timer_t;
+
+#endif /* timer_t not defined and <time.h> or need timer_t.  */
+#undef	__need_timer_t
+
+
+#if (!defined __timespec_defined					\
+     && ((defined _TIME_H						\
+	  && (defined __USE_POSIX199309 || defined __USE_MISC		\
+	      || defined __USE_ISOC11))					\
+	 || defined __need_timespec))
+# define __timespec_defined	1
+
+# include <bits/types.h>	/* This defines __time_t for us.  */
+
+/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
+   has nanoseconds instead of microseconds.  */
+struct timespec
+  {
+    __time_t tv_sec;		/* Seconds.  */
+    __syscall_slong_t tv_nsec;	/* Nanoseconds.  */
+  };
+
+#endif /* timespec not defined and <time.h> or need timespec.  */
+#undef	__need_timespec
+
+
+#ifdef	_TIME_H
+__BEGIN_NAMESPACE_STD
+/* Used by other time functions.  */
+struct tm
+{
+  int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
+  int tm_min;			/* Minutes.	[0-59] */
+  int tm_hour;			/* Hours.	[0-23] */
+  int tm_mday;			/* Day.		[1-31] */
+  int tm_mon;			/* Month.	[0-11] */
+  int tm_year;			/* Year	- 1900.  */
+  int tm_wday;			/* Day of week.	[0-6] */
+  int tm_yday;			/* Days in year.[0-365]	*/
+  int tm_isdst;			/* DST.		[-1/0/1]*/
+
+# ifdef	__USE_BSD
+  long int tm_gmtoff;		/* Seconds east of UTC.  */
+  const char *tm_zone;		/* Timezone abbreviation.  */
+# else
+  long int __tm_gmtoff;		/* Seconds east of UTC.  */
+  const char *__tm_zone;	/* Timezone abbreviation.  */
+# endif
+};
+__END_NAMESPACE_STD
+#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
+__USING_NAMESPACE_STD(tm)
+#endif
+
+
+# ifdef __USE_POSIX199309
+/* POSIX.1b structure for timer start values and intervals.  */
+struct itimerspec
+  {
+    struct timespec it_interval;
+    struct timespec it_value;
+  };
+
+/* We can use a simple forward declaration.  */
+struct sigevent;
+
+# endif	/* POSIX.1b */
+
+# ifdef __USE_XOPEN2K
+#  ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#   define __pid_t_defined
+#  endif
+# endif
+
+
+# ifdef __USE_ISOC11
+/* Time base values for timespec_get.  */
+# define TIME_UTC 1
+# endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Time used by the program so far (user time + system time).
+   The result / CLOCKS_PER_SECOND is program time in seconds.  */
+extern clock_t clock (void) __THROW;
+
+/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
+extern time_t time (time_t *__timer) __THROW;
+
+/* Return the difference between TIME1 and TIME0.  */
+extern double difftime (time_t __time1, time_t __time0)
+     __THROW __attribute__ ((__const__));
+
+/* Return the `time_t' representation of TP and normalize TP.  */
+extern time_t mktime (struct tm *__tp) __THROW;
+
+
+/* Format TP into S according to FORMAT.
+   Write no more than MAXSIZE characters and return the number
+   of characters written, or 0 if it would exceed MAXSIZE.  */
+extern size_t strftime (char *__restrict __s, size_t __maxsize,
+			const char *__restrict __format,
+			const struct tm *__restrict __tp) __THROW;
+__END_NAMESPACE_STD
+
+# ifdef __USE_XOPEN
+/* Parse S according to FORMAT and store binary time information in TP.
+   The return value is a pointer to the first unparsed character in S.  */
+extern char *strptime (const char *__restrict __s,
+		       const char *__restrict __fmt, struct tm *__tp)
+     __THROW;
+# endif
+
+# ifdef __USE_XOPEN2K8
+/* Similar to the two functions above but take the information from
+   the provided locale and not the global locale.  */
+# include <xlocale.h>
+
+extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
+			  const char *__restrict __format,
+			  const struct tm *__restrict __tp,
+			  __locale_t __loc) __THROW;
+# endif
+
+# ifdef __USE_GNU
+extern char *strptime_l (const char *__restrict __s,
+			 const char *__restrict __fmt, struct tm *__tp,
+			 __locale_t __loc) __THROW;
+# endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Return the `struct tm' representation of *TIMER
+   in Universal Coordinated Time (aka Greenwich Mean Time).  */
+extern struct tm *gmtime (const time_t *__timer) __THROW;
+
+/* Return the `struct tm' representation
+   of *TIMER in the local timezone.  */
+extern struct tm *localtime (const time_t *__timer) __THROW;
+__END_NAMESPACE_STD
+
+# if defined __USE_POSIX || defined __USE_MISC
+/* Return the `struct tm' representation of *TIMER in UTC,
+   using *TP to store the result.  */
+extern struct tm *gmtime_r (const time_t *__restrict __timer,
+			    struct tm *__restrict __tp) __THROW;
+
+/* Return the `struct tm' representation of *TIMER in local time,
+   using *TP to store the result.  */
+extern struct tm *localtime_r (const time_t *__restrict __timer,
+			       struct tm *__restrict __tp) __THROW;
+# endif	/* POSIX or misc */
+
+__BEGIN_NAMESPACE_STD
+/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
+   that is the representation of TP in this format.  */
+extern char *asctime (const struct tm *__tp) __THROW;
+
+/* Equivalent to `asctime (localtime (timer))'.  */
+extern char *ctime (const time_t *__timer) __THROW;
+__END_NAMESPACE_STD
+
+# if defined __USE_POSIX || defined __USE_MISC
+/* Reentrant versions of the above functions.  */
+
+/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
+   that is the representation of TP in this format.  */
+extern char *asctime_r (const struct tm *__restrict __tp,
+			char *__restrict __buf) __THROW;
+
+/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
+extern char *ctime_r (const time_t *__restrict __timer,
+		      char *__restrict __buf) __THROW;
+# endif	/* POSIX or misc */
+
+
+/* Defined in localtime.c.  */
+extern char *__tzname[2];	/* Current timezone names.  */
+extern int __daylight;		/* If daylight-saving time is ever in use.  */
+extern long int __timezone;	/* Seconds west of UTC.  */
+
+
+# ifdef	__USE_POSIX
+/* Same as above.  */
+extern char *tzname[2];
+
+/* Set time conversion information from the TZ environment variable.
+   If TZ is not defined, a locale-dependent default is used.  */
+extern void tzset (void) __THROW;
+# endif
+
+# if defined __USE_SVID || defined __USE_XOPEN
+extern int daylight;
+extern long int timezone;
+# endif
+
+# ifdef __USE_SVID
+/* Set the system time to *WHEN.
+   This call is restricted to the superuser.  */
+extern int stime (const time_t *__when) __THROW;
+# endif
+
+
+/* Nonzero if YEAR is a leap year (every 4 years,
+   except every 100th isn't, and every 400th is).  */
+# define __isleap(year)	\
+  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+
+
+# ifdef __USE_MISC
+/* Miscellaneous functions many Unices inherited from the public domain
+   localtime package.  These are included only for compatibility.  */
+
+/* Like `mktime', but for TP represents Universal Time, not local time.  */
+extern time_t timegm (struct tm *__tp) __THROW;
+
+/* Another name for `mktime'.  */
+extern time_t timelocal (struct tm *__tp) __THROW;
+
+/* Return the number of days in YEAR.  */
+extern int dysize (int __year) __THROW  __attribute__ ((__const__));
+# endif
+
+
+# ifdef __USE_POSIX199309
+/* Pause execution for a number of nanoseconds.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int nanosleep (const struct timespec *__requested_time,
+		      struct timespec *__remaining);
+
+
+/* Get resolution of clock CLOCK_ID.  */
+extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __THROW;
+
+/* Get current value of clock CLOCK_ID and store it in TP.  */
+extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __THROW;
+
+/* Set clock CLOCK_ID to value TP.  */
+extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
+     __THROW;
+
+#  ifdef __USE_XOPEN2K
+/* High-resolution sleep with the specified clock.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int clock_nanosleep (clockid_t __clock_id, int __flags,
+			    const struct timespec *__req,
+			    struct timespec *__rem);
+
+/* Return clock ID for CPU-time clock.  */
+extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __THROW;
+#  endif
+
+
+/* Create new per-process timer using CLOCK_ID.  */
+extern int timer_create (clockid_t __clock_id,
+			 struct sigevent *__restrict __evp,
+			 timer_t *__restrict __timerid) __THROW;
+
+/* Delete timer TIMERID.  */
+extern int timer_delete (timer_t __timerid) __THROW;
+
+/* Set timer TIMERID to VALUE, returning old value in OVALUE.  */
+extern int timer_settime (timer_t __timerid, int __flags,
+			  const struct itimerspec *__restrict __value,
+			  struct itimerspec *__restrict __ovalue) __THROW;
+
+/* Get current value of timer TIMERID and store it in VALUE.  */
+extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
+     __THROW;
+
+/* Get expiration overrun for timer TIMERID.  */
+extern int timer_getoverrun (timer_t __timerid) __THROW;
+# endif
+
+
+# ifdef __USE_ISOC11
+/* Set TS to calendar time based in time base BASE.  */
+extern int timespec_get (struct timespec *__ts, int __base)
+     __THROW __nonnull ((1));
+# endif
+
+
+# ifdef __USE_XOPEN_EXTENDED
+/* Set to one of the following values to indicate an error.
+     1  the DATEMSK environment variable is null or undefined,
+     2  the template file cannot be opened for reading,
+     3  failed to get file status information,
+     4  the template file is not a regular file,
+     5  an error is encountered while reading the template file,
+     6  memory allication failed (not enough memory available),
+     7  there is no line in the template that matches the input,
+     8  invalid input specification Example: February 31 or a time is
+	specified that can not be represented in a time_t (representing
+	the time in seconds since 00:00:00 UTC, January 1, 1970) */
+extern int getdate_err;
+
+/* Parse the given string as a date specification and return a value
+   representing the value.  The templates from the file identified by
+   the environment variable DATEMSK are used.  In case of an error
+   `getdate_err' is set.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct tm *getdate (const char *__string);
+# endif
+
+# ifdef __USE_GNU
+/* Since `getdate' is not reentrant because of the use of `getdate_err'
+   and the static buffer to return the result in, we provide a thread-safe
+   variant.  The functionality is the same.  The result is returned in
+   the buffer pointed to by RESBUFP and in case of an error the return
+   value is != 0 with the same values as given above for `getdate_err'.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int getdate_r (const char *__restrict __string,
+		      struct tm *__restrict __resbufp);
+# endif
+
+__END_DECLS
+
+#endif /* <time.h> included.  */
+
+#endif /* <time.h> not already included.  */
diff --git a/include/ttyent.h b/include/ttyent.h
new file mode 100644
index 0000000..fe418a5
--- /dev/null
+++ b/include/ttyent.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ttyent.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef	_TTYENT_H
+#define	_TTYENT_H	1
+
+#include <features.h>
+
+#define	_PATH_TTYS	"/etc/ttys"
+
+#define	_TTYS_OFF	"off"
+#define	_TTYS_ON	"on"
+#define	_TTYS_SECURE	"secure"
+#define	_TTYS_WINDOW	"window"
+
+struct ttyent {
+	char	*ty_name;	/* terminal device name */
+	char	*ty_getty;	/* command to execute, usually getty */
+	char	*ty_type;	/* terminal type for termcap */
+#define	TTY_ON		0x01	/* enable logins (start ty_getty program) */
+#define	TTY_SECURE	0x02	/* allow uid of 0 to login */
+	int	ty_status;	/* status flags */
+	char 	*ty_window;	/* command to start up window manager */
+	char	*ty_comment;	/* comment field */
+};
+
+
+__BEGIN_DECLS
+
+extern struct ttyent *getttyent (void) __THROW;
+extern struct ttyent *getttynam (const char *__tty) __THROW;
+extern int setttyent (void) __THROW;
+extern int endttyent (void) __THROW;
+
+__END_DECLS
+
+#endif /* ttyent.h */
diff --git a/include/uchar.h b/include/uchar.h
new file mode 100644
index 0000000..c12d77e
--- /dev/null
+++ b/include/uchar.h
@@ -0,0 +1,83 @@
+/* Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *      ISO C11 Standard: 7.28
+ *	Unicode utilities	<uchar.h>
+ */
+
+#ifndef _UCHAR_H
+#define _UCHAR_H	1
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+#define __need_mbstate_t
+#include <wchar.h>
+
+#ifndef __mbstate_t_defined
+__BEGIN_NAMESPACE_C99
+/* Public type.  */
+typedef __mbstate_t mbstate_t;
+__END_NAMESPACE_C99
+# define __mbstate_t_defined 1
+#endif
+
+
+#if defined __GNUC__ && !defined __USE_ISOCXX11
+/* Define the 16-bit and 32-bit character types.  Use the information
+   provided by the compiler.  */
+# if !defined __CHAR16_TYPE__ || !defined __CHAR32_TYPE__
+#  if defined __STDC_VERSION__ && __STDC_VERSION__ < 201000L
+#   error "<uchar.h> requires ISO C11 mode"
+#  else
+#   error "definitions of __CHAR16_TYPE__ and/or __CHAR32_TYPE__ missing"
+#  endif
+# endif
+typedef __CHAR16_TYPE__ char16_t;
+typedef __CHAR32_TYPE__ char32_t;
+#endif
+
+
+__BEGIN_DECLS
+
+/* Write char16_t representation of multibyte character pointed
+   to by S to PC16.  */
+extern size_t mbrtoc16 (char16_t *__restrict __pc16,
+			const char *__restrict __s, size_t __n,
+			mbstate_t *__restrict __p) __THROW;
+
+/* Write multibyte representation of char16_t C16 to S.  */
+extern size_t c16rtomb (char *__restrict __s, char16_t __c16,
+			mbstate_t *__restrict __ps) __THROW;
+
+
+
+/* Write char32_t representation of multibyte character pointed
+   to by S to PC32.  */
+extern size_t mbrtoc32 (char32_t *__restrict __pc32,
+			const char *__restrict __s, size_t __n,
+			mbstate_t *__restrict __p) __THROW;
+
+/* Write multibyte representation of char32_t C32 to S.  */
+extern size_t c32rtomb (char *__restrict __s, char32_t __c32,
+			mbstate_t *__restrict __ps) __THROW;
+
+__END_DECLS
+
+#endif	/* uchar.h */
diff --git a/include/ucontext.h b/include/ucontext.h
new file mode 100644
index 0000000..209ce31
--- /dev/null
+++ b/include/ucontext.h
@@ -0,0 +1,52 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* System V ABI compliant user-level context switching support.  */
+
+#ifndef _UCONTEXT_H
+#define _UCONTEXT_H	1
+
+#include <features.h>
+
+/* Get machine dependent definition of data structures.  */
+#include <sys/ucontext.h>
+
+__BEGIN_DECLS
+
+/* Get user context and store it in variable pointed to by UCP.  */
+extern int getcontext (ucontext_t *__ucp) __THROWNL;
+
+/* Set user context from information of variable pointed to by UCP.  */
+extern int setcontext (const ucontext_t *__ucp) __THROWNL;
+
+/* Save current context in context variable pointed to by OUCP and set
+   context from variable pointed to by UCP.  */
+extern int swapcontext (ucontext_t *__restrict __oucp,
+			const ucontext_t *__restrict __ucp) __THROWNL;
+
+/* Manipulate user context UCP to continue with calling functions FUNC
+   and the ARGC-1 parameters following ARGC when the context is used
+   the next time in `setcontext' or `swapcontext'.
+
+   We cannot say anything about the parameters FUNC takes; `void'
+   is as good as any other choice.  */
+extern void makecontext (ucontext_t *__ucp, void (*__func) (void),
+			 int __argc, ...) __THROW;
+
+__END_DECLS
+
+#endif /* ucontext.h */
diff --git a/include/ulimit.h b/include/ulimit.h
new file mode 100644
index 0000000..2d01aeb
--- /dev/null
+++ b/include/ulimit.h
@@ -0,0 +1,47 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ULIMIT_H
+#define _ULIMIT_H	1
+
+#include <features.h>
+
+/* Constants used as the first parameter for `ulimit'.  They denote limits
+   which can be set or retrieved using this function.  */
+enum
+{
+  UL_GETFSIZE = 1,			/* Return limit on the size of a file,
+					   in units of 512 bytes.  */
+#define UL_GETFSIZE	UL_GETFSIZE
+  UL_SETFSIZE,				/* Set limit on the size of a file to
+					   second argument.  */
+#define UL_SETFSIZE	UL_SETFSIZE
+  __UL_GETMAXBRK,			/* Return the maximum possible address
+					   of the data segment.  */
+  __UL_GETOPENMAX			/* Return the maximum number of files
+					   that the calling process can open.*/
+};
+
+
+__BEGIN_DECLS
+
+/* Control process limits according to CMD.  */
+extern long int ulimit (int __cmd, ...) __THROW;
+
+__END_DECLS
+
+#endif /* ulimit.h */
diff --git a/include/unistd.h b/include/unistd.h
new file mode 100644
index 0000000..64734b0
--- /dev/null
+++ b/include/unistd.h
@@ -0,0 +1,1153 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
+ */
+
+#ifndef	_UNISTD_H
+#define	_UNISTD_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* These may be used to determine what facilities are present at compile time.
+   Their values can be obtained at run time from `sysconf'.  */
+
+#ifdef __USE_XOPEN2K8
+/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */
+# define _POSIX_VERSION	200809L
+#elif defined __USE_XOPEN2K
+/* POSIX Standard approved as ISO/IEC 9945-1 as of December 2001.  */
+# define _POSIX_VERSION	200112L
+#elif defined __USE_POSIX199506
+/* POSIX Standard approved as ISO/IEC 9945-1 as of June 1995.  */
+# define _POSIX_VERSION	199506L
+#elif defined __USE_POSIX199309
+/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1993.  */
+# define _POSIX_VERSION	199309L
+#else
+/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1990.  */
+# define _POSIX_VERSION	199009L
+#endif
+
+/* These are not #ifdef __USE_POSIX2 because they are
+   in the theoretically application-owned namespace.  */
+
+#ifdef __USE_XOPEN2K8
+# define __POSIX2_THIS_VERSION	200809L
+/* The utilities on GNU systems also correspond to this version.  */
+#elif defined __USE_XOPEN2K
+/* The utilities on GNU systems also correspond to this version.  */
+# define __POSIX2_THIS_VERSION	200112L
+#elif defined __USE_POSIX199506
+/* The utilities on GNU systems also correspond to this version.  */
+# define __POSIX2_THIS_VERSION	199506L
+#else
+/* The utilities on GNU systems also correspond to this version.  */
+# define __POSIX2_THIS_VERSION	199209L
+#endif
+
+/* The utilities on GNU systems also correspond to this version.  */
+#define _POSIX2_VERSION	__POSIX2_THIS_VERSION
+
+/* If defined, the implementation supports the
+   C Language Bindings Option.  */
+#define	_POSIX2_C_BIND	__POSIX2_THIS_VERSION
+
+/* If defined, the implementation supports the
+   C Language Development Utilities Option.  */
+#define	_POSIX2_C_DEV	__POSIX2_THIS_VERSION
+
+/* If defined, the implementation supports the
+   Software Development Utilities Option.  */
+#define	_POSIX2_SW_DEV	__POSIX2_THIS_VERSION
+
+/* If defined, the implementation supports the
+   creation of locales with the localedef utility.  */
+#define _POSIX2_LOCALEDEF       __POSIX2_THIS_VERSION
+
+/* X/Open version number to which the library conforms.  It is selectable.  */
+#ifdef __USE_XOPEN2K8
+# define _XOPEN_VERSION	700
+#elif defined __USE_XOPEN2K
+# define _XOPEN_VERSION	600
+#elif defined __USE_UNIX98
+# define _XOPEN_VERSION	500
+#else
+# define _XOPEN_VERSION	4
+#endif
+
+/* Commands and utilities from XPG4 are available.  */
+#define _XOPEN_XCU_VERSION	4
+
+/* We are compatible with the old published standards as well.  */
+#define _XOPEN_XPG2	1
+#define _XOPEN_XPG3	1
+#define _XOPEN_XPG4	1
+
+/* The X/Open Unix extensions are available.  */
+#define _XOPEN_UNIX	1
+
+/* Encryption is present.  */
+#define	_XOPEN_CRYPT	1
+
+/* The enhanced internationalization capabilities according to XPG4.2
+   are present.  */
+#define	_XOPEN_ENH_I18N	1
+
+/* The legacy interfaces are also available.  */
+#define _XOPEN_LEGACY	1
+
+
+/* Get values of POSIX options:
+
+   If these symbols are defined, the corresponding features are
+   always available.  If not, they may be available sometimes.
+   The current values can be obtained with `sysconf'.
+
+   _POSIX_JOB_CONTROL		Job control is supported.
+   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
+				and a saved set-group-ID.
+   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
+   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
+   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
+   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
+   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
+   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
+   _POSIX_FSYNC			The fsync function is present.
+   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
+   _POSIX_MEMLOCK		Locking of all memory is supported.
+   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
+   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
+   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
+   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
+   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
+   _POSIX_THREADS		POSIX.1c pthreads are supported.
+   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
+   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
+   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
+   _POSIX_THREAD_PRIORITY_SCHEDULING
+				POSIX.1c thread execution scheduling supported.
+   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
+   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
+   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
+   _POSIX_PII			Protocol-independent interfaces are supported.
+   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
+   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
+   _POSIX_PII_INTERNET		Internet family of protocols supported.
+   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
+   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
+   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
+   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
+   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
+   _POSIX_POLL			Implementation supports `poll' function.
+   _POSIX_SELECT		Implementation supports `select' and `pselect'.
+
+   _XOPEN_REALTIME		X/Open realtime support is available.
+   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
+   _XOPEN_SHM			Shared memory interface according to XPG4.2.
+
+   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
+				int, long, pointer, and off_t types.
+   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
+				int, long, and pointer and off_t with at least
+				64 bits.
+   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
+				int, and 64-bit long, pointer, and off_t types.
+   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
+				least 32 bits int and long, pointer, and off_t
+				with at least 64 bits.
+
+   If any of these symbols is defined as -1, the corresponding option is not
+   true for any file.  If any is defined as other than -1, the corresponding
+   option is true for all files.  If a symbol is not defined at all, the value
+   for a specific file can be obtained from `pathconf' and `fpathconf'.
+
+   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
+				the owner of a file.  `chown' can only be used
+				to change the group ID of a file to a group of
+				which the calling process is a member.
+   _POSIX_NO_TRUNC		Pathname components longer than
+				NAME_MAX generate an error.
+   _POSIX_VDISABLE		If defined, if the value of an element of the
+				`c_cc' member of `struct termios' is
+				_POSIX_VDISABLE, no character will have the
+				effect associated with that element.
+   _POSIX_SYNC_IO		Synchronous I/O may be performed.
+   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
+   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.
+
+   Support for the Large File Support interface is not generally available.
+   If it is available the following constants are defined to one.
+   _LFS64_LARGEFILE		Low-level I/O supports large files.
+   _LFS64_STDIO			Standard I/O supports large files.
+   */
+
+#include <bits/posix_opt.h>
+
+/* Get the environment definitions from Unix98.  */
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+# include <bits/environments.h>
+#endif
+
+/* Standard file descriptors.  */
+#define	STDIN_FILENO	0	/* Standard input.  */
+#define	STDOUT_FILENO	1	/* Standard output.  */
+#define	STDERR_FILENO	2	/* Standard error output.  */
+
+
+/* All functions that are not declared anywhere else.  */
+
+#include <bits/types.h>
+
+#ifndef	__ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+#endif
+
+#define	__need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K
+/* The Single Unix specification says that some more types are
+   available here.  */
+# ifndef __gid_t_defined
+typedef __gid_t gid_t;
+#  define __gid_t_defined
+# endif
+
+# ifndef __uid_t_defined
+typedef __uid_t uid_t;
+#  define __uid_t_defined
+# endif
+
+# ifndef __off_t_defined
+#  ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+#  else
+typedef __off64_t off_t;
+#  endif
+#  define __off_t_defined
+# endif
+# if defined __USE_LARGEFILE64 && !defined __off64_t_defined
+typedef __off64_t off64_t;
+#  define __off64_t_defined
+# endif
+
+# ifndef __useconds_t_defined
+typedef __useconds_t useconds_t;
+#  define __useconds_t_defined
+# endif
+
+# ifndef __pid_t_defined
+typedef __pid_t pid_t;
+#  define __pid_t_defined
+# endif
+#endif	/* X/Open */
+
+#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K
+# ifndef __intptr_t_defined
+typedef __intptr_t intptr_t;
+#  define __intptr_t_defined
+# endif
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN
+# ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+#  define __socklen_t_defined
+# endif
+#endif
+
+/* Values for the second argument to access.
+   These may be OR'd together.  */
+#define	R_OK	4		/* Test for read permission.  */
+#define	W_OK	2		/* Test for write permission.  */
+#define	X_OK	1		/* Test for execute permission.  */
+#define	F_OK	0		/* Test for existence.  */
+
+/* Test for access to NAME using the real UID and real GID.  */
+extern int access (const char *__name, int __type) __THROW __nonnull ((1));
+
+#ifdef __USE_GNU
+/* Test for access to NAME using the effective UID and GID
+   (as normal file operations use).  */
+extern int euidaccess (const char *__name, int __type)
+     __THROW __nonnull ((1));
+
+/* An alias for `euidaccess', used by some other systems.  */
+extern int eaccess (const char *__name, int __type)
+     __THROW __nonnull ((1));
+#endif
+
+#ifdef __USE_ATFILE
+/* Test for access to FILE relative to the directory FD is open on.
+   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
+   otherwise use real IDs like `access'.  */
+extern int faccessat (int __fd, const char *__file, int __type, int __flag)
+     __THROW __nonnull ((2)) __wur;
+#endif /* Use GNU.  */
+
+
+/* Values for the WHENCE argument to lseek.  */
+#ifndef	_STDIO_H		/* <stdio.h> has the same definitions.  */
+# define SEEK_SET	0	/* Seek from beginning of file.  */
+# define SEEK_CUR	1	/* Seek from current position.  */
+# define SEEK_END	2	/* Seek from end of file.  */
+# ifdef __USE_GNU
+#  define SEEK_DATA	3	/* Seek to next data.  */
+#  define SEEK_HOLE	4	/* Seek to next hole.  */
+# endif
+#endif
+
+#if defined __USE_BSD && !defined L_SET
+/* Old BSD names for the same constants; just for compatibility.  */
+# define L_SET		SEEK_SET
+# define L_INCR		SEEK_CUR
+# define L_XTND		SEEK_END
+#endif
+
+
+/* Move FD's file position to OFFSET bytes from the
+   beginning of the file (if WHENCE is SEEK_SET),
+   the current position (if WHENCE is SEEK_CUR),
+   or the end of the file (if WHENCE is SEEK_END).
+   Return the new file position.  */
+#ifndef __USE_FILE_OFFSET64
+extern __off_t lseek (int __fd, __off_t __offset, int __whence) __THROW;
+#else
+# ifdef __REDIRECT_NTH
+extern __off64_t __REDIRECT_NTH (lseek,
+				 (int __fd, __off64_t __offset, int __whence),
+				 lseek64);
+# else
+#  define lseek lseek64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
+     __THROW;
+#endif
+
+/* Close the file descriptor FD.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int close (int __fd);
+
+/* Read NBYTES into BUF from FD.  Return the
+   number read, -1 for errors or 0 for EOF.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;
+
+/* Write N bytes of BUF to FD.  Return the number written, or -1.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur;
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
+# ifndef __USE_FILE_OFFSET64
+/* Read NBYTES into BUF from FD at the given position OFFSET without
+   changing the file pointer.  Return the number read, -1 for errors
+   or 0 for EOF.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
+		      __off_t __offset) __wur;
+
+/* Write N bytes of BUF to FD at the given position OFFSET without
+   changing the file pointer.  Return the number written, or -1.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
+		       __off_t __offset) __wur;
+# else
+#  ifdef __REDIRECT
+extern ssize_t __REDIRECT (pread, (int __fd, void *__buf, size_t __nbytes,
+				   __off64_t __offset),
+			   pread64) __wur;
+extern ssize_t __REDIRECT (pwrite, (int __fd, const void *__buf,
+				    size_t __nbytes, __off64_t __offset),
+			   pwrite64) __wur;
+#  else
+#   define pread pread64
+#   define pwrite pwrite64
+#  endif
+# endif
+
+# ifdef __USE_LARGEFILE64
+/* Read NBYTES into BUF from FD at the given position OFFSET without
+   changing the file pointer.  Return the number read, -1 for errors
+   or 0 for EOF.  */
+extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
+			__off64_t __offset) __wur;
+/* Write N bytes of BUF to FD at the given position OFFSET without
+   changing the file pointer.  Return the number written, or -1.  */
+extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
+			 __off64_t __offset) __wur;
+# endif
+#endif
+
+/* Create a one-way communication channel (pipe).
+   If successful, two file descriptors are stored in PIPEDES;
+   bytes written on PIPEDES[1] can be read from PIPEDES[0].
+   Returns 0 if successful, -1 if not.  */
+extern int pipe (int __pipedes[2]) __THROW __wur;
+
+#ifdef __USE_GNU
+/* Same as pipe but apply flags passed in FLAGS to the new file
+   descriptors.  */
+extern int pipe2 (int __pipedes[2], int __flags) __THROW __wur;
+#endif
+
+/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
+   If SECONDS is zero, any currently scheduled alarm will be cancelled.
+   The function returns the number of seconds remaining until the last
+   alarm scheduled would have signaled, or zero if there wasn't one.
+   There is no return value to indicate an error, but you can set `errno'
+   to 0 and check its value after calling `alarm', and this might tell you.
+   The signal may come late due to processor scheduling.  */
+extern unsigned int alarm (unsigned int __seconds) __THROW;
+
+/* Make the process sleep for SECONDS seconds, or until a signal arrives
+   and is not ignored.  The function returns the number of seconds less
+   than SECONDS which it actually slept (thus zero if it slept the full time).
+   If a signal handler does a `longjmp' or modifies the handling of the
+   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
+   signal afterwards is undefined.  There is no return value to indicate
+   error, but if `sleep' returns SECONDS, it probably didn't work.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern unsigned int sleep (unsigned int __seconds);
+
+#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \
+    || defined __USE_BSD
+/* Set an alarm to go off (generating a SIGALRM signal) in VALUE
+   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
+   timer is reset to go off every INTERVAL microseconds thereafter.
+   Returns the number of microseconds remaining before the alarm.  */
+extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
+     __THROW;
+
+/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
+   or ignored.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int usleep (__useconds_t __useconds);
+#endif
+
+
+/* Suspend the process until a signal arrives.
+   This always returns -1 and sets `errno' to EINTR.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int pause (void);
+
+
+/* Change the owner and group of FILE.  */
+extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
+     __THROW __nonnull ((1)) __wur;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+/* Change the owner and group of the file that FD is open on.  */
+extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __THROW __wur;
+
+
+/* Change owner and group of FILE, if it is a symbolic
+   link the ownership of the symbolic link is changed.  */
+extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
+     __THROW __nonnull ((1)) __wur;
+
+#endif /* Use BSD || X/Open Unix.  */
+
+#ifdef __USE_ATFILE
+/* Change the owner and group of FILE relative to the directory FD is open
+   on.  */
+extern int fchownat (int __fd, const char *__file, __uid_t __owner,
+		     __gid_t __group, int __flag)
+     __THROW __nonnull ((2)) __wur;
+#endif /* Use GNU.  */
+
+/* Change the process's working directory to PATH.  */
+extern int chdir (const char *__path) __THROW __nonnull ((1)) __wur;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+/* Change the process's working directory to the one FD is open on.  */
+extern int fchdir (int __fd) __THROW __wur;
+#endif
+
+/* Get the pathname of the current working directory,
+   and put it in SIZE bytes of BUF.  Returns NULL if the
+   directory couldn't be determined or SIZE was too small.
+   If successful, returns BUF.  In GNU, if BUF is NULL,
+   an array is allocated with `malloc'; the array is SIZE
+   bytes long, unless SIZE == 0, in which case it is as
+   big as necessary.  */
+extern char *getcwd (char *__buf, size_t __size) __THROW __wur;
+
+#ifdef	__USE_GNU
+/* Return a malloc'd string containing the current directory name.
+   If the environment variable `PWD' is set, and its value is correct,
+   that value is used.  */
+extern char *get_current_dir_name (void) __THROW;
+#endif
+
+#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \
+    || defined __USE_BSD
+/* Put the absolute pathname of the current working directory in BUF.
+   If successful, return BUF.  If not, put an error message in
+   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */
+extern char *getwd (char *__buf)
+     __THROW __nonnull ((1)) __attribute_deprecated__ __wur;
+#endif
+
+
+/* Duplicate FD, returning a new file descriptor on the same file.  */
+extern int dup (int __fd) __THROW __wur;
+
+/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */
+extern int dup2 (int __fd, int __fd2) __THROW;
+
+#ifdef __USE_GNU
+/* Duplicate FD to FD2, closing FD2 and making it open on the same
+   file while setting flags according to FLAGS.  */
+extern int dup3 (int __fd, int __fd2, int __flags) __THROW;
+#endif
+
+/* NULL-terminated array of "NAME=VALUE" environment variables.  */
+extern char **__environ;
+#ifdef __USE_GNU
+extern char **environ;
+#endif
+
+
+/* Replace the current process, executing PATH with arguments ARGV and
+   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
+extern int execve (const char *__path, char *const __argv[],
+		   char *const __envp[]) __THROW __nonnull ((1, 2));
+
+#ifdef __USE_XOPEN2K8
+/* Execute the file FD refers to, overlaying the running program image.
+   ARGV and ENVP are passed to the new program, as for `execve'.  */
+extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
+     __THROW __nonnull ((2));
+#endif
+
+
+/* Execute PATH with arguments ARGV and environment from `environ'.  */
+extern int execv (const char *__path, char *const __argv[])
+     __THROW __nonnull ((1, 2));
+
+/* Execute PATH with all arguments after PATH until a NULL pointer,
+   and the argument after that for environment.  */
+extern int execle (const char *__path, const char *__arg, ...)
+     __THROW __nonnull ((1, 2));
+
+/* Execute PATH with all arguments after PATH until
+   a NULL pointer and environment from `environ'.  */
+extern int execl (const char *__path, const char *__arg, ...)
+     __THROW __nonnull ((1, 2));
+
+/* Execute FILE, searching in the `PATH' environment variable if it contains
+   no slashes, with arguments ARGV and environment from `environ'.  */
+extern int execvp (const char *__file, char *const __argv[])
+     __THROW __nonnull ((1, 2));
+
+/* Execute FILE, searching in the `PATH' environment variable if
+   it contains no slashes, with all arguments after FILE until a
+   NULL pointer and environment from `environ'.  */
+extern int execlp (const char *__file, const char *__arg, ...)
+     __THROW __nonnull ((1, 2));
+
+#ifdef __USE_GNU
+/* Execute FILE, searching in the `PATH' environment variable if it contains
+   no slashes, with arguments ARGV and environment from `environ'.  */
+extern int execvpe (const char *__file, char *const __argv[],
+		    char *const __envp[])
+     __THROW __nonnull ((1, 2));
+#endif
+
+
+#if defined __USE_MISC || defined __USE_XOPEN
+/* Add INC to priority of the current process.  */
+extern int nice (int __inc) __THROW __wur;
+#endif
+
+
+/* Terminate program execution with the low-order 8 bits of STATUS.  */
+extern void _exit (int __status) __attribute__ ((__noreturn__));
+
+
+/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
+   the `_SC_*' symbols for the NAME argument to `sysconf';
+   and the `_CS_*' symbols for the NAME argument to `confstr'.  */
+#include <bits/confname.h>
+
+/* Get file-specific configuration information about PATH.  */
+extern long int pathconf (const char *__path, int __name)
+     __THROW __nonnull ((1));
+
+/* Get file-specific configuration about descriptor FD.  */
+extern long int fpathconf (int __fd, int __name) __THROW;
+
+/* Get the value of the system variable NAME.  */
+extern long int sysconf (int __name) __THROW;
+
+#ifdef	__USE_POSIX2
+/* Get the value of the string-valued system variable NAME.  */
+extern size_t confstr (int __name, char *__buf, size_t __len) __THROW;
+#endif
+
+
+/* Get the process ID of the calling process.  */
+extern __pid_t getpid (void) __THROW;
+
+/* Get the process ID of the calling process's parent.  */
+extern __pid_t getppid (void) __THROW;
+
+/* Get the process group ID of the calling process.  */
+extern __pid_t getpgrp (void) __THROW;
+
+/* Get the process group ID of process PID.  */
+extern __pid_t __getpgid (__pid_t __pid) __THROW;
+#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+extern __pid_t getpgid (__pid_t __pid) __THROW;
+#endif
+
+
+/* Set the process group ID of the process matching PID to PGID.
+   If PID is zero, the current process's process group ID is set.
+   If PGID is zero, the process ID of the process is used.  */
+extern int setpgid (__pid_t __pid, __pid_t __pgid) __THROW;
+
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Both System V and BSD have `setpgrp' functions, but with different
+   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
+   (above).  The System V function takes no arguments and puts the calling
+   process in its on group like `setpgid (0, 0)'.
+
+   New programs should always use `setpgid' instead.
+
+   GNU provides the POSIX.1 function.  */
+
+/* Set the process group ID of the calling process to its own PID.
+   This is exactly the same as `setpgid (0, 0)'.  */
+extern int setpgrp (void) __THROW;
+
+#endif	/* Use SVID or BSD.  */
+
+/* Create a new session with the calling process as its leader.
+   The process group IDs of the session and the calling process
+   are set to the process ID of the calling process, which is returned.  */
+extern __pid_t setsid (void) __THROW;
+
+#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+/* Return the session ID of the given process.  */
+extern __pid_t getsid (__pid_t __pid) __THROW;
+#endif
+
+/* Get the real user ID of the calling process.  */
+extern __uid_t getuid (void) __THROW;
+
+/* Get the effective user ID of the calling process.  */
+extern __uid_t geteuid (void) __THROW;
+
+/* Get the real group ID of the calling process.  */
+extern __gid_t getgid (void) __THROW;
+
+/* Get the effective group ID of the calling process.  */
+extern __gid_t getegid (void) __THROW;
+
+/* If SIZE is zero, return the number of supplementary groups
+   the calling process is in.  Otherwise, fill in the group IDs
+   of its supplementary groups in LIST and return the number written.  */
+extern int getgroups (int __size, __gid_t __list[]) __THROW __wur;
+
+#ifdef	__USE_GNU
+/* Return nonzero iff the calling process is in group GID.  */
+extern int group_member (__gid_t __gid) __THROW;
+#endif
+
+/* Set the user ID of the calling process to UID.
+   If the calling process is the super-user, set the real
+   and effective user IDs, and the saved set-user-ID to UID;
+   if not, the effective user ID is set to UID.  */
+extern int setuid (__uid_t __uid) __THROW __wur;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Set the real user ID of the calling process to RUID,
+   and the effective user ID of the calling process to EUID.  */
+extern int setreuid (__uid_t __ruid, __uid_t __euid) __THROW __wur;
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+/* Set the effective user ID of the calling process to UID.  */
+extern int seteuid (__uid_t __uid) __THROW __wur;
+#endif /* Use BSD.  */
+
+/* Set the group ID of the calling process to GID.
+   If the calling process is the super-user, set the real
+   and effective group IDs, and the saved set-group-ID to GID;
+   if not, the effective group ID is set to GID.  */
+extern int setgid (__gid_t __gid) __THROW __wur;
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Set the real group ID of the calling process to RGID,
+   and the effective group ID of the calling process to EGID.  */
+extern int setregid (__gid_t __rgid, __gid_t __egid) __THROW __wur;
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+/* Set the effective group ID of the calling process to GID.  */
+extern int setegid (__gid_t __gid) __THROW __wur;
+#endif /* Use BSD.  */
+
+#ifdef __USE_GNU
+/* Fetch the real user ID, effective user ID, and saved-set user ID,
+   of the calling process.  */
+extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
+     __THROW;
+
+/* Fetch the real group ID, effective group ID, and saved-set group ID,
+   of the calling process.  */
+extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
+     __THROW;
+
+/* Set the real user ID, effective user ID, and saved-set user ID,
+   of the calling process to RUID, EUID, and SUID, respectively.  */
+extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
+     __THROW __wur;
+
+/* Set the real group ID, effective group ID, and saved-set group ID,
+   of the calling process to RGID, EGID, and SGID, respectively.  */
+extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
+     __THROW __wur;
+#endif
+
+
+/* Clone the calling process, creating an exact copy.
+   Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+extern __pid_t fork (void) __THROWNL;
+
+#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \
+    || defined __USE_BSD
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+extern __pid_t vfork (void) __THROW;
+#endif /* Use BSD or XPG < 7. */
+
+
+/* Return the pathname of the terminal FD is open on, or NULL on errors.
+   The returned storage is good only until the next call to this function.  */
+extern char *ttyname (int __fd) __THROW;
+
+/* Store at most BUFLEN characters of the pathname of the terminal FD is
+   open on in BUF.  Return 0 on success, otherwise an error number.  */
+extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
+     __THROW __nonnull ((2)) __wur;
+
+/* Return 1 if FD is a valid descriptor associated
+   with a terminal, zero if not.  */
+extern int isatty (int __fd) __THROW;
+
+#if defined __USE_BSD \
+    || (defined __USE_XOPEN_EXTENDED && !defined __USE_UNIX98)
+/* Return the index into the active-logins file (utmp) for
+   the controlling terminal.  */
+extern int ttyslot (void) __THROW;
+#endif
+
+
+/* Make a link to FROM named TO.  */
+extern int link (const char *__from, const char *__to)
+     __THROW __nonnull ((1, 2)) __wur;
+
+#ifdef __USE_ATFILE
+/* Like link but relative paths in TO and FROM are interpreted relative
+   to FROMFD and TOFD respectively.  */
+extern int linkat (int __fromfd, const char *__from, int __tofd,
+		   const char *__to, int __flags)
+     __THROW __nonnull ((2, 4)) __wur;
+#endif
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K
+/* Make a symbolic link to FROM named TO.  */
+extern int symlink (const char *__from, const char *__to)
+     __THROW __nonnull ((1, 2)) __wur;
+
+/* Read the contents of the symbolic link PATH into no more than
+   LEN bytes of BUF.  The contents are not null-terminated.
+   Returns the number of characters read, or -1 for errors.  */
+extern ssize_t readlink (const char *__restrict __path,
+			 char *__restrict __buf, size_t __len)
+     __THROW __nonnull ((1, 2)) __wur;
+#endif /* Use BSD.  */
+
+#ifdef __USE_ATFILE
+/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */
+extern int symlinkat (const char *__from, int __tofd,
+		      const char *__to) __THROW __nonnull ((1, 3)) __wur;
+
+/* Like readlink but a relative PATH is interpreted relative to FD.  */
+extern ssize_t readlinkat (int __fd, const char *__restrict __path,
+			   char *__restrict __buf, size_t __len)
+     __THROW __nonnull ((2, 3)) __wur;
+#endif
+
+/* Remove the link NAME.  */
+extern int unlink (const char *__name) __THROW __nonnull ((1));
+
+#ifdef __USE_ATFILE
+/* Remove the link NAME relative to FD.  */
+extern int unlinkat (int __fd, const char *__name, int __flag)
+     __THROW __nonnull ((2));
+#endif
+
+/* Remove the directory PATH.  */
+extern int rmdir (const char *__path) __THROW __nonnull ((1));
+
+
+/* Return the foreground process group ID of FD.  */
+extern __pid_t tcgetpgrp (int __fd) __THROW;
+
+/* Set the foreground process group ID of FD set PGRP_ID.  */
+extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __THROW;
+
+
+/* Return the login name of the user.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern char *getlogin (void);
+#if defined __USE_REENTRANT || defined __USE_POSIX199506
+/* Return at most NAME_LEN characters of the login name of the user in NAME.
+   If it cannot be determined or some other error occurred, return the error
+   code.  Otherwise return 0.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int getlogin_r (char *__name, size_t __name_len) __nonnull ((1));
+#endif
+
+#ifdef	__USE_BSD
+/* Set the login name returned by `getlogin'.  */
+extern int setlogin (const char *__name) __THROW __nonnull ((1));
+#endif
+
+
+#ifdef	__USE_POSIX2
+/* Get definitions and prototypes for functions to process the
+   arguments in ARGV (ARGC of them, minus the program name) for
+   options given in OPTS.  */
+# define __need_getopt
+# include <getopt.h>
+#endif
+
+
+#if defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Put the name of the current host in no more than LEN bytes of NAME.
+   The result is null-terminated if LEN is large enough for the full
+   name and the terminator.  */
+extern int gethostname (char *__name, size_t __len) __THROW __nonnull ((1));
+#endif
+
+
+#if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_UNIX98)
+/* Set the name of the current host to NAME, which is LEN bytes long.
+   This call is restricted to the super-user.  */
+extern int sethostname (const char *__name, size_t __len)
+     __THROW __nonnull ((1)) __wur;
+
+/* Set the current machine's Internet number to ID.
+   This call is restricted to the super-user.  */
+extern int sethostid (long int __id) __THROW __wur;
+
+
+/* Get and set the NIS (aka YP) domain name, if any.
+   Called just like `gethostname' and `sethostname'.
+   The NIS domain name is usually the empty string when not using NIS.  */
+extern int getdomainname (char *__name, size_t __len)
+     __THROW __nonnull ((1)) __wur;
+extern int setdomainname (const char *__name, size_t __len)
+     __THROW __nonnull ((1)) __wur;
+
+
+/* Revoke access permissions to all processes currently communicating
+   with the control terminal, and then send a SIGHUP signal to the process
+   group of the control terminal.  */
+extern int vhangup (void) __THROW;
+
+/* Revoke the access of all descriptors currently open on FILE.  */
+extern int revoke (const char *__file) __THROW __nonnull ((1)) __wur;
+
+
+/* Enable statistical profiling, writing samples of the PC into at most
+   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
+   is enabled, the system examines the user PC and increments
+   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
+   disable profiling.  Returns zero on success, -1 on error.  */
+extern int profil (unsigned short int *__sample_buffer, size_t __size,
+		   size_t __offset, unsigned int __scale)
+     __THROW __nonnull ((1));
+
+
+/* Turn accounting on if NAME is an existing file.  The system will then write
+   a record for each process as it terminates, to this file.  If NAME is NULL,
+   turn accounting off.  This call is restricted to the super-user.  */
+extern int acct (const char *__name) __THROW;
+
+
+/* Successive calls return the shells listed in `/etc/shells'.  */
+extern char *getusershell (void) __THROW;
+extern void endusershell (void) __THROW; /* Discard cached info.  */
+extern void setusershell (void) __THROW; /* Rewind and re-read the file.  */
+
+
+/* Put the program in the background, and dissociate from the controlling
+   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
+   redirects stdin, stdout, and stderr to /dev/null.  */
+extern int daemon (int __nochdir, int __noclose) __THROW __wur;
+#endif /* Use BSD || X/Open.  */
+
+
+#if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
+/* Make PATH be the root directory (the starting point for absolute paths).
+   This call is restricted to the super-user.  */
+extern int chroot (const char *__path) __THROW __nonnull ((1)) __wur;
+
+/* Prompt with PROMPT and read a string from the terminal without echoing.
+   Uses /dev/tty if possible; otherwise stderr and stdin.  */
+extern char *getpass (const char *__prompt) __nonnull ((1));
+#endif /* Use BSD || X/Open.  */
+
+
+/* Make all changes done to FD actually appear on disk.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int fsync (int __fd);
+
+
+#ifdef __USE_GNU
+/* Make all changes done to all files on the file system associated
+   with FD actually appear on disk.  */
+extern int syncfs (int __fd) __THROW;
+#endif
+
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+
+/* Return identifier for the current host.  */
+extern long int gethostid (void);
+
+/* Make all changes done to all files actually appear on disk.  */
+extern void sync (void) __THROW;
+
+
+# if defined __USE_BSD || !defined __USE_XOPEN2K
+/* Return the number of bytes in a page.  This is the system's page size,
+   which is not necessarily the same as the hardware page size.  */
+extern int getpagesize (void)  __THROW __attribute__ ((__const__));
+
+
+/* Return the maximum number of file descriptors
+   the current process could possibly have.  */
+extern int getdtablesize (void) __THROW;
+# endif
+
+#endif /* Use BSD || X/Open Unix.  */
+
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+
+/* Truncate FILE to LENGTH bytes.  */
+# ifndef __USE_FILE_OFFSET64
+extern int truncate (const char *__file, __off_t __length)
+     __THROW __nonnull ((1)) __wur;
+# else
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (truncate,
+			   (const char *__file, __off64_t __length),
+			   truncate64) __nonnull ((1)) __wur;
+#  else
+#   define truncate truncate64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int truncate64 (const char *__file, __off64_t __length)
+     __THROW __nonnull ((1)) __wur;
+# endif
+
+#endif /* Use BSD || X/Open Unix || POSIX 2008.  */
+
+#if defined __USE_BSD || defined __USE_POSIX199309 \
+    || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K
+
+/* Truncate the file FD is open on to LENGTH bytes.  */
+# ifndef __USE_FILE_OFFSET64
+extern int ftruncate (int __fd, __off_t __length) __THROW __wur;
+# else
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (ftruncate, (int __fd, __off64_t __length),
+			   ftruncate64) __wur;
+#  else
+#   define ftruncate ftruncate64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int ftruncate64 (int __fd, __off64_t __length) __THROW __wur;
+# endif
+
+#endif /* Use BSD || POSIX.1b || X/Open Unix || XPG6.  */
+
+
+#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \
+    || defined __USE_MISC
+
+/* Set the end of accessible data space (aka "the break") to ADDR.
+   Returns zero on success and -1 for errors (with errno set).  */
+extern int brk (void *__addr) __THROW __wur;
+
+/* Increase or decrease the end of accessible data space by DELTA bytes.
+   If successful, returns the address the previous end of data space
+   (i.e. the beginning of the new space, if DELTA > 0);
+   returns (void *) -1 for errors (with errno set).  */
+extern void *sbrk (intptr_t __delta) __THROW;
+#endif
+
+
+#ifdef __USE_MISC
+/* Invoke `system call' number SYSNO, passing it the remaining arguments.
+   This is completely system-dependent, and not often useful.
+
+   In Unix, `syscall' sets `errno' for all errors and most calls return -1
+   for errors; in many systems you cannot pass arguments or get return
+   values for all system calls (`pipe', `fork', and `getppid' typically
+   among them).
+
+   In Mach, all system calls take normal arguments and always return an
+   error code (zero for success).  */
+extern long int syscall (long int __sysno, ...) __THROW;
+
+#endif	/* Use misc.  */
+
+
+#if (defined __USE_MISC || defined __USE_XOPEN_EXTENDED) && !defined F_LOCK
+/* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
+   files consistent.  Some systems have them there and some here, and some
+   software depends on the macros being defined without including both.  */
+
+/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
+   LEN is always relative to the current file position.
+   The CMD argument is one of the following.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+
+# define F_ULOCK 0	/* Unlock a previously locked region.  */
+# define F_LOCK  1	/* Lock a region for exclusive use.  */
+# define F_TLOCK 2	/* Test and lock a region for exclusive use.  */
+# define F_TEST  3	/* Test a region for other processes locks.  */
+
+# ifndef __USE_FILE_OFFSET64
+extern int lockf (int __fd, int __cmd, __off_t __len) __wur;
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (lockf, (int __fd, int __cmd, __off64_t __len),
+		       lockf64) __wur;
+#  else
+#   define lockf lockf64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int lockf64 (int __fd, int __cmd, __off64_t __len) __wur;
+# endif
+#endif /* Use misc and F_LOCK not already defined.  */
+
+
+#ifdef __USE_GNU
+
+/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'
+   set to EINTR.  */
+
+# define TEMP_FAILURE_RETRY(expression) \
+  (__extension__							      \
+    ({ long int __result;						      \
+       do __result = (long int) (expression);				      \
+       while (__result == -1L && errno == EINTR);			      \
+       __result; }))
+#endif
+
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+/* Synchronize at least the data part of a file with the underlying
+   media.  */
+extern int fdatasync (int __fildes);
+#endif /* Use POSIX199309 */
+
+
+/* XPG4.2 specifies that prototypes for the encryption functions must
+   be defined here.  */
+#ifdef	__USE_XOPEN
+/* Encrypt at most 8 characters from KEY using salt to perturb DES.  */
+extern char *crypt (const char *__key, const char *__salt)
+     __THROW __nonnull ((1, 2));
+
+/* Encrypt data in BLOCK in place if EDFLAG is zero; otherwise decrypt
+   block in place.  */
+extern void encrypt (char *__glibc_block, int __edflag)
+     __THROW __nonnull ((1));
+
+
+/* Swab pairs bytes in the first N bytes of the area pointed to by
+   FROM and copy the result to TO.  The value of TO must not be in the
+   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM
+   is without partner.  */
+extern void swab (const void *__restrict __from, void *__restrict __to,
+		  ssize_t __n) __THROW __nonnull ((1, 2));
+#endif
+
+
+/* The Single Unix specification demands this prototype to be here.
+   It is also found in <stdio.h>.  */
+#if defined __USE_XOPEN && !defined __USE_XOPEN2K
+/* Return the name of the controlling terminal.  */
+extern char *ctermid (char *__s) __THROW;
+#endif
+
+
+/* Define some macros helping to catch buffer overflows.  */
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+# include <bits/unistd.h>
+#endif
+
+__END_DECLS
+
+#endif /* unistd.h  */
diff --git a/include/ustat.h b/include/ustat.h
new file mode 100644
index 0000000..cba150e
--- /dev/null
+++ b/include/ustat.h
@@ -0,0 +1 @@
+#include <sys/ustat.h>
diff --git a/include/utime.h b/include/utime.h
new file mode 100644
index 0000000..727e107
--- /dev/null
+++ b/include/utime.h
@@ -0,0 +1,51 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	POSIX Standard: 5.6.6 Set File Access and Modification Times  <utime.h>
+ */
+
+#ifndef	_UTIME_H
+#define	_UTIME_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/types.h>
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K
+# define __need_time_t
+# include <time.h>
+#endif
+
+/* Structure describing file times.  */
+struct utimbuf
+  {
+    __time_t actime;		/* Access time.  */
+    __time_t modtime;		/* Modification time.  */
+  };
+
+/* Set the access and modification times of FILE to those given in
+   *FILE_TIMES.  If FILE_TIMES is NULL, set them to the current time.  */
+extern int utime (const char *__file,
+		  const struct utimbuf *__file_times)
+     __THROW __nonnull ((1));
+
+__END_DECLS
+
+#endif /* utime.h */
diff --git a/include/utmp.h b/include/utmp.h
new file mode 100644
index 0000000..6f1094b
--- /dev/null
+++ b/include/utmp.h
@@ -0,0 +1,96 @@
+/* Copyright (C) 1993-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_UTMP_H
+#define	_UTMP_H	1
+
+#include <features.h>
+
+#include <sys/types.h>
+
+
+__BEGIN_DECLS
+
+/* Get system dependent values and data structures.  */
+#include <bits/utmp.h>
+
+/* Compatibility names for the strings of the canonical file names.  */
+#define UTMP_FILE	_PATH_UTMP
+#define UTMP_FILENAME	_PATH_UTMP
+#define WTMP_FILE	_PATH_WTMP
+#define WTMP_FILENAME	_PATH_WTMP
+
+
+
+/* Make FD be the controlling terminal, stdin, stdout, and stderr;
+   then close FD.  Returns 0 on success, nonzero on error.  */
+extern int login_tty (int __fd) __THROW;
+
+
+/* Write the given entry into utmp and wtmp.  */
+extern void login (const struct utmp *__entry) __THROW;
+
+/* Write the utmp entry to say the user on UT_LINE has logged out.  */
+extern int logout (const char *__ut_line) __THROW;
+
+/* Append to wtmp an entry for the current time and the given info.  */
+extern void logwtmp (const char *__ut_line, const char *__ut_name,
+		     const char *__ut_host) __THROW;
+
+/* Append entry UTMP to the wtmp-like file WTMP_FILE.  */
+extern void updwtmp (const char *__wtmp_file, const struct utmp *__utmp)
+     __THROW;
+
+/* Change name of the utmp file to be examined.  */
+extern int utmpname (const char *__file) __THROW;
+
+/* Read next entry from a utmp-like file.  */
+extern struct utmp *getutent (void) __THROW;
+
+/* Reset the input stream to the beginning of the file.  */
+extern void setutent (void) __THROW;
+
+/* Close the current open file.  */
+extern void endutent (void) __THROW;
+
+/* Search forward from the current point in the utmp file until the
+   next entry with a ut_type matching ID->ut_type.  */
+extern struct utmp *getutid (const struct utmp *__id) __THROW;
+
+/* Search forward from the current point in the utmp file until the
+   next entry with a ut_line matching LINE->ut_line.  */
+extern struct utmp *getutline (const struct utmp *__line) __THROW;
+
+/* Write out entry pointed to by UTMP_PTR into the utmp file.  */
+extern struct utmp *pututline (const struct utmp *__utmp_ptr) __THROW;
+
+
+#ifdef	__USE_MISC
+/* Reentrant versions of the file for handling utmp files.  */
+extern int getutent_r (struct utmp *__buffer, struct utmp **__result) __THROW;
+
+extern int getutid_r (const struct utmp *__id, struct utmp *__buffer,
+		      struct utmp **__result) __THROW;
+
+extern int getutline_r (const struct utmp *__line,
+			struct utmp *__buffer, struct utmp **__result) __THROW;
+
+#endif	/* Use misc.  */
+
+__END_DECLS
+
+#endif /* utmp.h  */
diff --git a/include/utmpx.h b/include/utmpx.h
new file mode 100644
index 0000000..2a35b89
--- /dev/null
+++ b/include/utmpx.h
@@ -0,0 +1,125 @@
+/* Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_UTMPX_H
+#define	_UTMPX_H	1
+
+#include <features.h>
+#include <sys/time.h>
+
+/* Required according to Unix98.  */
+#ifndef __pid_t_defined
+typedef __pid_t pid_t;
+# define __pid_t_defined
+#endif
+
+/* Get system dependent values and data structures.  */
+#include <bits/utmpx.h>
+
+#ifdef __USE_GNU
+/* Compatibility names for the strings of the canonical file names.  */
+# define UTMPX_FILE	_PATH_UTMPX
+# define UTMPX_FILENAME	_PATH_UTMPX
+# define WTMPX_FILE	_PATH_WTMPX
+# define WTMPX_FILENAME	_PATH_WTMPX
+#endif
+
+/* For the getutmp{,x} functions we need the `struct utmp'.  */
+#ifdef __USE_GNU
+struct utmp;
+#endif
+
+
+__BEGIN_DECLS
+
+/* Open user accounting database.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void setutxent (void);
+
+/* Close user accounting database.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern void endutxent (void);
+
+/* Get the next entry from the user accounting database.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct utmpx *getutxent (void);
+
+/* Get the user accounting database entry corresponding to ID.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct utmpx *getutxid (const struct utmpx *__id);
+
+/* Get the user accounting database entry corresponding to LINE.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct utmpx *getutxline (const struct utmpx *__line);
+
+/* Write the entry UTMPX into the user accounting database.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern struct utmpx *pututxline (const struct utmpx *__utmpx);
+
+
+#ifdef __USE_GNU
+/* Change name of the utmpx file to be examined.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int utmpxname (const char *__file);
+
+/* Append entry UTMP to the wtmpx-like file WTMPX_FILE.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern void updwtmpx (const char *__wtmpx_file,
+		      const struct utmpx *__utmpx);
+
+
+/* Copy the information in UTMPX to UTMP.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern void getutmp (const struct utmpx *__utmpx,
+		     struct utmp *__utmp);
+
+/* Copy the information in UTMP to UTMPX.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern void getutmpx (const struct utmp *__utmp, struct utmpx *__utmpx);
+#endif
+
+__END_DECLS
+
+#endif /* utmpx.h  */
diff --git a/include/values.h b/include/values.h
new file mode 100644
index 0000000..24b1fe6
--- /dev/null
+++ b/include/values.h
@@ -0,0 +1,68 @@
+/* Old compatibility names for <limits.h> and <float.h> constants.
+   Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This interface is obsolete.  New programs should use
+   <limits.h> and/or <float.h> instead of <values.h>.  */
+
+#ifndef	_VALUES_H
+#define	_VALUES_H	1
+
+#include <features.h>
+
+#include <limits.h>
+
+#define _TYPEBITS(type)	(sizeof (type) * CHAR_BIT)
+
+#define CHARBITS	_TYPEBITS (char)
+#define SHORTBITS	_TYPEBITS (short int)
+#define INTBITS		_TYPEBITS (int)
+#define LONGBITS	_TYPEBITS (long int)
+#define PTRBITS		_TYPEBITS (char *)
+#define DOUBLEBITS	_TYPEBITS (double)
+#define FLOATBITS	_TYPEBITS (float)
+
+#define MINSHORT	SHRT_MIN
+#define	MININT		INT_MIN
+#define	MINLONG		LONG_MIN
+
+#define	MAXSHORT	SHRT_MAX
+#define	MAXINT		INT_MAX
+#define	MAXLONG		LONG_MAX
+
+#define HIBITS		MINSHORT
+#define HIBITL		MINLONG
+
+
+#include <float.h>
+
+#define	MAXDOUBLE	DBL_MAX
+#define	MAXFLOAT	FLT_MAX
+#define	MINDOUBLE	DBL_MIN
+#define	MINFLOAT	FLT_MIN
+#define	DMINEXP		DBL_MIN_EXP
+#define	FMINEXP		FLT_MIN_EXP
+#define	DMAXEXP		DBL_MAX_EXP
+#define	FMAXEXP		FLT_MAX_EXP
+
+
+#ifdef __USE_MISC
+/* Some systems define this name instead of CHAR_BIT or CHARBITS.  */
+# define BITSPERBYTE	CHAR_BIT
+#endif
+
+#endif	/* values.h */
diff --git a/include/wait.h b/include/wait.h
new file mode 100644
index 0000000..d01b811
--- /dev/null
+++ b/include/wait.h
@@ -0,0 +1 @@
+#include <sys/wait.h>
diff --git a/include/wchar.h b/include/wchar.h
new file mode 100644
index 0000000..29340fd
--- /dev/null
+++ b/include/wchar.h
@@ -0,0 +1,900 @@
+/* Copyright (C) 1995-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *      ISO C99 Standard: 7.24
+ *	Extended multibyte and wide character utilities	<wchar.h>
+ */
+
+#ifndef _WCHAR_H
+
+#if !defined __need_mbstate_t && !defined __need_wint_t
+# define _WCHAR_H 1
+# include <features.h>
+#endif
+
+#ifdef _WCHAR_H
+/* Get FILE definition.  */
+# define __need___FILE
+# if defined __USE_UNIX98 || defined __USE_XOPEN2K
+#  define __need_FILE
+# endif
+# include <stdio.h>
+/* Get va_list definition.  */
+# define __need___va_list
+# include <stdarg.h>
+
+# include <bits/wchar.h>
+
+/* Get size_t, wchar_t, wint_t and NULL from <stddef.h>.  */
+# define __need_size_t
+# define __need_wchar_t
+# define __need_NULL
+#endif
+#if defined _WCHAR_H || defined __need_wint_t || !defined __WINT_TYPE__
+# undef __need_wint_t
+# define __need_wint_t
+# include <stddef.h>
+
+/* We try to get wint_t from <stddef.h>, but not all GCC versions define it
+   there.  So define it ourselves if it remains undefined.  */
+# ifndef _WINT_T
+/* Integral type unchanged by default argument promotions that can
+   hold any value corresponding to members of the extended character
+   set, as well as at least one value that does not correspond to any
+   member of the extended character set.  */
+#  define _WINT_T
+typedef unsigned int wint_t;
+# else
+/* Work around problems with the <stddef.h> file which doesn't put
+   wint_t in the std namespace.  */
+#  if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES \
+      && defined __WINT_TYPE__
+__BEGIN_NAMESPACE_STD
+typedef __WINT_TYPE__ wint_t;
+__END_NAMESPACE_STD
+#  endif
+# endif
+
+/* Tell the caller that we provide correct C++ prototypes.  */
+# if defined __cplusplus && __GNUC_PREREQ (4, 4)
+#  define __CORRECT_ISO_CPP_WCHAR_H_PROTO
+# endif
+#endif
+
+#if (defined _WCHAR_H || defined __need_mbstate_t) && !defined ____mbstate_t_defined
+# define ____mbstate_t_defined	1
+/* Conversion state information.  */
+typedef struct
+{
+  int __count;
+  union
+  {
+# ifdef __WINT_TYPE__
+    __WINT_TYPE__ __wch;
+# else
+    wint_t __wch;
+# endif
+    char __wchb[4];
+  } __value;		/* Value so far.  */
+} __mbstate_t;
+#endif
+#undef __need_mbstate_t
+
+
+/* The rest of the file is only used if used if __need_mbstate_t is not
+   defined.  */
+#ifdef _WCHAR_H
+
+# ifndef __mbstate_t_defined
+__BEGIN_NAMESPACE_C99
+/* Public type.  */
+typedef __mbstate_t mbstate_t;
+__END_NAMESPACE_C99
+#  define __mbstate_t_defined 1
+# endif
+
+#ifdef __USE_GNU
+__USING_NAMESPACE_C99(mbstate_t)
+#endif
+
+#ifndef WCHAR_MIN
+/* These constants might also be defined in <inttypes.h>.  */
+# define WCHAR_MIN __WCHAR_MIN
+# define WCHAR_MAX __WCHAR_MAX
+#endif
+
+#ifndef WEOF
+# define WEOF (0xffffffffu)
+#endif
+
+/* For XPG4 compliance we have to define the stuff from <wctype.h> here
+   as well.  */
+#if defined __USE_XOPEN && !defined __USE_UNIX98
+# include <wctype.h>
+#endif
+
+
+__BEGIN_DECLS
+
+__BEGIN_NAMESPACE_STD
+/* This incomplete type is defined in <time.h> but needed here because
+   of `wcsftime'.  */
+struct tm;
+__END_NAMESPACE_STD
+/* XXX We have to clean this up at some point.  Since tm is in the std
+   namespace but wcsftime is in __c99 the type wouldn't be found
+   without inserting it in the global namespace.  */
+__USING_NAMESPACE_STD(tm)
+
+
+__BEGIN_NAMESPACE_STD
+/* Copy SRC to DEST.  */
+extern wchar_t *wcscpy (wchar_t *__restrict __dest,
+			const wchar_t *__restrict __src) __THROW;
+/* Copy no more than N wide-characters of SRC to DEST.  */
+extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
+			 const wchar_t *__restrict __src, size_t __n)
+     __THROW;
+
+/* Append SRC onto DEST.  */
+extern wchar_t *wcscat (wchar_t *__restrict __dest,
+			const wchar_t *__restrict __src) __THROW;
+/* Append no more than N wide-characters of SRC onto DEST.  */
+extern wchar_t *wcsncat (wchar_t *__restrict __dest,
+			 const wchar_t *__restrict __src, size_t __n)
+     __THROW;
+
+/* Compare S1 and S2.  */
+extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
+     __THROW __attribute_pure__;
+/* Compare N wide-characters of S1 and S2.  */
+extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
+     __THROW __attribute_pure__;
+__END_NAMESPACE_STD
+
+#ifdef __USE_XOPEN2K8
+/* Compare S1 and S2, ignoring case.  */
+extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) __THROW;
+
+/* Compare no more than N chars of S1 and S2, ignoring case.  */
+extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
+			size_t __n) __THROW;
+
+/* Similar to the two functions above but take the information from
+   the provided locale and not the global locale.  */
+# include <xlocale.h>
+
+extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
+			 __locale_t __loc) __THROW;
+
+extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
+			  size_t __n, __locale_t __loc) __THROW;
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Compare S1 and S2, both interpreted as appropriate to the
+   LC_COLLATE category of the current locale.  */
+extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) __THROW;
+/* Transform S2 into array pointed to by S1 such that if wcscmp is
+   applied to two transformed strings the result is the as applying
+   `wcscoll' to the original strings.  */
+extern size_t wcsxfrm (wchar_t *__restrict __s1,
+		       const wchar_t *__restrict __s2, size_t __n) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_XOPEN2K8
+/* Similar to the two functions above but take the information from
+   the provided locale and not the global locale.  */
+
+/* Compare S1 and S2, both interpreted as appropriate to the
+   LC_COLLATE category of the given locale.  */
+extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
+		      __locale_t __loc) __THROW;
+
+/* Transform S2 into array pointed to by S1 such that if wcscmp is
+   applied to two transformed strings the result is the as applying
+   `wcscoll' to the original strings.  */
+extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
+			 size_t __n, __locale_t __loc) __THROW;
+
+/* Duplicate S, returning an identical malloc'd string.  */
+extern wchar_t *wcsdup (const wchar_t *__s) __THROW __attribute_malloc__;
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Find the first occurrence of WC in WCS.  */
+#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
+extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
+     __THROW __asm ("wcschr") __attribute_pure__;
+extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
+     __THROW __asm ("wcschr") __attribute_pure__;
+#else
+extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
+     __THROW __attribute_pure__;
+#endif
+/* Find the last occurrence of WC in WCS.  */
+#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
+extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
+     __THROW __asm ("wcsrchr") __attribute_pure__;
+extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
+     __THROW __asm ("wcsrchr") __attribute_pure__;
+#else
+extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
+     __THROW __attribute_pure__;
+#endif
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* This function is similar to `wcschr'.  But it returns a pointer to
+   the closing NUL wide character in case C is not found in S.  */
+extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
+     __THROW __attribute_pure__;
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Return the length of the initial segmet of WCS which
+   consists entirely of wide characters not in REJECT.  */
+extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
+     __THROW __attribute_pure__;
+/* Return the length of the initial segmet of WCS which
+   consists entirely of wide characters in  ACCEPT.  */
+extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
+     __THROW __attribute_pure__;
+/* Find the first occurrence in WCS of any character in ACCEPT.  */
+#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
+extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
+     __THROW __asm ("wcspbrk") __attribute_pure__;
+extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
+				     const wchar_t *__accept)
+     __THROW __asm ("wcspbrk") __attribute_pure__;
+#else
+extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
+     __THROW __attribute_pure__;
+#endif
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
+extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
+     __THROW __asm ("wcsstr") __attribute_pure__;
+extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
+				    const wchar_t *__needle)
+     __THROW __asm ("wcsstr") __attribute_pure__;
+#else
+extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
+     __THROW __attribute_pure__;
+#endif
+
+/* Divide WCS into tokens separated by characters in DELIM.  */
+extern wchar_t *wcstok (wchar_t *__restrict __s,
+			const wchar_t *__restrict __delim,
+			wchar_t **__restrict __ptr) __THROW;
+
+/* Return the number of wide characters in S.  */
+extern size_t wcslen (const wchar_t *__s) __THROW __attribute_pure__;
+__END_NAMESPACE_STD
+
+#ifdef __USE_XOPEN
+/* Another name for `wcsstr' from XPG4.  */
+# ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
+extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
+     __THROW __asm ("wcswcs") __attribute_pure__;
+extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
+				    const wchar_t *__needle)
+     __THROW __asm ("wcswcs") __attribute_pure__;
+# else
+extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
+     __THROW __attribute_pure__;
+# endif
+#endif
+
+#ifdef __USE_XOPEN2K8
+/* Return the number of wide characters in S, but at most MAXLEN.  */
+extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
+     __THROW __attribute_pure__;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Search N wide characters of S for C.  */
+#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
+extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
+     __THROW __asm ("wmemchr") __attribute_pure__;
+extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
+				     size_t __n)
+     __THROW __asm ("wmemchr") __attribute_pure__;
+#else
+extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
+     __THROW __attribute_pure__;
+#endif
+
+/* Compare N wide characters of S1 and S2.  */
+extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
+     __THROW __attribute_pure__;
+
+/* Copy N wide characters of SRC to DEST.  */
+extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
+			 const wchar_t *__restrict __s2, size_t __n) __THROW;
+
+/* Copy N wide characters of SRC to DEST, guaranteeing
+   correct behavior for overlapping strings.  */
+extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
+     __THROW;
+
+/* Set N wide characters of S to C.  */
+extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_GNU
+/* Copy N wide characters of SRC to DEST and return pointer to following
+   wide character.  */
+extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
+			  const wchar_t *__restrict __s2, size_t __n)
+     __THROW;
+#endif
+
+
+__BEGIN_NAMESPACE_STD
+/* Determine whether C constitutes a valid (one-byte) multibyte
+   character.  */
+extern wint_t btowc (int __c) __THROW;
+
+/* Determine whether C corresponds to a member of the extended
+   character set whose multibyte representation is a single byte.  */
+extern int wctob (wint_t __c) __THROW;
+
+/* Determine whether PS points to an object representing the initial
+   state.  */
+extern int mbsinit (const mbstate_t *__ps) __THROW __attribute_pure__;
+
+/* Write wide character representation of multibyte character pointed
+   to by S to PWC.  */
+extern size_t mbrtowc (wchar_t *__restrict __pwc,
+		       const char *__restrict __s, size_t __n,
+		       mbstate_t *__restrict __p) __THROW;
+
+/* Write multibyte representation of wide character WC to S.  */
+extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
+		       mbstate_t *__restrict __ps) __THROW;
+
+/* Return number of bytes in multibyte character pointed to by S.  */
+extern size_t __mbrlen (const char *__restrict __s, size_t __n,
+			mbstate_t *__restrict __ps) __THROW;
+extern size_t mbrlen (const char *__restrict __s, size_t __n,
+		      mbstate_t *__restrict __ps) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_EXTERN_INLINES
+/* Define inline function as optimization.  */
+
+/* We can use the BTOWC and WCTOB optimizations since we know that all
+   locales must use ASCII encoding for the values in the ASCII range
+   and because the wchar_t encoding is always ISO 10646.  */
+extern wint_t __btowc_alias (int __c) __asm ("btowc");
+__extern_inline wint_t
+__NTH (btowc (int __c))
+{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
+	  ? (wint_t) __c : __btowc_alias (__c)); }
+
+extern int __wctob_alias (wint_t __c) __asm ("wctob");
+__extern_inline int
+__NTH (wctob (wint_t __wc))
+{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
+	  ? (int) __wc : __wctob_alias (__wc)); }
+
+__extern_inline size_t
+__NTH (mbrlen (const char *__restrict __s, size_t __n,
+	       mbstate_t *__restrict __ps))
+{ return (__ps != NULL
+	  ? mbrtowc (NULL, __s, __n, __ps) : __mbrlen (__s, __n, NULL)); }
+#endif
+
+__BEGIN_NAMESPACE_STD
+/* Write wide character representation of multibyte character string
+   SRC to DST.  */
+extern size_t mbsrtowcs (wchar_t *__restrict __dst,
+			 const char **__restrict __src, size_t __len,
+			 mbstate_t *__restrict __ps) __THROW;
+
+/* Write multibyte character representation of wide character string
+   SRC to DST.  */
+extern size_t wcsrtombs (char *__restrict __dst,
+			 const wchar_t **__restrict __src, size_t __len,
+			 mbstate_t *__restrict __ps) __THROW;
+__END_NAMESPACE_STD
+
+
+#ifdef	__USE_XOPEN2K8
+/* Write wide character representation of at most NMC bytes of the
+   multibyte character string SRC to DST.  */
+extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
+			  const char **__restrict __src, size_t __nmc,
+			  size_t __len, mbstate_t *__restrict __ps) __THROW;
+
+/* Write multibyte character representation of at most NWC characters
+   from the wide character string SRC to DST.  */
+extern size_t wcsnrtombs (char *__restrict __dst,
+			  const wchar_t **__restrict __src,
+			  size_t __nwc, size_t __len,
+			  mbstate_t *__restrict __ps) __THROW;
+#endif	/* use POSIX 2008 */
+
+
+/* The following functions are extensions found in X/Open CAE.  */
+#ifdef __USE_XOPEN
+/* Determine number of column positions required for C.  */
+extern int wcwidth (wchar_t __c) __THROW;
+
+/* Determine number of column positions required for first N wide
+   characters (or fewer if S ends before this) in S.  */
+extern int wcswidth (const wchar_t *__s, size_t __n) __THROW;
+#endif	/* Use X/Open.  */
+
+
+__BEGIN_NAMESPACE_STD
+/* Convert initial portion of the wide string NPTR to `double'
+   representation.  */
+extern double wcstod (const wchar_t *__restrict __nptr,
+		      wchar_t **__restrict __endptr) __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
+extern float wcstof (const wchar_t *__restrict __nptr,
+		     wchar_t **__restrict __endptr) __THROW;
+extern long double wcstold (const wchar_t *__restrict __nptr,
+			    wchar_t **__restrict __endptr) __THROW;
+__END_NAMESPACE_C99
+#endif /* C99 */
+
+
+__BEGIN_NAMESPACE_STD
+/* Convert initial portion of wide string NPTR to `long int'
+   representation.  */
+extern long int wcstol (const wchar_t *__restrict __nptr,
+			wchar_t **__restrict __endptr, int __base) __THROW;
+
+/* Convert initial portion of wide string NPTR to `unsigned long int'
+   representation.  */
+extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
+				  wchar_t **__restrict __endptr, int __base)
+     __THROW;
+__END_NAMESPACE_STD
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Convert initial portion of wide string NPTR to `long long int'
+   representation.  */
+__extension__
+extern long long int wcstoll (const wchar_t *__restrict __nptr,
+			      wchar_t **__restrict __endptr, int __base)
+     __THROW;
+
+/* Convert initial portion of wide string NPTR to `unsigned long long int'
+   representation.  */
+__extension__
+extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
+					wchar_t **__restrict __endptr,
+					int __base) __THROW;
+__END_NAMESPACE_C99
+#endif /* ISO C99.  */
+
+#ifdef __USE_GNU
+/* Convert initial portion of wide string NPTR to `long long int'
+   representation.  */
+__extension__
+extern long long int wcstoq (const wchar_t *__restrict __nptr,
+			     wchar_t **__restrict __endptr, int __base)
+     __THROW;
+
+/* Convert initial portion of wide string NPTR to `unsigned long long int'
+   representation.  */
+__extension__
+extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
+				       wchar_t **__restrict __endptr,
+				       int __base) __THROW;
+#endif /* Use GNU.  */
+
+#ifdef __USE_GNU
+/* The concept of one static locale per category is not very well
+   thought out.  Many applications will need to process its data using
+   information from several different locales.  Another application is
+   the implementation of the internationalization handling in the
+   upcoming ISO C++ standard library.  To support this another set of
+   the functions using locale data exist which have an additional
+   argument.
+
+   Attention: all these functions are *not* standardized in any form.
+   This is a proof-of-concept implementation.  */
+
+/* Structure for reentrant locale using functions.  This is an
+   (almost) opaque type for the user level programs.  */
+# include <xlocale.h>
+
+/* Special versions of the functions above which take the locale to
+   use as an additional parameter.  */
+extern long int wcstol_l (const wchar_t *__restrict __nptr,
+			  wchar_t **__restrict __endptr, int __base,
+			  __locale_t __loc) __THROW;
+
+extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
+				    wchar_t **__restrict __endptr,
+				    int __base, __locale_t __loc) __THROW;
+
+__extension__
+extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
+				wchar_t **__restrict __endptr,
+				int __base, __locale_t __loc) __THROW;
+
+__extension__
+extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
+					  wchar_t **__restrict __endptr,
+					  int __base, __locale_t __loc)
+     __THROW;
+
+extern double wcstod_l (const wchar_t *__restrict __nptr,
+			wchar_t **__restrict __endptr, __locale_t __loc)
+     __THROW;
+
+extern float wcstof_l (const wchar_t *__restrict __nptr,
+		       wchar_t **__restrict __endptr, __locale_t __loc)
+     __THROW;
+
+extern long double wcstold_l (const wchar_t *__restrict __nptr,
+			      wchar_t **__restrict __endptr,
+			      __locale_t __loc) __THROW;
+#endif	/* use GNU */
+
+
+#ifdef __USE_XOPEN2K8
+/* Copy SRC to DEST, returning the address of the terminating L'\0' in
+   DEST.  */
+extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
+			const wchar_t *__restrict __src) __THROW;
+
+/* Copy no more than N characters of SRC to DEST, returning the address of
+   the last character written into DEST.  */
+extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
+			 const wchar_t *__restrict __src, size_t __n)
+     __THROW;
+
+
+/* Wide character I/O functions.  */
+
+/* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
+   a wide character string.  */
+extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __THROW;
+#endif
+
+#if defined __USE_ISOC95 || defined __USE_UNIX98
+__BEGIN_NAMESPACE_STD
+
+/* Select orientation for stream.  */
+extern int fwide (__FILE *__fp, int __mode) __THROW;
+
+
+/* Write formatted output to STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fwprintf (__FILE *__restrict __stream,
+		     const wchar_t *__restrict __format, ...)
+     /* __attribute__ ((__format__ (__wprintf__, 2, 3))) */;
+/* Write formatted output to stdout.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int wprintf (const wchar_t *__restrict __format, ...)
+     /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */;
+/* Write formatted output of at most N characters to S.  */
+extern int swprintf (wchar_t *__restrict __s, size_t __n,
+		     const wchar_t *__restrict __format, ...)
+     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 4))) */;
+
+/* Write formatted output to S from argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vfwprintf (__FILE *__restrict __s,
+		      const wchar_t *__restrict __format,
+		      __gnuc_va_list __arg)
+     /* __attribute__ ((__format__ (__wprintf__, 2, 0))) */;
+/* Write formatted output to stdout from argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vwprintf (const wchar_t *__restrict __format,
+		     __gnuc_va_list __arg)
+     /* __attribute__ ((__format__ (__wprintf__, 1, 0))) */;
+/* Write formatted output of at most N character to S from argument
+   list ARG.  */
+extern int vswprintf (wchar_t *__restrict __s, size_t __n,
+		      const wchar_t *__restrict __format,
+		      __gnuc_va_list __arg)
+     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 0))) */;
+
+
+/* Read formatted input from STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fwscanf (__FILE *__restrict __stream,
+		    const wchar_t *__restrict __format, ...)
+     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
+/* Read formatted input from stdin.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int wscanf (const wchar_t *__restrict __format, ...)
+     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
+/* Read formatted input from S.  */
+extern int swscanf (const wchar_t *__restrict __s,
+		    const wchar_t *__restrict __format, ...)
+     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
+
+# if defined __USE_ISOC99 && !defined __USE_GNU \
+     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
+     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
+#  ifdef __REDIRECT
+/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
+   GNU extension which conflicts with valid %a followed by letter
+   s, S or [.  */
+extern int __REDIRECT (fwscanf, (__FILE *__restrict __stream,
+				 const wchar_t *__restrict __format, ...),
+		       __isoc99_fwscanf)
+     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
+extern int __REDIRECT (wscanf, (const wchar_t *__restrict __format, ...),
+		       __isoc99_wscanf)
+     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
+extern int __REDIRECT_NTH (swscanf, (const wchar_t *__restrict __s,
+				     const wchar_t *__restrict __format,
+				     ...), __isoc99_swscanf)
+     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
+#  else
+extern int __isoc99_fwscanf (__FILE *__restrict __stream,
+			     const wchar_t *__restrict __format, ...);
+extern int __isoc99_wscanf (const wchar_t *__restrict __format, ...);
+extern int __isoc99_swscanf (const wchar_t *__restrict __s,
+			     const wchar_t *__restrict __format, ...)
+     __THROW;
+#   define fwscanf __isoc99_fwscanf
+#   define wscanf __isoc99_wscanf
+#   define swscanf __isoc99_swscanf
+#  endif
+# endif
+
+__END_NAMESPACE_STD
+#endif /* Use ISO C95, C99 and Unix98. */
+
+#ifdef __USE_ISOC99
+__BEGIN_NAMESPACE_C99
+/* Read formatted input from S into argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vfwscanf (__FILE *__restrict __s,
+		     const wchar_t *__restrict __format,
+		     __gnuc_va_list __arg)
+     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
+/* Read formatted input from stdin into argument list ARG.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int vwscanf (const wchar_t *__restrict __format,
+		    __gnuc_va_list __arg)
+     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
+/* Read formatted input from S into argument list ARG.  */
+extern int vswscanf (const wchar_t *__restrict __s,
+		     const wchar_t *__restrict __format,
+		     __gnuc_va_list __arg)
+     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
+
+# if !defined __USE_GNU \
+     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
+     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
+#  ifdef __REDIRECT
+extern int __REDIRECT (vfwscanf, (__FILE *__restrict __s,
+				  const wchar_t *__restrict __format,
+				  __gnuc_va_list __arg), __isoc99_vfwscanf)
+     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
+extern int __REDIRECT (vwscanf, (const wchar_t *__restrict __format,
+				 __gnuc_va_list __arg), __isoc99_vwscanf)
+     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
+extern int __REDIRECT_NTH (vswscanf, (const wchar_t *__restrict __s,
+				      const wchar_t *__restrict __format,
+				      __gnuc_va_list __arg), __isoc99_vswscanf)
+     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
+#  else
+extern int __isoc99_vfwscanf (__FILE *__restrict __s,
+			      const wchar_t *__restrict __format,
+			      __gnuc_va_list __arg);
+extern int __isoc99_vwscanf (const wchar_t *__restrict __format,
+			     __gnuc_va_list __arg);
+extern int __isoc99_vswscanf (const wchar_t *__restrict __s,
+			      const wchar_t *__restrict __format,
+			      __gnuc_va_list __arg) __THROW;
+#   define vfwscanf __isoc99_vfwscanf
+#   define vwscanf __isoc99_vwscanf
+#   define vswscanf __isoc99_vswscanf
+#  endif
+# endif
+
+__END_NAMESPACE_C99
+#endif /* Use ISO C99. */
+
+
+__BEGIN_NAMESPACE_STD
+/* Read a character from STREAM.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern wint_t fgetwc (__FILE *__stream);
+extern wint_t getwc (__FILE *__stream);
+
+/* Read a character from stdin.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern wint_t getwchar (void);
+
+
+/* Write a character to STREAM.
+
+   These functions are possible cancellation points and therefore not
+   marked with __THROW.  */
+extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
+extern wint_t putwc (wchar_t __wc, __FILE *__stream);
+
+/* Write a character to stdout.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern wint_t putwchar (wchar_t __wc);
+
+
+/* Get a newline-terminated wide character string of finite length
+   from STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
+			__FILE *__restrict __stream);
+
+/* Write a string to STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int fputws (const wchar_t *__restrict __ws,
+		   __FILE *__restrict __stream);
+
+
+/* Push a character back onto the input buffer of STREAM.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
+__END_NAMESPACE_STD
+
+
+#ifdef __USE_GNU
+/* These are defined to be equivalent to the `char' functions defined
+   in POSIX.1:1996.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern wint_t getwc_unlocked (__FILE *__stream);
+extern wint_t getwchar_unlocked (void);
+
+/* This is the wide character version of a GNU extension.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern wint_t fgetwc_unlocked (__FILE *__stream);
+
+/* Faster version when locking is not necessary.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
+
+/* These are defined to be equivalent to the `char' functions defined
+   in POSIX.1:1996.
+
+   These functions are not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation they are cancellation points and
+   therefore not marked with __THROW.  */
+extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
+extern wint_t putwchar_unlocked (wchar_t __wc);
+
+
+/* This function does the same as `fgetws' but does not lock the stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
+				 __FILE *__restrict __stream);
+
+/* This function does the same as `fputws' but does not lock the stream.
+
+   This function is not part of POSIX and therefore no official
+   cancellation point.  But due to similarity with an POSIX interface
+   or due to the implementation it is a cancellation point and
+   therefore not marked with __THROW.  */
+extern int fputws_unlocked (const wchar_t *__restrict __ws,
+			    __FILE *__restrict __stream);
+#endif
+
+
+__BEGIN_NAMESPACE_C99
+/* Format TP into S according to FORMAT.
+   Write no more than MAXSIZE wide characters and return the number
+   of wide characters written, or 0 if it would exceed MAXSIZE.  */
+extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
+			const wchar_t *__restrict __format,
+			const struct tm *__restrict __tp) __THROW;
+__END_NAMESPACE_C99
+
+# ifdef __USE_GNU
+# include <xlocale.h>
+
+/* Similar to `wcsftime' but takes the information from
+   the provided locale and not the global locale.  */
+extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
+			  const wchar_t *__restrict __format,
+			  const struct tm *__restrict __tp,
+			  __locale_t __loc) __THROW;
+# endif
+
+/* The X/Open standard demands that most of the functions defined in
+   the <wctype.h> header must also appear here.  This is probably
+   because some X/Open members wrote their implementation before the
+   ISO C standard was published and introduced the better solution.
+   We have to provide these definitions for compliance reasons but we
+   do this nonsense only if really necessary.  */
+#if defined __USE_UNIX98 && !defined __USE_GNU
+# define __need_iswxxx
+# include <wctype.h>
+#endif
+
+/* Define some macros helping to catch buffer overflows.  */
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+# include <bits/wchar2.h>
+#endif
+
+#ifdef __LDBL_COMPAT
+# include <bits/wchar-ldbl.h>
+#endif
+
+__END_DECLS
+
+#endif	/* _WCHAR_H defined */
+
+#endif /* wchar.h  */
+
+/* Undefine all __need_* constants in case we are included to get those
+   constants but the whole file was already read.  */
+#undef __need_mbstate_t
+#undef __need_wint_t
diff --git a/include/wctype.h b/include/wctype.h
new file mode 100644
index 0000000..a307f05
--- /dev/null
+++ b/include/wctype.h
@@ -0,0 +1,318 @@
+/* Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/*
+ *	ISO C99 Standard: 7.25
+ *	Wide character classification and mapping utilities  <wctype.h>
+ */
+
+#ifndef _WCTYPE_H
+
+#include <features.h>
+#include <bits/types.h>
+
+#ifndef __need_iswxxx
+# define _WCTYPE_H	1
+
+/* Get wint_t from <wchar.h>.  */
+# define __need_wint_t
+# include <wchar.h>
+
+/* Constant expression of type `wint_t' whose value does not correspond
+   to any member of the extended character set.  */
+# ifndef WEOF
+#  define WEOF (0xffffffffu)
+# endif
+#endif
+#undef __need_iswxxx
+
+
+/* The following part is also used in the <wcsmbs.h> header when compiled
+   in the Unix98 compatibility mode.  */
+#ifndef __iswxxx_defined
+# define __iswxxx_defined	1
+
+__BEGIN_NAMESPACE_C99
+/* Scalar type that can hold values which represent locale-specific
+   character classifications.  */
+typedef unsigned long int wctype_t;
+__END_NAMESPACE_C99
+
+# ifndef _ISwbit
+/* The characteristics are stored always in network byte order (big
+   endian).  We define the bit value interpretations here dependent on the
+   machine's byte order.  */
+
+#  include <endian.h>
+#  if __BYTE_ORDER == __BIG_ENDIAN
+#   define _ISwbit(bit)	(1 << (bit))
+#  else /* __BYTE_ORDER == __LITTLE_ENDIAN */
+#   define _ISwbit(bit)	\
+	((bit) < 8 ? (int) ((1UL << (bit)) << 24)			      \
+	 : ((bit) < 16 ? (int) ((1UL << (bit)) << 8)			      \
+	    : ((bit) < 24 ? (int) ((1UL << (bit)) >> 8)			      \
+	       : (int) ((1UL << (bit)) >> 24))))
+#  endif
+
+enum
+{
+  __ISwupper = 0,			/* UPPERCASE.  */
+  __ISwlower = 1,			/* lowercase.  */
+  __ISwalpha = 2,			/* Alphabetic.  */
+  __ISwdigit = 3,			/* Numeric.  */
+  __ISwxdigit = 4,			/* Hexadecimal numeric.  */
+  __ISwspace = 5,			/* Whitespace.  */
+  __ISwprint = 6,			/* Printing.  */
+  __ISwgraph = 7,			/* Graphical.  */
+  __ISwblank = 8,			/* Blank (usually SPC and TAB).  */
+  __ISwcntrl = 9,			/* Control character.  */
+  __ISwpunct = 10,			/* Punctuation.  */
+  __ISwalnum = 11,			/* Alphanumeric.  */
+
+  _ISwupper = _ISwbit (__ISwupper),	/* UPPERCASE.  */
+  _ISwlower = _ISwbit (__ISwlower),	/* lowercase.  */
+  _ISwalpha = _ISwbit (__ISwalpha),	/* Alphabetic.  */
+  _ISwdigit = _ISwbit (__ISwdigit),	/* Numeric.  */
+  _ISwxdigit = _ISwbit (__ISwxdigit),	/* Hexadecimal numeric.  */
+  _ISwspace = _ISwbit (__ISwspace),	/* Whitespace.  */
+  _ISwprint = _ISwbit (__ISwprint),	/* Printing.  */
+  _ISwgraph = _ISwbit (__ISwgraph),	/* Graphical.  */
+  _ISwblank = _ISwbit (__ISwblank),	/* Blank (usually SPC and TAB).  */
+  _ISwcntrl = _ISwbit (__ISwcntrl),	/* Control character.  */
+  _ISwpunct = _ISwbit (__ISwpunct),	/* Punctuation.  */
+  _ISwalnum = _ISwbit (__ISwalnum)	/* Alphanumeric.  */
+};
+# endif /* Not _ISwbit  */
+
+
+__BEGIN_DECLS
+
+__BEGIN_NAMESPACE_C99
+/*
+ * Wide-character classification functions: 7.15.2.1.
+ */
+
+/* Test for any wide character for which `iswalpha' or `iswdigit' is
+   true.  */
+extern int iswalnum (wint_t __wc) __THROW;
+
+/* Test for any wide character for which `iswupper' or 'iswlower' is
+   true, or any wide character that is one of a locale-specific set of
+   wide-characters for which none of `iswcntrl', `iswdigit',
+   `iswpunct', or `iswspace' is true.  */
+extern int iswalpha (wint_t __wc) __THROW;
+
+/* Test for any control wide character.  */
+extern int iswcntrl (wint_t __wc) __THROW;
+
+/* Test for any wide character that corresponds to a decimal-digit
+   character.  */
+extern int iswdigit (wint_t __wc) __THROW;
+
+/* Test for any wide character for which `iswprint' is true and
+   `iswspace' is false.  */
+extern int iswgraph (wint_t __wc) __THROW;
+
+/* Test for any wide character that corresponds to a lowercase letter
+   or is one of a locale-specific set of wide characters for which
+   none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
+extern int iswlower (wint_t __wc) __THROW;
+
+/* Test for any printing wide character.  */
+extern int iswprint (wint_t __wc) __THROW;
+
+/* Test for any printing wide character that is one of a
+   locale-specific et of wide characters for which neither `iswspace'
+   nor `iswalnum' is true.  */
+extern int iswpunct (wint_t __wc) __THROW;
+
+/* Test for any wide character that corresponds to a locale-specific
+   set of wide characters for which none of `iswalnum', `iswgraph', or
+   `iswpunct' is true.  */
+extern int iswspace (wint_t __wc) __THROW;
+
+/* Test for any wide character that corresponds to an uppercase letter
+   or is one of a locale-specific set of wide character for which none
+   of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
+extern int iswupper (wint_t __wc) __THROW;
+
+/* Test for any wide character that corresponds to a hexadecimal-digit
+   character equivalent to that performed be the functions described
+   in the previous subclause.  */
+extern int iswxdigit (wint_t __wc) __THROW;
+
+/* Test for any wide character that corresponds to a standard blank
+   wide character or a locale-specific set of wide characters for
+   which `iswalnum' is false.  */
+# ifdef __USE_ISOC99
+extern int iswblank (wint_t __wc) __THROW;
+# endif
+
+/*
+ * Extensible wide-character classification functions: 7.15.2.2.
+ */
+
+/* Construct value that describes a class of wide characters identified
+   by the string argument PROPERTY.  */
+extern wctype_t wctype (const char *__property) __THROW;
+
+/* Determine whether the wide-character WC has the property described by
+   DESC.  */
+extern int iswctype (wint_t __wc, wctype_t __desc) __THROW;
+__END_NAMESPACE_C99
+
+
+/*
+ * Wide-character case-mapping functions: 7.15.3.1.
+ */
+
+__BEGIN_NAMESPACE_C99
+/* Scalar type that can hold values which represent locale-specific
+   character mappings.  */
+typedef const __int32_t *wctrans_t;
+__END_NAMESPACE_C99
+#ifdef __USE_GNU
+__USING_NAMESPACE_C99(wctrans_t)
+#endif
+
+__BEGIN_NAMESPACE_C99
+/* Converts an uppercase letter to the corresponding lowercase letter.  */
+extern wint_t towlower (wint_t __wc) __THROW;
+
+/* Converts an lowercase letter to the corresponding uppercase letter.  */
+extern wint_t towupper (wint_t __wc) __THROW;
+__END_NAMESPACE_C99
+
+__END_DECLS
+
+#endif	/* need iswxxx.  */
+
+
+/* The remaining definitions and declarations must not appear in the
+   <wchar.h> header.  */
+#ifdef _WCTYPE_H
+
+/*
+ * Extensible wide-character mapping functions: 7.15.3.2.
+ */
+
+__BEGIN_DECLS
+
+__BEGIN_NAMESPACE_C99
+/* Construct value that describes a mapping between wide characters
+   identified by the string argument PROPERTY.  */
+extern wctrans_t wctrans (const char *__property) __THROW;
+
+/* Map the wide character WC using the mapping described by DESC.  */
+extern wint_t towctrans (wint_t __wc, wctrans_t __desc) __THROW;
+__END_NAMESPACE_C99
+
+# ifdef __USE_XOPEN2K8
+/* Declare the interface to extended locale model.  */
+#  include <xlocale.h>
+
+/* Test for any wide character for which `iswalpha' or `iswdigit' is
+   true.  */
+extern int iswalnum_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any wide character for which `iswupper' or 'iswlower' is
+   true, or any wide character that is one of a locale-specific set of
+   wide-characters for which none of `iswcntrl', `iswdigit',
+   `iswpunct', or `iswspace' is true.  */
+extern int iswalpha_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any control wide character.  */
+extern int iswcntrl_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any wide character that corresponds to a decimal-digit
+   character.  */
+extern int iswdigit_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any wide character for which `iswprint' is true and
+   `iswspace' is false.  */
+extern int iswgraph_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any wide character that corresponds to a lowercase letter
+   or is one of a locale-specific set of wide characters for which
+   none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
+extern int iswlower_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any printing wide character.  */
+extern int iswprint_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any printing wide character that is one of a
+   locale-specific et of wide characters for which neither `iswspace'
+   nor `iswalnum' is true.  */
+extern int iswpunct_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any wide character that corresponds to a locale-specific
+   set of wide characters for which none of `iswalnum', `iswgraph', or
+   `iswpunct' is true.  */
+extern int iswspace_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any wide character that corresponds to an uppercase letter
+   or is one of a locale-specific set of wide character for which none
+   of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
+extern int iswupper_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any wide character that corresponds to a hexadecimal-digit
+   character equivalent to that performed be the functions described
+   in the previous subclause.  */
+extern int iswxdigit_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Test for any wide character that corresponds to a standard blank
+   wide character or a locale-specific set of wide characters for
+   which `iswalnum' is false.  */
+extern int iswblank_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Construct value that describes a class of wide characters identified
+   by the string argument PROPERTY.  */
+extern wctype_t wctype_l (const char *__property, __locale_t __locale)
+     __THROW;
+
+/* Determine whether the wide-character WC has the property described by
+   DESC.  */
+extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
+     __THROW;
+
+
+/*
+ * Wide-character case-mapping functions.
+ */
+
+/* Converts an uppercase letter to the corresponding lowercase letter.  */
+extern wint_t towlower_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Converts an lowercase letter to the corresponding uppercase letter.  */
+extern wint_t towupper_l (wint_t __wc, __locale_t __locale) __THROW;
+
+/* Construct value that describes a mapping between wide characters
+   identified by the string argument PROPERTY.  */
+extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
+     __THROW;
+
+/* Map the wide character WC using the mapping described by DESC.  */
+extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
+			   __locale_t __locale) __THROW;
+
+# endif /* Use POSIX 2008.  */
+
+__END_DECLS
+
+#endif	/* __WCTYPE_H defined.  */
+
+#endif /* wctype.h  */
diff --git a/include/wordexp.h b/include/wordexp.h
new file mode 100644
index 0000000..f9ba108
--- /dev/null
+++ b/include/wordexp.h
@@ -0,0 +1,70 @@
+/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_WORDEXP_H
+#define	_WORDEXP_H	1
+
+#include <features.h>
+#define __need_size_t
+#include <stddef.h>
+
+__BEGIN_DECLS
+
+/* Bits set in the FLAGS argument to `wordexp'.  */
+enum
+  {
+    WRDE_DOOFFS = (1 << 0),	/* Insert PWORDEXP->we_offs NULLs.  */
+    WRDE_APPEND = (1 << 1),	/* Append to results of a previous call.  */
+    WRDE_NOCMD = (1 << 2),	/* Don't do command substitution.  */
+    WRDE_REUSE = (1 << 3),	/* Reuse storage in PWORDEXP.  */
+    WRDE_SHOWERR = (1 << 4),	/* Don't redirect stderr to /dev/null.  */
+    WRDE_UNDEF = (1 << 5),	/* Error for expanding undefined variables.  */
+    __WRDE_FLAGS = (WRDE_DOOFFS | WRDE_APPEND | WRDE_NOCMD |
+		    WRDE_REUSE | WRDE_SHOWERR | WRDE_UNDEF)
+  };
+
+/* Structure describing a word-expansion run.  */
+typedef struct
+  {
+    size_t we_wordc;		/* Count of words matched.  */
+    char **we_wordv;		/* List of expanded words.  */
+    size_t we_offs;		/* Slots to reserve in `we_wordv'.  */
+  } wordexp_t;
+
+/* Possible nonzero return values from `wordexp'.  */
+enum
+  {
+#ifdef __USE_XOPEN
+    WRDE_NOSYS = -1,		/* Never used since we support `wordexp'.  */
+#endif
+    WRDE_NOSPACE = 1,		/* Ran out of memory.  */
+    WRDE_BADCHAR,		/* A metachar appears in the wrong place.  */
+    WRDE_BADVAL,		/* Undefined var reference with WRDE_UNDEF.  */
+    WRDE_CMDSUB,		/* Command substitution with WRDE_NOCMD.  */
+    WRDE_SYNTAX			/* Shell syntax error.  */
+  };
+
+/* Do word expansion of WORDS into PWORDEXP.  */
+extern int wordexp (const char *__restrict __words,
+		    wordexp_t *__restrict __pwordexp, int __flags);
+
+/* Free the storage allocated by a `wordexp' call.  */
+extern void wordfree (wordexp_t *__wordexp) __THROW;
+
+__END_DECLS
+
+#endif /* wordexp.h  */
diff --git a/include/xlocale.h b/include/xlocale.h
new file mode 100644
index 0000000..f58208f
--- /dev/null
+++ b/include/xlocale.h
@@ -0,0 +1,44 @@
+/* Definition of locale datatype.
+   Copyright (C) 1997-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _XLOCALE_H
+#define _XLOCALE_H	1
+
+/* Structure for reentrant locale using functions.  This is an
+   (almost) opaque type for the user level programs.  The file and
+   this data structure is not standardized.  Don't rely on it.  It can
+   go away without warning.  */
+typedef struct __locale_struct
+{
+  /* Note: LC_ALL is not a valid index into this array.  */
+  struct __locale_data *__locales[13]; /* 13 = __LC_LAST. */
+
+  /* To increase the speed of this solution we add some special members.  */
+  const unsigned short int *__ctype_b;
+  const int *__ctype_tolower;
+  const int *__ctype_toupper;
+
+  /* Note: LC_ALL is not a valid index into this array.  */
+  const char *__names[13];
+} *__locale_t;
+
+/* POSIX 2008 makes locale_t official.  */
+typedef __locale_t locale_t;
+
+#endif /* xlocale.h */
-- 
2.9.2

